%PDF-1.2
%‚„œ”
2 0 obj
<<
/Length 449
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
18.000 0.000 0.000 18.000 124.000 703.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(OpenGL)Tj
0 -1.2222 TD
0.000 Tw
(Programming Guide)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 658.690 m
547.000 658.690 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - About This Guide - 1)Tj
ET
endstream
endobj
3 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
9 0 obj
<<
/Length 4600
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(About This Guide)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 685.000 Tm
(The OpenGL graphics system is a software interface to graphics hardware. \(The GL stands for Graphics)Tj
0 -1.5 TD
(Library.\) It allows you to create interactive programs that produce color images of moving)Tj
T*
(three-dimensional objects. With OpenGL, you can control computer-graphics technology to produce)Tj
T*
(realistic pictures or ones that depart from reality in imaginative ways. This guide explains how to)Tj
T*
(program with the OpenGL graphics system to deliver the visual effect you want.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 591.000 Tm
(What This Guide Contains)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 569.000 Tm
(This guide has 14 chapters, one more than the ideal number. The first five chapters present basic)Tj
T*
(information that you need to understand to be able to draw a properly colored and lit three-dimensional)Tj
T*
(object on the screen.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 1, )Tj
/F13 1 Tf
4.4 0 TD
("Introduction to OpenGL,")Tj
/F11 1 Tf
11.9 0 TD
( provides a glimpse into the kinds of things OpenGL can)Tj
-16.3 -1.6 TD
(do. It also presents a simple OpenGL program and explains essential programming details you need)Tj
0 -1.5 TD
(to know for subsequent chapters.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 2, )Tj
/F13 1 Tf
4.4 0 TD
("State Management and Drawing Geometric Objects,")Tj
/F11 1 Tf
23.5 0 TD
( explains how to create a)Tj
-27.9 -1.6 TD
(three-dimensional geometric description of an object that is eventually drawn on the screen.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 3, )Tj
/F13 1 Tf
4.4 0 TD
("Viewing,")Tj
/F11 1 Tf
4.9 0 TD
( describes how such three-dimensional models are transformed before being)Tj
-9.3 -1.6 TD
(drawn onto a two-dimensional screen. You can control these transformations to show a particular)Tj
0 -1.5 TD
(view of a model.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 4, )Tj
/F13 1 Tf
4.4 0 TD
("Color,")Tj
/F11 1 Tf
3.8 0 TD
( describes how to specify the color and shading method used to draw an object.)Tj
/F33 1 Tf
-10 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 5, )Tj
/F13 1 Tf
4.4 0 TD
("Lighting,")Tj
/F11 1 Tf
5 0 TD
( explains how to control the lighting conditions surrounding an object and)Tj
-9.4 -1.5 TD
(how that object responds to light \(that is, how it reflects or absorbs light\). Lighting is an important)Tj
T*
(topic, since objects usually don't look three-dimensional until they're lit.)Tj
-1.9 -2.7 TD
(The remaining chapters explain how to optimize or add sophisticated features to your three-dimensional)Tj
0 -1.5 TD
(scene. You might choose not to take advantage of many of these features until you're more comfortable)Tj
T*
(with OpenGL. Particularly advanced topics are noted in the text where they occur.)Tj
/F33 1 Tf
0.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 6, )Tj
/F13 1 Tf
4.4 0 TD
("Blending, Antialiasing, Fog, and Polygon Offset,")Tj
/F11 1 Tf
21.7 0 TD
( describes techniques essential to)Tj
-26.1 -1.6 TD
(creating a realistic scene)Tj
/F33 1 Tf
9.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(alpha blending \(to create transparent objects\), antialiasing \(to eliminate)Tj
-10.8 -1.6 TD
(jagged edges\), atmospheric effects \(to simulate fog or smog\), and polygon offset \(to remove visual)Tj
0 -1.5 TD
(artifacts when highlighting the edges of filled polygons\).)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 7, )Tj
/F13 1 Tf
4.4 0 TD
("Display Lists,")Tj
/F11 1 Tf
6.9 0 TD
( discusses how to store a series of OpenGL commands for execution at a)Tj
-11.3 -1.6 TD
(later time. You'll want to use this feature to increase the performance of your OpenGL program.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 8, )Tj
/F13 1 Tf
4.4 0 TD
("Drawing Pixels, Bitmaps, Fonts, and Images,")Tj
/F11 1 Tf
20.2 0 TD
( discusses how to work with sets of)Tj
-24.6 -1.6 TD
(two-dimensional data as bitmaps or images. One typical use for bitmaps is describing characters in)Tj
0 -1.5 TD
(fonts.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 9, )Tj
/F13 1 Tf
4.4 0 TD
("Texture Mapping,")Tj
/F11 1 Tf
8.9 0 TD
( explains how to map one- and two-dimensional images called)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - About This Guide - 1)Tj
ET
endstream
endobj
10 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
14 0 obj
<<
/Length 4359
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(textures onto three-dimensional objects. Many marvelous effects can be achieved through texture)Tj
0 -1.5 TD
(mapping.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 10, )Tj
/F13 1 Tf
4.9 0 TD
("The Framebuffer,")Tj
/F11 1 Tf
8.8 0 TD
( describes all the possible buffers that can exist in an OpenGL)Tj
-13.7 -1.6 TD
(implementation and how you can control them. You can use the buffers for such effects as)Tj
0 -1.5 TD
(hidden-surface elimination, stenciling, masking, motion blur, and depth-of-field focusing.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 11, )Tj
/F13 1 Tf
4.9 0 TD
("Tessellators and Quadrics,")Tj
/F11 1 Tf
12.5 0 TD
( shows how to use the tessellation and quadrics routines)Tj
-17.4 -1.6 TD
(in the GLU \(OpenGL Utility Library\).)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 12, )Tj
/F13 1 Tf
4.9 0 TD
("Evaluators and NURBS,")Tj
/F11 1 Tf
11.5 0 TD
( gives an introduction to advanced techniques for)Tj
-16.4 -1.6 TD
(efficiently generating curves or surfaces.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 13, )Tj
/F13 1 Tf
4.9 0 TD
("Selection and Feedback,")Tj
/F11 1 Tf
11.4 0 TD
( explains how you can use OpenGL's selection mechanism)Tj
-16.3 -1.5 TD
(to select an object on the screen. It also explains the feedback mechanism, which allows you to)Tj
T*
(collect the drawing information OpenGL produces rather than having it be used to draw on the)Tj
T*
(screen.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Chapter 14, )Tj
/F13 1 Tf
4.9 0 TD
("Now That You Know,")Tj
/F11 1 Tf
10.5 0 TD
( describes how to use OpenGL in several clever and)Tj
-15.4 -1.5 TD
(unexpected ways to produce interesting results. These techniques are drawn from years of)Tj
T*
(experience with both OpenGL and the technological precursor to OpenGL, the Silicon Graphics)Tj
T*
(IRIS Graphics Library.)Tj
-1.9 -2.7 TD
(In addition, there are several appendices that you will likely find useful.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix A, )Tj
/F13 1 Tf
5.4 0 TD
("Order of Operations,")Tj
/F11 1 Tf
10.2 0 TD
(,  gives a technical overview of the operations OpenGL)Tj
-15.6 -1.6 TD
(performs, briefly describing them in the order in which they occur as an application executes.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix B, )Tj
/F13 1 Tf
5.4 0 TD
("State Variables,")Tj
/F11 1 Tf
7.8 0 TD
( lists the state variables that OpenGL maintains and describes how)Tj
-13.2 -1.6 TD
(to obtain their values.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix C, )Tj
/F13 1 Tf
5.4 0 TD
("OpenGL and Window Systems,")Tj
/F11 1 Tf
14.5 0 TD
( briefly describes the routines available in)Tj
-19.9 -1.6 TD
(window-system specific libraries, which are extended to support OpenGL rendering. WIndow)Tj
0 -1.5 TD
(system interfaces to the X Window System, Apple MacIntosh, IBM OS/2, and Microsoft Windows)Tj
T*
(NT and Windows 95 are discussed here.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix D, )Tj
/F13 1 Tf
5.4 0 TD
("Basics of GLUT: The OpenGL Utility Toolkit,")Tj
/F11 1 Tf
20.8 0 TD
( discusses the library that handles)Tj
-26.2 -1.6 TD
(window system operations. GLUT is portable and it makes code examples shorter and more)Tj
0 -1.5 TD
(comprehensible.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix E, )Tj
/F13 1 Tf
5.3 0 TD
("Calculating Normal Vectors,")Tj
/F11 1 Tf
13.4 0 TD
( tells you how to calculate normal vectors for)Tj
-18.7 -1.6 TD
(different types of geometric objects.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix F, )Tj
/F13 1 Tf
5.3 0 TD
("Homogeneous Coordinates and Transformation Matrices,")Tj
/F11 1 Tf
25.8 0 TD
( explains some of the)Tj
-31.1 -1.6 TD
(mathematics behind matrix transformations.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix G, )Tj
/F13 1 Tf
5.4 0 TD
("Programming Tips,")Tj
/F11 1 Tf
9.5 0 TD
( lists some programming tips based on the intentions of the)Tj
-14.9 -1.5 TD
(designers of OpenGL that you might find useful.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - About This Guide - 2)Tj
ET
endstream
endobj
15 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
17 0 obj
<<
/Length 3655
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix H, )Tj
/F13 1 Tf
5.4 0 TD
("OpenGL Invariance,")Tj
/F11 1 Tf
10 0 TD
( describes when and where an OpenGL implementation must)Tj
-15.4 -1.6 TD
(generate the exact pixel values described in the OpenGL specification.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appendix I, )Tj
/F13 1 Tf
5 0 TD
("Color Plates,")Tj
/F11 1 Tf
6.6 0 TD
( contains the color plates that appear in the printed version of this)Tj
-11.6 -1.6 TD
(guide.)Tj
-1.9 -2.7 TD
[(Finally, an extensive )-44(Glossary)55( defines the key terms used in this guide.)]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 596.000 Tm
(What's New in This Edition)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 574.000 Tm
(To the question, "What's new in this edition?" the wiseacre answer is "About 100 pages." The more)Tj
0 -1.5 TD
(informative answer follows.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Detailed information about the following new features of OpenGL Version 1.1 has been added.)Tj
/F33 1 Tf
0 -2.3 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
(Vertex arrays)Tj
/F33 1 Tf
-1.8 -2.3 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
(Texturing enhancements, including texture objects \(including residency and prioritization\),)Tj
0 -1.6 TD
(internal texture image format, texture subimages, texture proxies, and copying textures from)Tj
0 -1.5 TD
(frame buffer data)Tj
/F33 1 Tf
-1.8 -2.2 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
(Polygon offset)Tj
/F33 1 Tf
-1.8 -2.3 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
(Logical operation in RGBA mode)Tj
/F33 1 Tf
-3.6 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Program examples have been converted to Mark Kilgard's GLUT, which stands for Graphics)Tj
0 -1.6 TD
(Library Utility Toolkit. GLUT is an increasingly popular windowing toolkit, which is)Tj
0 -1.5 TD
(well-documented and has been ported to different window systems.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(More detail about some topics that were in the first edition, especially coverage of the OpenGL)Tj
0 -1.5 TD
(Utility \(GLU\) Library.)Tj
/F33 1 Tf
0 -2.3 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
(An entire chapter on GLU tessellators and quadrics)Tj
/F33 1 Tf
-1.8 -2.2 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
[(A section \(in )17(Chapter 3)16(\))0( on the use of )]TJ
/F15 1 Tf
15.3 0 TD
(gluProject\(\))Tj
/F11 1 Tf
4.9 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluUnProject\(\))Tj
/F11 1 Tf
6.1 0 TD
(, which mimics or)Tj
-28.2 -1.6 TD
(reverses the operations of)Tj
0 -1.1 TD
(the geometric processing pipeline \(This has been the subject of frequent discussions on the)Tj
0 -1.2 TD
(Internet newsgroup on OpenGL, )Tj
/F15 1 Tf
13.2 0 TD
(comp.graphics.api.opengl)Tj
/F11 1 Tf
10.5 0 TD
(.\))Tj
/F33 1 Tf
-25.5 -2.2 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
(Expanded coverage \(and more diagrams\) about images)Tj
/F33 1 Tf
-1.8 -2.3 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
(Changes to GLU NURBS properties)Tj
/F33 1 Tf
-1.8 -2.2 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
(Error handling and vendor-specific extensions to OpenGL)Tj
/F33 1 Tf
-1.8 -2.3 TD
(-)Tj
/F11 1 Tf
1.8 0 TD
[(Appendix C)-38( expanded to include OpenGL interfaces to several window/operating systems)]TJ
-1.8 -2.2 TD
(The first edition's appendix on the OpenGL Utility Library was removed, and its information has)Tj
0 -1.5 TD
(been integrated into other chapters.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A much larger and more informative index)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - About This Guide - 3)Tj
ET
endstream
endobj
18 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
21 0 obj
<<
/Length 4672
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
(Bug fixes and minor topic reordering. Moving the display list chapter is the most noticeable change.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 670.000 Tm
(What You Should Know Before Reading This Guide)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 648.000 Tm
(This guide assumes only that you know how to program in the C language and that you have some)Tj
0 -1.5 TD
(background in mathematics \(geometry, trigonometry, linear algebra, calculus, and differential geometry\).)Tj
T*
(Even if you have little or no experience with computer-graphics technology, you should be able to follow)Tj
T*
(most of the discussions in this book. Of course, computer graphics is a huge subject, so you may want to)Tj
T*
(enrich your learning experience with supplemental reading.)Tj
/F33 1 Tf
0.1 -2.3 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(Computer Graphics: Principles and Practice)Tj
/F11 1 Tf
18.1 0 TD
( by James D. Foley, Andries van Dam, Steven K.)Tj
-18.1 -1.6 TD
(Feiner, and John F. Hughes \(Reading, MA: Addison-Wesley, 1990\))Tj
/F33 1 Tf
27.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(This book is an encyclopedic)Tj
-28.1 -1.6 TD
(treatment of the subject of computer graphics. It includes a wealth of information but is probably)Tj
0 -1.5 TD
(best read after you have some experience with the subject.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(3D Computer Graphics: A User's Guide for Artists and Designers)Tj
/F11 1 Tf
26.6 0 TD
( by Andrew S. Glassner \(New)Tj
-26.6 -1.7 TD
(York: Design Press, 1989\))Tj
/F33 1 Tf
10.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(This book is a nontechnical, gentle introduction to computer graphics.)Tj
-11.6 -1.6 TD
(It focuses on the visual effects that can be achieved rather than on the techniques needed to achieve)Tj
0 -1.5 TD
(them.)Tj
-1.9 -2.7 TD
(Once you begin programming with OpenGL, you might want to obtain the )Tj
/F15 1 Tf
30.1 0 TD
(OpenGL Reference Manual)Tj
/F11 1 Tf
-30.1 -1.5 TD
(by the OpenGL Architecture Review Board \(Reading, MA: Addison-Wesley Developers Press, 1996\),)Tj
T*
(which is designed as a companion volume to this guide. The )Tj
/F15 1 Tf
24.4 0 TD
(Reference Manual)Tj
/F11 1 Tf
7.3 0 TD
( provides a technical view)Tj
-31.7 -1.5 TD
(of how OpenGL operates on data that describes a geometric object or an image to produce an image on)Tj
0 -1.6 TD
(the screen. It also contains full descriptions of each set of related OpenGL commands)Tj
/F33 1 Tf
34.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the parameters)Tj
-35.2 -1.6 TD
(used by the commands, the default values for those parameters, and what the commands accomplish.)Tj
0 -1.5 TD
(Many OpenGL implementations have this same material on-line, in the form of )Tj
/F15 1 Tf
32 0 TD
(man)Tj
/F11 1 Tf
1.7 0 TD
( pages or other help)Tj
-33.7 -1.5 TD
(documents, and it's probably more up-to-date. There is also a http version on the World Wide Web;)Tj
T*
[(consult Silicon Graphics OpenGL Web Site \()11(http://www.sgi.com/Technology/openGL)-43(\) for the latest)]TJ
T*
(pointer.)Tj
0 -2.1 TD
(OpenGL is really a hardware-independent specification of a programming interface, and you use a)Tj
0 -1.5 TD
(particular implementation of it on a particular kind of hardware. This guide explains how to program)Tj
0 -1.6 TD
(with any OpenGL implementation. However, since implementations may vary slightly)Tj
/F33 1 Tf
34.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in performance)Tj
-35.6 -1.7 TD
(and in providing additional, optional features, for example)Tj
/F33 1 Tf
23.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(you might want to investigate whether)Tj
-24.4 -1.6 TD
(supplementary documentation is available for the particular implementation you're using. In addition,)Tj
0 -1.5 TD
(you might have OpenGL-related utilities, toolkits, programming and debugging support, widgets, sample)Tj
T*
(programs, and demos available to you with your system.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 136.000 Tm
(How to Obtain the Sample Code)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 114.000 Tm
(This guide contains many sample programs to illustrate the use of particular OpenGL programming)Tj
T*
(techniques. These programs make use of Mark Kilgard's OpenGL Utility Toolkit \(GLUT\). GLUT is)Tj
T*
(documented in )Tj
/F15 1 Tf
6.2 0 TD
(OpenGL Programming for the X Window System)Tj
/F11 1 Tf
19.6 0 TD
( by Mark Kilgard \(Reading, MA:)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - About This Guide - 4)Tj
ET
endstream
endobj
22 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
24 0 obj
<<
/Length 3623
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(Addison-Wesley Developers Press, 1996\). The section ")249(OpenGL-Related Libraries)179(" in Chapter 1 and)]TJ
0 -1.5 TD
[(Appendix D)17( gives more information about using GLUT. If you have access to the Internet, you can)]TJ
T*
(obtain the source code for both the sample programs and GLUT for free via anonymous ftp \(file-transfer)Tj
T*
(protocol\).)Tj
0 -2.1 TD
(For the source code examples found in this book, grab this file:)Tj
/F7 1 Tf
T*
(ftp://sgigate.sgi.com/pub/opengl/opengl1_1.tar.Z)Tj
/F11 1 Tf
T*
(The files you receive are compressed )Tj
/F15 1 Tf
15.1 0 TD
(tar)Tj
/F11 1 Tf
1.2 0 TD
( archives. To uncompress and extract the files, type)Tj
/F7 1 Tf
-16.3 -2.1 TD
(uncompress opengl1_1.tar)Tj
0 -1.5 TD
(tar xf opengl1_1.tar)Tj
/F11 1 Tf
0 -2.1 TD
(For Mark Kilgard's source code for an X Window System version of GLUT, you need to know what the)Tj
0 -1.5 TD
(most current version is. The filename will be )Tj
/F15 1 Tf
18.2 0 TD
(glut-i.j.tar.Z)Tj
/F11 1 Tf
4.9 0 TD
(, where )Tj
/F15 1 Tf
3.2 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
( is the major revision number and )Tj
/F15 1 Tf
13.7 0 TD
(j)Tj
/F11 1 Tf
0.3 0 TD
( is)Tj
-40.6 -1.5 TD
(the minor revision number of the most recent version. Check the directory for the right numbers, then)Tj
T*
(grab this file:)Tj
/F7 1 Tf
0 -2.1 TD
(ftp://sgigate.sgi.com/pub/opengl/xjournal/GLUT/glut-i.j.tar.Z)Tj
/F11 1 Tf
T*
(This file must also be uncompressed and extracted by using the )Tj
/F15 1 Tf
25.6 0 TD
(tar)Tj
/F11 1 Tf
1.1 0 TD
( command. The sample programs and)Tj
-26.7 -1.5 TD
(GLUT library are created as subdirectories from wherever you are in the file directory structure.)Tj
0 -2.1 TD
(Other ports of GLUT \(for example, for Microsoft Windows NT\) are springing up. A good place to start)Tj
0 -1.5 TD
(searching for the latest developments in GLUT and for OpenGL, in general, is Silicon Graphics')Tj
T*
(OpenGL Web Site:)Tj
/F7 1 Tf
0 -2.1 TD
(http://www.sgi.com/Technology/openGL)Tj
/F11 1 Tf
T*
(Many implementations of OpenGL might also include the code samples as part of the system. This)Tj
0 -1.5 TD
(source code is probably the best source for your implementation, because it might have been optimized)Tj
T*
(for your system. Read your machine-specific OpenGL documentation to see where the code samples can)Tj
T*
(be found.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 272.000 Tm
(Errata)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 250.000 Tm
(Although this book is ideal and perfec in every conceivable way, there is a a pointer to an errata list from)Tj
T*
(the Silicon Graphics OpenGL Web Site:)Tj
0 -2.1 TD
(http://www.sgi.com/Technology/openGL)Tj
T*
(The authors are quite certain there will be a little note there to reassure the reader of the pristeen quality)Tj
0 -1.5 TD
(of this book.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 145.000 Tm
(Style Conventions)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 123.000 Tm
(These style conventions are used in this guide:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F13 1 Tf
1.8 0 TD
(Bold)Tj
/F33 1 Tf
2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Command and routine names and matrices)Tj
/F33 1 Tf
-4.8 -2.3 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(Italics)Tj
/F33 1 Tf
2.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Variables, arguments, parameter names, spatial dimensions, matrix components, and the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - About This Guide - 5)Tj
ET
endstream
endobj
25 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
28 0 obj
<<
/Length 1394
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(first occurrence of key terms)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Regular)Tj
/F33 1 Tf
3.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Enumerated types and defined constants)Tj
-6.1 -2.8 TD
(Code examples are set off from the text in a monospace font, and command summaries are shaded with)Tj
0 -1.5 TD
(gray boxes.)Tj
0 -2.1 TD
(In a command summary, braces are used to identify choices among data types. In the following example,)Tj
/F15 1 Tf
0 -1.5 TD
(glCommand)Tj
/F11 1 Tf
4.9 0 TD
( has four possible suffixes: s, i, f, and d, which stand for the data types GLshort, GLint,)Tj
-4.9 -1.5 TD
(GLfloat, and GLdouble. In the function prototype for )Tj
/F15 1 Tf
21.6 0 TD
(glCommand)Tj
/F11 1 Tf
4.8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(TYPE)Tj
/F11 1 Tf
2.4 0 TD
( is a wildcard that represents the)Tj
-29.3 -1.5 TD
(data type indicated by the suffix.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glCommand)-10({sifd}\()78(TYPE)-66(x1)44(, TYPE)-66(y1)44(, TYPE)34(x2)-56(, TYPE)34(y2)-56(\);)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 537.440 m
547.000 537.440 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Acknowledgments - 6)Tj
ET
endstream
endobj
29 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
31 0 obj
<<
/Length 4240
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(Acknowledgments)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 685.000 Tm
0.000 Tw
(The second edition of this book required the support of many individuals. The impetus for the second)Tj
0 -1.5 TD
(edition began with Paula Womack and Tom McReynolds of Silicon Graphics, who recognized the need)Tj
T*
(for a revision and also contributed some of the new material. John Schimpf, OpenGL Product Manager at)Tj
T*
(Silicon Graphics, was instrumental in getting the revision off and running.)Tj
0 -2.1 TD
(Thanks to many people at Silicon Graphics: Allen Akin, Brian Cabral, Norman Chin, Kathleen)Tj
0 -1.5 TD
(Danielson, Craig Dunwoody, Michael Gold, Paul Ho, Deanna Hohn, Brian Hook, Kevin Hunter, David)Tj
T*
(Koller, Zicheng Liu, Rob Mace, Mark Segal, Pierre Tardif, and David Yu for putting up with intrusions)Tj
T*
(and inane questions. Thanks to Dave Orton and Kurt Akeley for executive-level support. Thanks to Kay)Tj
T*
(Maitz and Renate Kempf for document production support. And thanks to Cindy Ahuna, for always)Tj
T*
(keeping an eye out for free food.)Tj
0 -2.1 TD
(Special thanks are due to the reviewers who volunteered and trudged through the six hundred pages of)Tj
0 -1.5 TD
(technical material that constitute the second edition: Bill Armstrong of Evans & Sutherland, Patrick)Tj
T*
(Brown of IBM, Jim Cobb of Parametric Technology, Mark Kilgard of Silicon Graphics, Dale Kirkland of)Tj
T*
(Intergraph, and Andy Vesper of Digital Equipment. Their careful diligence has greatly improved the)Tj
T*
(quality of this book.)Tj
0 -2.1 TD
(Thanks to Mike Heck of Template Graphics Software, Gilman Wong of Microsoft, and Suzy Deffeyes of)Tj
0 -1.5 TD
[(IBM for their contributions to the technical information in )29(Appendix C)-38(.)]TJ
0 -2.1 TD
(The continued success of the OpenGL owes much to the commitment of the OpenGL Architecture)Tj
0 -1.5 TD
(Review Board \(ARB\) participants. They guide the evolution of the OpenGL standard and update the)Tj
T*
(specification to reflect the needs and desires of the graphics industry.  Active contributors of the OpenGL)Tj
T*
(ARB include Fred Fisher of AccelGraphics; Bill Clifford, Dick Coulter, and Andy Vesper of Digital)Tj
T*
(Equipment Corporation; Bill Armstrong of Evans & Sutherland; Kevin LeFebvre and Randi Rost of)Tj
T*
(Hewlett-Packard; Pat Brown and Bimal Poddar of IBM; Igor Sinyak of Intel; Dale Kirkland of)Tj
T*
(Intergraph; Henri Warren of Megatek; Otto Berkes, Drew Bliss, Hock San Lee, and Steve Wright of)Tj
T*
(Microsoft; Ken Garnett of NCD; Jim Cobb of Parametric Technology; Craig Dunwoody, Chris Frazier,)Tj
T*
(and Paula Womack of Silicon Graphics; Tim Misner and Bill Sweeney of Sun Microsystems; Mike Heck)Tj
T*
(of Template Graphics Software; and Andy Bigos, Phil Huxley, and Jeremy Morris of 3Dlabs.)Tj
0 -2.1 TD
(The second edition of this book would not have been possible without the first edition, and neither)Tj
0 -1.5 TD
(edition would have been possible without the creation of OpenGL.)Tj
0 -2.1 TD
(Thanks to the chief architects of OpenGL: Mark Segal and Kurt Akeley. Special recognition goes to the)Tj
0 -1.5 TD
(pioneers who heavily contributed to the initial design and functionality of OpenGL: Allen Akin, David)Tj
T*
(Blythe, Jim Bushnell, Dick Coulter, John Dennis, Raymond Drewry, Fred Fisher, Chris Frazier, Momi)Tj
T*
(Furuya, Bill Glazier, Kipp Hickman, Paul Ho, Rick Hodgson, Simon Hui, Lesley Kalmin, Phil Karlton,)Tj
T*
(On Lee, Randi Rost, Kevin P. Smith, Murali Sundaresan, Pierre Tardif, Linas Vepstas, Chuck Whitmer,)Tj
T*
(Jim Winget, and Wei Yen.)Tj
0 -2.1 TD
(Assembling the set of colorplates was no mean feat. The sequence of plates based on the cover image)Tj
0 -1.5 TD
[(\()33(Plate 1)-50( through )11(Plate 9)50(\))0( was created by Thad Beier, Seth Katz, and Mason Woo. )-25(Plate 10)-50( through )11(Plate)]TJ
T*
(12 are snapshots of programs created by Mason. Gavin Bell, Kevin Goldsmith, Linda Roy, and Mark)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Acknowledgments - 1)Tj
ET
endstream
endobj
32 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
34 0 obj
<<
/Length 4422
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Daly created the fly-through program used for )Tj
18.7 0 TD
[(Plate 24)-50(. The model for )-28(Plate 25)50( was created by Barry)]TJ
-18.7 -1.5 TD
(Brouillette of Silicon Graphics; Doug Voorhies, also of Silicon Graphics, performed some image)Tj
T*
[(processing for the final image. )43(Plate 26)-50( was created by John Rohlf and Michael Jones, both of Silicon)]TJ
T*
[(Graphics. )10(Plate 27)-50( was created by Carl Korobkin of Silicon Graphics. )77(Plate 28)-50( is a snapshot from a)]TJ
T*
(program written by Gavin Bell with contributions from the Open Inventor team at Silicon)Tj
0 -1.6 TD
(Graphics)Tj
/F33 1 Tf
3.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Alain Dumesny, Dave Immel, David Mott, Howard Look, Paul Isaacs, Paul Strauss, and Rikk)Tj
-4.6 -1.6 TD
[(Carey. )-12(Plate 29 and 30 are snapshots from a visual simulation program created by the Silicon Graphics)]TJ
T*
(IRIS Performer team)Tj
/F33 1 Tf
8.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Craig Phillips, John Rohlf,  Sharon Clay, Jim Helman, and Michael Jones)Tj
/F33 1 Tf
29.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(from)Tj
-39.9 -1.6 TD
[(a database produced for Silicon Graphics by Paradigm Simulation, Inc. )21(Plate 31)-50( is a snapshot from)]TJ
0 -1.5 TD
(skyfly, the precursor to Performer, which was created by John Rohlf, Sharon Clay, and Ben Garlick, all)Tj
T*
(of Silicon Graphics.)Tj
0 -2.1 TD
(Several other people played special roles in creating this book. If we were to list other names as authors)Tj
0 -1.5 TD
(on the front of this book, Kurt Akeley and Mark Segal would be there, as honorary yeoman. They helped)Tj
T*
(define the structure and goals of the book, provided key sections of material for it, reviewed it when)Tj
T*
(everybody else was too tired of it to do so, and supplied that all-important humor and support throughout)Tj
T*
(the process. Kay Maitz provided invaluable production and design assistance. Kathy Gochenour very)Tj
T*
(generously created many of the illustrations for this book. Susan Riley copyedited the manuscript, which)Tj
T*
(is a brave task, indeed.)Tj
0 -2.1 TD
(And now, each of the authors would like to take the 15 minutes that have been allotted to them by Andy)Tj
0 -1.5 TD
(Warhol to say thank you.)Tj
0 -2.2 TD
(I'd like to thank my managers at Silicon Graphics)Tj
/F33 1 Tf
19.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Dave Larson and Way Ting)Tj
/F33 1 Tf
11.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(and the members of)Tj
-33.1 -1.7 TD
(my group)Tj
/F33 1 Tf
3.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Patricia Creek, Arthur Evans, Beth Fryer, Jed Hartman, Ken Jones, Robert Reimann, Eve)Tj
-4.9 -1.7 TD
(Stratton \(aka Margaret-Anne Halse\), John Stearns, and Josie Wernecke)Tj
/F33 1 Tf
28.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for their support during this)Tj
-29.5 -1.5 TD
(lengthy process. Last but surely not least, I want to thank those whose contributions toward this project)Tj
T*
(are too deep and mysterious to elucidate: Yvonne Leach, Kathleen Lancaster, Caroline Rose, Cindy)Tj
T*
(Kleinfeld, and my parents, Florence and Ferdinand Neider.)Tj
/F33 1 Tf
0 -2.2 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(JLN)Tj
-1 -2.2 TD
(In addition to my parents, Edward and Irene Davis, I'd like to thank the people who taught me most of)Tj
0 -1.6 TD
(what I know about computers and computer graphics)Tj
/F33 1 Tf
21.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Doug Engelbart and Jim Clark.)Tj
/F33 1 Tf
-22.2 -2.3 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(TRD)Tj
-1 -2.2 TD
(I'd like to thank the many past and current members of Silicon Graphics whose accommodation and)Tj
0 -1.5 TD
(enlightenment were essential to my contribution to this book: Gerald Anderson, Wendy Chin, Bert)Tj
T*
(Fornaciari, Bill Glazier, Jill Huchital, Howard Look, Bill Mannel, David Marsland, Dave Orton, Linda)Tj
T*
(Roy, Keith Seto, and Dave Shreiner. Very special thanks to Karrin Nicol, Leilani Gayles, Kevin)Tj
T*
(Dankwardt, Kiyoshi Hasegawa, and Raj Singh for their guidance throughout my career. I also bestow)Tj
T*
(much gratitude to my teammates on the Stanford B ice hockey team for periods of glorious distraction)Tj
T*
(throughout the initial writing of this book. Finally, I'd like to thank my family, especially my mother, Bo,)Tj
T*
(and my late father, Henry.)Tj
/F33 1 Tf
0 -2.2 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(MW)Tj
ET
Q
endstream
endobj
35 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
37 0 obj
<<
/Length 265
>>
stream
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 691.520 m
547.000 691.520 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 3)Tj
ET
endstream
endobj
38 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
40 0 obj
<<
/Length 3536
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 1)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Introduction to OpenGL)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Appreciate in general terms what OpenGL does)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Identify different levels of rendering complexity)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Understand the basic structure of an OpenGL program)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Recognize OpenGL command syntax)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Identify the sequence of operations of the OpenGL rendering pipeline)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Understand in general terms how to animate graphics in an OpenGL program)Tj
-1.9 -2.8 TD
(This chapter introduces OpenGL. It has the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("What Is OpenGL?")48( explains what OpenGL is, what it does and doesn't do, and how it works.)]TJ
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("A Smidgen of OpenGL Code")38( presents a small OpenGL program and briefly discusses it. This)]TJ
0 -1.6 TD
(section also defines a few basic computer-graphics terms.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("OpenGL Command Syntax")-39( explains some of the conventions and notations used by OpenGL)]TJ
0 -1.6 TD
(commands.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("OpenGL as a State Machine")-8( describes the use of state variables in OpenGL and the commands for)]TJ
0 -1.5 TD
(querying, enabling, and disabling states.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("OpenGL Rendering Pipeline")-40( shows a typical sequence of operations for processing geometric and)]TJ
0 -1.5 TD
(image data.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("OpenGL-Related Libraries")195( describes sets of OpenGL-related routines, including an auxiliary)]TJ
0 -1.6 TD
(library specifically written for this book to simplify programming examples.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Animation" explains in general terms how to create pictures on the screen that move.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 212.000 Tm
(What Is OpenGL?)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 190.000 Tm
(OpenGL is a software interface to graphics hardware. This interface consists of about 150 distinct)Tj
0 -1.5 TD
(commands that you use to specify the objects and operations needed to produce interactive)Tj
T*
(three-dimensional applications.)Tj
0 -2.1 TD
(OpenGL is designed as a streamlined, hardware-independent interface to be implemented on many)Tj
0 -1.5 TD
(different hardware platforms. To achieve these qualities, no commands for performing windowing tasks)Tj
T*
(or obtaining user input are included in OpenGL; instead, you must work through whatever windowing)Tj
T*
(system controls the particular hardware you're using. Similarly, OpenGL doesn't provide high-level)Tj
T*
(commands for describing models of three-dimensional objects. Such commands might allow you to)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 1)Tj
ET
endstream
endobj
41 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
45 0 obj
<<
/Length 5410
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(specify relatively complicated shapes such as automobiles, parts of the body, airplanes, or molecules.)Tj
0 -1.6 TD
(With OpenGL, you must build up your desired model from a small set of )Tj
/F15 1 Tf
29.5 0 TD
(geometric primitives)Tj
/F33 1 Tf
8.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(points,)Tj
-38.7 -1.6 TD
(lines, and polygons.)Tj
0 -2.1 TD
(A sophisticated library that provides these features could certainly be built on top of OpenGL. The)Tj
0 -1.5 TD
(OpenGL Utility Library \(GLU\) provides many of the modeling features, such as quadric surfaces and)Tj
T*
(NURBS curves and surfaces. GLU is a standard part of every OpenGL implementation. Also, there is a)Tj
T*
(higher-level, object-oriented toolkit, Open Inventor, which is built atop OpenGL, and is available)Tj
T*
[(separately for many implementations of OpenGL. \(See )21("OpenGL-Related Libraries")195( for more)]TJ
T*
(information about Open Inventor.\))Tj
0 -2.1 TD
(Now that you know what OpenGL )Tj
/F15 1 Tf
14.1 0 TD
(doesn't)Tj
/F11 1 Tf
3 0 TD
( do, here's what it )Tj
/F15 1 Tf
7.4 0 TD
(does)Tj
/F11 1 Tf
1.8 0 TD
( do. Take a look at the color)Tj
-26.3 -1.6 TD
(plates)Tj
/F33 1 Tf
2.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(they illustrate typical uses of OpenGL. They show the scene on the cover of this book, )Tj
/F15 1 Tf
34.9 0 TD
(rendered)Tj
/F11 1 Tf
-38.2 -1.6 TD
(\(which is to say, drawn\) by a computer using OpenGL in successively more complicated ways. The)Tj
0 -1.5 TD
(following list describes in general terms how these pictures were made.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 1")-34( shows the entire scene displayed as a )]TJ
/F13 1 Tf
18.9 0 TD
(wireframe)Tj
/F11 1 Tf
4.4 0 TD
( model)Tj
/F33 1 Tf
2.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, as if all the objects in the)Tj
-27.1 -1.6 TD
(scene were made of wire. Each )Tj
/F13 1 Tf
12.7 0 TD
(line)Tj
/F11 1 Tf
1.5 0 TD
( of wire corresponds to an edge of a primitive \(typically a)Tj
-14.2 -1.5 TD
(polygon\). For example, the surface of the table is constructed from triangular polygons that are)Tj
T*
(positioned like slices of pie.)Tj
0 -2.1 TD
(Note that you can see portions of objects that would be obscured if the objects were solid rather than)Tj
0 -1.5 TD
(wireframe. For example, you can see the entire model of the hills outside the window even though)Tj
T*
(most of this model is normally hidden by the wall of the room. The globe appears to be nearly solid)Tj
T*
(because it's composed of hundreds of colored blocks, and you see the wireframe lines for all the)Tj
T*
(edges of all the blocks, even those forming the back side of the globe. The way the globe is)Tj
T*
(constructed gives you an idea of how complex objects can be created by assembling lower-level)Tj
T*
(objects.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 2")-34( shows a )]TJ
/F15 1 Tf
7.3 0 TD
(depth-cued)Tj
/F11 1 Tf
4.4 0 TD
( version of the same wireframe scene. Note that the lines farther from)Tj
-11.7 -1.6 TD
(the eye are dimmer, just as they would be in real life, thereby giving a visual cue of )Tj
/F13 1 Tf
33.6 0 TD
(depth)Tj
/F11 1 Tf
2.5 0 TD
(. OpenGL)Tj
-36.1 -1.6 TD
(uses atmospheric effects \(collectively referred to as )Tj
/F13 1 Tf
20.8 0 TD
(fog)Tj
/F11 1 Tf
1.3 0 TD
(\) to achieve depth cueing.)Tj
/F33 1 Tf
-23.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 3")-34( shows an )]TJ
/F15 1 Tf
7.8 0 TD
(antialiased)Tj
/F11 1 Tf
4.4 0 TD
( version of the wireframe scene. Antialiasing is a technique for)Tj
-12.2 -1.5 TD
(reducing the jagged edges \(also known as )Tj
/F15 1 Tf
16.9 0 TD
(jaggies)Tj
/F11 1 Tf
2.9 0 TD
(\) created when approximating smooth edges using)Tj
/F15 1 Tf
-19.8 -1.7 TD
(pixels)Tj
/F33 1 Tf
2.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(short for picture )Tj
/F15 1 Tf
6.7 0 TD
(elements)Tj
/F33 1 Tf
3.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(which are confined to a rectangular grid. Such jaggies are)Tj
-14.5 -1.5 TD
(usually the most visible with near-horizontal or near-vertical lines.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 4")-34( shows a )]TJ
/F15 1 Tf
7.3 0 TD
(flat-shaded)Tj
/F11 1 Tf
4.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(unlit)Tj
/F11 1 Tf
1.8 0 TD
( version of the scene. The objects in the scene are now shown as)Tj
-14.1 -1.6 TD
(solid. They appear "flat" in the sense that only one color is used to render each polygon, so they)Tj
0 -1.5 TD
(don't appear smoothly rounded. There are no effects from any light sources.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 5")-34( shows a )]TJ
/F15 1 Tf
7.3 0 TD
(lit, smooth-shaded)Tj
/F11 1 Tf
7.3 0 TD
( version of the scene. Note how the scene looks much more)Tj
-14.6 -1.6 TD
(realistic and three-dimensional when the objects are shaded to respond to the light sources in the)Tj
0 -1.5 TD
(room as if the objects were smoothly rounded.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 6")-34( adds )]TJ
/F15 1 Tf
5.9 0 TD
(shadows)Tj
/F11 1 Tf
3.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(textures)Tj
/F11 1 Tf
3.2 0 TD
( to the previous version of the scene. Shadows aren't an)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 2)Tj
ET
endstream
endobj
46 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
48 0 obj
<<
/Length 4449
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(explicitly defined feature of OpenGL \(there is no "shadow command"\), but you can create them)Tj
0 -1.5 TD
[(yourself using the techniques described in )-45(Chapter 14)16(. )]TJ
/F15 1 Tf
22 0 TD
(Texture mapping)Tj
/F11 1 Tf
6.8 0 TD
( allows you to apply a)Tj
-28.8 -1.5 TD
(two-dimensional image onto a three-dimensional object. In this scene, the top on the table surface is)Tj
T*
(the most vibrant example of texture mapping. The wood grain on the floor and table surface are all)Tj
T*
(texture mapped, as well as the wallpaper and the toy top \(on the table\).)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 7")-34( shows a )]TJ
/F15 1 Tf
7.3 0 TD
(motion-blurred)Tj
/F11 1 Tf
6.1 0 TD
( object in the scene. The sphinx \(or dog, depending on your)Tj
-13.4 -1.6 TD
(Rorschach tendencies\) appears to be captured moving forward, leaving a blurred trace of its path of)Tj
0 -1.5 TD
(motion.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 8")-34( shows the scene as it's drawn for the cover of the book from a different viewpoint. This)]TJ
0 -1.6 TD
(plate illustrates that the image really is a snapshot of models of three-dimensional objects.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 9")-34( brings back the use of fog, which was seen in )65("Plate 2,")16( to show the presence of smoke)]TJ
0 -1.6 TD
[(particles in the air. Note how the same effect in )-8("Plate 2")-34( now has a more dramatic impact in )55("Plate)]TJ
0 -1.5 TD
(9.")Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Plate 10")-34( shows the )]TJ
/F15 1 Tf
8.5 0 TD
(depth-of-field effect)Tj
/F11 1 Tf
7.9 0 TD
(, which simulates the inability of a camera lens to maintain)Tj
-16.4 -1.5 TD
(all objects in a photographed scene in focus. The camera focuses on a particular spot in the scene.)Tj
T*
(Objects that are significantly closer or farther than that spot are somewhat blurred.)Tj
-1.9 -2.7 TD
(The color plates give you an idea of the kinds of things you can do with the OpenGL graphics system.)Tj
0 -1.5 TD
(The following list briefly describes the major graphics operations which OpenGL performs to render an)Tj
T*
[(image on the screen. \(See "OpenGL Rendering Pipeline")-40( for detailed information about this order of)]TJ
T*
(operations.\))Tj
0 -2.1 TD
[(1.)-1050(Construct shapes from geometric primitives, thereby creating mathematical descriptions of objects.)]TJ
1.8 -1.5 TD
(\(OpenGL considers points, lines, polygons, images, and bitmaps to be primitives.\))Tj
-1.8 -2.1 TD
[(2.)-1050(Arrange the objects in three-dimensional space and select the desired vantage point for viewing the)]TJ
1.8 -1.5 TD
(composed scene.)Tj
-1.8 -2.1 TD
[(3.)-1050(Calculate the color of all the objects. The color might be explicitly assigned by the application,)]TJ
1.8 -1.5 TD
(determined from specified lighting conditions, obtained by pasting a texture onto the objects, or)Tj
T*
(some combination of these three actions.)Tj
-1.8 -2.1 TD
[(4.)-1050(Convert the mathematical description of objects and their associated color information to pixels on)]TJ
1.8 -1.5 TD
(the screen. This process is called )Tj
/F15 1 Tf
13.4 0 TD
(rasterization)Tj
/F11 1 Tf
5.1 0 TD
(.)Tj
-20.3 -2.6 TD
(During these stages, OpenGL might perform other operations, such as eliminating parts of objects that)Tj
0 -1.5 TD
(are hidden by other objects. In addition, after the scene is rasterized but before it's drawn on the screen,)Tj
T*
(you can perform some operations on the pixel data if you want.)Tj
0 -2.1 TD
(In some implementations \(such as with the X Window System\), OpenGL is designed to work even if the)Tj
0 -1.5 TD
(computer that displays the graphics you create isn't the computer that runs your graphics program. This)Tj
T*
(might be the case if you work in a networked computer environment where many computers are)Tj
T*
(connected to one another by a digital network. In this situation, the computer on which your program)Tj
0 -1.6 TD
(runs and issues OpenGL drawing commands is called the )Tj
/F13 1 Tf
23.2 0 TD
(client)Tj
/F11 1 Tf
2.3 0 TD
(, and the computer that receives those)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 3)Tj
ET
endstream
endobj
49 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
50 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im1
/Width 392
/Height 218
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.0)
>>
stream
endstream
endobj
52 0 obj
<<
/Length 3415
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(commands and performs the drawing is called the )Tj
/F13 1 Tf
20.2 0 TD
(server)Tj
/F11 1 Tf
2.6 0 TD
(. The format for transmitting OpenGL)Tj
-22.8 -1.5 TD
(commands \(called the )Tj
/F15 1 Tf
9 0 TD
(protocol)Tj
/F11 1 Tf
3.4 0 TD
(\) from the client to the server is always the same, so OpenGL programs)Tj
-12.4 -1.6 TD
(can work across a )Tj
/F13 1 Tf
7.4 0 TD
(network)Tj
/F11 1 Tf
3.5 0 TD
( even if the client and server are different kinds of computers. If an OpenGL)Tj
-10.9 -1.5 TD
(program isn't running across a network, then there's only one computer, and it is both the client and the)Tj
T*
(server.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 617.000 Tm
(A Smidgen of OpenGL Code)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 595.000 Tm
(Because you can do so many things with the OpenGL graphics system, an OpenGL program can be)Tj
T*
(complicated. However, the basic structure of a useful program can be simple: Its tasks are to initialize)Tj
T*
(certain states that control how OpenGL renders and to specify objects to be rendered.)Tj
0 -2.1 TD
(Before you look at some OpenGL code, let's go over a few terms. )Tj
/F15 1 Tf
26.6 0 TD
(Rendering)Tj
/F11 1 Tf
4.2 0 TD
(, which you've already seen)Tj
-30.8 -1.5 TD
(used, is the process by which a computer creates images from models. These )Tj
/F15 1 Tf
31 0 TD
(models)Tj
/F11 1 Tf
2.8 0 TD
(, or objects, are)Tj
-33.8 -1.6 TD
(constructed from geometric primitives)Tj
/F33 1 Tf
15.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(points, lines, and polygons)Tj
/F33 1 Tf
10.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that are specified by their )Tj
/F13 1 Tf
10.4 0 TD
(vertices)Tj
/F11 1 Tf
3.2 0 TD
(.)Tj
-41.7 -2.2 TD
(The final rendered image consists of pixels drawn on the screen; a pixel is the smallest visible element)Tj
0 -1.5 TD
(the display hardware can put on the screen. Information about the pixels \(for instance, what color they're)Tj
0 -1.6 TD
(supposed to be\) is organized in memory into bitplanes. A )Tj
/F13 1 Tf
23.1 0 TD
(bitplane)Tj
/F11 1 Tf
3.5 0 TD
( is an area of memory that holds one)Tj
/F13 1 Tf
-26.6 -1.5 TD
(bit)Tj
/F11 1 Tf
1.2 0 TD
( of information for every pixel on the screen; the bit might indicate how red a particular pixel is)Tj
-1.2 -1.5 TD
(supposed to be, for example. The bitplanes are themselves organized into a )Tj
/F15 1 Tf
30.3 0 TD
(framebuffer)Tj
/F11 1 Tf
4.7 0 TD
(, which holds all)Tj
-35 -1.5 TD
(the information that the graphics display needs to control the color and intensity of all the pixels on the)Tj
T*
(screen.)Tj
0 -2.1 TD
[(Now look at what an OpenGL program might look like. )-16(Example 1-1)]TJ
27.7 0 TD
( renders a white rectangle on a)Tj
-27.7 -1.5 TD
[(black background, as shown in )11(Figure 1-1)225(.)]TJ
ET
Q
/GS1 gs
q
392 0 0 218 124 131.84 cm
/Im1 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 119.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 1-1 )Tj
/F11 1 Tf
5.1 0 TD
(White Rectangle on a Black Background)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 1-1 )Tj
/F11 1 Tf
6.1 0 TD
(Chunk of OpenGL Code)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 4)Tj
ET
endstream
endobj
53 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im1 50 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
55 0 obj
<<
/Length 4258
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(#include <whateverYouNeed.h>)Tj
0 -3 TD
(main\(\) {)Tj
T*
(   InitializeAWindowPlease\(\);)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glClear \(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
T*
(   glOrtho\(0.0, 1.0, 0.0, 1.0, -1.0, 1.0\);)Tj
T*
(   glBegin\(GL_POLYGON\);)Tj
T*
(      glVertex3f \(0.25, 0.25, 0.0\);)Tj
T*
(      glVertex3f \(0.75, 0.25, 0.0\);)Tj
T*
(      glVertex3f \(0.75, 0.75, 0.0\);)Tj
T*
(      glVertex3f \(0.25, 0.75, 0.0\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   glFlush\(\);)Tj
0 -3 TD
(   UpdateTheWindowAndCheckForEvents\(\);)Tj
0 -1.5 TD
(})Tj
/F11 1 Tf
0 -2.1 TD
(The first line of the )Tj
/F15 1 Tf
8 0 TD
(main\(\))Tj
/F11 1 Tf
2.6 0 TD
( routine initializes a )Tj
/F15 1 Tf
8.2 0 TD
(window)Tj
/F11 1 Tf
3.1 0 TD
( on the screen: The )Tj
/F15 1 Tf
7.9 0 TD
(InitializeAWindowPlease\(\))Tj
/F11 1 Tf
-29.8 -1.5 TD
(routine is meant as a placeholder for window system-specific routines, which are generally not OpenGL)Tj
T*
(calls. The next two lines are OpenGL commands that clear the window to black: )Tj
/F15 1 Tf
32.4 0 TD
(glClearColor\(\))Tj
/F11 1 Tf
-32.4 -1.5 TD
(establishes what color the window will be cleared to, and )Tj
/F15 1 Tf
23.1 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.8 0 TD
( actually clears the window. Once the)Tj
-26.9 -1.5 TD
(clearing color is set, the window is cleared to that color whenever )Tj
/F15 1 Tf
26.5 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.7 0 TD
( is called. This clearing color)Tj
-30.2 -1.5 TD
(can be changed with another call to )Tj
/F15 1 Tf
14.4 0 TD
(glClearColor\(\))Tj
/F11 1 Tf
6.1 0 TD
(. Similarly, the )Tj
/F15 1 Tf
6.2 0 TD
(glColor3f\(\))Tj
/F11 1 Tf
4.5 0 TD
( command establishes what)Tj
-31.2 -1.6 TD
(color to use for drawing objects)Tj
/F33 1 Tf
12.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in this case, the color is white. All objects drawn after this point use)Tj
-13.7 -1.6 TD
(this color, until it's changed with another call to set the color.)Tj
0 -2.2 TD
(The next OpenGL command used in the program, )Tj
/F15 1 Tf
20.2 0 TD
(glOrtho\(\))Tj
/F11 1 Tf
3.8 0 TD
(, specifies the )Tj
/F13 1 Tf
5.7 0 TD
(coordinate system)Tj
/F11 1 Tf
7.7 0 TD
( OpenGL)Tj
-37.4 -1.5 TD
(assumes as it draws the final image and how the image gets mapped to the screen. The next calls, which)Tj
0 -1.6 TD
(are bracketed by )Tj
/F15 1 Tf
6.9 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
(, define the object to be drawn)Tj
/F33 1 Tf
12.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in this example, a polygon with)Tj
-28.8 -1.5 TD
(four vertices. The polygon's "corners" are defined by the )Tj
/F15 1 Tf
23 0 TD
(glVertex3f\(\))Tj
/F11 1 Tf
4.9 0 TD
( commands. As you might be able)Tj
-27.9 -1.5 TD
(to guess from the arguments, which are \()Tj
/F15 1 Tf
16.3 0 TD
(x, y, z)Tj
/F11 1 Tf
2.3 0 TD
(\) coordinates, the polygon is a rectangle on the z=0 plane.)Tj
-18.6 -2.1 TD
(Finally, )Tj
/F15 1 Tf
3.3 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.8 0 TD
( ensures that the drawing commands are actually executed rather than stored in a )Tj
/F15 1 Tf
32.4 0 TD
(buffer)Tj
/F11 1 Tf
-39.5 -1.5 TD
(awaiting additional OpenGL commands. The )Tj
/F15 1 Tf
18.3 0 TD
(UpdateTheWindowAndCheckForEvents\(\))Tj
/F11 1 Tf
16.7 0 TD
( placeholder)Tj
-35 -1.5 TD
(routine manages the contents of the window and begins event processing.)Tj
0 -2.1 TD
(Actually, this piece of OpenGL code isn't well structured. You may be asking, "What happens if I try to)Tj
0 -1.5 TD
(move or resize the window?" Or, "Do I need to reset the coordinate system each time I draw the)Tj
T*
(rectangle?" Later in this chapter, you will see replacements for both )Tj
/F15 1 Tf
27.3 0 TD
(InitializeAWindowPlease\(\))Tj
/F11 1 Tf
10.8 0 TD
( and)Tj
/F15 1 Tf
-38.1 -1.5 TD
(UpdateTheWindowAndCheckForEvents\(\) )Tj
/F11 1 Tf
16.9 0 TD
(that actually work but will require restructuring the code to)Tj
-16.9 -1.5 TD
(make it efficient.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 5)Tj
ET
endstream
endobj
56 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
58 0 obj
<<
/Length 4996
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 698.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL Command Syntax)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 676.000 Tm
(As you might have observed from the simple program in the previous section, OpenGL commands use)Tj
0 -1.5 TD
(the prefix )Tj
/F15 1 Tf
4.1 0 TD
(gl)Tj
/F11 1 Tf
0.8 0 TD
( and initial capital letters for each word making up the command name \(recall)Tj
/F15 1 Tf
-4.9 -1.5 TD
(glClearColor\(\))Tj
/F11 1 Tf
6.1 0 TD
(, for example\). Similarly, OpenGL defined constants begin with GL_, use all capital)Tj
-6.1 -1.5 TD
(letters, and use underscores to separate words \(like GL_COLOR_BUFFER_BIT\).)Tj
0 -2.1 TD
(You might also have noticed some seemingly extraneous letters appended to some command names \(for)Tj
0 -1.5 TD
(example, the )Tj
/F15 1 Tf
5.4 0 TD
(3f)Tj
/F11 1 Tf
0.7 0 TD
( in )Tj
/F15 1 Tf
1.3 0 TD
(glColor3f\(\) and glVertex3f\(\))Tj
/F11 1 Tf
11.4 0 TD
(\). It's true that the )Tj
/F15 1 Tf
7.4 0 TD
(Color)Tj
/F11 1 Tf
2.4 0 TD
( part of the command name)Tj
/F15 1 Tf
-28.6 -1.5 TD
(glColor3f\(\))Tj
/F11 1 Tf
4.6 0 TD
( is enough to define the command as one that sets the current color. However, more than one)Tj
-4.6 -1.5 TD
(such command has been defined so that you can use different types of arguments. In particular, the )Tj
/F15 1 Tf
39.8 0 TD
(3)Tj
/F11 1 Tf
0.5 0 TD
( part)Tj
-40.3 -1.5 TD
(of the suffix indicates that three arguments are given; another version of the )Tj
/F15 1 Tf
30.6 0 TD
(Color)Tj
/F11 1 Tf
2.3 0 TD
( command takes four)Tj
-32.9 -1.5 TD
(arguments. The )Tj
/F15 1 Tf
6.5 0 TD
(f)Tj
/F11 1 Tf
0.2 0 TD
( part of the suffix indicates that the arguments are floating-point numbers. Having)Tj
-6.7 -1.5 TD
(different formats allows OpenGL to accept the user's data in his or her own data format.)Tj
0 -2.1 TD
(Some OpenGL commands accept as many as 8 different data types for their arguments. The letters used)Tj
0 -1.5 TD
[(as suffixes to specify these data types for ISO C implementations of OpenGL are shown in )-46(Table 1-1)]TJ
40.4 0 TD
(,)Tj
-40.4 -1.5 TD
(along with the corresponding OpenGL type definitions. The particular implementation of OpenGL that)Tj
T*
(you're using might not follow this scheme exactly; an implementation in C++ or Ada, for example,)Tj
T*
(wouldn't need to.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 427.690 m
472.000 427.690 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 420.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Suffix)-1347(Data Type)-8220(Typical Corresponding)]TJ
17.125 -1.5 TD
(C-Language Type)Tj
11.875 1.5 TD
(OpenGL Type Definition)Tj
ET
Q
124.000 402.170 m
472.000 402.170 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 394.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(b)-3167(8-bit integer)-6408(signed char)-5973(GLbyte)]TJ
0 -1.4444 TD
[(s)-3278(16-bit integer)-5908(short)-8555(GLshort)]TJ
T*
[(i)-3389(32-bit integer)-5908(int or long)-6388(GLint, GLsizei)]TJ
T*
[(f)-3334(32-bit floating-point)-2953(float)-8722(GLfloat, GLclampf)]TJ
T*
[(d)-3167(64-bit floating-point)-2953(double)-7833(GLdouble, GLclampd)]TJ
T*
[(ub)-2667(8-bit unsigned integer)-2546(unsigned char)-4973(GLubyte, GLboolean)]TJ
T*
[(us)-2778(16-bit unsigned integer)-2046(unsigned short)-4694(GLushort)]TJ
T*
[(ui)-2889(32-bit unsigned integer)-2046(unsigned int or unsigned)]TJ
15.2222 -1.3333 TD
(long)Tj
10.5556 1.3333 TD
(GLuint, GLenum, GLbitfield)Tj
ET
Q
124.000 283.260 m
472.010 283.260 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 267.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 1-1 )Tj
/F11 1 Tf
4.6 0 TD
(Command Suffixes and Argument Data Types)Tj
-4.6 -2.1 TD
(Thus, the two commands)Tj
/F7 1 Tf
T*
(glVertex2i\(1, 3\);)Tj
0 -1.5 TD
(glVertex2f\(1.0, 3.0\);)Tj
/F11 1 Tf
0 -2.1 TD
(are equivalent, except that the first specifies the vertex's coordinates as 32-bit integers, and the second)Tj
0 -1.5 TD
(specifies them as single-precision floating-point numbers.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Implementations of OpenGL have leeway in selecting which C data type to use to represent)Tj
-2.8 -1.4 TD
(OpenGL data types. If you resolutely use the OpenGL defined data types throughout your application,)Tj
0 -1.5 TD
(you will avoid mismatched types when porting your code between different implementations.)Tj
0 -2.1 TD
(Some OpenGL commands can take a final letter )Tj
/F15 1 Tf
19.5 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
(, which indicates that the command takes a pointer to a)Tj
-19.9 -1.5 TD
(vector \(or array\) of values rather than a series of individual arguments. Many commands have both)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 6)Tj
ET
endstream
endobj
59 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
61 0 obj
<<
/Length 4968
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(vector and nonvector versions, but some commands accept only individual arguments and others require)Tj
0 -1.5 TD
(that at least some of the arguments be specified as a vector. The following lines show how you might use)Tj
T*
(a vector and a nonvector version of the command that sets the current color:)Tj
/F7 1 Tf
0 -2.1 TD
(glColor3f\(1.0, 0.0, 0.0\);)Tj
0 -3 TD
(GLfloat color_array[] = {1.0, 0.0, 0.0};)Tj
0 -1.5 TD
(glColor3fv\(color_array\);)Tj
/F11 1 Tf
0 -2.1 TD
(Finally, OpenGL defines the typedef GLvoid. This is most often used for OpenGL commands that accept)Tj
0 -1.5 TD
(pointers to arrays of values.)Tj
0 -2.1 TD
(In the rest of this guide \(except in actual code examples\), OpenGL commands are referred to by their)Tj
0 -1.5 TD
(base names only, and an asterisk is included to indicate that there may be more to the command name.)Tj
T*
(For example, )Tj
/F15 1 Tf
5.5 0 TD
(glColor*\(\))Tj
/F11 1 Tf
4.3 0 TD
( stands for all variations of the command you use to set the current color. If we)Tj
-9.8 -1.5 TD
(want to make a specific point about one version of a particular command, we include the suffix necessary)Tj
T*
(to define that version. For example, )Tj
/F15 1 Tf
14.5 0 TD
(glVertex*v\(\))Tj
/F11 1 Tf
5 0 TD
( refers to all the vector versions of the command you use)Tj
-19.5 -1.5 TD
(to specify vertices.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 449.000 Tm
(OpenGL as a State Machine)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 427.000 Tm
(OpenGL is a state machine. You put it into various states \(or modes\) that then remain in effect until you)Tj
T*
(change them. As you've already seen, the current color is a state variable. You can set the current color)Tj
T*
(to white, red, or any other color, and thereafter every object is drawn with that color until you set the)Tj
T*
(current color to something else. The current color is only one of many state variables that OpenGL)Tj
T*
(maintains. Others control such things as the current viewing and projection transformations, line and)Tj
T*
(polygon stipple patterns, polygon drawing modes, pixel-packing conventions, positions and)Tj
T*
(characteristics of lights, and material properties of the objects being drawn. Many state variables refer to)Tj
T*
(modes that are enabled or disabled with the command )Tj
/F15 1 Tf
21.8 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.6 0 TD
(.)Tj
-32 -2.1 TD
(Each state variable or mode has a default value, and at any point you can query the system for each)Tj
0 -1.5 TD
(variable's current value. Typically, you use one of the six following commands to do this:)Tj
/F15 1 Tf
T*
(glGetBooleanv\(\))Tj
/F11 1 Tf
6.7 0 TD
(,)Tj
/F15 1 Tf
0.2 0 TD
( glGetDoublev\(\))Tj
/F11 1 Tf
6.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glGetFloatv\(\))Tj
/F11 1 Tf
5.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.3 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glGetPointerv\(\))Tj
/F11 1 Tf
6.3 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(glIsEnabled\(\))Tj
/F11 1 Tf
5.5 0 TD
(.)Tj
-40.1 -1.5 TD
(Which of these commands you select depends on what data type you want the answer to be given in.)Tj
T*
(Some state variables have a more specific query command \(such as )Tj
/F15 1 Tf
27.2 0 TD
(glGetLight*\(\))Tj
/F11 1 Tf
5.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glGetError\(\))Tj
/F11 1 Tf
5.2 0 TD
(, or)Tj
/F15 1 Tf
-38.4 -1.5 TD
(glGetPolygonStipple\(\))Tj
/F11 1 Tf
9 0 TD
(\). In addition, you can save a collection of state variables on an attribute stack with)Tj
/F15 1 Tf
-9 -1.5 TD
(glPushAttrib\(\))Tj
/F11 1 Tf
5.8 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(glPushClientAttrib\(\))Tj
/F11 1 Tf
8.2 0 TD
(, temporarily modify them, and later restore the values with)Tj
/F15 1 Tf
-15.3 -1.5 TD
(glPopAttrib\(\))Tj
/F11 1 Tf
5.4 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(glPopClientAttrib\(\))Tj
/F11 1 Tf
7.9 0 TD
(. For temporary state changes, you should use these commands)Tj
-14.6 -1.5 TD
(rather than any of the query commands, since they're likely to be more efficient.)Tj
0 -2.1 TD
[(See )-6(Appendix B)-38( for the complete list of state variables you can query. For each variable, the appendix)]TJ
0 -1.5 TD
(also lists a suggested )Tj
/F15 1 Tf
8.6 0 TD
(glGet*\(\))Tj
/F11 1 Tf
3.4 0 TD
( command that returns the variable's value, the attribute class to which it)Tj
-12 -1.5 TD
(belongs, and the variable's default value.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 97.000 Tm
(OpenGL Rendering Pipeline)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 75.000 Tm
(Most implementations of OpenGL have a similar order of operations, a series of processing stages called)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 7)Tj
ET
endstream
endobj
62 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
63 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im2
/Width 549
/Height 216
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.1)
>>
stream
endstream
endobj
65 0 obj
<<
/Length 3213
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(the OpenGL rendering pipeline. This ordering, as shown in )16(Figure 1-2)225(, is not a strict rule of how)]TJ
0 -1.5 TD
(OpenGL is implemented but provides a reliable guide for predicting what OpenGL will do.)Tj
0 -2.1 TD
(If you are new to three-dimensional graphics, the upcoming description may seem like drinking water out)Tj
0 -1.5 TD
[(of a fire hose. You can skim this now, but come back to )-17(Figure 1-2)225( as you go through each chapter in this)]TJ
T*
(book.)Tj
0 -2.1 TD
(The following diagram shows the Henry Ford assembly line approach, which OpenGL takes to)Tj
0 -1.5 TD
(processing data. Geometric data \(vertices, lines, and polygons\) follow the path through the row of boxes)Tj
T*
(that includes evaluators and per-vertex operations, while pixel data \(pixels, images, and bitmaps\) are)Tj
T*
(treated differently for part of the process. Both types of data undergo the same final steps \(rasterization)Tj
T*
(and per-fragment operations\) before the final pixel data is written into the framebuffer.)Tj
ET
Q
/GS1 gs
q
423 0 0 166 124 380.54 cm
/Im2 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 367.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 1-2 )Tj
/F11 1 Tf
5.1 0 TD
(Order of Operations)Tj
-5.1 -2.1 TD
(Now you'll see more detail about the key stages in the OpenGL rendering pipeline.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 318.000 Tm
(Display Lists)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 296.000 Tm
(All data, whether it describes geometry or pixels, can be saved in a )Tj
/F15 1 Tf
27 0 TD
(display list)Tj
/F11 1 Tf
4.4 0 TD
( for current or later use.)Tj
-31.4 -1.6 TD
(\(The alternative to retaining data in a display list is processing the data immediately)Tj
/F33 1 Tf
33.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(also known as)Tj
/F15 1 Tf
-34.5 -1.6 TD
(immediate mode)Tj
/F11 1 Tf
6.6 0 TD
(.\) When a display list is executed, the retained data is sent from the display list just as if)Tj
-6.6 -1.5 TD
[(it were sent by the application in immediate mode. \(See )28(Chapter 7)16( for more information about display)]TJ
T*
(lists.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 205.000 Tm
(Evaluators)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 184.000 Tm
(All geometric primitives are eventually described by vertices. Parametric curves and surfaces may be)Tj
T*
(initially described by control points and polynomial functions called basis functions. Evaluators provide)Tj
T*
(a method to derive the vertices used to represent the surface from the control points. The method is a)Tj
T*
(polynomial mapping, which can produce surface normal, texture coordinates, colors, and spatial)Tj
T*
[(coordinate values from the control points. \(See Chapter 12)16( to learn more about evaluators.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 95.000 Tm
(Per-Vertex Operations)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 8)Tj
ET
endstream
endobj
66 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im2 63 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
68 0 obj
<<
/Length 4100
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(For vertex data, next is the "per-vertex operations" stage, which converts the vertices into primitives.)Tj
0 -1.5 TD
(Some vertex data \(for example, spatial coordinates\) are transformed by 4 x 4 floating-point matrices.)Tj
T*
(Spatial coordinates are projected from a position in the 3D world to a position on your screen. \(See)Tj
T*
[(Chapter 3)16( for details about the transformation matrices.\))]TJ
0 -2.1 TD
(If advanced features are enabled, this stage is even busier. If texturing is used, texture coordinates may be)Tj
0 -1.5 TD
(generated and transformed here. If lighting is enabled, the lighting calculations are performed using the)Tj
T*
(transformed vertex, surface normal, light source position, material properties, and other lighting)Tj
T*
(information to produce a color value.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 571.000 Tm
(Primitive Assembly)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 550.000 Tm
(Clipping, a major part of primitive assembly, is the elimination of portions of geometry which fall)Tj
T*
(outside a half-space, defined by a plane. Point clipping simply passes or rejects vertices; line or polygon)Tj
T*
(clipping can add additional vertices depending upon how the line or polygon is clipped.)Tj
0 -2.1 TD
(In some cases, this is followed by perspective division, which makes distant geometric objects appear)Tj
0 -1.5 TD
(smaller than closer objects. Then viewport and depth \(z coordinate\) operations are applied. If culling is)Tj
T*
(enabled and the primitive is a polygon, it then may be rejected by a culling test. Depending upon the)Tj
T*
[(polygon mode, a polygon may be drawn as points or lines. \(See )-33("Polygon Details" in Chapter 2)28(.)0(\))]TJ
0 -2.1 TD
(The results of this stage are complete geometric primitives, which are the transformed and clipped)Tj
0 -1.5 TD
(vertices with related color, depth, and sometimes texture-coordinate values and guidelines for the)Tj
T*
(rasterization step.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 374.000 Tm
(Pixel Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 352.000 Tm
(While geometric data takes one path through the OpenGL rendering pipeline, pixel data takes a different)Tj
T*
(route. Pixels from an array in system memory are first unpacked from one of a variety of formats into the)Tj
T*
(proper number of components. Next the data is scaled, biased, and processed by a pixel map. The results)Tj
T*
[(are clamped and then either written into texture memory or sent to the rasterization step. \(See )-19("Imaging)]TJ
T*
[(Pipeline" in Chapter 8)-19(.)0(\))]TJ
0 -2.1 TD
(If pixel data is read from the frame buffer, pixel-transfer operations \(scale, bias, mapping, and clamping\))Tj
0 -1.5 TD
(are performed. Then these results are packed into an appropriate format and returned to an array in)Tj
T*
(system memory.)Tj
0 -2.1 TD
(There are special pixel copy operations to copy data in the framebuffer to other parts of the framebuffer)Tj
0 -1.5 TD
(or to the texture memory. A single pass is made through the pixel transfer operations before the data is)Tj
T*
(written to the texture memory or back to the framebuffer.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 162.000 Tm
(Texture Assembly)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 140.000 Tm
(An OpenGL application may wish to apply texture images onto geometric objects to make them look)Tj
T*
(more realistic. If several texture images are used, it's wise to put them into texture objects so that you can)Tj
T*
(easily switch among them.)Tj
0 -2.1 TD
(Some OpenGL implementations may have special resources to accelerate texture performance. There)Tj
0 -1.5 TD
(may be specialized, high-performance texture memory. If this memory is available, the texture objects)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 9)Tj
ET
endstream
endobj
69 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
71 0 obj
<<
/Length 4542
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(may be prioritized to control the use of this limited and valuable resource. \(See )-40(Chapter 9)16(.)0(\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 678.000 Tm
(Rasterization)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 657.000 Tm
(Rasterization is the conversion of both geometric and pixel data into )Tj
/F15 1 Tf
27.6 0 TD
(fragments)Tj
/F11 1 Tf
4 0 TD
(. Each fragment square)Tj
-31.6 -1.5 TD
(corresponds to a pixel in the framebuffer. Line and polygon stipples, line width, point size, shading)Tj
T*
(model, and coverage calculations to support antialiasing are taken into consideration as vertices are)Tj
T*
(connected into lines or the interior pixels are calculated for a filled polygon. Color and depth values are)Tj
T*
(assigned for each fragment square.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 568.000 Tm
(Fragment Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 547.000 Tm
(Before values are actually stored into the framebuffer, a series of operations are performed that may alter)Tj
T*
(or even throw out fragments. All these operations can be enabled or disabled.)Tj
0 -2.2 TD
(The first operation which may be encountered is texturing, where a )Tj
/F13 1 Tf
27.1 0 TD
(texel)Tj
/F11 1 Tf
2 0 TD
( \(texture element\) is generated)Tj
-29.1 -1.5 TD
(from texture memory for each fragment and applied to the fragment. Then fog calculations may be)Tj
T*
(applied, followed by the scissor test, the alpha test, the stencil test, and the depth-buffer test \(the depth)Tj
T*
(buffer is for hidden-surface removal\). Failing an enabled test may end the continued processing of a)Tj
T*
(fragment's square. Then, blending, dithering, logical operation, and masking by a bitmask may be)Tj
T*
[(performed. \(See )-7(Chapter 6)16( and )-56(Chapter 10)16(\) Finally, the thoroughly processedfragment is drawn into the)]TJ
T*
(appropriate buffer, where it has finally advanced to be a pixel and achieved its final resting place.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 387.000 Tm
(OpenGL-Related Libraries)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 365.000 Tm
(OpenGL provides a powerful but primitive set of rendering commands, and all higher-level drawing must)Tj
T*
(be done in terms of these commands. Also, OpenGL programs have to use the underlying mechanisms of)Tj
T*
(the windowing system. A number of libraries exist to allow you to simplify your programming tasks,)Tj
T*
(including the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The OpenGL Utility Library \(GLU\) contains several routines that use lower-level OpenGL)Tj
0 -1.6 TD
(commands to perform such tasks as setting up matrices for specific viewing orientations and)Tj
0 -1.5 TD
(projections, performing polygon tessellation, and rendering surfaces. This library is provided as part)Tj
T*
(of every OpenGL implementation. Portions of the GLU are described in the )Tj
/F15 1 Tf
30.6 0 TD
(OpenGL Reference)Tj
-30.6 -1.5 TD
(Manual)Tj
/F11 1 Tf
3.1 0 TD
(. The more useful GLU routines are described in this guide, where they're relevant to the)Tj
-3.1 -1.5 TD
[(topic being discussed, such as in all of Chapter 11 and in the section )28("The GLU NURBS Interface")]TJ
T*
[(in Chapter 12)45(. GLU routines use the prefix )]TJ
/F15 1 Tf
17.4 0 TD
(glu)Tj
/F11 1 Tf
1.3 0 TD
(.)Tj
/F33 1 Tf
-20.5 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(For every window system, there is a library that extends the functionality of that window system to)Tj
0 -1.6 TD
(support OpenGL rendering. For machines that use the X Window System, the OpenGL Extension to)Tj
0 -1.5 TD
(the X Window System \(GLX\) is provided as an adjunct to OpenGL. GLX routines use the prefix)Tj
/F15 1 Tf
T*
(glX)Tj
/F11 1 Tf
1.4 0 TD
(. For Microsoft Windows, the WGL routines provide the Windows to OpenGL interface. All)Tj
-1.4 -1.5 TD
(WGL routines use the prefix )Tj
/F15 1 Tf
11.7 0 TD
(wgl)Tj
/F11 1 Tf
1.4 0 TD
(. For IBM OS/2, the PGL is the Presentation Manager to OpenGL)Tj
-13.1 -1.5 TD
(interface, and its routines use the prefix )Tj
/F15 1 Tf
16.1 0 TD
(pgl)Tj
/F11 1 Tf
1.2 0 TD
(.)Tj
-17.3 -2.1 TD
[(All these window system extension libraries are described in more detail in both )-39(Appendix C)62(.)0( In)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 10)Tj
ET
endstream
endobj
72 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
74 0 obj
<<
/Length 4021
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(addition, the GLX routines are also described in the )Tj
/F15 1 Tf
20.9 0 TD
(OpenGL Reference Manual)Tj
/F11 1 Tf
11.1 0 TD
(.)Tj
/F33 1 Tf
-33.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The OpenGL Utility Toolkit \(GLUT\) is a window system-independent toolkit, written by Mark)Tj
0 -1.6 TD
(Kilgard, to hide the complexities of differing window system APIs. GLUT is the subject of the next)Tj
0 -1.5 TD
(section, and it's described in more detail in Mark Kilgard's book )Tj
/F15 1 Tf
26.2 0 TD
(OpenGL Programming for the X)Tj
-26.2 -1.5 TD
(Window System)Tj
/F11 1 Tf
6.3 0 TD
( \(ISBN 0-201-48359-9\). GLUT routines use the prefix )Tj
/F15 1 Tf
22 0 TD
(glut. )Tj
/F11 1 Tf
2.1 0 TD
("How to Obtain the)Tj
-30.4 -1.5 TD
(Sample Code")Tj
/F15 1 Tf
5.8 0 TD
( in the Preface )Tj
/F11 1 Tf
6.1 0 TD
(describes how to obtain the source code for GLUT, using ftp.)Tj
/F33 1 Tf
-13.7 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Open Inventor is an object-oriented toolkit based on OpenGL which provides objects and methods)Tj
0 -1.6 TD
(for creating interactive three-dimensional graphics applications. Open Inventor, which is written in)Tj
0 -1.5 TD
(C++, provides prebuilt objects and a built-in event model for user interaction, high-level application)Tj
T*
(components for creating and editing three-dimensional scenes, and the ability to print objects and)Tj
T*
(exchange data in other graphics formats. Open Inventor is separate from OpenGL.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 511.000 Tm
(Include Files)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 489.000 Tm
(For all OpenGL applications, you want to include the gl.h header file in every file. Almost all OpenGL)Tj
T*
(applications use GLU, the aforementioned OpenGL Utility Library, which requires inclusion of the glu.h)Tj
T*
(header file. So almost every OpenGL source file begins with)Tj
/F7 1 Tf
0 -2.1 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
/F11 1 Tf
0 -2.1 TD
(If you are directly accessing a window interface library to support OpenGL, such as GLX, AGL, PGL, or)Tj
0 -1.5 TD
(WGL, you must include additional header files. For example, if you are calling GLX, you may need to)Tj
T*
(add these lines to your code)Tj
/F7 1 Tf
0 -2.1 TD
(#include <X11/Xlib.h>)Tj
0 -1.5 TD
(#include <GL/glx.h>)Tj
/F11 1 Tf
0 -2.1 TD
(If you are using GLUT for managing your window manager tasks, you should include)Tj
/F7 1 Tf
T*
(#include <GL/glut.h>)Tj
/F11 1 Tf
T*
(Note that glut.h includes gl.h, glu.h, and glx.h automatically, so including all three files is redundant.)Tj
0 -1.5 TD
(GLUT for Microsoft Windows includes the appropriate header file to access WGL.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 229.000 Tm
(GLUT, the OpenGL Utility Toolkit)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 208.000 Tm
(As you know, OpenGL contains rendering commands but is designed to be independent of any window)Tj
T*
(system or operating system. Consequently, it contains no commands for opening windows or reading)Tj
T*
(events from the keyboard or mouse. Unfortunately, it's impossible to write a complete graphics program)Tj
T*
(without at least opening a window, and most interesting programs require a bit of user input or other)Tj
T*
(services from the operating system or window system. In many cases, complete programs make the most)Tj
T*
(interesting examples, so this book uses GLUT to simplify opening windows, detecting input, and so on.)Tj
T*
(If you have an implementation of OpenGL and GLUT on your system, the examples in this book should)Tj
T*
(run without change when linked with them.)Tj
0 -2.1 TD
(In addition, since OpenGL drawing commands are limited to those that generate simple geometric)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 11)Tj
ET
endstream
endobj
75 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
78 0 obj
<<
/Length 4894
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(primitives \(points, lines, and polygons\), GLUT includes several routines that create more complicated)Tj
0 -1.5 TD
(three-dimensional objects such as a sphere, a torus, and a teapot. This way, snapshots of program output)Tj
T*
(can be interesting to look at. \(Note that the OpenGL Utility Library, GLU, also has quadrics routines that)Tj
T*
(create some of the same three-dimensional objects as GLUT, such as a sphere, cylinder, or cone.\))Tj
0 -2.1 TD
(GLUT may not be satisfactory for full-featured OpenGL applications, but you may find it a useful)Tj
0 -1.5 TD
(starting point for learning OpenGL. The rest of this section briefly describes a small subset of GLUT)Tj
T*
[(routines so that you can follow the programming examples in the rest of this book. \(See )6(Appendix D)17( for)]TJ
T*
(more details about this subset of GLUT, or see Chapters 4 and 5 of )Tj
/F15 1 Tf
27 0 TD
(OpenGL Programming for the X)Tj
-27 -1.5 TD
(Window System)Tj
/F11 1 Tf
6.3 0 TD
( for information about the rest of GLUT.\))Tj
/F27 1 Tf
-6.3 -3 TD
(Window Management)Tj
/F11 1 Tf
0 -2.1 TD
(Five routines perform tasks necessary to initialize a window.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glutInit)Tj
/F11 1 Tf
2.9 0 TD
(\(int *)Tj
/F15 1 Tf
2.2 0 TD
(argc)Tj
/F11 1 Tf
1.8 0 TD
(, char **)Tj
/F15 1 Tf
3.5 0 TD
(argv)Tj
/F11 1 Tf
1.8 0 TD
(\) initializes GLUT and processes any command line arguments \(for)Tj
-12.2 -1.6 TD
(X, this would be options like -display and -geometry\). )Tj
/F15 1 Tf
21.9 0 TD
(glutInit\(\))Tj
/F11 1 Tf
3.6 0 TD
( should be called before any other)Tj
-25.5 -1.5 TD
(GLUT routine.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glutInitDisplayMode)Tj
/F11 1 Tf
8.3 0 TD
(\(unsigned int )Tj
/F15 1 Tf
5.5 0 TD
(mode)Tj
/F11 1 Tf
2.2 0 TD
(\) specifies whether to use an )Tj
/F15 1 Tf
11.6 0 TD
(RGBA)Tj
/F11 1 Tf
2.6 0 TD
( or color-index color)Tj
-30.2 -1.6 TD
(model. You can also specify whether you want a single- or double-buffered window. \(If you're)Tj
0 -1.5 TD
(working in color-index mode, you'll want to load certain colors into the color map; use)Tj
/F15 1 Tf
T*
(glutSetColor\(\))Tj
/F11 1 Tf
5.8 0 TD
( to do this.\) Finally, you can use this routine to indicate that you want the window to)Tj
-5.8 -1.5 TD
(have an associated depth, stencil, and/or accumulation buffer. For example, if you want a window)Tj
T*
(with double buffering, the RGBA color model, and a depth buffer, you might call)Tj
/F15 1 Tf
T*
(glutInitDisplayMode)Tj
/F11 1 Tf
8.3 0 TD
(\()Tj
/F15 1 Tf
0.4 0 TD
(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)Tj
/F11 1 Tf
19.8 0 TD
(\).)Tj
/F33 1 Tf
-30.3 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glutInitWindowPosition)Tj
/F11 1 Tf
9.6 0 TD
(\(int)Tj
/F15 1 Tf
1.3 0 TD
( x)Tj
/F11 1 Tf
0.7 0 TD
(, int)Tj
/F15 1 Tf
1.6 0 TD
( y)Tj
/F11 1 Tf
0.7 0 TD
(\) specifies the screen location for the upper-left corner of your)Tj
-13.9 -1.6 TD
(window.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glutInitWindowSize)Tj
/F11 1 Tf
7.8 0 TD
(\(int )Tj
/F15 1 Tf
1.7 0 TD
(width)Tj
/F11 1 Tf
2.2 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(size)Tj
/F11 1 Tf
1.5 0 TD
(\) specifies the size, in pixels, of your window.)Tj
/F33 1 Tf
-16.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(int )Tj
/F15 1 Tf
1.3 0 TD
(glutCreateWindow)Tj
/F11 1 Tf
7.6 0 TD
(\(char *)Tj
/F15 1 Tf
2.8 0 TD
(string)Tj
/F11 1 Tf
2.3 0 TD
(\) creates a window with an OpenGL context. It returns a unique)Tj
-14 -1.5 TD
(identifier for the new window. Be warned: Until )Tj
/F15 1 Tf
19.6 0 TD
(glutMainLoop\(\))Tj
/F11 1 Tf
6.4 0 TD
( is called \(see next section\), the)Tj
-26 -1.5 TD
(window is not yet displayed.)Tj
/F27 1 Tf
-1.9 -3.6 TD
(The Display Callback)Tj
/F15 1 Tf
0 -2.1 TD
(glutDisplayFunc)Tj
/F11 1 Tf
6.7 0 TD
(\(void \(*)Tj
/F15 1 Tf
3.2 0 TD
(func)Tj
/F11 1 Tf
1.7 0 TD
(\)\(void\)\) is the first and most important event callback function you will see.)Tj
-11.6 -1.5 TD
(Whenever GLUT determines the contents of the window need to be redisplayed, the callback function)Tj
T*
(registered by )Tj
/F15 1 Tf
5.4 0 TD
(glutDisplayFunc\(\))Tj
/F11 1 Tf
7.4 0 TD
( is executed. Therefore, you should put all the routines you need to)Tj
-12.8 -1.5 TD
(redraw the scene in the display callback function.)Tj
0 -2.1 TD
(If your program changes the contents of the window, sometimes you will have to call)Tj
/F15 1 Tf
0 -1.5 TD
(glutPostRedisplay)Tj
/F11 1 Tf
7.3 0 TD
(\(void\), which gives )Tj
/F15 1 Tf
8 0 TD
(glutMainLoop\(\))Tj
/F11 1 Tf
6.4 0 TD
( a nudge to call the registered display callback at)Tj
-21.7 -1.5 TD
(its next opportunity.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 12)Tj
ET
endstream
endobj
79 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
81 0 obj
<<
/Length 2429
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Running the Program)Tj
/F11 1 Tf
0 -2.1 TD
(The very last thing you must do is call )Tj
/F15 1 Tf
15.6 0 TD
(glutMainLoop)Tj
/F11 1 Tf
5.7 0 TD
(\(void\). All windows that have been created are now)Tj
-21.3 -1.5 TD
(shown, and rendering to those windows is now effective. Event processing begins, and the registered)Tj
T*
(display callback is triggered. Once this loop is entered, it is never exited!)Tj
0 -2.1 TD
(Example 1-2)Tj
5.1 0 TD
[( shows how you might use GLUT to create the simple program shown in )-10(Example 1-1)170(. Note)]TJ
-5.1 -1.5 TD
(the restructuring of the code. To maximize efficiency, operations that need only be called once \(setting)Tj
T*
(the background color and coordinate system\) are now in a procedure called )Tj
/F15 1 Tf
30.3 0 TD
(init\(\))Tj
/F11 1 Tf
2 0 TD
(. Operations to render)Tj
-32.3 -1.5 TD
(\(and possibly re-render\) the scene are in the )Tj
/F15 1 Tf
17.8 0 TD
(display\(\))Tj
/F11 1 Tf
3.5 0 TD
( procedure, which is the registered GLUT display)Tj
-21.3 -1.5 TD
(callback.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 1-2 )Tj
/F11 1 Tf
6.1 0 TD
(Simple OpenGL Program Using GLUT: hello.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glut.h>)Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(/*  clear all pixels  */)Tj
T*
(    glClear \(GL_COLOR_BUFFER_BIT\);)Tj
0 -3 TD
(/*  draw white polygon \(rectangle\) with corners at)Tj
0 -1.5 TD
( *  \(0.25, 0.25, 0.0\) and \(0.75, 0.75, 0.0\)  )Tj
T*
( */)Tj
T*
(    glColor3f \(1.0, 1.0, 1.0\);)Tj
T*
(    glBegin\(GL_POLYGON\);)Tj
T*
(        glVertex3f \(0.25, 0.25, 0.0\);)Tj
T*
(        glVertex3f \(0.75, 0.25, 0.0\);)Tj
T*
(        glVertex3f \(0.75, 0.75, 0.0\);)Tj
T*
(        glVertex3f \(0.25, 0.75, 0.0\);)Tj
T*
(    glEnd\(\);)Tj
0 -3 TD
(/*  don't wait!  )Tj
0 -1.5 TD
( *  start processing buffered OpenGL routines )Tj
T*
( */)Tj
T*
(    glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void init \(void\) )Tj
0 -1.5 TD
({)Tj
T*
(/*  select clearing \(background\) color       */)Tj
T*
(    glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
0 -3 TD
(/*  initialize viewing values  */)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 13)Tj
ET
endstream
endobj
82 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
84 0 obj
<<
/Length 3632
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(    glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(    glLoadIdentity\(\);)Tj
T*
(    glOrtho\(0.0, 1.0, 0.0, 1.0, -1.0, 1.0\);)Tj
T*
(})Tj
0 -3 TD
(/* )Tj
0 -1.5 TD
( *  Declare initial window size, position, and display mode)Tj
T*
( *  \(single buffer and RGBA\).  Open window with "hello")Tj
T*
( *  in its title bar.  Call initialization routines.)Tj
T*
( *  Register callback function to display graphics.)Tj
T*
( *  Enter main loop and process events.)Tj
T*
( */)Tj
T*
(int main\(int argc, char** argv\))Tj
T*
({)Tj
T*
(    glutInit\(&argc, argv\);)Tj
T*
(    glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(    glutInitWindowSize \(250, 250\); )Tj
T*
(    glutInitWindowPosition \(100, 100\);)Tj
T*
(    glutCreateWindow \("hello"\);)Tj
T*
(    init \(\);)Tj
T*
(    glutDisplayFunc\(display\); )Tj
T*
(    glutMainLoop\(\);)Tj
T*
(    return 0;   /* ISO C requires main to return int. */)Tj
T*
(})Tj
/F27 1 Tf
0 -3 TD
(Handling Input Events)Tj
/F11 1 Tf
0 -2.1 TD
(You can use these routines to register callback commands that are invoked when specified events occur.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glutReshapeFunc)Tj
/F11 1 Tf
7 0 TD
(\(void \(*)Tj
/F15 1 Tf
3.2 0 TD
(func)Tj
/F11 1 Tf
1.7 0 TD
(\)\(int )Tj
/F15 1 Tf
2 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(h)Tj
/F11 1 Tf
0.5 0 TD
(\)\) indicates what action should be taken when the window)Tj
-16.9 -1.6 TD
(is resized.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glutKeyboardFunc)Tj
/F11 1 Tf
7.6 0 TD
(\(void \(*)Tj
/F15 1 Tf
3.1 0 TD
(func)Tj
/F11 1 Tf
1.8 0 TD
(\)\(unsigned char )Tj
/F15 1 Tf
6.5 0 TD
(key)Tj
/F11 1 Tf
1.3 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(, int)Tj
/F15 1 Tf
1.5 0 TD
( y)Tj
/F11 1 Tf
0.7 0 TD
(\)\) and )Tj
/F15 1 Tf
2.6 0 TD
(glutMouseFunc)Tj
/F11 1 Tf
6.3 0 TD
(\(void \(*)Tj
/F15 1 Tf
3.2 0 TD
(func)Tj
/F11 1 Tf
1.7 0 TD
(\)\(int)Tj
/F15 1 Tf
-38.6 -1.6 TD
(button)Tj
/F11 1 Tf
2.6 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(state)Tj
/F11 1 Tf
1.9 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(, int)Tj
/F15 1 Tf
1.6 0 TD
( y)Tj
/F11 1 Tf
0.7 0 TD
(\)\) allow you to link a keyboard key or a mouse button with a routine)Tj
-10.8 -1.5 TD
(that's invoked when the key or mouse button is pressed or released.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glutMotionFunc)Tj
/F11 1 Tf
6.5 0 TD
(\(void \(*)Tj
/F15 1 Tf
3.2 0 TD
(func)Tj
/F11 1 Tf
1.7 0 TD
(\)\(int )Tj
/F15 1 Tf
2 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(\)\) registers a routine to call back when the mouse is moved)Tj
-16.1 -1.6 TD
(while a mouse button is also pressed.)Tj
/F27 1 Tf
-1.9 -3.6 TD
(Managing a Background Process)Tj
/F11 1 Tf
0 -2.2 TD
(You can specify a function that's to be executed if no other events are pending)Tj
/F33 1 Tf
31.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, when the)Tj
-32.4 -1.7 TD
(event loop would otherwise be idle)Tj
/F33 1 Tf
14 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(with )Tj
/F15 1 Tf
2.1 0 TD
(glutIdleFunc)Tj
/F11 1 Tf
5.1 0 TD
(\(void \(*)Tj
/F15 1 Tf
3.2 0 TD
(func)Tj
/F11 1 Tf
1.7 0 TD
(\)\(void\)\). This routine takes a pointer)Tj
-27.1 -1.6 TD
(to the function as its only argument. Pass in NULL \(zero\) to disable the execution of the function.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 14)Tj
ET
endstream
endobj
85 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
87 0 obj
<<
/Length 4101
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Drawing Three-Dimensional Objects)Tj
/F11 1 Tf
0 -2.1 TD
(GLUT includes several routines for drawing these three-dimensional objects:)Tj
0 -1.1 TD
[(cone)-11912(icosahedron)-8967(teapot)]TJ
0 -1.4 TD
[(cube)-11912(octahedron)-9357(tetrahedron)]TJ
T*
[(dodecahedron)-8190(sphere)-11190(torus)]TJ
0 -2.1 TD
(You can draw these objects as wireframes or as solid shaded objects with surface normals defined. For)Tj
0 -1.5 TD
(example, the routines for a cube and a sphere are as follows:)Tj
0 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glutWireCube)Tj
/F11 1 Tf
5.6 0 TD
(\(GLdouble )Tj
/F15 1 Tf
4.7 0 TD
(size)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-13.8 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glutSolidCube)Tj
/F11 1 Tf
5.8 0 TD
(\(GLdouble )Tj
/F15 1 Tf
4.6 0 TD
(size)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-13.9 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glutWireSphere)Tj
/F11 1 Tf
6.3 0 TD
(\(GLdouble )Tj
/F15 1 Tf
4.6 0 TD
(radius)Tj
/F11 1 Tf
2.6 0 TD
(, GLint )Tj
/F15 1 Tf
3.1 0 TD
(slices, )Tj
/F11 1 Tf
2.8 0 TD
(GLint )Tj
/F15 1 Tf
2.6 0 TD
(stacks)Tj
/F11 1 Tf
2.4 0 TD
(\);)Tj
-26.4 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glutSolidSphere)Tj
/F11 1 Tf
6.4 0 TD
(\(GLdouble )Tj
/F15 1 Tf
4.7 0 TD
(radius)Tj
/F11 1 Tf
2.5 0 TD
(, GLint )Tj
/F15 1 Tf
3.2 0 TD
(slices, )Tj
/F11 1 Tf
2.7 0 TD
(GLint )Tj
/F15 1 Tf
2.6 0 TD
(stacks)Tj
/F11 1 Tf
2.5 0 TD
(\);)Tj
-26.6 -2.1 TD
[(All these models are drawn centered at the origin of the world coordinate system. \(See )30( for information)]TJ
0 -1.5 TD
(on the prototypes of all these drawing routines.\))Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 460.000 Tm
(Animation)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 438.000 Tm
(One of the most exciting things you can do on a graphics computer is draw pictures that move. Whether)Tj
T*
(you're an engineer trying to see all sides of a mechanical part you're designing, a pilot learning to fly an)Tj
T*
(airplane using a simulation, or merely a computer-game aficionado, it's clear that )Tj
/F13 1 Tf
32.8 0 TD
(animation)Tj
/F11 1 Tf
4.4 0 TD
( is an)Tj
-37.2 -1.5 TD
(important part of computer graphics.)Tj
0 -2.1 TD
(In a movie theater, motion is achieved by taking a sequence of pictures and projecting them at 24 per)Tj
0 -1.5 TD
(second on the screen. Each frame is moved into position behind the lens, the shutter is opened, and the)Tj
T*
(frame is displayed. The shutter is momentarily closed while the film is advanced to the next frame, then)Tj
T*
(that frame is displayed, and so on. Although you're watching 24 different frames each second, your brain)Tj
T*
(blends them all into a smooth animation. \(The old Charlie Chaplin movies were shot at 16 frames per)Tj
T*
(second and are noticeably jerky.\) In fact, most modern projectors display each picture twice at a rate of)Tj
T*
(48 per second to reduce flickering. Computer-graphics screens typically refresh \(redraw the picture\))Tj
T*
(approximately 60 to 76 times per second, and some even run at about 120 refreshes per second. Clearly,)Tj
T*
(60 per second is smoother than 30, and 120 is marginally better than 60. Refresh rates faster than 120,)Tj
T*
(however, are beyond the point of diminishing returns, since the human eye is only so good.)Tj
0 -2.1 TD
(The key reason that motion picture projection works is that each frame is complete when it is displayed.)Tj
0 -1.5 TD
(Suppose you try to do computer animation of your million-frame movie with a program like this:)Tj
/F7 1 Tf
0 -2.1 TD
(open_window\(\); )Tj
0 -1.5 TD
(for \(i = 0; i < 1000000; i++\) { )Tj
T*
(   clear_the_window\(\); )Tj
T*
(   draw_frame\(i\); )Tj
T*
(   wait_until_a_24th_of_a_second_is_over\(\); )Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(If you add the time it takes for your system to clear the screen and to draw a typical frame, this program)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 15)Tj
ET
endstream
endobj
88 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
90 0 obj
<<
/Length 4355
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(gives more and more disturbing results depending on how close to 1/24 second it takes to clear and draw.)Tj
0 -1.5 TD
(Suppose the drawing takes nearly a full 1/24 second. Items drawn first are visible for the full 1/24 second)Tj
T*
(and present a solid image on the screen; items drawn toward the end are instantly cleared as the program)Tj
T*
(starts on the next frame. They present at best a ghostlike image, since for most of the 1/24 second your)Tj
T*
(eye is viewing the cleared background instead of the items that were unlucky enough to be drawn last.)Tj
T*
(The problem is that this program doesn't display completely drawn frames; instead, you watch the)Tj
T*
(drawing as it happens.)Tj
0 -2.2 TD
(Most OpenGL implementations provide )Tj
/F13 1 Tf
16.3 0 TD
(double-buffering)Tj
/F33 1 Tf
7.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(hardware or software that supplies two)Tj
-24.5 -1.6 TD
(complete color buffers. One is displayed while the other is being drawn. When the drawing of a frame is)Tj
0 -1.5 TD
(complete, the two buffers are swapped, so the one that was being viewed is now used for drawing, and)Tj
T*
(vice versa. This is like a movie projector with only two frames in a loop; while one is being projected on)Tj
T*
(the screen, an artist is desperately erasing and redrawing the frame that's not visible. As long as the artist)Tj
T*
(is quick enough, the viewer notices no difference between this setup and one where all the frames are)Tj
T*
(already drawn and the projector is simply displaying them one after the other. With double-buffering,)Tj
T*
(every frame is shown only when the drawing is complete; the viewer never sees a partially drawn frame.)Tj
0 -2.1 TD
(A modified version of the preceding program that does display smoothly animated graphics might look)Tj
0 -1.5 TD
(like this:)Tj
/F7 1 Tf
0 -2.1 TD
(open_window_in_double_buffer_mode\(\); )Tj
0 -1.5 TD
(for \(i = 0; i < 1000000; i++\) { )Tj
T*
(   clear_the_window\(\); )Tj
T*
(   draw_frame\(i\); )Tj
T*
(   swap_the_buffers\(\); )Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 332.000 Tm
(The Refresh That Pauses)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 311.000 Tm
(For some OpenGL implementations, in addition to simply swapping the viewable and drawable buffers,)Tj
T*
(the )Tj
/F15 1 Tf
1.5 0 TD
(swap_the_buffers\(\))Tj
/F11 1 Tf
7.7 0 TD
( routine waits until the current screen refresh period is over so that the previous)Tj
-9.2 -1.5 TD
(buffer is completely displayed. This routine also allows the new buffer to be completely displayed,)Tj
T*
(starting from the beginning. Assuming that your system refreshes the display 60 times per second, this)Tj
T*
(means that the fastest frame rate you can achieve is 60 frames per second \()Tj
/F15 1 Tf
29.9 0 TD
(fps)Tj
/F11 1 Tf
1.1 0 TD
(\), and if all your frames can)Tj
-31 -1.5 TD
(be cleared and drawn in under 1/60 second, your animation will run smoothly at that rate.)Tj
0 -2.1 TD
(What often happens on such a system is that the frame is too complicated to draw in 1/60 second, so each)Tj
0 -1.5 TD
(frame is displayed more than once. If, for example, it takes 1/45 second to draw a frame, you get 30 fps,)Tj
T*
(and the graphics are idle for 1/30-1/45=1/90 second per frame, or one-third of the time.)Tj
0 -2.1 TD
(In addition, the video refresh rate is constant, which can have some unexpected performance)Tj
0 -1.5 TD
(consequences. For example, with the 1/60 second per refresh monitor and a constant frame rate, you can)Tj
T*
(run at 60 fps, 30 fps, 20 fps, 15 fps, 12 fps, and so on \(60/1, 60/2, 60/3, 60/4, 60/5, ...\). That means that if)Tj
T*
(you're writing an application and gradually adding features \(say it's a flight simulator, and you're adding)Tj
0 -1.6 TD
(ground scenery\), at first each feature you add has no effect on the overall performance)Tj
/F33 1 Tf
34.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(you still get 60)Tj
-35.5 -1.6 TD
(fps. Then, all of a sudden, you add one new feature, and the system can't quite draw the whole thing in)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 16)Tj
ET
endstream
endobj
91 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
92 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im3
/Width 727
/Height 207
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.2)
>>
stream
endstream
endobj
94 0 obj
<<
/Length 3729
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(1/60 of a second, so the animation slows from 60 fps to 30 fps because it misses the first possible)Tj
0 -1.5 TD
(buffer-swapping time. A similar thing happens when the drawing time per frame is more than 1/30)Tj
0 -1.6 TD
(second)Tj
/F33 1 Tf
2.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the animation drops from 30 to 20 fps.)Tj
-3.8 -2.2 TD
(If the scene's complexity is close to any of the magic times \(1/60 second, 2/60 second, 3/60 second, and)Tj
0 -1.5 TD
(so on in this example\), then because of random variation, some frames go slightly over the time and)Tj
T*
(some slightly under. Then the frame rate is irregular, which can be visually disturbing. In this case, if you)Tj
T*
(can't simplify the scene so that all the frames are fast enough, it might be better to add an intentional,)Tj
T*
(tiny delay to make sure they all miss, giving a constant, slower, frame rate. If your frames have)Tj
T*
(drastically different complexities, a more sophisticated approach might be necessary.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 554.000 Tm
(Motion = Redraw + Swap)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 533.000 Tm
(The structure of real animation programs does not differ too much from this description. Usually, it is)Tj
T*
(easier to redraw the entire buffer from scratch for each frame than to figure out which parts require)Tj
T*
(redrawing. This is especially true with applications such as three-dimensional flight simulators where a)Tj
T*
(tiny change in the plane's orientation changes the position of everything outside the window.)Tj
0 -2.2 TD
(In most animations, the objects in a scene are simply redrawn with different transformations)Tj
/F33 1 Tf
36.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the)Tj
/F13 1 Tf
-37.9 -1.6 TD
(viewpoint)Tj
/F11 1 Tf
4.2 0 TD
( of the viewer moves, or a car moves down the road a bit, or an object is rotated slightly. If)Tj
-4.2 -1.5 TD
(significant recomputation is required for non-drawing operations, the attainable frame rate often slows)Tj
T*
(down. Keep in mind, however, that the idle time after the )Tj
/F15 1 Tf
23.2 0 TD
(swap_the_buffers\(\))Tj
/F11 1 Tf
7.7 0 TD
( routine can often be used)Tj
-30.9 -1.5 TD
(for such calculations.)Tj
0 -2.1 TD
(OpenGL doesn't have a )Tj
/F15 1 Tf
9.8 0 TD
(swap_the_buffers\(\))Tj
/F11 1 Tf
7.7 0 TD
( command because the feature might not be available on all)Tj
-17.5 -1.5 TD
(hardware and, in any case, it's highly dependent on the window system. For example, if you are using the)Tj
T*
(X Window System and accessing it directly, you might use the following GLX routine:)Tj
0 -2.1 TD
(void glXSwapBuffers\(Display *)Tj
/F15 1 Tf
12.9 0 TD
(dpy)Tj
/F11 1 Tf
1.5 0 TD
(, Window )Tj
/F15 1 Tf
4.2 0 TD
(window)Tj
/F11 1 Tf
3.1 0 TD
(\);)Tj
-21.7 -2.1 TD
[(\(See )27(Appendix C)-38( for equivalent routines for other window systems.\))]TJ
T*
(If you are using the GLUT library, you'll want to call this routine:)Tj
T*
(void glutSwapBuffers\(void\);)Tj
T*
(Example 1-3)Tj
5.1 0 TD
( illustrates the use of )Tj
/F15 1 Tf
8.6 0 TD
(glutSwapBuffers\(\))Tj
/F11 1 Tf
7.2 0 TD
( in an example that draws a spinning square as)Tj
-20.9 -1.5 TD
[(shown in )-11(Figure 1-3)225(. The following example also shows how to use GLUT to control an input device and)]TJ
T*
(turn on and off an idle function. In this example, the mouse buttons toggle the spinning on and off.)Tj
ET
Q
/GS1 gs
q
423 0 0 120 124 84.46 cm
/Im3 Do
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 17)Tj
ET
endstream
endobj
95 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im3 92 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
97 0 obj
<<
/Length 1630
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 1-3 )Tj
/F11 1 Tf
5.1 0 TD
(Double-Buffered Rotating Square)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 1-3 )Tj
/F11 1 Tf
6.1 0 TD
(Double-Buffered Program: double.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(static GLfloat spin = 0.0;)Tj
T*
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glRotatef\(spin, 0.0, 0.0, 1.0\);)Tj
T*
(   glColor3f\(1.0, 1.0, 1.0\);)Tj
T*
(   glRectf\(-25.0, -25.0, 25.0, 25.0\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glutSwapBuffers\(\);)Tj
T*
(})Tj
0 -3 TD
(void spinDisplay\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   spin = spin + 2.0;)Tj
T*
(   if \(spin > 360.0\))Tj
T*
(      spin = spin - 360.0;)Tj
T*
(   glutPostRedisplay\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   glOrtho\(-50.0, 50.0, -50.0, 50.0, -1.0, 1.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 1,  Introduction to OpenGL - 18)Tj
ET
endstream
endobj
98 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
100 0 obj
<<
/Length 1515
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(})Tj
0 -3 TD
(void mouse\(int button, int state, int x, int y\) )Tj
0 -1.5 TD
({)Tj
T*
(   switch \(button\) {)Tj
T*
(      case GLUT_LEFT_BUTTON:)Tj
T*
(         if \(state == GLUT_DOWN\))Tj
T*
(            glutIdleFunc\(spinDisplay\);)Tj
T*
(         break;)Tj
T*
(      case GLUT_MIDDLE_BUTTON:)Tj
T*
(         if \(state == GLUT_DOWN\))Tj
T*
(            glutIdleFunc\(NULL\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(/* )Tj
0 -1.5 TD
( *  Request double buffer display mode.)Tj
T*
( *  Register mouse input callback functions)Tj
T*
( */)Tj
T*
(int main\(int argc, char** argv\))Tj
T*
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_DOUBLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(250, 250\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\); )Tj
T*
(   glutMouseFunc\(mouse\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 153.960 m
547.000 153.960 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 19)Tj
ET
endstream
endobj
101 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
103 0 obj
<<
/Length 4142
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 2)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(State Management and Drawing Geometric Objects)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Clear the window to an arbitrary color)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Force any pending drawing to complete)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Draw with any geometric primitive)Tj
/F33 1 Tf
14.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(points, lines, and polygons)Tj
/F33 1 Tf
10.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in two or three dimensions)Tj
/F33 1 Tf
-28.6 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Turn states on and off and query state variables)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Control the display of those primitives)Tj
/F33 1 Tf
15.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, draw dashed lines or outlined polygons)Tj
/F33 1 Tf
-18.2 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Specify )Tj
/F13 1 Tf
3.3 0 TD
(normal vectors)Tj
/F11 1 Tf
6.4 0 TD
( at appropriate points on the surface of solid objects)Tj
/F33 1 Tf
-11.5 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use )Tj
/F15 1 Tf
1.8 0 TD
(vertex arrays)Tj
/F11 1 Tf
5.3 0 TD
( to store and access a lot of geometric data with only a few function calls)Tj
/F33 1 Tf
-8.9 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Save and restore several state variables at once)Tj
-1.9 -2.8 TD
(Although you can draw complex and interesting pictures using OpenGL, they're all constructed from a)Tj
0 -1.6 TD
(small number of primitive graphical items. This shouldn't be too surprising)Tj
/F33 1 Tf
30.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(look at what Leonardo da)Tj
-31.1 -1.6 TD
(Vinci accomplished with just pencils and paintbrushes.)Tj
0 -2.1 TD
(At the highest level of abstraction, there are three basic drawing operations: clearing the window,)Tj
0 -1.5 TD
(drawing a geometric object, and drawing a raster object. Raster objects, which include such things as)Tj
T*
[(two-dimensional images, bitmaps, and character fonts, are covered in )228(Chapter 8)16(.)0( In this chapter, you)]TJ
T*
(learn how to clear the screen and to draw geometric objects, including points, straight lines, and flat)Tj
T*
(polygons.)Tj
0 -2.1 TD
(You might think to yourself, "Wait a minute. I've seen lots of computer graphics in movies and on)Tj
0 -1.5 TD
(television, and there are plenty of beautifully shaded curved lines and surfaces. How are those drawn, if)Tj
T*
(all OpenGL can draw are straight lines and flat polygons?" Even the image on the cover of this book)Tj
T*
(includes a round table and objects on the table that have curved surfaces. It turns out that all the curved)Tj
T*
(lines and surfaces you've seen are approximated by large numbers of little flat polygons or straight lines,)Tj
T*
(in much the same way that the globe on the cover is constructed from a large set of rectangular blocks.)Tj
T*
(The globe doesn't appear to have a smooth surface because the blocks are relatively large compared to)Tj
T*
(the globe. Later in this chapter, we show you how to construct curved lines and surfaces from lots of)Tj
T*
(small geometric primitives.)Tj
0 -2.1 TD
(This chapter has the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("A Drawing Survival Kit")-45( explains how to clear the window and force drawing to be completed. It)]TJ
0 -1.5 TD
(also gives you basic information about controlling the color of geometric objects and describing a)Tj
T*
(coordinate system.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Describing Points, Lines, and Polygons" shows you what the set of primitive geometric objects is)Tj
0 -1.5 TD
(and how to draw them.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 1)Tj
ET
endstream
endobj
104 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
106 0 obj
<<
/Length 4310
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 702.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Basic State Management")-40( describes how to turn on and off some states \(modes\) and query state)]TJ
0 -1.6 TD
(variables.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Displaying Points, Lines, and Polygons" explains what control you have over the details of how)Tj
0 -1.7 TD
(primitives are drawn)Tj
/F33 1 Tf
8.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, what diameter points have, whether lines are solid or dashed,)Tj
-9.3 -1.6 TD
(and whether polygons are outlined or filled.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Normal Vectors")32( discusses how to specify normal vectors for geometric objects and \(briefly\) what)]TJ
0 -1.6 TD
(these vectors are for.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Vertex Arrays")9( shows you how to put lots of geometric data into just a few arrays and how, with)]TJ
0 -1.6 TD
(only a few function calls, to render the geometry it describes. Reducing function calls may increase)Tj
0 -1.5 TD
(the efficiency and performance of rendering.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Attribute Groups")22( reveals how to query the current value of state variables and how to save and)]TJ
0 -1.6 TD
(restore several related state values all at once.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Some Hints for Building Polygonal Models of Surfaces")13( explores the issues and techniques)]TJ
0 -1.5 TD
(involved in constructing polygonal approximations to surfaces.)Tj
-1.9 -2.7 TD
(One thing to keep in mind as you read the rest of this chapter is that with OpenGL, unless you specify)Tj
0 -1.5 TD
(otherwise, every time you issue a drawing command, the specified object is drawn. This might seem)Tj
T*
(obvious, but in some systems, you first make a list of things to draw. When your list is complete, you tell)Tj
T*
(the graphics hardware to draw the items in the list. The first style is called )Tj
/F15 1 Tf
29.8 0 TD
(immediate-mode)Tj
/F11 1 Tf
6.7 0 TD
( graphics and)Tj
-36.5 -1.5 TD
(is the default OpenGL style. In addition to using immediate mode, you can choose to save some)Tj
T*
(commands in a list \(called a )Tj
/F15 1 Tf
11.4 0 TD
(display list)Tj
/F11 1 Tf
4.4 0 TD
(\) for later drawing. Immediate-mode graphics are typically easier)Tj
-15.8 -1.5 TD
[(to program, but display lists are often more efficient. )-39(Chapter 7)16( tells you how to use display lists and why)]TJ
T*
(you might want to use them.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 299.000 Tm
(A Drawing Survival Kit)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 277.000 Tm
(This section explains how to clear the window in preparation for drawing, set the color of objects that are)Tj
T*
(to be drawn, and force drawing to be completed. None of these subjects has anything to do with)Tj
T*
(geometric objects in a direct way, but any program that draws geometric objects has to deal with these)Tj
T*
(issues.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 203.000 Tm
(Clearing the Window)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 182.000 Tm
(Drawing on a computer screen is different from drawing on paper in that the paper starts out white, and)Tj
T*
(all you have to do is draw the picture. On a computer, the memory holding the picture is usually filled)Tj
T*
(with the last picture you drew, so you typically need to clear it to some background color before you start)Tj
T*
(to draw the new scene. The color you use for the background depends on the application. For a word)Tj
T*
(processor, you might clear to white \(the color of the paper\) before you begin to draw the text. If you're)Tj
T*
(drawing a view from a spaceship, you clear to the black of space before beginning to draw the stars,)Tj
T*
(planets, and alien spaceships. Sometimes you might not need to clear the screen at all; for example, if the)Tj
T*
(image is the inside of a room, the entire graphics window gets covered as you draw all the walls.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 2)Tj
ET
endstream
endobj
107 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
110 0 obj
<<
/Length 4612
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 703.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(At this point, you might be wondering why we keep talking about )Tj
/F15 1 Tf
26.6 0 TD
(clearing)Tj
/F11 1 Tf
3.3 0 TD
( the window)Tj
/F33 1 Tf
5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(why not just)Tj
-35.9 -1.6 TD
(draw a rectangle of the appropriate color that's large enough to cover the entire window? First, a special)Tj
0 -1.5 TD
(command to clear a window can be much more efficient than a general-purpose drawing command. In)Tj
T*
[(addition, as you'll see in )-44(Chapter 3)16(,)0( OpenGL allows you to set the coordinate system, viewing position,)]TJ
T*
(and viewing direction arbitrarily, so it might be difficult to figure out an appropriate size and location for)Tj
T*
(a window-clearing rectangle. Finally, on many machines, the graphics hardware consists of multiple)Tj
T*
(buffers in addition to the buffer containing colors of the pixels that are displayed. These other buffers)Tj
T*
(must be cleared from time to time, and it's convenient to have a single command that can clear any)Tj
T*
[(combination of them. \(See )-39(Chapter 10)16( for a discussion of all the possible buffers.\))]TJ
0 -2.1 TD
(You must also know how the colors of pixels are stored in the graphics hardware known as )Tj
/F15 1 Tf
36.7 0 TD
(bitplanes)Tj
/F11 1 Tf
3.7 0 TD
(.)Tj
-40.4 -1.5 TD
(There are two methods of storage. Either the red, green, blue, and alpha \(RGBA\) values of a pixel can be)Tj
T*
(directly stored in the bitplanes, or a single index value that references a color lookup table is stored.)Tj
T*
(RGBA color-display mode is more commonly used, so most of the examples in this book use it. \(See)Tj
T*
[(Chapter 4)16( for more information about both display modes.\) You can safely ignore all references to alpha)]TJ
T*
[(values until )-10(Chapter 6)16(.)]TJ
0 -2.1 TD
(As an example, these lines of code clear an RGBA mode window to black:)Tj
/F7 1 Tf
T*
(glClearColor\(0.0, 0.0, 0.0, 0.0\); )Tj
0 -1.5 TD
(glClear\(GL_COLOR_BUFFER_BIT\);)Tj
/F11 1 Tf
0 -2.1 TD
(The first line sets the clearing color to black, and the next command clears the entire window to the)Tj
0 -1.5 TD
(current clearing color. The single parameter to )Tj
/F15 1 Tf
18.8 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.8 0 TD
( indicates which buffers are to be cleared. In this)Tj
-22.6 -1.5 TD
(case, the program clears only the color buffer, where the image displayed on the screen is kept.)Tj
T*
(Typically, you set the clearing color once, early in your application, and then you clear the buffers as)Tj
T*
(often as necessary. OpenGL keeps track of the current clearing color as a state variable rather than)Tj
T*
(requiring you to specify it each time a buffer is cleared.)Tj
0 -2.1 TD
[(Chapter 4)16( and )-56(Chapter 10)16( talk about how other buffers are used. For now, all you need to know is that)]TJ
0 -1.5 TD
(clearing them is simple. For example, to clear both the color buffer and the depth buffer, you would use)Tj
T*
(the following sequence of commands:)Tj
/F7 1 Tf
0 -2.1 TD
(glClearColor\(0.0, 0.0, 0.0, 0.0\); )Tj
0 -1.5 TD
(glClearDepth\(1.0\); )Tj
T*
(glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
/F11 1 Tf
0 -2.1 TD
(In this case, the call to )Tj
/F15 1 Tf
9.2 0 TD
(glClearColor\(\))Tj
/F11 1 Tf
6 0 TD
( is the same as before, the )Tj
/F15 1 Tf
10.6 0 TD
(glClearDepth\(\))Tj
/F11 1 Tf
6.2 0 TD
( command specifies the)Tj
-32 -1.5 TD
(value to which every pixel of the depth buffer is to be set, and the parameter to the )Tj
/F15 1 Tf
33.2 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.8 0 TD
( command)Tj
-37 -1.5 TD
(now consists of the bitwise OR of all the buffers to be cleared. The following summary of )Tj
/F15 1 Tf
36.2 0 TD
(glClear\(\))Tj
/F11 1 Tf
-36.2 -1.5 TD
(includes a table that lists the buffers that can be cleared, their names, and the chapter where each type of)Tj
T*
(buffer is discussed.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glClearColor)-9(\(GLclampf )84(red)-67(, GLclampf )51(green)-23(, GLclampf )-49(blue)22(,)]TJ
0 -1.1 TD
0.050 Tw
[(GLclampf alpha)78(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Sets the current clearing color for use in clearing color buffers in RGBA mode. \(See )45(Chapter 4)-72( for)]TJ
T*
[(more information on RGBA mode.\) The )-16(red)33(, green)-23(, blue)22(, and )-50(alpha)78( values are clamped if necessary)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 3)Tj
ET
endstream
endobj
111 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
113 0 obj
<<
/Length 4564
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(to the range [0,1]. The default clearing color is \(0, 0, 0, 0\), which is black.)Tj
-1.8 -2.1 TD
0.028 Tw
[(void glClear)56(\(GLbitfield )24(mask)-45(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Clears the specified buffers to their current clearing values. The )-26(mask)55( argument is a bitwise-ORed)]TJ
T*
(combination of the values listed in Table 2-1)Tj
17.9 0 TD
(.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 649.000 m
470.000 649.000 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 641.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Buffer)-9430(Name)-13402(Reference)]TJ
ET
Q
124.000 635.480 m
470.000 635.480 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 627.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Color buffer)-6028(GL_COLOR_BUFFER_BIT)-2720(Chapter 4)]TJ
0 -1.4444 TD
[(Depth buffer)-5862(GL_DEPTH_BUFFER_BIT)-2887(Chapter 10)]TJ
T*
[(Accumulation buffer)-2640(GL_ACCUM_BUFFER_BIT)-2441(Chapter 10)]TJ
T*
[(Stencil buffer)-5528(GL_STENCIL_BUFFER_BIT)-1997(Chapter 10)]TJ
ET
Q
124.000 580.770 m
470.010 580.770 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 565.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 2-1 )Tj
/F11 1 Tf
4.6 0 TD
(Clearing Buffers)Tj
-4.6 -2.2 TD
(Before issuing a command to clear multiple buffers, you have to set the values to which each buffer is to)Tj
0 -1.5 TD
(be cleared if you want something other than the default RGBA color, depth value, accumulation color,)Tj
T*
(and stencil index. In addition to the )Tj
/F15 1 Tf
14.4 0 TD
(glClearColor\(\))Tj
/F11 1 Tf
6 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glClearDepth\(\))Tj
/F11 1 Tf
6.2 0 TD
( commands that set the current)Tj
-28.6 -1.5 TD
(values for clearing the color and depth buffers, )Tj
/F15 1 Tf
19 0 TD
(glClearIndex\(\))Tj
/F11 1 Tf
5.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glClearAccum\(\))Tj
/F11 1 Tf
6.5 0 TD
(, and )Tj
/F15 1 Tf
2.1 0 TD
(glClearStencil\(\))Tj
/F11 1 Tf
-34 -1.5 TD
(specify the )Tj
/F15 1 Tf
4.6 0 TD
(color index)Tj
/F11 1 Tf
4.5 0 TD
(, accumulation color, and stencil index used to clear the corresponding buffers.)Tj
-9.1 -1.5 TD
[(\(See )27(Chapter 4)16( and )-56(Chapter 10)16( for descriptions of these buffers and their uses.\))]TJ
0 -2.1 TD
(OpenGL allows you to specify multiple buffers because clearing is generally a slow operation, since)Tj
0 -1.5 TD
(every pixel in the window \(possibly millions\) is touched, and some graphics hardware allows sets of)Tj
T*
(buffers to be cleared simultaneously. Hardware that doesn't support simultaneous clears performs them)Tj
T*
(sequentially. The difference between)Tj
/F7 1 Tf
0 -2 TD
(glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
/F11 1 Tf
0 -2.2 TD
(and)Tj
/F7 1 Tf
0 -2 TD
(glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(glClear\(GL_DEPTH_BUFFER_BIT\);)Tj
/F11 1 Tf
0 -2.2 TD
(is that although both have the same final effect, the first example might run faster on many machines. It)Tj
0 -1.5 TD
(certainly won't run more slowly.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 260.000 Tm
(Specifying a Color)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 238.000 Tm
(With OpenGL, the description of the shape of an object being drawn is independent of the description of)Tj
T*
(its color. Whenever a particular geometric object is drawn, it's drawn using the currently specified)Tj
T*
(coloring scheme. The coloring scheme might be as simple as "draw everything in fire-engine red," or)Tj
T*
(might be as complicated as "assume the object is made out of blue plastic, that there's a yellow spotlight)Tj
T*
(pointed in such and such a direction, and that there's a general low-level reddish-brown light everywhere)Tj
T*
(else." In general, an OpenGL programmer first sets the color or coloring scheme and then draws the)Tj
T*
(objects. Until the color or coloring scheme is changed, all objects are drawn in that color or using that)Tj
T*
(coloring scheme. This method helps OpenGL achieve higher drawing performance than would result if it)Tj
T*
(didn't keep track of the current color.)Tj
0 -2.1 TD
(For example, the pseudocode)Tj
/F7 1 Tf
T*
(set_current_color\(red\); )Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 4)Tj
ET
endstream
endobj
114 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
116 0 obj
<<
/Length 3923
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(draw_object\(A\); )Tj
0 -1.5 TD
(draw_object\(B\); )Tj
T*
(set_current_color\(green\); )Tj
T*
(set_current_color\(blue\); )Tj
T*
(draw_object\(C\);)Tj
/F11 1 Tf
0 -2.1 TD
0.000 Tw
(draws objects A and B in red, and object C in blue. The command on the fourth line that sets the current)Tj
0 -1.5 TD
(color to green is wasted.)Tj
0 -2.1 TD
(Coloring, lighting, and shading are all large topics with entire chapters or large sections devoted to them.)Tj
0 -1.5 TD
(To draw geometric primitives that can be seen, however, you need some basic knowledge of how to set)Tj
T*
[(the current color; this information is provided in the next paragraphs. \(See )16(Chapter 4)16( and )-56(Chapter 5)16( for)]TJ
T*
(details on these topics.\))Tj
0 -2.1 TD
(To set a color, use the command )Tj
/F15 1 Tf
13.2 0 TD
(glColor3f\(\))Tj
/F11 1 Tf
4.6 0 TD
(. It takes three parameters, all of which are floating-point)Tj
-17.8 -1.5 TD
(numbers between 0.0 and 1.0. The parameters are, in order, the red, green, and blue )Tj
/F15 1 Tf
33.7 0 TD
(components)Tj
/F11 1 Tf
4.7 0 TD
( of the)Tj
-38.4 -1.5 TD
(color. You can think of these three values as specifying a "mix" of colors: 0.0 means don't use any of)Tj
T*
(that component, and 1.0 means use all you can of that component. Thus, the code)Tj
/F7 1 Tf
0 -2.1 TD
(glColor3f\(1.0, 0.0, 0.0\);)Tj
/F11 1 Tf
T*
(makes the brightest red the system can draw, with no green or blue components. All zeros makes black;)Tj
0 -1.5 TD
(in contrast, all ones makes white. Setting all three components to 0.5 yields gray \(halfway between black)Tj
T*
(and white\). Here are eight commands and the colors they would set.)Tj
/F7 1 Tf
0 -2.1 TD
(glColor3f\(0.0, 0.0, 0.0\);          black )Tj
0 -1.5 TD
(glColor3f\(1.0, 0.0, 0.0\);           red )Tj
T*
(glColor3f\(0.0, 1.0, 0.0\);           green )Tj
T*
(glColor3f\(1.0, 1.0, 0.0\);           yellow )Tj
T*
(glColor3f\(0.0, 0.0, 1.0\);           blue )Tj
T*
(glColor3f\(1.0, 0.0, 1.0\);           magenta )Tj
T*
(glColor3f\(0.0, 1.0, 1.0\);           cyan )Tj
T*
(glColor3f\(1.0, 1.0, 1.0\);           white)Tj
/F11 1 Tf
0 -2.1 TD
(You might have noticed earlier that the routine to set the clearing color, )Tj
/F15 1 Tf
28.9 0 TD
(glClearColor\(\))Tj
/F11 1 Tf
6 0 TD
(, takes four)Tj
-34.9 -1.5 TD
(parameters, the first three of which match the parameters for )Tj
/F15 1 Tf
24.5 0 TD
(glColor3f\(\))Tj
/F11 1 Tf
4.5 0 TD
(. The fourth parameter is the)Tj
-29 -1.5 TD
[(alpha value; it's covered in detail in )-17("Blending" in Chapter 6)-22(.)0( For now, set the fourth parameter of)]TJ
/F15 1 Tf
T*
(glClearColor\(\))Tj
/F11 1 Tf
6.1 0 TD
( to 0.0, which is its default value.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 188.000 Tm
(Forcing Completion of Drawing)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 167.000 Tm
[(As you saw in )45("OpenGL Rendering Pipeline" in Chapter 1)-45(,)0( most modern graphics systems can be)]TJ
0 -1.5 TD
(thought of as an assembly line. The main central processing unit \(CPU\) issues a drawing command.)Tj
T*
(Perhaps other hardware does geometric transformations. Clipping is performed, followed by shading)Tj
T*
(and/or texturing. Finally, the values are written into the bitplanes for display. In high-end architectures,)Tj
T*
(each of these operations is performed by a different piece of hardware that's been designed to perform its)Tj
T*
(particular task quickly. In such an architecture, there's no need for the CPU to wait for each drawing)Tj
T*
(command to complete before issuing the next one. While the CPU is sending a vertex down the pipeline,)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 5)Tj
ET
endstream
endobj
117 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
119 0 obj
<<
/Length 5235
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(the transformation hardware is working on transforming the last one sent, the one before that is being)Tj
0 -1.5 TD
(clipped, and so on. In such a system, if the CPU waited for each command to complete before issuing the)Tj
T*
(next, there could be a huge performance penalty.)Tj
0 -2.1 TD
(In addition, the application might be running on more than one machine. For example, suppose that the)Tj
0 -1.5 TD
(main program is running elsewhere \(on a machine called the client\) and that you're viewing the results of)Tj
T*
(the drawing on your workstation or terminal \(the server\), which is connected by a network to the client.)Tj
T*
(In that case, it might be horribly inefficient to send each command over the network one at a time, since)Tj
T*
(considerable overhead is often associated with each network transmission. Usually, the client gathers a)Tj
T*
(collection of commands into a single network packet before sending it. Unfortunately, the network code)Tj
T*
(on the client typically has no way of knowing that the graphics program is finished drawing a frame or)Tj
T*
(scene. In the worst case, it waits forever for enough additional drawing commands to fill a packet, and)Tj
T*
(you never see the completed drawing.)Tj
0 -2.1 TD
(For this reason, OpenGL provides the command )Tj
/F15 1 Tf
19.6 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
(, which forces the client to send the network)Tj
-23.3 -1.5 TD
(packet even though it might not be full. Where there is no network and all commands are truly executed)Tj
T*
(immediately on the server, )Tj
/F15 1 Tf
10.9 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( might have no effect. However, if you're writing a program that you)Tj
-14.6 -1.5 TD
(want to work properly both with and without a network, include a call to )Tj
/F15 1 Tf
29.3 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( at the end of each)Tj
-33 -1.6 TD
(frame or scene. Note that )Tj
/F15 1 Tf
10.3 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.8 0 TD
( doesn't wait for the drawing to complete)Tj
/F33 1 Tf
16.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(it just forces the drawing)Tj
-31.6 -1.6 TD
(to begin execution, thereby guaranteeing that all previous commands )Tj
/F15 1 Tf
27.8 0 TD
(execute)Tj
/F11 1 Tf
3 0 TD
( in finite time even if no)Tj
-30.8 -1.5 TD
(further rendering commands are executed.)Tj
0 -2.1 TD
(There are other situations where )Tj
/F15 1 Tf
13.1 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.8 0 TD
( is useful.)Tj
/F33 1 Tf
-16.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Software renderers that build image in system memory and don't want to constantly update the)Tj
0 -1.6 TD
(screen.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Implementations that gather sets of rendering commands to amortize start-up costs. The)Tj
0 -1.6 TD
(aforementioned network transmission example is one instance of this.)Tj
/F15 1 Tf
-1.9 -2.7 TD
0.028 Tw
[(void glFlush)56(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Forces previously issued OpenGL commands to begin execution, thus guaranteeing that they)Tj
T*
(complete in finite time.)Tj
/F11 1 Tf
-1.8 -2.2 TD
(A few commands)Tj
/F33 1 Tf
7.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, commands that swap buffers in double-buffer mode)Tj
/F33 1 Tf
26 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(automatically)Tj
-35.1 -1.6 TD
(flush pending commands onto the network before they can occur.)Tj
0 -2.1 TD
(If )Tj
/F15 1 Tf
0.9 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( isn't sufficient for you, try )Tj
/F15 1 Tf
11.1 0 TD
(glFinish\(\))Tj
/F11 1 Tf
4 0 TD
(. This command flushes the network as )Tj
/F15 1 Tf
15.9 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( does)Tj
-39.3 -1.5 TD
(and then waits for notification from the graphics hardware or network indicating that the drawing is)Tj
0 -1.6 TD
(complete in the framebuffer. You might need to use )Tj
/F15 1 Tf
21 0 TD
(glFinish\(\))Tj
/F11 1 Tf
4 0 TD
( if you want to synchronize tasks)Tj
/F33 1 Tf
13.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for)Tj
-39.2 -1.5 TD
(example, to make sure that your three-dimensional rendering is on the screen before you use Display)Tj
T*
(PostScript to draw labels on top of the rendering. Another example would be to ensure that the drawing is)Tj
T*
(complete before it begins to accept user input. After you issue a )Tj
/F15 1 Tf
25.7 0 TD
(glFinish\(\))Tj
/F11 1 Tf
4 0 TD
( command, your graphics)Tj
-29.7 -1.5 TD
(process is blocked until it receives notification from the graphics hardware that the drawing is complete.)Tj
T*
(Keep in mind that excessive use of )Tj
/F15 1 Tf
14.2 0 TD
(glFinish\(\))Tj
/F11 1 Tf
4 0 TD
( can reduce the performance of your application, especially)Tj
-18.2 -1.5 TD
(if you're running over a network, because it requires round-trip communication. If )Tj
/F15 1 Tf
33.2 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( is sufficient)Tj
-36.9 -1.5 TD
(for your needs, use it instead of )Tj
/F15 1 Tf
12.8 0 TD
(glFinish\(\))Tj
/F11 1 Tf
4 0 TD
(.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 6)Tj
ET
endstream
endobj
120 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
122 0 obj
<<
/Length 3594
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 704.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.028 Tw
[(void glFinish)34(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Forces all previously issued OpenGL commands to complete. This command doesn't return until all)Tj
T*
(effects from previous commands are fully realized.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 645.000 Tm
(Coordinate System Survival Kit)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 623.000 Tm
(Whenever you initially open a window or later move or resize that window, the window system will send)Tj
T*
(an event to notify you. If you are using GLUT, the notification is automated; whatever routine has been)Tj
T*
(registered to )Tj
/F15 1 Tf
5.2 0 TD
(glutReshapeFunc\(\))Tj
/F11 1 Tf
7.7 0 TD
( will be called. You must register a callback function that will)Tj
/F33 1 Tf
-12.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Reestablish the rectangular region that will be the new rendering canvas)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Define the coordinate system to which objects will be drawn)Tj
-1.9 -2.7 TD
[(In )-17(Chapter 3)16( you'll see how to define three-dimensional coordinate systems, but right now, just create a)]TJ
0 -1.5 TD
(simple, basic two-dimensional coordinate system into which you can draw a few objects. Call)Tj
/F15 1 Tf
T*
(glutReshapeFunc)Tj
/F11 1 Tf
7 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(reshape)Tj
/F11 1 Tf
3.2 0 TD
(\), where )Tj
/F15 1 Tf
3.5 0 TD
(reshape\(\))Tj
/F11 1 Tf
3.9 0 TD
[( is the following function shown in )52(Example 2-1)]TJ
19.3 0 TD
(.)Tj
/F27 1 Tf
-37.2 -2.1 TD
(Example 2-1 )Tj
/F11 1 Tf
6.1 0 TD
(Reshape Callback Function)Tj
/F7 1 Tf
-6.1 -2.4 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   gluOrtho2D \(0.0, \(GLdouble\) w, 0.0, \(GLdouble\) h\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(The internals of GLUT will pass this function two arguments: the width and height, in pixels, of the new,)Tj
0 -1.5 TD
(moved, or resized window. )Tj
/F15 1 Tf
11.1 0 TD
(glViewport\(\))Tj
/F11 1 Tf
5.1 0 TD
( adjusts the pixel rectangle for drawing to be the entire new)Tj
-16.2 -1.5 TD
(window. The next three routines adjust the coordinate system for drawing so that the lower-left corner is)Tj
T*
(\(0, 0\), and the upper-right corner is \()Tj
/F15 1 Tf
14.6 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(h)Tj
/F11 1 Tf
0.5 0 TD
[(\) \(See )10(Figure 2-1)225(\).)]TJ
-16.3 -2.1 TD
(To explain it another way, think about a piece of graphing paper. The )Tj
/F15 1 Tf
28 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(h)Tj
/F11 1 Tf
0.5 0 TD
( values in )Tj
/F15 1 Tf
4.1 0 TD
(reshape\(\))Tj
/F11 1 Tf
-35.2 -1.5 TD
(represent how many columns and rows of squares are on your graph paper. Then you have to put axes on)Tj
T*
(the graph paper. The )Tj
/F15 1 Tf
8.5 0 TD
(gluOrtho2D\(\))Tj
/F11 1 Tf
5.6 0 TD
( routine puts the origin, \(0, 0\), all the way in the lowest, leftmost)Tj
-14.1 -1.5 TD
(square, and makes each square represent one unit. Now when you render the points, lines, and polygons)Tj
T*
(in the rest of this chapter, they will appear on this paper in easily predictable squares. \(For now, keep all)Tj
T*
(your objects two-dimensional.\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 7)Tj
ET
endstream
endobj
123 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
124 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im4
/Width 183
/Height 166
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.3)
>>
stream
endstream
endobj
126 0 obj
<<
/Length 3351
>>
stream
/GS1 gs
q
183 0 0 166 124 554 cm
/Im4 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 541.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-1 )Tj
/F11 1 Tf
5.1 0 TD
(Coordinate System Defined by w = 50, h = 50)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 508.000 Tm
(Describing Points, Lines, and Polygons)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 486.000 Tm
(This section explains how to describe OpenGL geometric primitives. All geometric primitives are)Tj
0 -1.7 TD
(eventually described in terms of their )Tj
/F15 1 Tf
15.2 0 TD
(vertices)Tj
/F33 1 Tf
3.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(coordinates that define the points themselves, the)Tj
-19.3 -1.5 TD
(endpoints of line segments, or the corners of polygons. The next section discusses how these primitives)Tj
T*
(are displayed and what control you have over their display.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 410.000 Tm
(What Are Points, Lines, and Polygons?)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 388.000 Tm
(You probably have a fairly good idea of what a mathematician means by the terms )Tj
/F15 1 Tf
33.3 0 TD
(point)Tj
/F11 1 Tf
2.1 0 TD
(, )Tj
/F13 1 Tf
0.5 0 TD
(line)Tj
/F11 1 Tf
1.5 0 TD
(, and)Tj
/F13 1 Tf
-37.4 -1.5 TD
(polygon)Tj
/F11 1 Tf
3.4 0 TD
(. The OpenGL meanings are similar, but not quite the same.)Tj
-3.4 -2.1 TD
(One difference comes from the limitations of computer-based calculations. In any OpenGL)Tj
0 -1.5 TD
(implementation, floating-point calculations are of finite precision, and they have round-off errors.)Tj
T*
(Consequently, the coordinates of OpenGL points, lines, and polygons suffer from the same problems.)Tj
0 -2.1 TD
(Another more important difference arises from the limitations of a raster graphics display. On such a)Tj
0 -1.5 TD
(display, the smallest displayable unit is a pixel, and although pixels might be less than 1/100 of an inch)Tj
T*
(wide, they are still much larger than the mathematician's concepts of infinitely small \(for points\) or)Tj
T*
(infinitely thin \(for lines\). When OpenGL performs calculations, it assumes points are represented as)Tj
T*
(vectors of floating-point numbers. However, a point is typically \(but not always\) drawn as a single pixel,)Tj
T*
(and many different points with slightly different coordinates could be drawn by OpenGL on the same)Tj
T*
(pixel.)Tj
/F27 1 Tf
0 -3 TD
(Points)Tj
/F11 1 Tf
0 -2.2 TD
(A point is represented by a set of floating-point numbers called a )Tj
/F13 1 Tf
26.2 0 TD
(vertex)Tj
/F11 1 Tf
2.7 0 TD
(. All internal calculations are)Tj
-28.9 -1.5 TD
(done as if vertices are three-dimensional. Vertices specified by the user as two-dimensional \(that is, with)Tj
T*
(only )Tj
/F15 1 Tf
2 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
( coordinates\) are assigned a )Tj
/F15 1 Tf
11.3 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinate equal to zero by OpenGL.)Tj
/F27 1 Tf
-8.6 -2.1 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.2 TD
(OpenGL works in the )Tj
/F13 1 Tf
8.9 0 TD
(homogeneous coordinates)Tj
/F11 1 Tf
11 0 TD
( of three-dimensional projective geometry, so for)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 8)Tj
ET
endstream
endobj
127 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im4 124 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
128 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im5
/Width 283
/Height 92
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.4)
>>
stream
endstream
endobj
130 0 obj
<<
/Length 3892
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(internal calculations, all vertices are represented with four floating-point coordinates \()Tj
/F15 1 Tf
34.4 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(\). If )Tj
/F15 1 Tf
1.7 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( is)Tj
-40.3 -1.5 TD
(different from zero, these coordinates correspond to the Euclidean three-dimensional point \()Tj
/F15 1 Tf
36.8 0 TD
[(x/w)-11(, y/w)-11(,)]TJ
-36.8 -1.5 TD
(z/w)Tj
/F11 1 Tf
1.3 0 TD
(\). You can specify the )Tj
/F15 1 Tf
9.1 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( coordinate in OpenGL commands, but that's rarely done. If the )Tj
/F15 1 Tf
25.7 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( coordinate)Tj
-37.5 -1.5 TD
[(isn't specified, it's understood to be 1.0. \(See )-39(Appendix F)51( for more information about homogeneous)]TJ
T*
(coordinate systems.\))Tj
/F27 1 Tf
0 -3 TD
(Lines)Tj
/F11 1 Tf
0 -2.1 TD
(In OpenGL, the term )Tj
/F15 1 Tf
8.6 0 TD
(line)Tj
/F11 1 Tf
1.5 0 TD
( refers to a )Tj
/F15 1 Tf
4.5 0 TD
(line segment)Tj
/F11 1 Tf
5.1 0 TD
(, not the mathematician's version that extends to infinity)Tj
-19.7 -1.5 TD
(in both directions. There are easy ways to specify a connected series of line segments, or even a closed,)Tj
T*
[(connected series of segments \(see )48(Figure 2-2)225(\). In all cases, though, the lines constituting the connected)]TJ
T*
(series are specified in terms of the vertices at their endpoints.)Tj
ET
Q
/GS1 gs
q
283 0 0 92 124 448.84 cm
/Im5 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 436.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-2 )Tj
/F11 1 Tf
5.1 0 TD
(Two Connected Series of Line Segments)Tj
/F27 1 Tf
-5.1 -3 TD
(Polygons)Tj
/F11 1 Tf
0 -2.1 TD
(Polygons are the areas enclosed by single closed loops of line segments, where the line segments are)Tj
0 -1.5 TD
(specified by the vertices at their endpoints. Polygons are typically drawn with the pixels in the interior)Tj
T*
[(filled in, but you can also draw them as outlines or a set of points. \(See )11("Polygon Details.")-16(\))]TJ
0 -2.1 TD
(In general, polygons can be complicated, so OpenGL makes some strong restrictions on what constitutes)Tj
0 -1.5 TD
(a primitive polygon. First, the edges of OpenGL polygons can't intersect \(a mathematician would call a)Tj
T*
(polygon satisfying this condition a )Tj
/F15 1 Tf
14.1 0 TD
(simple polygon)Tj
/F11 1 Tf
6.1 0 TD
(\). Second, OpenGL polygons must be )Tj
/F15 1 Tf
15.3 0 TD
(convex)Tj
/F11 1 Tf
2.8 0 TD
(, meaning)Tj
-38.3 -1.5 TD
(that they cannot have indentations. Stated precisely, a region is convex if, given any two points in the)Tj
T*
[(interior, the line segment joining them is also in the interior. See Figure 2-3)225( for some examples of valid)]TJ
T*
(and invalid polygons. OpenGL, however, doesn't restrict the number of line segments making up the)Tj
T*
(boundary of a convex polygon. Note that polygons with holes can't be described. They are )Tj
/F13 1 Tf
36.5 0 TD
(nonconvex)Tj
/F11 1 Tf
4.6 0 TD
(,)Tj
-41.1 -1.5 TD
(and they can't be drawn with a boundary made up of a single closed loop. Be aware that if you present)Tj
T*
(OpenGL with a nonconvex filled polygon, it might not draw it as you expect. For instance, on most)Tj
0 -1.6 TD
(systems no more than the )Tj
/F13 1 Tf
10.4 0 TD
(convex hull)Tj
/F11 1 Tf
4.9 0 TD
( of the polygon would be filled. On some systems, less than the)Tj
-15.3 -1.5 TD
(convex hull might be filled.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 9)Tj
ET
endstream
endobj
131 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im5 128 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
132 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im6
/Width 395
/Height 109
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.5)
>>
stream
endstream
endobj
133 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im7
/Width 509
/Height 106
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.6)
>>
stream
endstream
endobj
135 0 obj
<<
/Length 3520
>>
stream
/GS1 gs
q
395 0 0 109 124 611 cm
/Im6 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 598.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-3 )Tj
/F11 1 Tf
5.1 0 TD
(Valid and Invalid Polygons)Tj
-5.1 -2.1 TD
(The reason for the OpenGL restrictions on valid polygon types is that it's simpler to provide fast)Tj
0 -1.5 TD
(polygon-rendering hardware for that restricted class of polygons. Simple polygons can be rendered)Tj
T*
(quickly. The difficult cases are hard to detect quickly. So for maximum performance, OpenGL crosses its)Tj
T*
(fingers and assumes the polygons are simple.)Tj
0 -2.1 TD
(Many real-world surfaces consist of nonsimple polygons, nonconvex polygons, or polygons with holes.)Tj
0 -1.5 TD
(Since all such polygons can be formed from unions of simple convex polygons, some routines to build)Tj
T*
(more complex objects are provided in the GLU library. These routines take complex descriptions and)Tj
T*
(tessellate them, or break them down into groups of the simpler OpenGL polygons that can then be)Tj
T*
[(rendered. \(See )26("Polygon Tessellation" in Chapter 11)-71( for more information about the )]TJ
/F13 1 Tf
33.8 0 TD
(tessellation)Tj
/F11 1 Tf
-33.8 -1.5 TD
(routines.\))Tj
0 -2.1 TD
(Since OpenGL vertices are always three-dimensional, the points forming the boundary of a particular)Tj
0 -1.6 TD
(polygon don't necessarily lie on the same plane in space. \(Of course, they do in many cases)Tj
/F33 1 Tf
36.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(if all the )Tj
/F15 1 Tf
3.6 0 TD
(z)Tj
/F11 1 Tf
-41.2 -1.6 TD
(coordinates are zero, for example, or if the polygon is a )Tj
/F13 1 Tf
22.4 0 TD
(triangle)Tj
/F11 1 Tf
3.3 0 TD
(.\) If a polygon's vertices don't lie in the)Tj
-25.7 -1.5 TD
(same plane, then after various rotations in space, changes in the viewpoint, and projection onto the)Tj
T*
(display screen, the points might no longer form a simple convex polygon. For example, imagine a)Tj
T*
(four-point )Tj
/F15 1 Tf
4.3 0 TD
(quadrilateral)Tj
/F11 1 Tf
5.3 0 TD
( where the points are slightly out of plane, and look at it almost edge-on. You can)Tj
-9.6 -1.5 TD
[(get a nonsimple polygon that resembles a bow tie, as shown in )51(Figure 2-4)225(, which isn't guaranteed to be)]TJ
T*
(rendered correctly. This situation isn't all that unusual if you approximate curved surfaces by)Tj
T*
(quadrilaterals made of points lying on the true surface. You can always avoid the problem by using)Tj
T*
(triangles, since any three points always lie on a plane.)Tj
ET
Q
q
423 0 0 88 124 175.39 cm
/Im7 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 163.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-4 )Tj
/F11 1 Tf
5.1 0 TD
(Nonplanar Polygon Transformed to Nonsimple Polygon)Tj
/F27 1 Tf
-5.1 -3 TD
(Rectangles)Tj
/F11 1 Tf
0 -2.2 TD
(Since rectangles are so common in graphics applications, OpenGL provides a filled-rectangle drawing)Tj
0 -1.5 TD
(primitive, )Tj
/F15 1 Tf
4.2 0 TD
(glRect*\(\))Tj
/F11 1 Tf
3.7 0 TD
[(. You can draw a rectangle as a polygon, as described in )19("OpenGL Geometric)]TJ
-7.9 -1.5 TD
[(Drawing Primitives,")20( but your particular implementation of OpenGL might have optimized )]TJ
/F15 1 Tf
36.8 0 TD
(glRect*\(\))Tj
/F11 1 Tf
3.7 0 TD
( for)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 10)Tj
ET
endstream
endobj
136 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im6 132 0 R
/Im7 133 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
137 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im8
/Width 510
/Height 101
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.7)
>>
stream
endstream
endobj
139 0 obj
<<
/Length 3969
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(rectangles.)Tj
/F15 1 Tf
0 -2.1 TD
0.000 Tw
[(void )-28(glRect)55({sifd}\()-22(TYPE)34(x1)-56(, TYPE)34(y1)-56(, TYPE)34(x2)44(, TYPE)-66(y2)44(\);)]TJ
0 -1.1 TD
0.028 Tw
[(void glRect)55({sifd})-55(v)44(\()33(TYPE)-66(*v1)44(, )28(TYPE)-66(*v2)44(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Draws the rectangle defined by the corner points \()22(x1, y1)-12(\) and \()-34(x2, y2)-12(\). The rectangle lies in the)]TJ
T*
[(plane )-28(z)-11(=0 and has sides parallel to the )83(x)-56(-)0( and )]TJ
18.6 0 TD
[(y)-56(-axes. If the vector form of the function is used, the)]TJ
-18.6 -1.5 TD
[(corners are given by two pointers to arrays, each of which contains an \()-10(x, y)-12(\))0( pair.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(Note that although the rectangle begins with a particular orientation in three-dimensional space \(in the)Tj
/F15 1 Tf
0 -1.5 TD
(x-y)Tj
/F11 1 Tf
1.2 0 TD
( plane and parallel to the axes\), you can change this by applying rotations or other transformations.)Tj
-1.2 -1.5 TD
[(\(See )27(Chapter 3)16( for information about how to do this.\))]TJ
/F27 1 Tf
0 -3 TD
(Curves and Curved Surfaces)Tj
/F11 1 Tf
0 -2.2 TD
(Any smoothly curved line or surface can be approximated)Tj
/F33 1 Tf
23.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(to any arbitrary degree of accuracy)Tj
/F33 1 Tf
14 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(by)Tj
-39.2 -1.6 TD
(short line segments or small polygonal regions. Thus, subdividing curved lines and surfaces sufficiently)Tj
0 -1.5 TD
(and then approximating them with straight line segments or flat polygons makes them appear curved \(see)Tj
T*
[(Figure 2-5)225(\). If you're skeptical that this really works, imagine subdividing until each line segment or)]TJ
T*
(polygon is so tiny that it's smaller than a pixel on the screen.)Tj
ET
Q
q
1 i 
124.000 455.970 422.990 -83.770 re
W n
/GS1 gs
q
423 0 0 84 124 371.97 cm
/Im8 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 359.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 2-5 )Tj
/F11 1 Tf
5.1 0 TD
(Approximating Curves)Tj
-5.1 -2.1 TD
(Even though curves aren't geometric primitives, OpenGL does provide some direct support for)Tj
0 -1.5 TD
[(subdividing and drawing them. \(See )23(Chapter 12)16( for information about how to draw curves and curved)]TJ
T*
(surfaces.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 280.000 Tm
(Specifying Vertices)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 258.000 Tm
(With OpenGL, all geometric objects are ultimately described as an ordered set of vertices. You use the)Tj
/F15 1 Tf
T*
(glVertex*\(\))Tj
/F11 1 Tf
4.6 0 TD
( command to specify a vertex.)Tj
/F15 1 Tf
-4.6 -2.1 TD
0.028 Tw
[(void glVertex)-12({234}{sifd}[v]\(TYPE)34(coords)22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Specifies a vertex for use in describing a geometric object. You can supply up to four coordinates \()-43(x)0(,)]TJ
T*
[(y, z, w\) for a particular vertex or as few as two \()35(x, y)-12(\))0( by selecting the appropriate version of the)]TJ
T*
[(command. If you use a version that doesn't explicitly specify )16(z)-11( or )-11(w)-33(,)0( z)89( is understood to be 0 and )-60(w)-33( is)]TJ
T*
[(understood to be 1. Calls to )-37(glVertex*\(\))55( are only effective between a )-35(glBegin\(\))-23( and glEnd\(\))55( pair.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(Example 2-2)Tj
5.1 0 TD
( provides some examples of using )Tj
/F15 1 Tf
13.9 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.5 0 TD
(.)Tj
/F27 1 Tf
-23.5 -2.1 TD
(Example 2-2 )Tj
/F11 1 Tf
6.1 0 TD
(Legal Uses of glVertex*\(\))Tj
/F7 1 Tf
-6.1 -2.4 TD
(glVertex2s\(2, 3\); )Tj
0 -1.5 TD
(glVertex3d\(0.0, 0.0, 3.1415926535898\); )Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 11)Tj
ET
endstream
endobj
140 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im8 137 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
141 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im9
/Width 194
/Height 87
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.8)
>>
stream
endstream
endobj
143 0 obj
<<
/Length 3782
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(glVertex4f\(2.3, 1.0, -2.2, 2.0\); )Tj
0 -3 TD
(GLdouble dvect[3] = {5.0, 9.0, 1992.0};)Tj
0 -1.5 TD
(glVertex3dv\(dvect\);)Tj
/F11 1 Tf
0 -2.1 TD
(The first example represents a vertex with three-dimensional coordinates \(2, 3, 0\). \(Remember that if it)Tj
0 -1.5 TD
(isn't specified, the )Tj
/F15 1 Tf
7.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinate is understood to be 0.\) The coordinates in the second example are \(0.0,)Tj
-8 -1.5 TD
(0.0, 3.1415926535898\) \(double-precision floating-point numbers\). The third example represents the)Tj
T*
(vertex with three-dimensional coordinates \(1.15, 0.5, -1.1\). \(Remember that the )Tj
/F15 1 Tf
32.1 0 TD
(x, y)Tj
/F11 1 Tf
1.3 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinates)Tj
-36 -1.5 TD
(are eventually divided by the )Tj
/F15 1 Tf
11.9 0 TD
(w)Tj
/F11 1 Tf
0.6 0 TD
( coordinate.\) In the final example, )Tj
/F15 1 Tf
13.9 0 TD
(dvect)Tj
/F11 1 Tf
2.1 0 TD
( is a pointer to an array of three)Tj
-28.5 -1.5 TD
(double-precision floating-point numbers.)Tj
0 -2.1 TD
(On some machines, the vector form of )Tj
/F15 1 Tf
15.6 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.6 0 TD
( is more efficient, since only a single parameter needs)Tj
-20.2 -1.5 TD
(to be passed to the graphics subsystem. Special hardware might be able to send a whole series of)Tj
T*
(coordinates in a single batch. If your machine is like this, it's to your advantage to arrange your data so)Tj
T*
(that the vertex coordinates are packed sequentially in memory. In this case, there may be some gain in)Tj
T*
[(performance by using the vertex array operations of OpenGL. \(See )23("Vertex Arrays.")-41(\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 461.000 Tm
(OpenGL Geometric Drawing Primitives)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 439.000 Tm
(Now that you've seen how to specify vertices, you still need to know how to tell OpenGL to create a set)Tj
T*
(of points, a line, or a polygon from those vertices. To do this, you bracket each set of vertices between a)Tj
T*
(call to )Tj
/F15 1 Tf
2.7 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and a call to )Tj
/F15 1 Tf
5.4 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
(. The argument passed to )Tj
/F15 1 Tf
10.3 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( determines what sort of)Tj
-29 -1.5 TD
[(geometric primitive is constructed from the vertices. For example, )49(Example 2-3)170( specifies the vertices for)]TJ
T*
[(the polygon shown in )-10(Figure 2-6)225(.)]TJ
/F27 1 Tf
0 -2.1 TD
(Example 2-3 )Tj
/F11 1 Tf
6.1 0 TD
(Filled Polygon)Tj
/F7 1 Tf
-6.1 -2.3 TD
(glBegin\(GL_POLYGON\);)Tj
0 -1.5 TD
(   glVertex2f\(0.0, 0.0\);)Tj
T*
(   glVertex2f\(0.0, 3.0\);)Tj
T*
(   glVertex2f\(4.0, 3.0\);)Tj
T*
(   glVertex2f\(6.0, 1.5\);)Tj
T*
(   glVertex2f\(4.0, 0.0\);)Tj
T*
(glEnd\(\);)Tj
ET
Q
/GS1 gs
q
194 0 0 87 124 143.18 cm
/Im9 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 130.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-6 )Tj
/F11 1 Tf
5.1 0 TD
(Drawing a Polygon or a Set of Points)Tj
-5.1 -2.1 TD
(If you had used GL_POINTS instead of GL_POLYGON, the primitive would have been simply the five)Tj
0 -1.5 TD
[(points shown in )-15(Figure 2-6)225(. Table 2-2)]TJ
15.1 0 TD
( in the following function summary for )Tj
/F15 1 Tf
15.9 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( lists the ten)Tj
-34.8 -1.5 TD
(possible arguments and the corresponding type of primitive.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 12)Tj
ET
endstream
endobj
144 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im9 141 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
147 0 obj
<<
/Length 2637
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 706.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.028 Tw
[(void glBegin)11(\(GLenum )55(mode)-34(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Marks the beginning of a vertex-data list that describes a geometric primitive. The type of primitive)Tj
T*
[(is indicated by )-16(mode)66(, which can be any of the values shown in )-38(Table 2-2)]TJ
29 0 TD
(.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 665.180 m
460.000 665.180 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 657.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Value)-10957(Meaning)]TJ
ET
Q
124.000 651.660 m
460.000 651.660 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 644.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_POINTS)-6777(individual points)]TJ
0 -1.4444 TD
[(GL_LINES)-7444(pairs of vertices interpreted as individual line segments)]TJ
0 -1.5556 TD
[(GL_LINE_STRIP)-4777(series of connected line segments)]TJ
0 -1.4444 TD
[(GL_LINE_LOOP)-4889(same as above, with a segment added between last and first)]TJ
12.1111 -1.3333 TD
(vertices)Tj
-12.1111 -1.4444 TD
[(GL_TRIANGLES)-4722(triples of vertices interpreted as triangles)]TJ
T*
[(GL_TRIANGLE_STRIP)-2055(linked strip of triangles)]TJ
T*
[(GL_TRIANGLE_FAN)-2778(linked fan of triangles)]TJ
T*
[(GL_QUADS)-6833(quadruples of vertices interpreted as four-sided polygons)]TJ
T*
[(GL_QUAD_STRIP)-4166(linked strip of quadrilaterals)]TJ
T*
[(GL_POLYGON)-5500(boundary of a simple, convex polygon)]TJ
ET
Q
124.000 506.650 m
460.010 506.650 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 490.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 2-2 )Tj
/F11 1 Tf
4.6 0 TD
(Geometric Primitive Names and Meanings)Tj
/F15 1 Tf
-4.6 -2.1 TD
0.028 Tw
[(void glEnd)-11(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Marks the end of a vertex-data list.)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(Figure 2-7)225( shows examples of all the geometric primitives listed in )35(Table 2-2)191(. The paragraphs that follow)]TJ
0 -1.5 TD
(the figure describe the pixels that are drawn for each of the objects. Note that in addition to points,)Tj
T*
(several types of lines and polygons are defined. Obviously, you can find many ways to draw the same)Tj
T*
(primitive. The method you choose depends on your vertex data.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 13)Tj
ET
endstream
endobj
148 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
149 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im10
/Width 464
/Height 382
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.9)
>>
stream
endstream
endobj
151 0 obj
<<
/Length 2347
>>
stream
/GS1 gs
q
423 0 0 348 124 372 cm
/Im10 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 359.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-7 )Tj
/F11 1 Tf
5.1 0 TD
(Geometric Primitive Types)Tj
-5.1 -2.1 TD
(As you read the following descriptions, assume that )Tj
/F15 1 Tf
21 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( vertices \(v0, v1, v2, ... , vn-1\) are described)Tj
-21.5 -1.5 TD
(between a )Tj
/F15 1 Tf
4.3 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( pair.)Tj
-13.1 -1.1 TD
[(GL_POINTS)-9566(Draws a point at each of the )]TJ
/F15 1 Tf
26.4 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( vertices.)Tj
-26.9 -1.4 TD
[(GL_LINES)-10234(Draws a series of unconnected line segments.  Segments are)]TJ
14.9 -1.5 TD
(drawn between v0 and v1, between v2 and  v3, and so on. If )Tj
/F15 1 Tf
24.3 0 TD
(n)Tj
/F11 1 Tf
-24.3 -1.5 TD
(is odd, the last segment is drawn  between vn-3 and vn-2, and)Tj
T*
(vn-1 is ignored.)Tj
-14.9 -1.5 TD
[(GL_LINE_STRIP)-7566(Draws a line segment from v0 to v1, then from v1 to v2,  and so)]TJ
14.9 -1.5 TD
(on, finally drawing the segment from vn-2 to  vn-1. Thus, a)Tj
T*
(total of )Tj
/F15 1 Tf
3.1 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(-)Tj
/F15 1 Tf
0.3 0 TD
(1)Tj
/F11 1 Tf
0.5 0 TD
( line segments are drawn.  Nothing is drawn unless )Tj
/F15 1 Tf
20.7 0 TD
(n)Tj
/F11 1 Tf
-25.1 -1.5 TD
(is larger than 1. There are no  restrictions on the vertices)Tj
T*
(describing a line strip \(or a  line loop\); the lines can intersect)Tj
T*
(arbitrarily.)Tj
-14.9 -1.4 TD
[(GL_LINE_LOOP)-7678(Same as GL_LINE_STRIP, except that a final line  segment is)]TJ
14.9 -1.5 TD
(drawn from vn-1 to v0, completing a loop.)Tj
-14.9 -1.4 TD
[(GL_TRIANGLES)-7511(Draws a series of triangles \(three-sided polygons\)  using)]TJ
14.9 -1.5 TD
(vertices v0, v1, v2, then v3, v4, v5, and so on. If )Tj
/F15 1 Tf
19.6 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(  isn't an)Tj
-20.1 -1.5 TD
(exact multiple of 3, the final one or two vertices  are ignored.)Tj
-14.9 -1.4 TD
[(GL_TRIANGLE_STRIP)-4844(Draws a series of triangles \(three-sided polygons\)  using)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 14)Tj
ET
endstream
endobj
152 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im10 149 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
154 0 obj
<<
/Length 4770
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 273.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(vertices v0, v1, v2, then v2, v1, v3 \(note the order\),  then v2,)Tj
0 -1.5 TD
(v3, v4, and so on. The ordering is to ensure that  the triangles)Tj
T*
(are all drawn with the same orientation so  that the strip can)Tj
T*
(correctly form part of a surface.  Preserving the orientation is)Tj
T*
(important for some  operations, such as culling. \(See)Tj
T*
[("Reversing and  Culling Polygon Faces")-21(\) )]TJ
/F15 1 Tf
16.8 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( must be at least  3)Tj
-17.3 -1.5 TD
(for anything to be drawn.)Tj
-14.9 -1.4 TD
[(GL_TRIANGLE_FAN)-5567(Same as GL_TRIANGLE_STRIP, except that the  vertices are)]TJ
14.9 -1.5 TD
(v0, v1, v2, then v0, v2, v3, then v0, v3, v4,  and so on \(see)Tj
T*
[(Figure 2-7)225(\).)]TJ
-14.9 -1.4 TD
[(GL_QUADS)-9622(Draws a series of quadrilaterals \(four-sided polygons\)  using)]TJ
14.9 -1.5 TD
(vertices v0, v1, v2, v3, then v4, v5, v6, v7, and so  on. If )Tj
/F15 1 Tf
22.8 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( isn't)Tj
-23.3 -1.5 TD
(a multiple of 4, the final one, two, or three  vertices are ignored.)Tj
-14.9 -1.5 TD
[(GL_QUAD_STRIP)-6955(Draws a series of quadrilaterals \(four-sided polygons\))]TJ
14.9 -1.5 TD
(beginning with v0, v1, v3, v2, then v2, v3, v5, v4, then  v4, v5,)Tj
T*
[(v7, v6, and so on \(see )44(Figure 2-7)225(\). )]TJ
/F15 1 Tf
14 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( must be at  least 4 before)Tj
-14.5 -1.5 TD
(anything is drawn. If )Tj
/F15 1 Tf
8.6 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( is odd, the final  vertex is ignored.)Tj
-24 -1.4 TD
[(GL_POLYGON)-8289(Draws a polygon using the points v0, ... , vn-1 as  vertices. )]TJ
/F15 1 Tf
38.6 0 TD
(n)Tj
/F11 1 Tf
-23.7 -1.5 TD
(must be at least 3, or nothing is drawn. In  addition, the polygon)Tj
T*
(specified must not intersect itself  and must be convex. If the)Tj
T*
(vertices don't satisfy these  conditions, the results are)Tj
T*
(unpredictable.)Tj
/F27 1 Tf
-14.9 -3 TD
(Restrictions on Using glBegin\(\) and glEnd\(\))Tj
/F11 1 Tf
0 -2.1 TD
(The most important information about vertices is their coordinates, which are specified by the)Tj
/F15 1 Tf
0 -1.6 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.6 0 TD
( command. You can also supply additional vertex-specific data for each vertex)Tj
/F33 1 Tf
31.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(a color, a)Tj
-37 -1.7 TD
(normal vector, texture coordinates, or any combination of these)Tj
/F33 1 Tf
25.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(using special commands. In addition, a)Tj
-26.4 -1.6 TD
(few other commands are valid between a )Tj
/F15 1 Tf
16.6 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
[( pair. Table 2-3)191( contains a complete list)]TJ
-25.4 -1.5 TD
(of such valid commands.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 271.300 m
471.000 271.300 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 264.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Command)-11735(Purpose of Command)-6233(Reference)]TJ
ET
Q
124.000 257.780 m
471.000 257.780 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 250.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(glVertex*\(\))-10112(set vertex coordinates)-6056(Chapter 2)]TJ
0 -1.4444 TD
[(glColor*\(\))-10555(set current color)-8279(Chapter 4)]TJ
T*
[(glIndex*\(\))-10556(set current color index)-5806(Chapter 4)]TJ
T*
[(glNormal*\(\))-9778(set normal vector coordinates)-2973(Chapter 2)]TJ
0 -1.5556 TD
[(glTexCoord*\(\))-8778(set texture coordinates)-5778(Chapter 9)]TJ
0 -1.4444 TD
[(glEdgeFlag*\(\))-9000(control drawing of edges)-4806(Chapter 2)]TJ
T*
[(glMaterial*\(\))-9445(set material properties)-5889(Chapter 5)]TJ
T*
[(glArrayElement\(\))-7668(extract vertex array data)-5086(Chapter 2)]TJ
T*
[(glEvalCoord*\(\), glEvalPoint*\(\))-2110(generate coordinates)-6529(Chapter 12)]TJ
T*
[(glCallList\(\), glCallLists\(\))-4553(execute display list\(s\))-6055(Chapter 7)]TJ
ET
Q
124.000 124.770 m
471.010 124.770 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 109.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 2-3 )Tj
/F11 1 Tf
4.6 0 TD
(Valid Commands between glBegin\(\) and glEnd\(\))Tj
-4.6 -2.2 TD
(No other OpenGL commands are valid between a )Tj
/F15 1 Tf
20.1 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( pair, and making most other)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 15)Tj
ET
endstream
endobj
155 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
157 0 obj
<<
/Length 4612
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL calls generates an error. Some vertex array commands, such as )Tj
/F15 1 Tf
29.1 0 TD
(glEnableClientState\(\))Tj
/F11 1 Tf
8.7 0 TD
( and)Tj
/F15 1 Tf
-37.8 -1.5 TD
(glVertexPointer\(\))Tj
/F11 1 Tf
7.1 0 TD
(, when called between )Tj
/F15 1 Tf
9.1 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
(, have undefined behavior but do not)Tj
-25 -1.5 TD
(necessarily generate an error. \(Also, routines related to OpenGL, such as )Tj
/F15 1 Tf
29.3 0 TD
(glX*\(\))Tj
/F11 1 Tf
2.6 0 TD
( routines have undefined)Tj
-31.9 -1.5 TD
(behavior between )Tj
/F15 1 Tf
7.3 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
(.\) These cases should be avoided, and debugging them may be)Tj
-16.1 -1.5 TD
(more difficult.)Tj
0 -2.1 TD
(Note, however, that only OpenGL commands are restricted; you can certainly include other)Tj
0 -1.5 TD
(programming-language constructs \(except for calls, such as the aforementioned )Tj
/F15 1 Tf
32 0 TD
(glX*\(\))Tj
/F11 1 Tf
2.6 0 TD
( routines\). For)Tj
-34.6 -1.5 TD
0.012 Tw
[(example, Example )12(2-4)]TJ
9 0 TD
0.000 Tw
( draws an outlined circle.)Tj
/F27 1 Tf
-9 -2.1 TD
(Example 2-4 )Tj
/F11 1 Tf
6.1 0 TD
(Other Constructs between glBegin\(\) and glEnd\(\))Tj
/F7 1 Tf
-6.1 -2.4 TD
(#define PI 3.1415926535898 )Tj
0 -1.5 TD
(GLint circle_points = 100; )Tj
T*
(glBegin\(GL_LINE_LOOP\); )Tj
T*
(for \(i = 0; i < circle_points; i++\) {    )Tj
T*
(   angle = 2*PI*i/circle_points; )Tj
T*
(   glVertex2f\(cos\(angle\), sin\(angle\)\); )Tj
T*
(} )Tj
T*
(glEnd\(\);)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(This example isn't the most efficient way to draw a circle, especially if you intend to do it)Tj
-2.8 -1.4 TD
(repeatedly. The graphics commands used are typically very fast, but this code calculates an angle and)Tj
T*
(calls the )Tj
/F15 1 Tf
3.6 0 TD
(sin\(\))Tj
/F11 1 Tf
1.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(cos\(\))Tj
/F11 1 Tf
2 0 TD
( routines for each vertex; in addition, there's the loop overhead. \(Another way to)Tj
-9.3 -1.5 TD
(calculate the vertices of a circle is to use a GLU routine; see "Quadrics: Rendering Spheres, Cylinders,)Tj
0 -1.4 TD
[(and Disks" in Chapter 11)-25(.\) If you need to draw lots of circles, calculate the coordinates of the vertices)]TJ
T*
[(once and save them in an array and create a display list \(see )35(Chapter 7)16(\), or use vertex arrays to render)]TJ
0 -1.5 TD
(them.)Tj
0 -2.1 TD
(Unless they are being compiled into a display list, all )Tj
/F15 1 Tf
21.5 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.5 0 TD
( commands should appear between)Tj
-26 -1.5 TD
(some )Tj
/F15 1 Tf
2.4 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
( combination. \(If they appear elsewhere, they don't accomplish anything.\) If)Tj
-11.1 -1.5 TD
(they appear in a display list, they are executed only if they appear between a )Tj
/F15 1 Tf
30.8 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
( and a )Tj
/F15 1 Tf
2.7 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
(.)Tj
-40.2 -1.5 TD
[(\(See )27(Chapter 7)16( for more information about display lists.\))]TJ
0 -2.1 TD
(Although many commands are allowed between )Tj
/F15 1 Tf
19.6 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
(, vertices are generated only when)Tj
-28.3 -1.5 TD
(a )Tj
/F15 1 Tf
0.7 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.5 0 TD
( command is issued. At the moment )Tj
/F15 1 Tf
14.7 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.5 0 TD
( is called, OpenGL assigns the resulting)Tj
-24.4 -1.5 TD
(vertex the current color, texture coordinates, normal vector information, and so on. To see this, look at)Tj
T*
(the following code sequence. The first point is drawn in red, and the second and third ones in blue,)Tj
T*
(despite the extra color commands.)Tj
/F7 1 Tf
0 -2 TD
(glBegin\(GL_POINTS\); )Tj
0 -1.5 TD
(   glColor3f\(0.0, 1.0, 0.0\);                  /* green */ )Tj
T*
(   glColor3f\(1.0, 0.0, 0.0\);                  /* red */ )Tj
T*
(   glVertex\(...\); )Tj
T*
(   glColor3f\(1.0, 1.0, 0.0\);                  /* yellow */ )Tj
T*
(   glColor3f\(0.0, 0.0, 1.0\);                  /* blue */ )Tj
T*
(   glVertex\(...\); )Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 16)Tj
ET
endstream
endobj
158 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
160 0 obj
<<
/Length 4399
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glVertex\(...\); )Tj
0 -1.5 TD
(glEnd\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(You can use any combination of the 24 versions of the )Tj
/F15 1 Tf
22.1 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.5 0 TD
( command between )Tj
/F15 1 Tf
8.1 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
( and)Tj
/F15 1 Tf
-38.4 -1.5 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
(, although in real applications all the calls in any particular instance tend to be of the same form.)Tj
-3.1 -1.5 TD
(If your vertex-data specification is consistent and repetitive \(for example, )Tj
/F15 1 Tf
29.6 0 TD
(glColor*)Tj
/F11 1 Tf
3.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glVertex*)Tj
/F11 1 Tf
3.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glColor*)Tj
/F11 1 Tf
3.6 0 TD
(,)Tj
/F15 1 Tf
-41.7 -1.5 TD
(glVertex*)Tj
/F11 1 Tf
3.9 0 TD
[(,...\), you may enhance your program's performance by using vertex arrays. \(See )17("Vertex)]TJ
-3.9 -1.5 TD
[(Arrays.")-21(\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 582.000 Tm
(Basic State Management)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 560.000 Tm
(In the previous section, you saw an example of a state variable, the current RGBA color, and how it can)Tj
T*
(be associated with a primitive. OpenGL maintains many states and state variables. An object may be)Tj
T*
(rendered with lighting, texturing, hidden surface removal, fog, or some other states affecting its)Tj
T*
(appearance.)Tj
0 -2.1 TD
(By default, most of these states are initially inactive. These states may be costly to activate; for example,)Tj
0 -1.5 TD
(turning on texture mapping will almost certainly slow down the speed of rendering a primitive. However,)Tj
T*
(the quality of the image will improve and look more realistic, due to the enhanced graphics capabilities.)Tj
0 -2.1 TD
(To turn on and off many of these states, use these two simple commands:)Tj
/F15 1 Tf
T*
0.028 Tw
[(void glEnable)11(\(GLenum )55(cap)-56(\);)]TJ
0 -1.1 TD
[(void glDisable)-11(\(GLenum )55(cap)44(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(glEnable\(\))-23( turns on a capability, and )7(glDisable\(\))56( turns it off. There are over 40 enumerated values)]TJ
T*
[(that can be passed as a parameter to glEnable\(\))-23( or )-11(glDisable\(\))56(. Some examples of these are)]TJ
T*
(GL_BLEND \(which controls blending RGBA values\), GL_DEPTH_TEST \(which controls depth)Tj
T*
(comparisons and updates to the depth buffer\), GL_FOG \(which controls fog\), GL_LINE_STIPPLE)Tj
T*
(\(patterned lines\), GL_LIGHTING \(you get the idea\), and so forth.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(You can also check if a state is currently enabled or disabled.)Tj
/F15 1 Tf
T*
0.049 Tw
[(GLboolean glIsEnabled)34(\(GLenum )76(capability\))]TJ
1.8 -1.5 TD
0.000 Tw
[(R)11(eturns GL_TRUE or GL_FALSE, depending upon whether the queried capability is currently)]TJ
T*
(activated.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The states you have just seen have two settings: on and off. However, most OpenGL routines set values)Tj
0 -1.5 TD
(for more complicated state variables. For example, the routine )Tj
/F15 1 Tf
25.1 0 TD
(glColor3f\(\))Tj
/F11 1 Tf
4.6 0 TD
( sets three values, which are)Tj
-29.7 -1.5 TD
(part of the GL_CURRENT_COLOR state. There are five querying routines used to find out what values)Tj
T*
(are set for many states:)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glGetBooleanv\(GLenum )27(pname)-34(, GLboolean *)51(params\);)]TJ
0 -1.1 TD
[(void )-28(glGetIntegerv)55(\(GLenum )-73(pname)66(, GLint *)-16(params\);)]TJ
T*
[(void )-28(glGetFloatv)34(\(GLenum )27(pname)-34(, GLfloat *)-38(params\);)]TJ
T*
[(void )-28(glGetDoublev)11(\(GLenum )27(pname)-34(, GLdouble *)51(params\);)]TJ
T*
[(void )-28(glGetPointerv)67(\(GLenum )-73(pname)66(, GLvoid **)-49(params\);)]TJ
1.8 -1.5 TD
(Obtains Boolean, integer, floating-point, double-precision, or pointer state variables. The )Tj
36.3 0 TD
(pname)Tj
-36.3 -1.5 TD
[(argument is a symbolic constant indicating the state variable to return, and )-24(params is a pointer to)]TJ
T*
[(an array of the indicated type in which to place the returned data. See the tables in )46(Appendix B)-62( for)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 17)Tj
ET
endstream
endobj
161 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
163 0 obj
<<
/Length 4057
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(the possible values for )23(pname)-34(. For example, to get the current RGBA color, a table in Appendix B)]TJ
0 -1.5 TD
[(suggests you use )17(glGetIntegerv)-45(\(GL_CURRENT_COLOR, )35(params\) or)]TJ
T*
[(glGetFloatv)34(\(GL_CURRENT_COLOR,)-15( params)-50(\). A type conversion is performed if necessary to)]TJ
T*
(return the desired variable as the requested data type.)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(These querying routines handle most, but not all, requests for obtaining state information. \(See )40("The)]TJ
0 -1.5 TD
[(Query Commands" in Appendix B)-46( for an additional 16 querying routines.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 597.000 Tm
(Displaying Points, Lines, and Polygons)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 575.000 Tm
(By default, a point is drawn as a single pixel on the screen, a line is drawn solid and one pixel wide, and)Tj
T*
(polygons are drawn solidly filled in. The following paragraphs discuss the details of how to change these)Tj
T*
(default display modes.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 516.000 Tm
(Point Details)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 494.000 Tm
(To control the size of a rendered point, use )Tj
/F15 1 Tf
17.4 0 TD
(glPointSize\(\))Tj
/F11 1 Tf
5.2 0 TD
( and supply the desired size in pixels as the)Tj
-22.6 -1.5 TD
(argument.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glPointSize)57(\(GLfloat )23(size\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Sets the width in pixels for rendered points; )24(size must be greater than 0.0 and by default is 1.0.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(The actual collection of pixels on the screen which are drawn for various point widths depends on)Tj
0 -1.5 TD
(whether antialiasing is enabled. \(Antialiasing is a technique for smoothing points and lines as they're)Tj
T*
[(rendered; see )-46("Antialiasing" in Chapter 6 for more detail.\) If antialiasing is disabled \(the default\),)]TJ
T*
(fractional widths are rounded to integer widths, and a screen-aligned square region of pixels is drawn.)Tj
T*
(Thus, if the width is 1.0, the square is 1 pixel by 1 pixel; if the width is 2.0, the square is 2 pixels by 2)Tj
T*
(pixels, and so on.)Tj
0 -2.1 TD
(With antialiasing enabled, a circular )Tj
/F15 1 Tf
14.7 0 TD
(group)Tj
/F11 1 Tf
2.4 0 TD
( of pixels is drawn, and the pixels on the boundaries are)Tj
-17.1 -1.5 TD
(typically drawn at less than full intensity to give the edge a smoother appearance. In this mode,)Tj
T*
(non-integer widths aren't rounded.)Tj
0 -2.1 TD
(Most OpenGL implementations support very large point sizes. The maximum size for antialiased points)Tj
0 -1.5 TD
(is queryable, but the same information is not available for standard, aliased points. A particular)Tj
T*
(implementation, however, might limit the size of standard, aliased points to not less than its maximum)Tj
T*
(antialiased point size, rounded to the nearest integer value. You can obtain this floating-point value by)Tj
T*
(using GL_POINT_SIZE_RANGE with )Tj
/F15 1 Tf
16 0 TD
(glGetFloatv\(\))Tj
/F11 1 Tf
5.5 0 TD
(.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 187.000 Tm
(Line Details)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 165.000 Tm
(With OpenGL, you can specify lines with different widths and lines that are )Tj
/F15 1 Tf
30.6 0 TD
(stippled)Tj
/F11 1 Tf
3.2 0 TD
( in various)Tj
-33.8 -1.6 TD
(ways)Tj
/F33 1 Tf
2.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(dotted, dashed, drawn with alternating dots and dashes, and so on.)Tj
/F27 1 Tf
-3.1 -3.1 TD
(Wide Lines)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glLineWidth)46(\(GLfloat )23(width)23(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Sets the width in pixels for rendered lines; )-32(width)23( must be greater than 0.0 and by default is 1.0.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 18)Tj
ET
endstream
endobj
164 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
166 0 obj
<<
/Length 4496
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The actual rendering of lines is affected by the antialiasing mode, in the same way as for points. \(See)Tj
0 -1.5 TD
("Antialiasing" in Chapter 6.\) Without antialiasing, widths of 1, 2, and 3 draw lines 1, 2, and 3 pixels)Tj
T*
(wide. With antialiasing enabled, non-integer line widths are possible, and pixels on the boundaries are)Tj
T*
(typically drawn at less than full intensity. As with point sizes, a particular OpenGL implementation)Tj
T*
(might limit the width of nonantialiased lines to its maximum antialiased line width, rounded to the)Tj
T*
(nearest integer value. You can obtain this floating-point value by using GL_LINE_WIDTH_RANGE)Tj
T*
(with )Tj
/F15 1 Tf
2 0 TD
(glGetFloatv\(\))Tj
/F11 1 Tf
5.5 0 TD
(.)Tj
/F27 1 Tf
-7.5 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Keep in mind that by default lines are 1 pixel wide, so they appear wider on lower-resolution)Tj
-2.8 -1.4 TD
(screens. For computer displays, this isn't typically an issue, but if you're using OpenGL to render to a)Tj
T*
(high-resolution plotter, 1-pixel lines might be nearly invisible. To obtain resolution-independent line)Tj
0 -1.5 TD
(widths, you need to take into account the physical dimensions of pixels.)Tj
/F27 1 Tf
8 -2.1 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(With nonantialiased wide lines, the line width isn't measured perpendicular to the line. Instead, it's)Tj
0 -1.5 TD
(measured in the )Tj
/F15 1 Tf
6.6 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( direction if the absolute value of the slope is less than 1.0; otherwise, it's measured in)Tj
-7 -1.5 TD
(the )Tj
/F15 1 Tf
1.5 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( direction. The rendering of an antialiased line is exactly equivalent to the rendering of a filled)Tj
-1.9 -1.5 TD
(rectangle of the given width, centered on the exact line.)Tj
/F27 1 Tf
0 -3 TD
(Stippled Lines)Tj
/F11 1 Tf
0 -2.2 TD
(To make stippled \(dotted or dashed\) lines, you use the command )Tj
/F15 1 Tf
26.1 0 TD
(glLineStipple\(\))Tj
/F11 1 Tf
6 0 TD
( to define the )Tj
/F13 1 Tf
5.5 0 TD
(stipple)Tj
/F11 1 Tf
-37.6 -1.5 TD
(pattern, and then you enable line stippling with )Tj
/F15 1 Tf
19.1 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
(.)Tj
/F7 1 Tf
-23.4 -2 TD
(glLineStipple\(1, 0x3F07\);)Tj
0 -1.5 TD
(glEnable\(GL_LINE_STIPPLE\);)Tj
/F15 1 Tf
0 -2.2 TD
0.028 Tw
[(void glLineStipple)35(\(GLint )45(factor)-11(, )28(GLushort )13(pattern)-11(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Sets the current stippling pattern for lines. The )-25(pattern)-11( argument is a 16-bit series of 0s and 1s, and)]TJ
T*
(it's repeated as necessary to stipple a given line. A 1 indicates that drawing occurs, and 0 that it)Tj
T*
(does not, on a pixel-by-pixel basis, beginning with the low-order bit of the pattern. The pattern can)Tj
T*
[(be stretched out by using )50(factor)-11(, which multiplies each subseries of consecutive 1s and 0s. Thus, if)]TJ
T*
[(three consecutive 1s appear in the pattern, they're stretched to six if )27(factor)-11( is 2. )-33(factor)-11( is clamped to)]TJ
T*
[(lie between 1 and 255. Line stippling must be enabled by passing GL_LINE_STIPPLE to )10(glEnable\(\))-23(;)]TJ
T*
[(it's disabled by passing the same argument to )-43(glDisable\(\))56(.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(With the preceding example and the pattern 0x3F07 \(which translates to 0011111100000111 in binary\), a)Tj
0 -1.5 TD
(line would be drawn with 3 pixels on, then 5 off, 6 on, and 2 off. \(If this seems backward, remember that)Tj
T*
(the low-order bit is used first.\) If )Tj
/F15 1 Tf
13.3 0 TD
(factor)Tj
/F11 1 Tf
2.4 0 TD
( had been 2, the pattern would have been elongated: 6 pixels on,)Tj
-15.7 -1.5 TD
[(10 off, 12 on, and 4 off. )-23(Figure 2-8)225( shows lines drawn with different patterns and repeat factors. If you)]TJ
T*
(don't enable line stippling, drawing proceeds as if )Tj
/F15 1 Tf
20.2 0 TD
(pattern)Tj
/F11 1 Tf
2.9 0 TD
( were 0xFFFF and )Tj
/F15 1 Tf
7.6 0 TD
(factor)Tj
/F11 1 Tf
2.4 0 TD
( 1. \(Use )Tj
/F15 1 Tf
3.4 0 TD
(glDisable\(\))Tj
/F11 1 Tf
-36.5 -1.5 TD
(with GL_LINE_STIPPLE to disable stippling.\) Note that stippling can be used in combination with wide)Tj
T*
(lines to produce wide stippled lines.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 19)Tj
ET
endstream
endobj
167 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
168 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im11
/Width 388
/Height 140
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.10)
>>
stream
endstream
endobj
169 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im12
/Width 379
/Height 138
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.11)
>>
stream
endstream
endobj
171 0 obj
<<
/Length 2552
>>
stream
/GS1 gs
q
388 0 0 140 124 580 cm
/Im11 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 567.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-8 )Tj
/F11 1 Tf
5.1 0 TD
(Stippled Lines)Tj
-5.1 -2.1 TD
(One way to think of the stippling is that as the line is being drawn, the pattern is shifted by 1 bit each)Tj
0 -1.5 TD
(time a pixel is drawn \(or )Tj
/F15 1 Tf
10.1 0 TD
(factor)Tj
/F11 1 Tf
2.3 0 TD
( pixels are drawn, if )Tj
/F15 1 Tf
8.3 0 TD
(factor)Tj
/F11 1 Tf
2.4 0 TD
( isn't 1\). When a series of connected line)Tj
-23.1 -1.5 TD
(segments is drawn between a single )Tj
/F15 1 Tf
14.6 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
(, the pattern continues to shift as one segment)Tj
-23.3 -1.5 TD
(turns into the next. This way, a stippling pattern continues across a series of connected line segments.)Tj
0 -1.6 TD
(When )Tj
/F15 1 Tf
2.6 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( is executed, the pattern is reset, and)Tj
/F33 1 Tf
14.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(if more lines are drawn before stippling is)Tj
-21.2 -1.7 TD
(disabled)Tj
/F33 1 Tf
3.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the stippling restarts at the beginning of the pattern. If you're drawing lines with GL_LINES,)Tj
-4.3 -1.6 TD
(the pattern resets for each independent line.)Tj
0 -2.1 TD
(Example 2-5)Tj
5.1 0 TD
( illustrates the results of drawing with a couple of different stipple patterns and line widths.)Tj
-5.1 -1.5 TD
(It also illustrates what happens if the lines are drawn as a series of individual segments instead of a single)Tj
T*
[(connected line strip. The results of running the program appear in Figure 2-9)225(.)]TJ
ET
Q
q
379 0 0 138 124 249.26 cm
/Im12 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 237.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-9 )Tj
/F11 1 Tf
5.1 0 TD
(Wide Stippled Lines)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 2-5 )Tj
/F11 1 Tf
6.1 0 TD
(Line Stipple Patterns: lines.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glut.h>)Tj
0 -3 TD
(#define drawOneLine\(x1,y1,x2,y2\)  glBegin\(GL_LINES\);  \\)Tj
0 -1.5 TD
(   glVertex2f \(\(x1\),\(y1\)\); glVertex2f \(\(x2\),\(y2\)\); glEnd\(\);)Tj
0 -3 TD
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 20)Tj
ET
endstream
endobj
172 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im11 168 0 R
/Im12 169 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
174 0 obj
<<
/Length 2180
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glShadeModel \(GL_FLAT\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i;)Tj
0 -3 TD
(   glClear \(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(/* select white for all lines  */)Tj
T*
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
0 -3 TD
(/* in 1st row, 3 lines, each with a different stipple  */)Tj
0 -1.5 TD
(   glEnable \(GL_LINE_STIPPLE\);)Tj
T*
(   )Tj
T*
(   glLineStipple \(1, 0x0101\);  /*  dotted  */)Tj
T*
(   drawOneLine \(50.0, 125.0, 150.0, 125.0\);)Tj
T*
(   glLineStipple \(1, 0x00FF\);  /*  dashed  */)Tj
T*
(   drawOneLine \(150.0, 125.0, 250.0, 125.0\);)Tj
T*
(   glLineStipple \(1, 0x1C47\);  /*  dash/dot/dash  */)Tj
T*
(   drawOneLine \(250.0, 125.0, 350.0, 125.0\);)Tj
T*
(/* in 2nd row, 3 wide lines, each with different stipple */)Tj
T*
(   glLineWidth \(5.0\);)Tj
T*
(   glLineStipple \(1, 0x0101\);  /*  dotted  */)Tj
T*
(   drawOneLine \(50.0, 100.0, 150.0, 100.0\);)Tj
T*
(   glLineStipple \(1, 0x00FF\);  /*  dashed  */)Tj
T*
(   drawOneLine \(150.0, 100.0, 250.0, 100.0\);)Tj
T*
(   glLineStipple \(1, 0x1C47\);  /*  dash/dot/dash  */)Tj
T*
(   drawOneLine \(250.0, 100.0, 350.0, 100.0\);)Tj
T*
(   glLineWidth \(1.0\);)Tj
0 -3 TD
(/* in 3rd row, 6 lines, with dash/dot/dash stipple  */)Tj
0 -1.5 TD
(/* as part of a single connected line strip         */)Tj
T*
(   glLineStipple \(1, 0x1C47\);  /*  dash/dot/dash  */)Tj
T*
(   glBegin \(GL_LINE_STRIP\);)Tj
T*
(   for \(i = 0; i < 7; i++\))Tj
T*
(      glVertex2f \(50.0 + \(\(GLfloat\) i * 50.0\), 75.0\);)Tj
T*
(   glEnd \(\);)Tj
0 -3 TD
(/* in 4th row, 6 independent lines with same stipple  */)Tj
0 -1.5 TD
(   for \(i = 0; i < 6; i++\) {)Tj
T*
(      drawOneLine \(50.0 + \(\(GLfloat\) i * 50.0\), 50.0,)Tj
T*
(         50.0 + \(\(GLfloat\)\(i+1\) * 50.0\), 50.0\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 21)Tj
ET
endstream
endobj
175 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
177 0 obj
<<
/Length 2585
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   })Tj
0 -3 TD
(/* in 5th row, 1 line, with dash/dot/dash stipple    */)Tj
0 -1.5 TD
(/* and a stipple repeat factor of 5                  */)Tj
T*
(   glLineStipple \(5, 0x1C47\);  /*  dash/dot/dash  */)Tj
T*
(   drawOneLine \(50.0, 25.0, 350.0, 25.0\);)Tj
0 -3 TD
(   glDisable \(GL_LINE_STIPPLE\);)Tj
0 -1.5 TD
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   gluOrtho2D \(0.0, \(GLdouble\) w, 0.0, \(GLdouble\) h\);)Tj
T*
(})Tj
T*
(int main\(int argc, char** argv\))Tj
T*
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(400, 150\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 233.000 Tm
(Polygon Details)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 211.000 Tm
(Polygons are typically drawn by filling in all the pixels enclosed within the boundary, but you can also)Tj
T*
(draw them as outlined polygons or simply as points at the vertices. A filled polygon might be solidly)Tj
T*
(filled or stippled with a certain pattern. Although the exact details are omitted here, filled polygons are)Tj
T*
(drawn in such a way that if adjacent polygons share an edge or vertex, the pixels making up the edge or)Tj
0 -1.6 TD
(vertex are drawn exactly once)Tj
/F33 1 Tf
12 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(they're included in only one of the polygons. This is done so that)Tj
-13 -1.6 TD
(partially transparent polygons don't have their edges drawn twice, which would make those edges appear)Tj
0 -1.5 TD
(darker \(or brighter, depending on what color you're drawing with\). Note that it might result in narrow)Tj
T*
(polygons having no filled pixels in one or more rows or columns of pixels. Antialiasing polygons is more)Tj
T*
[(complicated than for points and lines. \(See )33("Antialiasing" in Chapter 6 for details.\))]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 22)Tj
ET
endstream
endobj
178 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
181 0 obj
<<
/Length 4616
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Polygons as Points, Outlines, or Solids)Tj
/F11 1 Tf
0 -2.3 TD
(A polygon has two sides)Tj
/F33 1 Tf
9.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(front and back)Tj
/F33 1 Tf
5.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(and might be rendered differently depending on which side is)Tj
-17.6 -1.5 TD
(facing the viewer. This allows you to have cutaway views of solid objects in which there is an obvious)Tj
T*
(distinction between the parts that are inside and those that are outside. By default, both front and back)Tj
T*
(faces are drawn in the same way. To change this, or to draw only outlines or vertices, use)Tj
/F15 1 Tf
T*
(glPolygonMode\(\))Tj
/F11 1 Tf
7.1 0 TD
(.)Tj
/F15 1 Tf
-7.1 -2.1 TD
0.028 Tw
[(void glPolygonMode)-11(\(GLenum )55(face)-34(, )28(GLenum )122(mode)-34(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Controls the drawing mode for a polygon's front and back faces. The parameter )-8(face)-34( can be)]TJ
T*
[(GL_FRONT_AND_BACK, GL_FRONT, or GL_BACK; mode)-34( can be GL_POINT, GL_LINE, or)]TJ
T*
(GL_FILL to indicate whether the polygon should be drawn as points, outlined, or filled. By default,)Tj
T*
(both the front and back faces are drawn filled.)Tj
/F11 1 Tf
-1.8 -2.2 TD
(For example, you can have the )Tj
/F13 1 Tf
12.5 0 TD
(front faces)Tj
/F11 1 Tf
4.6 0 TD
( filled and the )Tj
/F13 1 Tf
5.7 0 TD
(back faces)Tj
/F11 1 Tf
4.4 0 TD
( outlined with two calls to this)Tj
-27.2 -1.5 TD
(routine:)Tj
/F7 1 Tf
0 -2 TD
(glPolygonMode\(GL_FRONT, GL_FILL\);)Tj
0 -1.5 TD
(glPolygonMode\(GL_BACK, GL_LINE\);)Tj
/F27 1 Tf
0 -3.1 TD
(Reversing and Culling Polygon Faces)Tj
/F11 1 Tf
0 -2.1 TD
(By convention, polygons whose vertices appear in counterclockwise order on the screen are called)Tj
0 -1.6 TD
(front-facing. You can construct the surface of any "reasonable" solid)Tj
/F33 1 Tf
27.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(a mathematician would call such a)Tj
-28.5 -1.6 TD
(surface an orientable manifold \(spheres, donuts, and teapots are orientable; Klein bottles and M\366bius strips)Tj
T*
(aren't\))Tj
/F33 1 Tf
2.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(from polygons of consistent orientation. In other words, you can use all clockwise polygons, or)Tj
-3.7 -1.5 TD
(all counterclockwise polygons. \(This is essentially the mathematical definition of )Tj
/F15 1 Tf
32.7 0 TD
(orientable)Tj
/F11 1 Tf
4.2 0 TD
(.\))Tj
-36.9 -2.1 TD
(Suppose you've consistently described a model of an orientable surface but that you happen to have the)Tj
0 -1.5 TD
(clockwise orientation on the outside. You can swap what OpenGL considers the back face by using the)Tj
T*
(function )Tj
/F15 1 Tf
3.6 0 TD
(glFrontFace\(\))Tj
/F11 1 Tf
5.7 0 TD
(, supplying the desired orientation for front-facing polygons.)Tj
/F15 1 Tf
-9.3 -2.1 TD
0.028 Tw
[(void glFrontFace)56(\(GLenum )-45(mode)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Controls how front-facing polygons are determined. By default, )Tj
25.7 0 TD
[(mode)-34( is GL_CCW, which)]TJ
-25.7 -1.5 TD
(corresponds to a counterclockwise orientation of the ordered vertices of a projected polygon in)Tj
T*
[(window coordinates. If )46(mode)-34( is GL_CW, faces with a clockwise orientation are considered)]TJ
T*
(front-facing.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(In a completely enclosed surface constructed from opaque polygons with a consistent orientation, none of)Tj
0 -1.7 TD
(the back-facing polygons are ever visible)Tj
/F33 1 Tf
16.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(they're always obscured by the front-facing polygons. If you)Tj
-17.5 -1.6 TD
(are outside this surface, you might enable )Tj
/F13 1 Tf
16.9 0 TD
(culling)Tj
/F11 1 Tf
2.9 0 TD
( to discard polygons that OpenGL determines are)Tj
-19.8 -1.5 TD
(back-facing. Similarly, if you are inside the object, only back-facing polygons are visible. To instruct)Tj
T*
(OpenGL to discard front- or back-facing polygons, use the command )Tj
/F15 1 Tf
27.9 0 TD
(glCullFace\(\))Tj
/F11 1 Tf
5.2 0 TD
( and enable culling)Tj
-33.1 -1.5 TD
(with )Tj
/F15 1 Tf
2 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
(.)Tj
/F15 1 Tf
-6.3 -2.1 TD
0.028 Tw
[(void glCullFace\(GLenum )55(mode)-34(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Indicates which polygons should be discarded \(culled\) before they're converted to screen)Tj
T*
(coordinates. The mode is either GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK to indicate)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 23)Tj
ET
endstream
endobj
182 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
183 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im13
/Width 160
/Height 72
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.12)
>>
stream
endstream
endobj
184 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im14
/Width 142
/Height 34
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.13)
>>
stream
endstream
endobj
186 0 obj
<<
/Length 4176
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(front-facing, back-facing, or all polygons. To take effect, culling must be enabled using )Tj
35.1 0 TD
(glEnable\(\))Tj
-35.1 -1.5 TD
[(with GL_CULL_FACE; it can be disabled with )43(glDisable\(\))-44( and the same argument.)]TJ
/F27 1 Tf
6.2 -2.1 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(In more technical terms, the decision of whether a face of a polygon is front- or back-facing depends on)Tj
0 -1.5 TD
(the sign of the polygon's area computed in window coordinates. One way to compute this area is)Tj
ET
Q
/GS1 gs
q
160 0 0 72 124 549.35 cm
/Im13 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 534.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(where )Tj
/F15 1 Tf
2.7 0 TD
0.000 Tw
(x)Tj
/F11 1 Tf
0.4 -0.2 TD
(i)Tj
0.3 0.2 TD
( and )Tj
/F15 1 Tf
2 0 TD
(y)Tj
/F11 1 Tf
0.4 -0.2 TD
(i)Tj
0.3 0.2 TD
( are the )Tj
/F15 1 Tf
3.2 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( window coordinates of the )Tj
/F15 1 Tf
11.1 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
(th vertex of the )Tj
/F15 1 Tf
6.4 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(-vertex polygon and)Tj
ET
Q
q
142 0 0 34 124 484.1901 cm
/Im14 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 465.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Assuming that GL_CCW has been specified, if )Tj
/F15 1 Tf
19.1 0 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
(>0, the polygon corresponding to that vertex is)Tj
-19.6 -1.5 TD
(considered to be front-facing; otherwise, it's back-facing. If GL_CW is specified and if )Tj
/F15 1 Tf
35.2 0 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
(<0, then the)Tj
-35.7 -1.5 TD
(corresponding polygon is front-facing; otherwise, it's back-facing.)Tj
/F27 1 Tf
8 -2.1 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
0.050 Tw
[(Modify Example )50(2-5)]TJ
8.4 0 TD
0.000 Tw
( by adding some filled polygons. Experiment with different colors. Try different)Tj
-8.4 -1.5 TD
(polygon modes. Also enable culling to see its effect.)Tj
/F27 1 Tf
0 -3 TD
(Stippling Polygons)Tj
/F11 1 Tf
0 -2.1 TD
(By default, filled polygons are drawn with a solid pattern. They can also be filled with a 32-bit by 32-bit)Tj
/F13 1 Tf
0 -1.6 TD
(window-aligned)Tj
/F11 1 Tf
6.8 0 TD
( stipple pattern, which you specify with )Tj
/F15 1 Tf
16 0 TD
(glPolygonStipple\(\))Tj
/F11 1 Tf
7.6 0 TD
(.)Tj
/F15 1 Tf
-30.4 -2.1 TD
[(void )-28(glPolygonStipple)-10(\(const GLubyte *)89(mask)-45(\);)]TJ
1.8 -1.6 TD
[(Defines the current stipple pattern for filled polygons. The argument mask)55( is a pointer to a 32)]TJ
/F33 1 Tf
37.6 0 TD
(\264)Tj
/F15 1 Tf
0.5 0 TD
(32)Tj
-38.1 -1.6 TD
(bitmap that's interpreted as a mask of 0s and 1s. Where a 1 appears, the corresponding pixel in the)Tj
0 -1.5 TD
[(polygon is drawn, and where a 0 appears, nothing is drawn. )-7(Figure 2-10)]TJ
29.2 0 TD
( shows how a stipple)Tj
-29.2 -1.5 TD
[(pattern is constructed from the characters in )40(mask)-45(. Polygon stippling is enabled and disabled by)]TJ
T*
[(using )17(glEnable\(\))-23( and glDisable\(\))56( with GL_POLYGON_STIPPLE as the argument. The)]TJ
T*
[(interpretation of the )7(mask)-45( data is affected by the )78(glPixelStore*\(\))11( GL_UNPACK* modes. \(See)]TJ
T*
("Controlling Pixel-Storage Modes" in Chapter 8)Tj
19.5 0 TD
(.\))Tj
/F11 1 Tf
-21.3 -2.1 TD
(In addition to defining the current polygon stippling pattern, you must enable stippling:)Tj
/F7 1 Tf
0 -2 TD
(glEnable\(GL_POLYGON_STIPPLE\);)Tj
/F11 1 Tf
0 -2.2 TD
(Use )Tj
/F15 1 Tf
1.8 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.6 0 TD
( with the same argument to disable polygon stippling.)Tj
-6.4 -2.1 TD
[(Figure 2-11)226( shows the results of polygons drawn unstippled and then with two different stippling)]TJ
0 -1.5 TD
[(patterns. The program is shown in )17(Example 2-6)170(. The reversal of white to black \(from )48(Figure 2-10)226( to)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 24)Tj
ET
endstream
endobj
187 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im13 183 0 R
/Im14 184 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
189 0 obj
<<
/Length 519
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(Figure 2-11)226(\) occurs because the program draws in white over a black background, using the pattern in)]TJ
0 -1.5 TD
[(Figure 2-10)226( as a stencil.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 25)Tj
ET
endstream
endobj
190 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
191 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im15
/Width 473
/Height 689
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.14)
>>
stream
endstream
endobj
193 0 obj
<<
/Length 465
>>
stream
/GS1 gs
q
423 0 0 616 124 104 cm
/Im15 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 91.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-10 )Tj
/F11 1 Tf
5.6 0 TD
(Constructing a Polygon Stipple Pattern)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 26)Tj
ET
endstream
endobj
194 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im15 191 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
195 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im16
/Width 316
/Height 120
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.15)
>>
stream
endstream
endobj
197 0 obj
<<
/Length 2324
>>
stream
/GS1 gs
q
316 0 0 120 124 600 cm
/Im16 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 587.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-11 )Tj
/F11 1 Tf
5.6 0 TD
(Stippled Polygons)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 2-6 )Tj
/F11 1 Tf
6.1 0 TD
(Polygon Stipple Patterns: polys.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glut.h>)Tj
T*
(void display\(void\))Tj
T*
({)Tj
T*
(   GLubyte fly[] = {)Tj
T*
(      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,)Tj
T*
(      0x03, 0x80, 0x01, 0xC0, 0x06, 0xC0, 0x03, 0x60, )Tj
T*
(      0x04, 0x60, 0x06, 0x20, 0x04, 0x30, 0x0C, 0x20, )Tj
T*
(      0x04, 0x18, 0x18, 0x20, 0x04, 0x0C, 0x30, 0x20,)Tj
T*
(      0x04, 0x06, 0x60, 0x20, 0x44, 0x03, 0xC0, 0x22, )Tj
T*
(      0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22, )Tj
T*
(      0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,)Tj
T*
(      0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22, )Tj
T*
(      0x66, 0x01, 0x80, 0x66, 0x33, 0x01, 0x80, 0xCC, )Tj
T*
(      0x19, 0x81, 0x81, 0x98, 0x0C, 0xC1, 0x83, 0x30,)Tj
T*
(      0x07, 0xe1, 0x87, 0xe0, 0x03, 0x3f, 0xfc, 0xc0, )Tj
T*
(      0x03, 0x31, 0x8c, 0xc0, 0x03, 0x33, 0xcc, 0xc0, )Tj
T*
(      0x06, 0x64, 0x26, 0x60, 0x0c, 0xcc, 0x33, 0x30,)Tj
T*
(      0x18, 0xcc, 0x33, 0x18, 0x10, 0xc4, 0x23, 0x08, )Tj
T*
(      0x10, 0x63, 0xC6, 0x08, 0x10, 0x30, 0x0c, 0x08, )Tj
T*
(      0x10, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x08};)Tj
T*
(   GLubyte halftone[] = {)Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,)Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,)Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,)Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 27)Tj
ET
endstream
endobj
198 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im16 195 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
200 0 obj
<<
/Length 1965
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
0 -1.5 TD
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,)Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, )Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,)Tj
T*
(      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55};)Tj
0 -3 TD
(   glClear \(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
0 -3 TD
(/*  draw one solid, unstippled rectangle,       */      )Tj
0 -1.5 TD
(/*  then two stippled rectangles                */)Tj
T*
(   glRectf \(25.0, 25.0, 125.0, 125.0\);)Tj
T*
(   glEnable \(GL_POLYGON_STIPPLE\);)Tj
T*
(   glPolygonStipple \(fly\);)Tj
T*
(   glRectf \(125.0, 25.0, 225.0, 125.0\);)Tj
T*
(   glPolygonStipple \(halftone\);)Tj
T*
(   glRectf \(225.0, 25.0, 325.0, 125.0\);)Tj
T*
(   glDisable \(GL_POLYGON_STIPPLE\);)Tj
0 -3 TD
(   glFlush \(\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void init \(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel \(GL_FLAT\);    )Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   gluOrtho2D \(0.0, \(GLdouble\) w, 0.0, \(GLdouble\) h\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(350, 150\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 28)Tj
ET
endstream
endobj
201 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
202 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im17
/Width 172
/Height 104
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.16)
>>
stream
endstream
endobj
204 0 obj
<<
/Length 3532
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   init \(\);)Tj
0 -1.5 TD
(   glutDisplayFunc\(display\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;  )Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(You might want to use display lists to store polygon stipple patterns to maximize efficiency. \(See)Tj
0 -1.5 TD
("Display-List Design Philosophy" in Chapter 7)Tj
18.8 0 TD
(.\))Tj
/F27 1 Tf
-18.8 -3 TD
(Marking Polygon Boundary Edges)Tj
8 -2.2 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(OpenGL can render only convex polygons, but many nonconvex polygons arise in practice. To draw)Tj
0 -1.6 TD
(these nonconvex polygons, you typically subdivide them into convex polygons)Tj
/F33 1 Tf
31.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(usually triangles, as)Tj
-32.6 -1.7 TD
[(shown in )-11(Figure 2-12)]TJ
/F33 1 Tf
8.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(and then draw the triangles. Unfortunately, if you decompose a general polygon)Tj
-9.6 -1.6 TD
(into triangles and draw the triangles, you can't really use )Tj
/F15 1 Tf
23 0 TD
(glPolygonMode\(\))Tj
/F11 1 Tf
7 0 TD
( to draw the polygon's outline,)Tj
-30 -1.5 TD
(since you get all the triangle outlines inside it. To solve this problem, you can tell OpenGL whether a)Tj
T*
(particular vertex precedes a boundary edge; OpenGL keeps track of this information by passing along)Tj
T*
(with each vertex a bit indicating whether that vertex is followed by a boundary edge. Then, when a)Tj
T*
[(polygon is drawn in GL_LINE mode, the nonboundary edges aren't drawn. In Figure 2-12)226(, the dashed)]TJ
T*
(lines represent added edges.)Tj
ET
Q
/GS1 gs
q
172 0 0 104 124 285.97 cm
/Im17 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 273.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-12 )Tj
/F11 1 Tf
5.6 0 TD
(Subdividing a Nonconvex Polygon)Tj
-5.6 -2.1 TD
(By default, all vertices are marked as preceding a boundary edge, but you can manually control the)Tj
0 -1.5 TD
(setting of the )Tj
/F13 1 Tf
5.5 0 TD
(edge flag)Tj
/F11 1 Tf
3.8 0 TD
( with the command )Tj
/F15 1 Tf
7.9 0 TD
(glEdgeFlag*\(\))Tj
/F11 1 Tf
5.9 0 TD
(. This command is used between )Tj
/F15 1 Tf
13.3 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and)Tj
/F15 1 Tf
-40.2 -1.5 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( pairs, and it affects all the vertices specified after it until the next )Tj
/F15 1 Tf
26.4 0 TD
(glEdgeFlag\(\))Tj
/F11 1 Tf
5.4 0 TD
( call is made. It)Tj
-34.9 -1.5 TD
(applies only to vertices specified for polygons, triangles, and quads, not to those specified for strips of)Tj
T*
(triangles or quads.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glEdgeFlag)23(\(GLboolean )12(flag)56(\);)]TJ
0 -1.1 TD
0.000 Tw
[(void )-28(glEdgeFlagv)67(\(const GLboolean *)-55(flag)56(\);)]TJ
1.8 -1.5 TD
[(Indicates whether a vertex should be considered as initializing a boundary edge of a polygon. If )41(flag)]TJ
T*
(is GL_TRUE, the edge flag is set to TRUE \(the default\), and any vertices created are considered to)Tj
T*
[(precede boundary edges until this function is called again with )47(flag)-44( being GL_FALSE.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
[(As an example, )44(Example 2-7)170( draws the outline shown in )-22(Figure 2-13)226(.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 29)Tj
ET
endstream
endobj
205 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im17 202 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
206 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im18
/Width 527
/Height 110
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.17)
>>
stream
endstream
endobj
208 0 obj
<<
/Length 3203
>>
stream
/GS1 gs
q
423 0 0 88 124 632 cm
/Im18 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 619.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-13 )Tj
/F11 1 Tf
5.6 0 TD
(Outlined Polygon Drawn Using Edge Flags)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 2-7 )Tj
/F11 1 Tf
6.1 0 TD
(Marking Polygon Boundary Edges)Tj
/F7 1 Tf
-6.1 -2.4 TD
(glPolygonMode\(GL_FRONT_AND_BACK, GL_LINE\);)Tj
0 -1.5 TD
(glBegin\(GL_POLYGON\);)Tj
T*
(    glEdgeFlag\(GL_TRUE\);)Tj
T*
(    glVertex3fv\(V0\);)Tj
T*
(    glEdgeFlag\(GL_FALSE\);)Tj
T*
(    glVertex3fv\(V1\);)Tj
T*
(    glEdgeFlag\(GL_TRUE\);)Tj
T*
(    glVertex3fv\(V2\);)Tj
T*
(glEnd\(\);)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 420.000 Tm
(Normal Vectors)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 398.000 Tm
(A )Tj
/F15 1 Tf
1 0 TD
(normal vector)Tj
/F11 1 Tf
5.6 0 TD
( \(or )Tj
/F13 1 Tf
1.7 0 TD
(normal)Tj
/F11 1 Tf
3.1 0 TD
(, for short\) is a vector that points in a direction that's perpendicular to a)Tj
-11.4 -1.5 TD
(surface. For a flat surface, one perpendicular direction is the same for every point on the surface, but for)Tj
T*
(a general curved surface, the normal direction might be different at each point on the surface. With)Tj
T*
(OpenGL, you can specify a normal for each polygon or for each vertex. Vertices of the same polygon)Tj
T*
(might share the same normal \(for a flat surface\) or have different normals \(for a curved surface\). But you)Tj
T*
(can't assign normals anywhere other than at the vertices.)Tj
0 -2.2 TD
(An object's normal vectors define the orientation of its surface in space)Tj
/F33 1 Tf
28.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in particular, its orientation)Tj
-29.6 -1.6 TD
(relative to light sources. These vectors are used by OpenGL to determine how much light the object)Tj
T*
(receives at its vertices. Lighting)Tj
/F33 1 Tf
12.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(a large topic by itself)Tj
/F33 1 Tf
8.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
[(is the subject of )56(Chapter 5)-84(,)0( and you might want)]TJ
-23.2 -1.6 TD
(to review the following information after you've read that chapter. Normal vectors are discussed briefly)Tj
0 -1.5 TD
(here because you define normal vectors for an object at the same time you define the object's geometry.)Tj
0 -2.1 TD
(You use )Tj
/F15 1 Tf
3.6 0 TD
(glNormal*\(\))Tj
/F11 1 Tf
5 0 TD
( to set the current normal to the value of the argument passed in. Subsequent calls to)Tj
/F15 1 Tf
-8.6 -1.5 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.6 0 TD
( cause the specified vertices to be assigned the current normal. Often, each vertex has a)Tj
-4.6 -1.5 TD
[(different normal, which necessitates a series of alternating calls, as in )-31(Example 2-8)]TJ
33.1 0 TD
(.)Tj
/F27 1 Tf
-33.1 -2.1 TD
(Example 2-8 )Tj
/F11 1 Tf
6.1 0 TD
(Surface Normals at Vertices)Tj
/F7 1 Tf
-6.1 -2.4 TD
(glBegin \(GL_POLYGON\);)Tj
0 -1.5 TD
(   glNormal3fv\(n0\);)Tj
T*
(   glVertex3fv\(v0\);)Tj
T*
(   glNormal3fv\(n1\);)Tj
T*
(   glVertex3fv\(v1\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 30)Tj
ET
endstream
endobj
209 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im18 206 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
210 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im19
/Width 170
/Height 39
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.18)
>>
stream
endstream
endobj
212 0 obj
<<
/Length 4489
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glNormal3fv\(n2\);)Tj
0 -1.5 TD
(   glVertex3fv\(v2\);)Tj
T*
(   glNormal3fv\(n3\);)Tj
T*
(   glVertex3fv\(v3\);)Tj
T*
(glEnd\(\);)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glNormal3)34({bsidf}\()-22(TYPE)34(nx)-56(, TYPE)34(ny)44(, TYPE)-66(nz\);)]TJ
0 -1.1 TD
0.028 Tw
[(void glNormal3)34({bsidf})-55(v)44(\(const )22(TYPE)34( )28(*v\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Sets the current normal vector as specified by the arguments. The nonvector version \(without the v)44(\))]TJ
T*
[(takes three arguments, which specify an \()-17(nx, ny, nz)-23(\) vector that's taken to be the normal.)]TJ
T*
[(Alternatively, you can use the vector version of this function \(with the )-16(v)44(\))0( and supply a single array of)]TJ
T*
[(three elements to specify the desired normal. The )16(b, s)-11(,)0( and )-50(i)78( versions scale their parameter values)]TJ
T*
(linearly to the range [-1.0,1.0].)Tj
/F11 1 Tf
-1.8 -2.2 TD
(There's no magic to finding the normals for an object)Tj
/F33 1 Tf
21.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(most likely, you have to perform some)Tj
-22.4 -1.7 TD
(calculations that might include taking derivatives)Tj
/F33 1 Tf
19.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(but there are several techniques and tricks you can)Tj
-20.7 -1.6 TD
[(use to achieve certain effects. )-48(Appendix E)6( explains how to find normal vectors for surfaces. If you)]TJ
0 -1.5 TD
(already know how to do this, if you can count on always being supplied with normal vectors, or if you)Tj
T*
(don't want to use the lighting facility provided by OpenGL lighting facility, you don't need to read this)Tj
T*
(appendix.)Tj
0 -2.1 TD
(Note that at a given point on a surface, two vectors are perpendicular to the surface, and they point in)Tj
0 -1.5 TD
(opposite directions. By convention, the normal is the one that points to the outside of the surface being)Tj
T*
(modeled. \(If you get inside and outside reversed in your model, just change every normal vector from \()Tj
/F15 1 Tf
41.2 0 TD
(x,)Tj
-41.2 -1.6 TD
(y, z)Tj
/F11 1 Tf
1.3 0 TD
(\) to \(-)Tj
/F33 1 Tf
2.3 0 TD
(x)Tj
/F15 1 Tf
0.5 0 TD
(, )Tj
/F11 1 Tf
0.5 0 TD
(-)Tj
/F15 1 Tf
0.3 0 TD
(y, )Tj
/F11 1 Tf
1 0 TD
(-)Tj
/F15 1 Tf
0.3 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(\)\).)Tj
-6.6 -2.2 TD
(Also, keep in mind that since normal vectors indicate direction only, their length is mostly irrelevant.)Tj
0 -1.5 TD
(You can specify normals of any length, but eventually they have to be converted to having a length of 1)Tj
T*
(before lighting calculations are performed. \(A vector that has a length of 1 is said to be of unit length, or)Tj
/F13 1 Tf
T*
(normalized)Tj
/F11 1 Tf
4.8 0 TD
(.\) In general, you should supply normalized normal vectors. To make a normal vector of unit)Tj
-4.8 -1.5 TD
(length, divide each of its )Tj
/F15 1 Tf
10.1 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( components by the length of the normal:)Tj
ET
Q
/GS1 gs
q
170 0 0 39 124 242.47 cm
/Im19 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 224.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Normal vectors remain normalized as long as your model transformations include only rotations and)Tj
0 -1.5 TD
[(translations. \(See )39(Chapter 3)-84( for a discussion of transformations.\) If you perform irregular transformations)]TJ
T*
(\(such as scaling or multiplying by a shear matrix\), or if you specify nonunit-length normals, then you)Tj
T*
(should have OpenGL automatically normalize your normal vectors after the transformations. To do this,)Tj
T*
(call )Tj
/F15 1 Tf
1.7 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( with GL_NORMALIZE as its argument. By default, automatic normalization is disabled.)Tj
-6 -1.5 TD
(Note that automatic normalization typically requires additional calculations that might reduce the)Tj
T*
(performance of your application.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 100.000 Tm
(Vertex Arrays)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 78.000 Tm
(You may have noticed that OpenGL requires many function calls to render geometric primitives.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 31)Tj
ET
endstream
endobj
213 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im19 210 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
214 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im20
/Width 100
/Height 103
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.19)
>>
stream
endstream
endobj
216 0 obj
<<
/Length 3870
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Drawing a 20-sided polygon requires 22 function calls: one call to )Tj
/F15 1 Tf
26.7 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
(, one call for each of the)Tj
-30.5 -1.5 TD
(vertices, and a final call to )Tj
/F15 1 Tf
10.8 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
(. In the two previous code examples, additional information \(polygon)Tj
-13.9 -1.5 TD
(boundary edge flags or surface normals\) added function calls for each vertex. This can quickly double or)Tj
T*
(triple the number of function calls required for one geometric object. For some systems, function calls)Tj
T*
(have a great deal of overhead and can hinder performance.)Tj
0 -2.1 TD
(An additional problem is the redundant processing of vertices that are shared between adjacent polygons.)Tj
0 -1.5 TD
[(For example, the cube in )-34(Figure 2-14)226( has six faces and eight shared vertices. Unfortunately, using the)]TJ
T*
(standard method of describing this object, each vertex would have to be specified three times: once for)Tj
T*
(every face that uses it. So 24 vertices would be processed, even though eight would be enough.)Tj
ET
Q
/GS1 gs
q
100 0 0 103 124 467.82 cm
/Im20 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 455.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-14 )Tj
/F11 1 Tf
5.6 0 TD
(Six Sides; Eight Shared Vertices)Tj
-5.6 -2.1 TD
(OpenGL has vertex array routines that allow you to specify a lot of vertex-related data with just a few)Tj
0 -1.5 TD
(arrays and to access that data with equally few function calls. Using vertex array routines, all 20 vertices)Tj
T*
(in a 20-sided polygon could be put into one array and called with one function. If each vertex also had a)Tj
T*
(surface normal, all 20 surface normals could be put into another array and also called with one function.)Tj
0 -2.1 TD
(Arranging data in vertex arrays may increase the performance of your application. Using vertex arrays)Tj
0 -1.5 TD
(reduces the number of function calls, which improves performance. Also, using vertex arrays may allow)Tj
T*
(non-redundant processing of shared vertices. \(Vertex sharing is not supported on all implementations of)Tj
T*
(OpenGL.\))Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Vertex arrays are standard in version 1.1 of OpenGL but were not part of the OpenGL 1.0)Tj
-2.8 -1.4 TD
(specification. With OpenGL 1.0, some vendors have implemented vertex arrays as an extension.)Tj
0 -2.1 TD
(There are three steps to using vertex arrays to render geometry.)Tj
T*
[(1.)-1050(Activate \(enable\) up to six arrays, each to store a different type of data: vertex coordinates, RGBA)]TJ
1.8 -1.5 TD
(colors, color indices, surface normals, texture coordinates, or polygon edge flags.)Tj
-1.8 -2.1 TD
[(2.)-1050(Put data into the array or arrays. The arrays are accessed by the addresses of \(that is, pointers to\))]TJ
1.8 -1.5 TD
(their memory locations. In the client-server model, this data is stored in the client's address space.)Tj
-1.8 -2.1 TD
[(3.)-1050(Draw geometry with the data. OpenGL obtains the data from all activated arrays by dereferencing)]TJ
1.8 -1.5 TD
(the pointers. In the client-server model, the data is transferred to the server's address space. There)Tj
T*
(are three ways to do this:)Tj
0 -2.1 TD
[(1.)-1050(Accessing individual array elements \(randomly hopping around\))]TJ
T*
[(2.)-1050(Creating a list of individual array elements \(methodically hopping around\))]TJ
T*
[(3.)-1050(Processing sequential array elements)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 32)Tj
ET
endstream
endobj
217 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im20 214 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
220 0 obj
<<
/Length 4362
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 142.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The dereferencing method you choose may depend upon the type of problem you encounter.)Tj
-1.8 -2.6 TD
(Interleaved vertex array data is another common method of organization. Instead of having up to six)Tj
0 -1.5 TD
(different arrays, each maintaining a different type of data \(color, surface normal, coordinate, and so on\),)Tj
T*
[(you might have the different types of data mixed into a single array. \(See )-29("Interleaved Arrays")-14( for two)]TJ
T*
(methods of solving this.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 608.000 Tm
(Step 1: Enabling Arrays)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 586.000 Tm
(The first step is to call )Tj
/F15 1 Tf
9.2 0 TD
(glEnableClientState\(\))Tj
/F11 1 Tf
8.7 0 TD
( with an enumerated parameter, which activates the chosen)Tj
-17.9 -1.5 TD
(array. In theory, you may need to call this up to six times to activate the six available arrays. In practice,)Tj
T*
(you'll probably activate only between one to four arrays. For example, it is unlikely that you would)Tj
T*
(activate both GL_COLOR_ARRAY and GL_INDEX_ARRAY, since your program's display mode)Tj
T*
(supports either RGBA mode or color-index mode, but probably not both simultaneously.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glEnableClientState)57(\(GLenum )-45(array)22(\))]TJ
1.8 -1.5 TD
0.000 Tw
(Specifies the array to enable. Symbolic constants GL_VERTEX_ARRAY, GL_COLOR_ARRAY,)Tj
T*
(GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_TEXTURE_COORD_ARRAY, and)Tj
T*
(GL_EDGE_FLAG_ARRAY are acceptable parameters.)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(If you use lighting, you may want to define a surface normal for every vertex. \(See )-15("Normal Vectors.")-18(\))]TJ
0 -1.5 TD
(To use vertex arrays for that case, you activate both the surface normal and vertex coordinate arrays:)Tj
/F7 1 Tf
0 -2 TD
(glEnableClientState\(GL_NORMAL_ARRAY\);)Tj
0 -1.5 TD
(glEnableClientState\(GL_VERTEX_ARRAY\);)Tj
/F11 1 Tf
0 -2.2 TD
(Suppose that you want to turn off lighting at some point and just draw the geometry using a single color.)Tj
0 -1.5 TD
(You want to call )Tj
/F15 1 Tf
6.9 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.5 0 TD
[( to turn off lighting states \(see )-50(Chapter 5)16(\). Now that lighting has been)]TJ
-11.4 -1.5 TD
(deactivated, you also want to stop changing the values of the surface normal state, which is wasted effort.)Tj
T*
(To do that, you call)Tj
/F7 1 Tf
0 -2 TD
(glDisableClientState\(GL_NORMAL_ARRAY\);)Tj
/F15 1 Tf
0 -2.2 TD
0.028 Tw
[(void glDisableClientState)35(\(GLenum )55(array)-78(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Specifies the array to disable. Accepts the same symbolic constants as )-22(glEnableClientState\(\))23(.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(You might be asking yourself why the architects of OpenGL created these new \(and long!\) command)Tj
0 -1.5 TD
(names, )Tj
/F15 1 Tf
3.1 0 TD
(gl*ClientState\(\))Tj
/F11 1 Tf
6.3 0 TD
(. Why can't you just call )Tj
/F15 1 Tf
10.1 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.6 0 TD
(? One reason is that)Tj
/F15 1 Tf
-30.3 -1.5 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.6 0 TD
( can be stored in a display list, but the specification of vertex arrays cannot,)Tj
-10.8 -1.5 TD
(because the data remains on the client's side.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 171.000 Tm
(Step 2: Specifying Data for the Arrays)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 149.000 Tm
(There is a straightforward way by which a single command specifies a single array in the client space.)Tj
0 -1.6 TD
(There are six different routines to specify arrays)Tj
/F33 1 Tf
19.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(one routine for each kind of array. There is also a)Tj
-20.2 -1.6 TD
(command that can specify several client-space arrays at once, all originating from a single interleaved)Tj
0 -1.5 TD
(array.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glVertexPointer)-11(\(GLint)67( size)-50(, GLenum )-6(type)66(, GLsizei )6(stride)-22(,)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 33)Tj
ET
endstream
endobj
221 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
223 0 obj
<<
/Length 4437
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(const GLvoid )12(*pointer)-11(\);)]TJ
1.8 -1.5 TD
[(Specifies where spatial coordinate data can be accessed. )28(pointer)-11( is the memory address of the first)]TJ
T*
[(coordinate of the first vertex in the array. )-38(type)66( specifies the data type \(GL_SHORT, GL_INT,)]TJ
T*
[(GL_FLOAT, or GL_DOUBLE\) of each coordinate in the array. )52(size is the number of coordinates)]TJ
T*
[(per vertex, which must be 2, 3, or 4. )39(stride)-22( is the byte offset between consecutive vertexes. If )-47(stride)78( is)]TJ
T*
(0, the vertices are understood to be tightly packed in the array.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(To access the other five arrays, there are five similar routines:)Tj
/F15 1 Tf
T*
[(void )-28(glColorPointer)13(\(GLint )17(size, GLenum )-6(type)-34(, GLsizei )6(stride)78(,)]TJ
0 -1.1 TD
[(const GLvoid *)12(pointer)-11(\);)]TJ
T*
[(void )-28(glIndexPointer\(GLenum )27(type)-34(, GLsizei )6(stride)78(, const GLvoid *)-88(pointer)89(\);)]TJ
T*
0.028 Tw
[(void glNormalPointer)35(\(GLenum )55(type)-34(, )28(GLsizei )34(stride)-22(,)]TJ
T*
0.000 Tw
[(const GLvoid *)12(pointer)-11(\);)]TJ
T*
[(void )-28(glTexCoordPointer)-21(\(GLint )17(size, GLenum )-6(type)66(, GLsizei )6(stride)-22(,)]TJ
T*
[(const GLvoid *)12(pointer)-11(\);)]TJ
T*
[(void )-28(glEdgeFlagPointer)23(\(GLsizei )39(stride)-22(, const GLvoid *)12(pointer)-11(\);)]TJ
/F11 1 Tf
0 -2.1 TD
(The main differences among the routines are whether size and type are unique or must be specified. For)Tj
0 -1.5 TD
(example, a surface normal always has three components, so it is redundant to specify its size. An edge)Tj
T*
[(flag is always a single Boolean, so neither size nor type needs to be mentioned. )16(Table 2-4)191( displays legal)]TJ
T*
(values for size and data types.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 440.000 m
466.000 440.000 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 432.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Command)-6985(Sizes)-3318(Values for )]TJ
8.000 0.000 1.700 8.000 307.000 432.000 Tm
(type)Tj
8.000 0.000 0.000 8.000 323.000 432.000 Tm
( Argument)Tj
ET
Q
124.000 426.480 m
466.000 426.480 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 418.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(glVertexPointer)-4167(2, 3, 4)-2722(GL_SHORT, GL_INT, GL_FLOAT, GL_DOUBLE)]TJ
0 -1.4444 TD
[(glNormalPointer)-3833(3)-4722(GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT,)]TJ
15.7778 -1.3333 TD
(GL_DOUBLE)Tj
-15.7778 -1.4444 TD
[(glColorPointer)-4610(3, 4)-3722(GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,)]TJ
15.7778 -1.3333 TD
(GL_UNSIGNED_SHORT, GL_INT,)Tj
T*
(GL_UNSIGNED_INT, GL_FLOAT, GL_DOUBLE)Tj
-15.7778 -1.4444 TD
[(glIndexPointer)-4611(1)-4722(GL_UNSIGNED_BYTE, GL_SHORT, GL_INT,)]TJ
15.7778 -1.3333 TD
(GL_FLOAT, GL_DOUBLE)Tj
-15.7778 -1.4444 TD
[(glTexCoordPointer)-2832(1, 2, 3, 4)-1722(GL_SHORT, GL_INT, GL_FLOAT, GL_DOUBLE)]TJ
T*
[(glEdgeFlagPointer)-3054(1)-4722(no type argument \(type of data must be GLboolean\))]TJ
ET
Q
124.000 297.670 m
466.010 297.670 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 281.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 2-4 )Tj
/F11 1 Tf
4.6 0 TD
(Vertex Array Sizes \(Values per Vertex\) and Data Types\(continued\))Tj
-4.6 -2.1 TD
(Example 2-9)Tj
5.1 0 TD
( uses vertex arrays for both RGBA colors and vertex coordinates. RGB floating-point values)Tj
-5.1 -1.5 TD
(and their corresponding \(x, y\) integer coordinates are loaded into the GL_COLOR_ARRAY and)Tj
T*
(GL_VERTEX_ARRAY.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 2-9 )Tj
/F11 1 Tf
6.1 0 TD
(Enabling and Loading Vertex Arrays: varray.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(static GLint vertices[] = {25, 25,)Tj
0 -1.5 TD
(                          100, 325,)Tj
T*
(                          175, 25,)Tj
T*
(                          175, 325,)Tj
T*
(                          250, 25,)Tj
T*
(                          325, 325};)Tj
T*
(static GLfloat colors[] = {1.0, 0.2, 0.2,)Tj
T*
(                          0.2, 0.2, 1.0,)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 34)Tj
ET
endstream
endobj
224 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
226 0 obj
<<
/Length 3359
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(                          0.8, 1.0, 0.2,)Tj
0 -1.5 TD
(                          0.75, 0.75, 0.75,)Tj
T*
(                          0.35, 0.35, 0.35,)Tj
T*
(                          0.5, 0.5, 0.5};)Tj
0 -3 TD
(glEnableClientState \(GL_COLOR_ARRAY\);)Tj
0 -1.5 TD
(glEnableClientState \(GL_VERTEX_ARRAY\);)Tj
0 -3 TD
(glColorPointer \(3, GL_FLOAT, 0, colors\);)Tj
0 -1.5 TD
(glVertexPointer \(2, GL_INT, 0, vertices\);)Tj
/F27 1 Tf
0 -3 TD
(Stride)Tj
/F11 1 Tf
0 -2.1 TD
(With a stride of zero, each type of vertex array \(RGB color, color index, vertex coordinate, and so on\))Tj
0 -1.5 TD
(must be tightly packed. The data in the array must be homogeneous; that is, the data must be all RGB)Tj
T*
(color values, all vertex coordinates, or all some other data similar in some fashion.)Tj
0 -2.1 TD
(Using a stride of other than zero can be useful, especially when dealing with interleaved arrays. In the)Tj
0 -1.5 TD
(following array of GLfloats, there are six vertices. For each vertex, there are three RGB color values,)Tj
T*
(which alternate with the \(x, y, z\) vertex coordinates.)Tj
/F7 1 Tf
0 -2.1 TD
(static GLfloat intertwined[] =)Tj
0 -1.5 TD
(      {1.0, 0.2, 1.0, 100.0, 100.0, 0.0,)Tj
T*
(       1.0, 0.2, 0.2, 0.0, 200.0, 0.0,)Tj
T*
(       1.0, 1.0, 0.2, 100.0, 300.0, 0.0,)Tj
T*
(       0.2, 1.0, 0.2, 200.0, 300.0, 0.0,)Tj
T*
(       0.2, 1.0, 1.0, 300.0, 200.0, 0.0,)Tj
T*
(       0.2, 0.2, 1.0, 200.0, 100.0, 0.0};)Tj
/F11 1 Tf
0 -2.1 TD
(Stride allows a vertex array to access its desired data at regular intervals in the array. For example, to)Tj
0 -1.5 TD
(reference only the color values in the )Tj
/F15 1 Tf
15.1 0 TD
(intertwined)Tj
/F11 1 Tf
4.5 0 TD
( array, the following call starts from the beginning of)Tj
-19.6 -1.5 TD
(the array \(which could also be passed as )Tj
/F15 1 Tf
16.3 0 TD
(&intertwined[0])Tj
/F11 1 Tf
6.6 0 TD
(\) and jumps ahead 6 * )Tj
/F15 1 Tf
9.1 0 TD
(sizeof)Tj
/F11 1 Tf
2.3 0 TD
(\(GLfloat\) bytes,)Tj
-34.3 -1.5 TD
(which is the size of both the color and vertex coordinate values. This jump is enough to get to the)Tj
T*
(beginning of the data for the next vertex.)Tj
/F7 1 Tf
0 -2.1 TD
(glColorPointer \(3, GL_FLOAT, 6 * sizeof\(GLfloat\), intertwined\);)Tj
/F11 1 Tf
T*
(For the vertex coordinate pointer, you need to start from further in the array, at the fourth element of)Tj
/F15 1 Tf
0 -1.5 TD
(intertwined)Tj
/F11 1 Tf
4.6 0 TD
( \(remember that C programmers start counting at zero\).)Tj
/F7 1 Tf
-4.6 -2.1 TD
(glVertexPointer\(3, GL_FLOAT,6*sizeof\(GLfloat\), &intertwined[3]\);)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 146.000 Tm
(Step 3: Dereferencing and Rendering)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 124.000 Tm
(Until the contents of the vertex arrays are dereferenced, the arrays remain on the client side, and their)Tj
0 -1.5 TD
(contents are easily changed. In Step 3, contents of the arrays are obtained, sent down to the server, and)Tj
T*
(then sent down the graphics processing pipeline for rendering.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 35)Tj
ET
endstream
endobj
227 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
229 0 obj
<<
/Length 3774
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(There are three ways to obtain data: from a single array element \(indexed location\), from a sequence of)Tj
0 -1.5 TD
(array elements, and from an ordered list of array elements.)Tj
/F27 1 Tf
0 -3 TD
(Dereference a Single Array Element)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glArrayElement)-11(\(GLint )45(ith)56(\))]TJ
1.8 -1.5 TD
0.000 Tw
[(Obtains the data of one \(the )45(ith)-44(\) vertex for all currently enabled arrays. For the vertex coordinate)]TJ
T*
[(array, the corresponding command would be )6(glVertex)-12([)-11(size][)-22(type)66(])-11(v\(\))10(, where )-6(size is one of [2,3,4],)]TJ
T*
[(and )-50(type)66( is one of [s,i,f,d] for GLshort, GLint, GLfloat, and GLdouble respectively. Both size and)]TJ
T*
[(type were defined by glVertexPointer\(\))-45(. For other enabled arrays, )39(glArrayElement\(\))55( calls)]TJ
T*
[(glEdgeFlagv\(\))33(, glTexCoord)-21([)-11(size][)-22(type)66(])-11(v\(\))10(, glColor)-88([)89(size][)-22(type)-34(])-11(v\(\))10(, glIndex[)-11(type)66(])-11(v\(\))10(, and)]TJ
T*
[(glNormal)34([)-11(type)-34(])-11(v\(\))10(. If the vertex coordinate array is enabled, the )38(glVertex*v\(\) routine is executed)]TJ
T*
(last, after the execution \(if enabled\) of up to five corresponding array values.)Tj
-1.8 -2.1 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7.1 0 TD
( is usually called between )Tj
/F15 1 Tf
10.5 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
(. \(If called outside, )Tj
/F15 1 Tf
7.7 0 TD
(glArrayElement\(\))Tj
/F11 1 Tf
-34.1 -1.5 TD
[(sets the current state for all enabled arrays, except for vertex, which has no current state.\) In )-7(Example)]TJ
T*
(2-10)Tj
1.8 0 TD
(, a triangle is drawn using the third, fourth, and sixth vertices from enabled vertex arrays \(again,)Tj
-1.8 -1.5 TD
(remember that C programmers begin counting array locations with zero\).)Tj
/F27 1 Tf
0 -2.1 TD
(Example 2-10 )Tj
/F11 1 Tf
6.7 0 TD
(Using glArrayElement\(\) to Define Colors and Vertices)Tj
/F7 1 Tf
-6.7 -2.4 TD
(glEnableClientState \(GL_COLOR_ARRAY\);)Tj
0 -1.5 TD
(glEnableClientState \(GL_VERTEX_ARRAY\);)Tj
T*
(glColorPointer \(3, GL_FLOAT, 0, colors\);)Tj
T*
(glVertexPointer \(2, GL_INT, 0, vertices\);)Tj
0 -3 TD
(glBegin\(GL_TRIANGLES\);)Tj
0 -1.5 TD
(glArrayElement \(2\);)Tj
T*
(glArrayElement \(3\);)Tj
T*
(glArrayElement \(5\);)Tj
T*
(glEnd\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(When executed, the latter five lines of code has the same effect as)Tj
/F7 1 Tf
T*
(glBegin\(GL_TRIANGLES\);)Tj
0 -1.5 TD
(glColor3fv\(colors+\(2*3*sizeof\(GLfloat\)\);)Tj
T*
(glVertex3fv\(vertices+\(2*2*sizeof\(GLint\)\);)Tj
T*
(glColor3fv\(colors+\(3*3*sizeof\(GLfloat\)\);)Tj
T*
(glVertex3fv\(vertices+\(3*2*sizeof\(GLint\)\);)Tj
T*
(glColor3fv\(colors+\(5*3*sizeof\(GLfloat\)\);)Tj
T*
(glVertex3fv\(vertices+\(5*2*sizeof\(GLint\)\);)Tj
T*
(glEnd\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(Since )Tj
/F15 1 Tf
2.5 0 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7 0 TD
( is only a single function call per vertex, it may reduce the number of function)Tj
-9.5 -1.5 TD
(calls, which increases overall performance.)Tj
0 -2.1 TD
(Be warned that if the contents of the array are changed between )Tj
/F15 1 Tf
25.7 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
(, there is no)Tj
-34.5 -1.5 TD
(guarantee that you will receive original data or changed data for your requested element. To be safe,)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 36)Tj
ET
endstream
endobj
230 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
231 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im21
/Width 167
/Height 127
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.20)
>>
stream
endstream
endobj
233 0 obj
<<
/Length 3503
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(don't change the contents of any array element which might be accessed until the primitive is completed.)Tj
/F27 1 Tf
0 -3 TD
(Dereference a List of Array Elements)Tj
/F15 1 Tf
0 -2.1 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7.1 0 TD
( is good for randomly "hopping around" your data arrays. A similar routine,)Tj
/F15 1 Tf
-7.1 -1.5 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
(, is good for hopping around your data arrays in a more orderly manner.)Tj
/F15 1 Tf
-7.4 -2.1 TD
[(void )-28(glDrawElements)23(\(GLenum )27(mode)-34(, GLsizei )6(count)22(, GLenum )-6(type)-34(,)]TJ
0 -1.1 TD
[(void *)-28(indices)33(\);)]TJ
1.8 -1.5 TD
[(Defines a sequence of geometric primitives using )16(count)22( number of elements, whose indices are)]TJ
T*
[(stored in the array )23(indices)-67(. type)66( must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT,)]TJ
T*
[(or GL_UNSIGNED_INT, indicating the data type of the )42(indices)-67( array. )72(mode)-34( specifies what kind of)]TJ
T*
[(primitives are constructed and is one of the same values that is accepted by )45(glBegin\(\))-23(; for example,)]TJ
T*
(GL_POLYGON, GL_LINE_LOOP, GL_LINES, GL_POINTS, and so on.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The effect of )Tj
/F15 1 Tf
5.4 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
( is almost the same as this command sequence:)Tj
/F7 1 Tf
-12.8 -2.1 TD
(int i;)Tj
0 -1.5 TD
(glBegin \(mode\);)Tj
T*
(for \(i = 0; i < count; i++\))Tj
T*
(   glArrayElement\(indices[i]\);)Tj
T*
(glEnd\(\);)Tj
/F15 1 Tf
0 -2.1 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
( additionally checks to make sure )Tj
/F15 1 Tf
13.6 0 TD
(mode)Tj
/F11 1 Tf
2.2 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(count)Tj
/F11 1 Tf
2.2 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(type)Tj
/F11 1 Tf
1.6 0 TD
( are valid. Also, unlike the)Tj
-29.7 -1.5 TD
(preceding sequence, executing )Tj
/F15 1 Tf
12.5 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
( leaves several states indeterminate. After execution of)Tj
/F15 1 Tf
-19.9 -1.5 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
(, current RGB color, color index, normal coordinates, texture coordinates, and edge)Tj
-7.4 -1.5 TD
(flag are indeterminate if the corresponding array has been enabled.)Tj
0 -2.1 TD
(With )Tj
/F15 1 Tf
2.3 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.3 0 TD
(, the vertices for each face of the cube can be placed in an array of indices.)Tj
-9.6 -1.5 TD
(Example 2-11)Tj
5.6 0 TD
( shows two ways to use )Tj
/F15 1 Tf
9.7 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
[( to render the cube. )43(Figure 2-15)226( shows the)]TJ
-22.7 -1.5 TD
[(numbering of the vertices used in )11(Example 2-11)]TJ
19.2 0 TD
(.)Tj
ET
Q
/GS1 gs
q
167 0 0 127 124 174.84 cm
/Im21 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 162.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-15 )Tj
/F11 1 Tf
5.6 0 TD
(Cube with Numbered Vertices)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 2-11 )Tj
/F11 1 Tf
6.7 0 TD
(Two Ways to Use glDrawElements\(\))Tj
/F7 1 Tf
-6.7 -2.4 TD
(static GLubyte frontIndices = {4, 5, 6, 7};)Tj
0 -1.5 TD
(static GLubyte rightIndices = {1, 2, 6, 5};)Tj
T*
(static GLubyte bottomIndices = {0, 1, 5, 4};)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 37)Tj
ET
endstream
endobj
234 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im21 231 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
236 0 obj
<<
/Length 3992
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(static GLubyte backIndices = {0, 3, 2, 1};)Tj
0 -1.5 TD
(static GLubyte leftIndices = {0, 4, 7, 3};)Tj
T*
(static GLubyte topIndices = {2, 3, 7, 6};)Tj
0 -3 TD
(glDrawElements\(GL_QUADS, 4, GL_UNSIGNED_BYTE, frontIndices\);)Tj
0 -1.5 TD
(glDrawElements\(GL_QUADS, 4, GL_UNSIGNED_BYTE, rightIndices\);)Tj
T*
(glDrawElements\(GL_QUADS, 4, GL_UNSIGNED_BYTE, bottomIndices\);)Tj
T*
(glDrawElements\(GL_QUADS, 4, GL_UNSIGNED_BYTE, backIndices\);)Tj
T*
(glDrawElements\(GL_QUADS, 4, GL_UNSIGNED_BYTE, leftIndices\);)Tj
T*
(glDrawElements\(GL_QUADS, 4, GL_UNSIGNED_BYTE, topIndices\);)Tj
/F11 1 Tf
0 -2.1 TD
(Or better still, crunch all the indices together:)Tj
/F7 1 Tf
T*
(static GLubyte allIndices = {4, 5, 6, 7, 1, 2, 6, 5, )Tj
0 -1.5 TD
( 0, 1, 5, 4, 0, 3, 2, 1, )Tj
T*
( 0, 4, 7, 3, 2, 3, 7, 6};)Tj
0 -3 TD
(glDrawElements\(GL_QUADS, 24, GL_UNSIGNED_BYTE, allIndices\);)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(It is an error to encapsulate )Tj
/F15 1 Tf
11.1 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
( between a )Tj
/F15 1 Tf
4.6 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
(/)Tj
/F15 1 Tf
0.3 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( pair.)Tj
-33 -2.1 TD
(With both )Tj
/F15 1 Tf
4.3 0 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
(, it is also possible that your OpenGL implementation)Tj
-20.7 -1.5 TD
(caches recently processed vertices, allowing your application to "share" or "reuse" vertices. Take the)Tj
T*
(aforementioned cube, for example, which has six faces \(polygons\) but only eight vertices. Each vertex is)Tj
T*
(used by exactly three faces. Without )Tj
/F15 1 Tf
14.8 0 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7.1 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
(, rendering all six faces)Tj
-30.6 -1.5 TD
(would require processing twenty-four vertices, even though sixteen vertices would be redundant. Your)Tj
T*
(implementation of OpenGL may be able to minimize redundancy and process as few as eight vertices.)Tj
T*
(\(Reuse of vertices may be limited to all vertices within a single )Tj
/F15 1 Tf
25.5 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
( call or, for)Tj
/F15 1 Tf
-32.9 -1.5 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7.1 0 TD
(, within one )Tj
/F15 1 Tf
5 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
(/)Tj
/F15 1 Tf
0.3 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( pair.\))Tj
/F27 1 Tf
-19.2 -3 TD
(Dereference a Sequence of Array Elements)Tj
/F11 1 Tf
0 -2.1 TD
(While )Tj
/F15 1 Tf
2.7 0 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
( "hop around" your data arrays, )Tj
/F15 1 Tf
12.8 0 TD
(glDrawArrays\(\))Tj
/F11 1 Tf
6.4 0 TD
( plows)Tj
-38.3 -1.5 TD
(straight through them.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glDrawArrays)-21(\(GLenum )27(mode)66(, GLint )-16(first)12(, GLsizei )6(count)-78(\);)]TJ
1.8 -1.5 TD
[(Constructs a sequence of geometric primitives using array elements starting at )8(first)12( and ending at)]TJ
T*
[(first)12(+)-25(count)22(-1 of each enabled array. )]TJ
14.9 0 TD
[(mode)-34( specifies what kinds of primitives are constructed and is)]TJ
-14.9 -1.5 TD
[(one of the same values accepted by glBegin\(\))-23(; for example, GL_POLYGON, GL_LINE_LOOP,)]TJ
T*
(GL_LINES, GL_POINTS, and so on.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The effect of )Tj
/F15 1 Tf
5.4 0 TD
(glDrawArrays\(\))Tj
/F11 1 Tf
6.5 0 TD
( is almost the same as this command sequence:)Tj
/F7 1 Tf
-11.9 -2.1 TD
(int i;)Tj
0 -1.5 TD
(glBegin \(mode\);)Tj
T*
(for \(i = 0; i < count; i++\))Tj
T*
(   glArrayElement\(first + i\);)Tj
T*
(glEnd\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 38)Tj
ET
endstream
endobj
237 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
239 0 obj
<<
/Length 4490
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 706.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(As is the case with )Tj
/F15 1 Tf
7.7 0 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glDrawArrays\(\))Tj
/F11 1 Tf
6.5 0 TD
( also performs error checking on its parameter)Tj
-22.1 -1.5 TD
(values and leaves the current RGB color, color index, normal coordinates, texture coordinates, and edge)Tj
T*
(flag with indeterminate values if the corresponding array has been enabled.)Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F33 1 Tf
-7.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Change the icosahedron drawing routine in Example 2-13)Tj
23.1 0 TD
( to use vertex arrays.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 596.000 Tm
(Interleaved Arrays)Tj
10.000 0.000 0.000 10.000 204.000 574.000 Tm
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
[(Earlier in this chapter \(in )49("Stride")-95(\), the special case of interleaved arrays was examined. In that section,)]TJ
0 -1.5 TD
(the array )Tj
/F15 1 Tf
3.8 0 TD
(intertwined)Tj
/F11 1 Tf
4.5 0 TD
(, which interleaves RGB color and 3D vertex coordinates, was accessed by calls to)Tj
/F15 1 Tf
-8.3 -1.5 TD
(glColorPointer\(\))Tj
/F11 1 Tf
6.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glVertexPointer\(\))Tj
/F11 1 Tf
7.1 0 TD
(. Careful use of stride helped properly specify the arrays.)Tj
/F7 1 Tf
-15.8 -2.1 TD
(static GLfloat intertwined[] =)Tj
0 -1.5 TD
(      {1.0, 0.2, 1.0, 100.0, 100.0, 0.0,)Tj
T*
(       1.0, 0.2, 0.2, 0.0, 200.0, 0.0,)Tj
T*
(       1.0, 1.0, 0.2, 100.0, 300.0, 0.0,)Tj
T*
(       0.2, 1.0, 0.2, 200.0, 300.0, 0.0,)Tj
T*
(       0.2, 1.0, 1.0, 300.0, 200.0, 0.0,)Tj
T*
(       0.2, 0.2, 1.0, 200.0, 100.0, 0.0};)Tj
/F11 1 Tf
0 -2.1 TD
(There is also a behemoth routine, )Tj
/F15 1 Tf
13.6 0 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.7 0 TD
(, that can specify several vertex arrays at once.)Tj
/F15 1 Tf
-22.3 -1.5 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.7 0 TD
( also enables and disables the appropriate arrays \(so it combines both Steps 1 and)Tj
-8.7 -1.5 TD
(2\). The array )Tj
/F15 1 Tf
5.4 0 TD
(intertwined)Tj
/F11 1 Tf
4.6 0 TD
( exactly fits one of the fourteen data interleaving configurations supported by)Tj
/F15 1 Tf
-10 -1.5 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.7 0 TD
(. So to specify the contents of the array )Tj
/F15 1 Tf
15.9 0 TD
(intertwined)Tj
/F11 1 Tf
4.6 0 TD
( into the RGB color and vertex)Tj
-29.2 -1.5 TD
(arrays and enable both arrays, call)Tj
/F7 1 Tf
0 -2.1 TD
(glInterleavedArrays \(GL_C3F_V3F, 0, intertwined\);)Tj
/F11 1 Tf
T*
(This call to )Tj
/F15 1 Tf
4.8 0 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.7 0 TD
( enables the GL_COLOR_ARRAY and GL_VERTEX_ARRAY)Tj
-13.5 -1.5 TD
(arrays. It disables the GL_INDEX_ARRAY, GL_TEXTURE_COORD_ARRAY,)Tj
T*
(GL_NORMAL_ARRAY, and GL_EDGE_FLAG_ARRAY.)Tj
0 -2.1 TD
(This call also has the same effect as calling )Tj
/F15 1 Tf
17.5 0 TD
(glColorPointer\(\))Tj
/F11 1 Tf
6.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glVertexPointer\(\))Tj
/F11 1 Tf
7.1 0 TD
( to specify the values)Tj
-33.3 -1.5 TD
(for six vertices into each array. Now you are ready for Step 3: Calling )Tj
/F15 1 Tf
28.2 0 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7 0 TD
(,)Tj
/F15 1 Tf
-35.2 -1.5 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(glDrawArrays\(\))Tj
/F11 1 Tf
6.4 0 TD
( to dereference array elements.)Tj
/F15 1 Tf
-15.4 -2.1 TD
[(void )-28(glInterleavedArrays)55(\(GLenum )-73(format)67(, GLsizei )6(stride)-22(, void *)-28(pointer)-11(\))]TJ
1.8 -1.5 TD
[(Initializes all six arrays, disabling arrays that are not specified in )-40(format)67(, and enabling the arrays)]TJ
T*
[(that are specified. )45(format)-33( is one of 14 symbolic constants, which represent 14 data configurations;)]TJ
T*
(Table 2-5)Tj
3.9 0 TD
[( displays )78(format )-83(values. )55(stride)-22( specifies the byte offset between consecutive vertexes. If)]TJ
-3.9 -1.5 TD
[(stride)-22( is 0, the vertexes are understood to be tightly packed in the array. )33(pointer)-11( is the memory)]TJ
T*
(address of the first coordinate of the first vertex in the array.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(Note that )Tj
/F15 1 Tf
3.9 0 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.8 0 TD
( does not support edge flags.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 39)Tj
ET
endstream
endobj
240 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
242 0 obj
<<
/Length 3917
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The mechanics of )Tj
/F15 1 Tf
7.4 0 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.7 0 TD
[( are intricate and require reference to )23(Example 2-12)]TJ
20.6 0 TD
[( and )-56(Table)]TJ
-36.7 -1.5 TD
(2-5)Tj
1.3 0 TD
(. In that example and table, you'll see e)Tj
15.8 -0.2 TD
(t)Tj
0.2 0.2 TD
(, e)Tj
1 -0.2 TD
(c)Tj
0.4 0.2 TD
(, and e)Tj
2.7 -0.2 TD
(n)Tj
0.5 0.2 TD
(, which are the boolean values for the enabled or)Tj
-21.9 -1.7 TD
(disabled texture coordinate, color, and normal arrays, and you'll see s)Tj
27.9 -0.2 TD
(t)Tj
0.2 0.2 TD
(, s)Tj
0.9 -0.2 TD
(c)Tj
0.5 0.2 TD
(, and s)Tj
2.5 -0.2 TD
(v)Tj
0.5 0.2 TD
(, which are the sizes)Tj
-32.5 -1.7 TD
(\(number of components\) for the texture coordinate, color, and vertex arrays. t)Tj
31 -0.2 TD
(c)Tj
0.4 0.2 TD
( is the data type for RGBA)Tj
-31.4 -1.7 TD
(color, which is the only array that can have non-float interleaved values. p)Tj
29.7 -0.2 TD
(c)Tj
0.4 0.2 TD
(, p)Tj
1 -0.2 TD
(n)Tj
0.5 0.2 TD
(, and p)Tj
2.7 -0.2 TD
(v)Tj
0.5 0.2 TD
( are the calculated)Tj
-34.8 -1.7 TD
(strides for jumping over individual color, normal, and vertex values, and s is the stride \(if one is not)Tj
0 -1.5 TD
(specified by the user\) to jump from one array element to the next.)Tj
0 -2.1 TD
(The effect of )Tj
/F15 1 Tf
5.4 0 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.7 0 TD
[( is the same as calling the command sequence in )10(Example 2-12)170( with)]TJ
-14.1 -1.5 TD
[(many values defined in )-45(Table 2-5)]TJ
13.4 0 TD
(. All pointer arithmetic is performed in units of)Tj
/F15 1 Tf
-13.4 -1.5 TD
(sizeof)Tj
/F11 1 Tf
2.3 0 TD
(\(GL_UNSIGNED_BYTE\).)Tj
/F27 1 Tf
-2.3 -2.1 TD
(Example 2-12 )Tj
/F11 1 Tf
6.7 0 TD
(Effect of glInterleavedArrays\(format, stride, pointer\))Tj
/F7 1 Tf
-6.7 -2.4 TD
(int str;)Tj
0 -1.5 TD
(/*  set e)Tj
5.4 -0.2 TD
(t)Tj
0.6 0.2 TD
(, e)Tj
1.8 -0.2 TD
(c)Tj
0.6 0.2 TD
(, e)Tj
1.8 -0.2 TD
(n)Tj
0.6 0.2 TD
(, s)Tj
1.8 -0.2 TD
(t)Tj
0.6 0.2 TD
(, s)Tj
1.8 -0.2 TD
(c)Tj
0.6 0.2 TD
(, s)Tj
1.8 -0.2 TD
(v)Tj
0.6 0.2 TD
(, t)Tj
1.8 -0.2 TD
(c)Tj
0.6 0.2 TD
(, p)Tj
1.8 -0.2 TD
(c)Tj
0.6 0.2 TD
(, p)Tj
1.8 -0.2 TD
(n)Tj
0.6 0.2 TD
(, p)Tj
1.8 -0.2 TD
(v)Tj
0.6 0.2 TD
(, and s)Tj
-27.6 -1.7 TD
( *  as a function of Table 2-5 and the value of format)Tj
0 -1.5 TD
( */)Tj
T*
(str = stride;)Tj
T*
(if \(str == 0\))Tj
T*
(   str = s;)Tj
T*
(glDisableClientState\(GL_EDGE_FLAG_ARRAY\);)Tj
T*
(glDisableClientState\(GL_INDEX_ARRAY\);)Tj
T*
(if \(e)Tj
3 -0.2 TD
(t)Tj
0.6 0.2 TD
(\) {)Tj
-3.6 -1.7 TD
(   glEnableClientState\(GL_TEXTURE_COORD_ARRAY\);)Tj
0 -1.5 TD
(   glTexCoordPointer\(s)Tj
13.2 -0.2 TD
(t)Tj
0.6 0.2 TD
(, GL_FLOAT, str, pointer\);)Tj
-13.8 -1.7 TD
(})Tj
0 -1.5 TD
(else)Tj
T*
(   glDisableClientState\(GL_TEXTURE_COORD_ARRAY\);)Tj
T*
(if \(e)Tj
3 -0.2 TD
(c)Tj
0.6 0.2 TD
(\) {)Tj
-3.6 -1.7 TD
(   glEnableClientState\(GL_COLOR_ARRAY\);)Tj
0 -1.5 TD
(   glColorPointer\(s)Tj
11.4 -0.2 TD
(c)Tj
0.6 0.2 TD
(, t)Tj
1.8 -0.2 TD
(c)Tj
0.6 0.2 TD
(, str, pointer+p)Tj
9.6 -0.2 TD
(c)Tj
0.6 0.2 TD
(\);)Tj
-24.6 -1.7 TD
(})Tj
0 -1.5 TD
(else)Tj
T*
(   glDisableClientState\(GL_COLOR_ARRAY\);)Tj
T*
(if \(e)Tj
3 -0.2 TD
(n)Tj
0.6 0.2 TD
(\) {)Tj
-3.6 -1.7 TD
(   glEnableClientState\(GL_NORMAL_ARRAY\);)Tj
0 -1.5 TD
(   glNormalPointer\(GL_FLOAT, str, pointer+p)Tj
25.8 -0.2 TD
(n)Tj
0.6 0.2 TD
(\);)Tj
-26.4 -1.7 TD
(})Tj
0 -1.5 TD
(else)Tj
T*
(   glDisableClientState\(GL_NORMAL_ARRAY\);)Tj
T*
(glEnableClientState\(GL_VERTEX_ARRAY\);)Tj
T*
(glVertexPointer\(s)Tj
10.2 -0.2 TD
(v)Tj
0.6 0.2 TD
(, GL_FLOAT, str, pointer+p)Tj
15.6 -0.2 TD
(v)Tj
0.6 0.2 TD
(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 40)Tj
ET
endstream
endobj
243 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
245 0 obj
<<
/Length 5712
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.017 Tw
[(In Table )17(2-5)]TJ
4.9 0 TD
0.000 Tw
(, T and F are True and False. f is )Tj
/F15 1 Tf
13.3 0 TD
(sizeof)Tj
/F11 1 Tf
2.3 0 TD
(\(GL_FLOAT\). c is 4 times)Tj
/F15 1 Tf
-20.5 -1.5 TD
(sizeof)Tj
/F11 1 Tf
2.3 0 TD
(\(GL_UNSIGNED_BYTE\), rounded up to the nearest multiple of f.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 681.840 m
534.000 681.840 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 674.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(format)-8138(e)]TJ
11.75 -0.25 TD
0.000 Tw
(t)Tj
2.5 0.25 TD
(e)Tj
0.5 -0.25 TD
(c)Tj
2.375 0.25 TD
(e)Tj
0.5 -0.25 TD
(n)Tj
2.5 0.25 TD
(s)Tj
0.5 -0.25 TD
(t)Tj
2.5 0.25 TD
(s)Tj
0.5 -0.25 TD
(c)Tj
2.5 0.25 TD
(s)Tj
0.5 -0.25 TD
(v)Tj
2.375 0.25 TD
(t)Tj
0.375 -0.25 TD
(c)Tj
10.375 0.25 TD
(p)Tj
0.625 -0.25 TD
(c)Tj
2.375 0.25 TD
(p)Tj
0.625 -0.25 TD
(n)Tj
2.25 0.25 TD
(p)Tj
0.625 -0.25 TD
(v)Tj
2.375 0.25 TD
(s)Tj
ET
Q
124.000 666.320 m
534.000 666.320 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 658.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(GL_V2F)-6389(F)-2111(F)-2000(F)-7444(2)-16833(0)-2167(2)0(f)]TJ
0 -1.4445 TD
[(GL_V3F)-6389(F)-2111(F)-2000(F)-7444(3)-16833(0)-2167(3)0(f)]TJ
T*
[(GL_C4UB_V2F)-3332(F)-2111(T)-1945(F)-4777(4)-2167(2)-2056(GL_UNSIGNED_B)]TJ
25.7778 -1.3333 TD
(YTE)Tj
9.5556 1.3333 TD
[(0)-4722(c)-2223(c+2f)]TJ
-35.3333 -2.7778 TD
[(GL_C4UB_V3F)-3332(F)-2111(T)-1945(F)-4777(4)-2167(3)-2056(GL_UNSIGNED_B)]TJ
25.7778 -1.3333 TD
(YTE)Tj
9.5556 1.3333 TD
[(0)-4722(c)-2223(c+3f)]TJ
-35.3333 -2.7778 TD
[(GL_C3F_V3F)-4165(F)-2111(T)-1945(F)-4777(3)-2167(3)-2056(GL_FLOAT)-4500(0)-4722(3)0(f)-1834(6)0(f)]TJ
0 -1.4444 TD
[(GL_N3F_V3F)-4110(F)-2111(F)-2000(T)-7389(3)-14278(0)-2056(3)0(f)-1834(6)0(f)]TJ
T*
[(GL_C4F_N3F_V3F)-1887(F)-2111(T)-1945(T)-4722(4)-2167(3)-2056(GL_FLOAT)-4500(0)-2167(4)0(f)-1722(7)0(f)-1834(10f)]TJ
T*
[(GL_T2F_V3F)-4221(T)-2056(F)-2000(F)-2111(2)-4833(3)-16833(2)0(f)-1834(5)0(f)]TJ
T*
[(GL_T4F_V4F)-4221(T)-2056(F)-2000(F)-2111(4)-4833(4)-16833(4)0(f)-1834(8)0(f)]TJ
T*
[(GL_T2F_C4UB_V3F)-1165(T)-2056(T)-1945(F)-2111(2)-2167(4)-2167(3)-2056(GL_UNSIGNED_B)]TJ
25.7778 -1.3333 TD
(YTE)Tj
9.5556 1.3333 TD
[(2f)-4389(c+2f)-825(c+5f)]TJ
-35.3333 -2.7778 TD
[(GL_T2F_C3F_V3F)-1998(T)-2056(T)-1945(F)-2111(2)-2167(3)-2167(3)-2056(GL_FLOAT)-4500(2f)-4389(5f)-1834(8f)]TJ
0 -1.4445 TD
[(GL_T2F_N3F_V3F)-1943(T)-2056(F)-2000(T)-2056(2)-4833(3)-14278(2)0(f)-1722(5)0(f)-1834(8)0(f)]TJ
T*
(GL_T2F_C4F_N3F_)Tj
0 -1.3333 TD
(V3F)Tj
10 1.3333 TD
[(T)-2056(T)-1945(T)-2056(2)-2167(4)-2167(3)-2056(GL_FLOAT)-4500(2f)-1834(6f)-1722(9f)-1834(12f)]TJ
-10 -2.7778 TD
(GL_T4F_C4F_N3F_)Tj
0 -1.3333 TD
(V4F)Tj
10 1.3333 TD
[(T)-2056(T)-1945(T)-2056(4)-2167(4)-2167(4)-2056(GL_FLOAT)-4500(4f)-1834(8f)-1722(11f)-1334(15f)]TJ
ET
Q
124.000 421.110 m
534.010 421.110 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 405.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 2-5 )Tj
/F11 1 Tf
4.6 0 TD
[(\(continued\)        )11(Variables that Direct glInterleavedArrays\(\))]TJ
-4.6 -2.1 TD
(Start by learning the simpler formats, GL_V2F, GL_V3F, and GL_C3F_V3F. If you use any of the)Tj
0 -1.5 TD
(formats with C4UB, you may have to use a struct data type or do some delicate type casting and pointer)Tj
T*
(math to pack four unsigned bytes into a single 32-bit word.)Tj
0 -2.1 TD
(For some OpenGL implementations, use of interleaved arrays may increase application performance.)Tj
0 -1.5 TD
(With an interleaved array, the exact layout of your data is known. You know your data is tightly packed)Tj
T*
(and may be accessed in one chunk. If interleaved arrays are not used, the stride and size information has)Tj
T*
(to be examined to detect whether data is tightly packed.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F15 1 Tf
2.8 0 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.8 0 TD
( only enables and disables vertex arrays and specifies values for the)Tj
-11.6 -1.4 TD
(vertex-array data. It does not render anything. You must still complete Step 3 and call )Tj
/F15 1 Tf
34.6 0 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7 0 TD
(,)Tj
/F15 1 Tf
-41.6 -1.5 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(glDrawArrays\(\))Tj
/F11 1 Tf
6.4 0 TD
( to dereference the pointers and render graphics.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 205.000 Tm
(Attribute Groups)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 183.000 Tm
[(In )-17("Basic State Management,")10( you saw how to set or query an individual state or state variable. Well, you)]TJ
0 -1.5 TD
(can also save and restore the values of a collection of related state variables with a single command.)Tj
0 -2.2 TD
(OpenGL groups related state variables into an )Tj
/F13 1 Tf
18.6 0 TD
(attribute group)Tj
/F11 1 Tf
6.6 0 TD
(. For example, the GL_LINE_BIT)Tj
-25.2 -1.5 TD
(attribute consists of five state variables: the line width, the GL_LINE_STIPPLE enable status, the line)Tj
T*
(stipple pattern, the line stipple repeat counter, and the GL_LINE_SMOOTH enable status. \(See)Tj
T*
("Antialiasing" in Chapter 6.\) With the commands )Tj
/F15 1 Tf
20 0 TD
(glPushAttrib\(\))Tj
/F11 1 Tf
5.8 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glPopAttrib\(\))Tj
/F11 1 Tf
5.3 0 TD
(, you can save and)Tj
-33.1 -1.5 TD
(restore all five state variables, all at once.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 41)Tj
ET
endstream
endobj
246 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
248 0 obj
<<
/Length 4588
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Some state variables are in more than one attribute group. For example, the state variable,)Tj
0 -1.5 TD
(GL_CULL_FACE, is part of both the polygon and the enable attribute groups.)Tj
0 -2.1 TD
(In OpenGL Version 1.1, there are now two different attribute stacks. In addition to the original attribute)Tj
0 -1.5 TD
(stack \(which saves the values of server state variables\), there is also a client attribute stack, accessible by)Tj
T*
(the commands )Tj
/F15 1 Tf
6.1 0 TD
(glPushClientAttrib\(\))Tj
/F11 1 Tf
8.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glPopClientAttrib\(\))Tj
/F11 1 Tf
7.9 0 TD
(.)Tj
-24.1 -2.1 TD
(In general, it's faster to use these commands than to get, save, and restore the values yourself. Some)Tj
0 -1.5 TD
(values might be maintained in the hardware, and getting them might be expensive. Also, if you're)Tj
T*
(operating on a remote client, all the attribute data has to be transferred across the network connection and)Tj
T*
(back as it is obtained, saved, and restored. However, your OpenGL implementation keeps the attribute)Tj
T*
(stack on the server, avoiding unnecessary network delays.)Tj
0 -2.1 TD
(There are about twenty different attribute groups, which can be saved and restored by )Tj
/F15 1 Tf
34.5 0 TD
(glPushAttrib\(\))Tj
/F11 1 Tf
5.7 0 TD
( and)Tj
/F15 1 Tf
-40.2 -1.5 TD
(glPopAttrib\(\))Tj
/F11 1 Tf
5.4 0 TD
(. There are two client attribute groups, which can be saved and restored by)Tj
/F15 1 Tf
-5.4 -1.5 TD
(glPushClientAttrib\(\))Tj
/F11 1 Tf
8.2 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glPopClientAttrib\(\))Tj
/F11 1 Tf
7.8 0 TD
(. For both server and client, the attributes are stored on a)Tj
-18 -1.5 TD
(stack, which has a depth of at least 16 saved attribute groups. \(The actual stack depths for your)Tj
T*
(implementation can be obtained using GL_MAX_ATTRIB_STACK_DEPTH and)Tj
T*
(GL_MAX_CLIENT_ATTRIB_STACK_DEPTH with )Tj
/F15 1 Tf
22.1 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
(.\) Pushing a full stack or popping)Tj
-28.3 -1.5 TD
(an empty one generates an error.)Tj
0 -2.1 TD
[(\(See the tables in )11(Appendix B)-38( to find out exactly which attributes are saved for particular mask values;)]TJ
0 -1.5 TD
(that is, which attributes are in a particular attribute group.\))Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glPushAttrib)13(\(GLbitfield )24(mask)55(\);)]TJ
0 -1.1 TD
[(void glPopAttrib)24(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(glPushAttrib\(\))-21( saves all the attributes indicated by bits in )19(mask)-45( by pushing them onto the attribute)]TJ
T*
[(stack. )-45(glPopAttrib\(\))90( restores the values of those state variables that were saved with the last)]TJ
T*
[(glPushAttrib\(\))-21(. Table 2-7)]TJ
10.1 0 TD
( lists the possible mask bits that can be logically ORed together to save any)Tj
-10.1 -1.5 TD
(combination of attributes. Each bit corresponds to a collection of individual state variables. For)Tj
T*
(example, GL_LIGHTING_BIT refers to all the state variables related to lighting, which include the)Tj
T*
(current material color, the ambient, diffuse, specular, and emitted light, a list of the lights that are)Tj
T*
[(enabled, and the directions of the spotlights. When )-43(glPopAttrib\(\))90( is called, all those variables are)]TJ
T*
(restored.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The special mask, GL_ALL_ATTRIB_BITS, is used to save and restore all the state variables in all the)Tj
0 -1.5 TD
(attribute groups.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 217.840 m
451.000 217.840 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 210.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Mask Bit)-15387(Attribute Group)]TJ
ET
Q
124.000 204.320 m
451.000 204.320 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 196.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(GL_ACCUM_BUFFER_BIT)-5441(accum-buffer)]TJ
0 -1.4444 TD
[(GL_ALL_ATTRIB_BITS)-6777(--)]TJ
T*
[(GL_COLOR_BUFFER_BIT)-5720(color-buffer)]TJ
T*
[(GL_CURRENT_BIT)-8721(current)]TJ
T*
[(GL_DEPTH_BUFFER_BIT)-5887(depth-buffer)]TJ
T*
[(GL_ENABLE_BIT)-9444(enable)]TJ
T*
[(GL_EVAL_BIT)-10722(eval)]TJ
T*
[(GL_FOG_BIT)-11388(fog)]TJ
T*
[(GL_HINT_BIT)-11000(hint)]TJ
T*
[(GL_LIGHTING_BIT)-8612(lighting)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 42)Tj
ET
endstream
endobj
249 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
252 0 obj
<<
/Length 4404
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
[(GL_LINE_BIT)-11111(line)]TJ
0 -1.4445 TD
[(GL_LIST_BIT)-11277(list)]TJ
T*
[(GL_PIXEL_MODE_BIT)-7111(pixel)]TJ
T*
[(GL_POINT_BIT)-10444(point)]TJ
T*
[(GL_POLYGON_BIT)-8611(polygon)]TJ
T*
[(GL_POLYGON_STIPPLE_BIT)-4276(polygon-stipple)]TJ
T*
[(GL_SCISSOR_BIT)-9331(scissor)]TJ
T*
[(GL_STENCIL_BUFFER_BIT)-4997(stencil-buffer)]TJ
T*
[(GL_TEXTURE_BIT)-8833(texture)]TJ
0 -1.5556 TD
[(GL_TRANSFORM_BIT)-7276(transform)]TJ
0 -1.4444 TD
[(GL_VIEWPORT_BIT)-8222(viewport)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 573.960 m
451.010 573.960 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 558.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 2-6 )Tj
/F11 1 Tf
4.6 0 TD
(\(continued\)        Attribute Groups)Tj
/F15 1 Tf
-4.6 -2.1 TD
0.028 Tw
[(void glPushClientAttrib)58(\(GLbitfield )24(mask)-45(\);)]TJ
0 -1.1 TD
[(void glPopClientAttrib)69(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(glPushClientAttrib\(\))24( saves all the attributes indicated by bits in )19(mask)-45( by pushing them onto the client)]TJ
T*
[(attribute stack. )-49(glPopClientAttrib\(\))35( restores the values of those state variables that were saved with)]TJ
T*
[(the last )-33(glPushClientAttrib\(\))24(. Table 2-7)]TJ
15.8 0 TD
( lists the possible mask bits that can be logically ORed)Tj
-15.8 -1.5 TD
(together to save any combination of client attributes.)Tj
T*
(There are two client attribute groups, feedback and select, that cannot be saved or restored with the)Tj
T*
(stack mechanism.)Tj
ET
Q
124.000 424.450 m
451.000 424.450 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 417.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Mask Bit)-15387(Attribute Group)]TJ
ET
Q
124.000 410.930 m
451.000 410.930 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 403.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(GL_CLIENT_PIXEL_STORE_BIT)-2832(pixel-store)]TJ
0 -1.4444 TD
[(GL_CLIENT_VERTEX_ARRAY_BIT)-1388(vertex-array)]TJ
T*
[(GL_ALL_CLIENT_ATTRIB_BITS)-2721(--)]TJ
T*
0.000 Tw
[(can't be pushed or popped)-6779(feedback)]TJ
T*
[(can't be pushed or popped)-6779(select)]TJ
ET
Q
124.000 343.170 m
451.010 343.170 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 327.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 2-7 )Tj
/F11 1 Tf
4.6 0 TD
(Client Attribute Groups)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 293.000 Tm
(Some Hints for Building Polygonal Models of Surfaces)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 271.000 Tm
(Following are some techniques that you might want to use as you build polygonal approximations of)Tj
0 -1.5 TD
[(surfaces. You might want to review this section after you've read )-14(Chapter 5)16( on lighting and )-43(Chapter 7)16( on)]TJ
T*
(display lists. The lighting conditions affect how models look once they're drawn, and some of the)Tj
T*
(following techniques are much more efficient when used in conjunction with display lists. As you read)Tj
T*
(these techniques, keep in mind that when lighting calculations are enabled, normal vectors must be)Tj
T*
(specified to get proper results.)Tj
0 -2.1 TD
(Constructing polygonal approximations to surfaces is an art, and there is no substitute for experience.)Tj
0 -1.5 TD
(This section, however, lists a few pointers that might make it a bit easier to get started.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Keep polygon orientations consistent. Make sure that when viewed from the outside, all the)Tj
0 -1.6 TD
(polygons on the surface are oriented in the same direction \(all clockwise or all counterclockwise\).)Tj
0 -1.5 TD
(Consistent orientation is important for polygon culling and two-sided lighting. Try to get this right)Tj
T*
(the first time, since it's excruciatingly painful to fix the problem later. \(If you use )Tj
/F15 1 Tf
32.8 0 TD
(glScale*\(\))Tj
/F11 1 Tf
4.1 0 TD
( to)Tj
-36.9 -1.5 TD
(reflect geometry around some axis of symmetry, you might change the orientation with)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 43)Tj
ET
endstream
endobj
253 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
254 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im22
/Width 240
/Height 108
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.21)
>>
stream
endstream
endobj
256 0 obj
<<
/Length 3501
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 143.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glFrontFace\(\))Tj
/F11 1 Tf
5.7 0 TD
0.000 Tw
( to keep the orientations consistent.\))Tj
/F33 1 Tf
-7.5 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(When you subdivide a surface, watch out for any nontriangular polygons. The three vertices of a)Tj
0 -1.6 TD
(triangle are guaranteed to lie on a plane; any polygon with four or more vertices might not.)Tj
0 -1.5 TD
(Nonplanar polygons can be viewed from some orientation such that the edges cross each other, and)Tj
T*
(OpenGL might not render such polygons correctly.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(There's always a trade-off between the display speed and the quality of the image. If you subdivide)Tj
0 -1.5 TD
(a surface into a small number of polygons, it renders quickly but might have a jagged appearance; if)Tj
T*
(you subdivide it into millions of tiny polygons, it probably looks good but might take a long time to)Tj
T*
(render. Ideally, you can provide a parameter to the subdivision routines that indicates how fine a)Tj
T*
(subdivision you want, and if the object is farther from the eye, you can use a coarser subdivision.)Tj
T*
(Also, when you subdivide, use large polygons where the surface is relatively flat, and small)Tj
T*
(polygons in regions of high curvature.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(For high-quality images, it's a good idea to subdivide more on the silhouette edges than in the)Tj
0 -1.5 TD
(interior. If the surface is to be rotated relative to the eye, this is tougher to do, since the silhouette)Tj
T*
(edges keep moving. Silhouette edges occur where the normal vectors are perpendicular to the vector)Tj
0 -1.6 TD
(from the surface to the viewpoint)Tj
/F33 1 Tf
13.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, when their vector dot product is zero. Your subdivision)Tj
-14.3 -1.6 TD
(algorithm might choose to subdivide more if this dot product is near zero.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[(Try to avoid T-intersections in your models \(see )186(Figure 2-16)]TJ
24.2 0 TD
(\). As shown, there's no guarantee that)Tj
-24.2 -1.6 TD
(the line segments AB and BC lie on exactly the same pixels as the segment AC. Sometimes they do,)Tj
0 -1.5 TD
(and sometimes they don't, depending on the transformations and orientation. This can cause cracks)Tj
T*
(to appear intermittently in the surface.)Tj
ET
Q
/GS1 gs
q
240 0 0 108 143 254.79 cm
/Im22 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 143.000 242.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 2-16 )Tj
/F11 1 Tf
5.6 0 TD
(Modifying an Undesirable T-intersection)Tj
/F33 1 Tf
-7.4 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If you're constructing a closed surface, make sure to use exactly the same numbers for coordinates)Tj
0 -1.6 TD
(at the beginning and end of a closed loop, or you can get gaps and cracks due to numerical)Tj
0 -1.5 TD
(round-off. Here's a two-dimensional example of bad code:)Tj
/F7 1 Tf
0 -2.1 TD
(/* don't use this code */)Tj
0 -1.5 TD
(#define PI 3.14159265 )Tj
T*
(#define EDGES 30 )Tj
0 -3 TD
(/* draw a circle */)Tj
0 -1.5 TD
(glBegin\(GL_LINE_STRIP\); )Tj
T*
(for \(i = 0; i <= EDGES; i++\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 44)Tj
ET
endstream
endobj
257 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im22 254 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
259 0 obj
<<
/Length 3078
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(    glVertex2f\(cos\(\(2*PI*i\)/EDGES\), sin\(\(2*PI*i\)/EDGES\)\); )Tj
0 -1.5 TD
(glEnd\(\); )Tj
/F11 1 Tf
0 -2.1 TD
(The edges meet exactly only if your machine manages to calculate the sine and cosine of 0 and of)Tj
0 -1.5 TD
(\(2*PI*EDGES/EDGES\) and gets exactly the same values. If you trust the floating-point unit on your)Tj
T*
(machine to do this right, the authors have a bridge they'd like to sell you.... To correct the code,)Tj
T*
(make sure that when )Tj
/F15 1 Tf
8.5 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
( == EDGES, you use 0 for the sine and cosine, not 2*PI*EDGES/EDGES. \(Or)Tj
-8.8 -1.5 TD
(simpler still, use GL_LINE_LOOP instead of GL_LINE_STRIP, and change the loop termination)Tj
T*
(condition to i < EDGES.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 565.000 Tm
(An Example: Building an Icosahedron)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 544.000 Tm
(To illustrate some of the considerations that arise in approximating a surface, let's look at some example)Tj
T*
(code sequences. This code concerns the vertices of a regular icosahedron \(which is a Platonic solid)Tj
T*
(composed of twenty faces that span twelve vertices, each face of which is an equilateral triangle\). An)Tj
T*
[(icosahedron can be considered a rough approximation for a sphere. )-21(Example 2-13)]TJ
32.7 0 TD
( defines the vertices)Tj
-32.7 -1.5 TD
(and triangles making up an icosahedron and then draws the icosahedron.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 2-13 )Tj
/F11 1 Tf
6.7 0 TD
(Drawing an Icosahedron)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#define X .525731112119133606 )Tj
0 -1.5 TD
(#define Z .850650808352039932)Tj
0 -3 TD
(static GLfloat vdata[12][3] = {    )Tj
0 -1.5 TD
(   {-X, 0.0, Z}, {X, 0.0, Z}, {-X, 0.0, -Z}, {X, 0.0, -Z},    )Tj
T*
(   {0.0, Z, X}, {0.0, Z, -X}, {0.0, -Z, X}, {0.0, -Z, -X},    )Tj
T*
(   {Z, X, 0.0}, {-Z, X, 0.0}, {Z, -X, 0.0}, {-Z, -X, 0.0} )Tj
T*
(};)Tj
T*
(static GLuint tindices[20][3] = { )Tj
T*
(   {0,4,1}, {0,9,4}, {9,5,4}, {4,5,8}, {4,8,1},    )Tj
T*
(   {8,10,1}, {8,3,10}, {5,3,8}, {5,2,3}, {2,7,3},    )Tj
T*
(   {7,10,3}, {7,6,10}, {7,11,6}, {11,0,6}, {0,1,6}, )Tj
T*
(   {6,1,10}, {9,0,11}, {9,11,2}, {9,2,5}, {7,2,11} };)Tj
T*
(int i;)Tj
0 -3 TD
(glBegin\(GL_TRIANGLES\);    )Tj
0 -1.5 TD
(for \(i = 0; i < 20; i++\) {    )Tj
T*
(   /* color information here */ )Tj
T*
(   glVertex3fv\(&vdata[tindices[i][0]][0]\); )Tj
T*
(   glVertex3fv\(&vdata[tindices[i][1]][0]\); )Tj
T*
(   glVertex3fv\(&vdata[tindices[i][2]][0]\); )Tj
T*
(})Tj
T*
(glEnd\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(The strange numbers )Tj
/F15 1 Tf
8.6 0 TD
(X)Tj
/F11 1 Tf
0.6 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(Z)Tj
/F11 1 Tf
0.5 0 TD
( are chosen so that the distance from the origin to any of the vertices of the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 45)Tj
ET
endstream
endobj
260 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
262 0 obj
<<
/Length 3719
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(icosahedron is 1.0. The coordinates of the twelve vertices are given in the array )Tj
/F15 1 Tf
32 0 TD
(vdata[][])Tj
/F11 1 Tf
3.8 0 TD
(, where the)Tj
-35.8 -1.6 TD
(zeroth vertex is {-)Tj
/F33 1 Tf
7.2 0 TD
(X)Tj
/F15 1 Tf
0.7 0 TD
(, 0.0, )Tj
/F33 1 Tf
2.2 0 TD
(Z)Tj
/F11 1 Tf
0.6 0 TD
(}, the first is {)Tj
/F15 1 Tf
5.7 0 TD
(X, 0.0, Z)Tj
/F11 1 Tf
3.5 0 TD
(}, and so on. The array )Tj
/F15 1 Tf
9.4 0 TD
(tindices[][])Tj
/F11 1 Tf
4.7 0 TD
( tells how to link the)Tj
-34 -1.6 TD
(vertices to make triangles. For example, the first triangle is made from the zeroth, fourth, and first vertex.)Tj
0 -1.5 TD
(If you take the vertices for triangles in the order given, all the triangles have the same orientation.)Tj
0 -2.1 TD
(The line that mentions color information should be replaced by a command that sets the color of the )Tj
/F15 1 Tf
40.2 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
(th)Tj
-40.5 -1.5 TD
(face. If no code appears here, all faces are drawn in the same color, and it'll be impossible to discern the)Tj
T*
(three-dimensional quality of the object. An alternative to explicitly specifying colors is to define surface)Tj
T*
(normals and use lighting, as described in the next subsection.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(In all the examples described in this section, unless the surface is to be drawn only once, you)Tj
-2.8 -1.4 TD
(should probably save the calculated vertex and normal coordinates so that the calculations don't need to)Tj
T*
(be repeated each time that the surface is drawn. This can be done using your own data structures or by)Tj
0 -1.5 TD
[(constructing display lists. \(See )-27(Chapter 7)16(.)0(\))]TJ
/F27 1 Tf
0 -3 TD
(Calculating Normal Vectors for a Surface)Tj
/F11 1 Tf
0 -2.1 TD
(If a surface is to be lit, you need to supply the vector normal to the surface. Calculating the normalized)Tj
0 -1.5 TD
(cross product of two vectors on that surface provides normal vector. With the flat surfaces of an)Tj
T*
(icosahedron, all three vertices defining a surface have the same normal vector. In this case, the normal)Tj
T*
[(needs to be specified only once for each set of three vertices. The code in )51(Example 2-14)170( can replace the)]TJ
T*
[("color information here" line in )44(Example 2-13)170( for drawing the icosahedron.)]TJ
/F27 1 Tf
0 -2.1 TD
(Example 2-14 )Tj
/F11 1 Tf
6.7 0 TD
(Generating Normal Vectors for a Surface)Tj
/F7 1 Tf
-6.7 -2.3 TD
(GLfloat d1[3], d2[3], norm[3];    )Tj
0 -1.5 TD
(for \(j = 0; j < 3; j++\) {    )Tj
T*
(   d1[j] = vdata[tindices[i][0]][j] - vdata[tindices[i][1]][j];    )Tj
T*
(   d2[j] = vdata[tindices[i][1]][j] - vdata[tindices[i][2]][j];    )Tj
T*
(})Tj
T*
(normcrossprod\(d1, d2, norm\); )Tj
T*
(glNormal3fv\(norm\);)Tj
/F11 1 Tf
0 -2.2 TD
(The function )Tj
/F15 1 Tf
5.4 0 TD
(normcrossprod\(\))Tj
/F11 1 Tf
6.8 0 TD
( produces the normalized cross product of two vectors, as shown in)Tj
-12.2 -1.5 TD
(Example 2-15)Tj
5.6 0 TD
(.)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 2-15 )Tj
/F11 1 Tf
6.7 0 TD
(Calculating the Normalized Cross Product of Two Vectors)Tj
/F7 1 Tf
-6.7 -2.3 TD
(void normalize\(float v[3]\) {    )Tj
0 -1.5 TD
(   GLfloat d = sqrt\(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]\); )Tj
T*
(   if \(d == 0.0\) {)Tj
T*
(      error\("zero length vector"\);    )Tj
T*
(      return;)Tj
T*
(   })Tj
T*
(   v[0] /= d; v[1] /= d; v[2] /= d; )Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 46)Tj
ET
endstream
endobj
263 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
265 0 obj
<<
/Length 2589
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void normcrossprod\(float v1[3], float v2[3], float out[3]\) )Tj
0 -1.5 TD
({ )Tj
T*
(   GLint i, j; )Tj
T*
(   GLfloat length;)Tj
0 -3 TD
(   out[0] = v1[1]*v2[2] - v1[2]*v2[1]; )Tj
0 -1.5 TD
(   out[1] = v1[2]*v2[0] - v1[0]*v2[2]; )Tj
T*
(   out[2] = v1[0]*v2[1] - v1[1]*v2[0]; )Tj
T*
(   normalize\(out\); )Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(If you're using an icosahedron as an approximation for a shaded sphere, you'll want to use normal)Tj
0 -1.5 TD
(vectors that are perpendicular to the true surface of the sphere, rather than being perpendicular to the)Tj
T*
(faces. For a sphere, the normal vectors are simple; each points in the same direction as the vector from)Tj
T*
(the origin to the corresponding vertex. Since the icosahedron vertex data is for an icosahedron of radius)Tj
T*
(1, the normal and vertex data is identical. Here is the code that would draw an icosahedral approximation)Tj
T*
[(of a smoothly shaded sphere \(assuming that lighting is enabled, as described in )34(Chapter 5)16(\))0(:)]TJ
/F7 1 Tf
0 -2.1 TD
(glBegin\(GL_TRIANGLES\); )Tj
0 -1.5 TD
(for \(i = 0; i < 20; i++\) {    )Tj
T*
(      glNormal3fv\(&vdata[tindices[i][0]][0]\); )Tj
T*
(      glVertex3fv\(&vdata[tindices[i][0]][0]\); )Tj
T*
(      glNormal3fv\(&vdata[tindices[i][1]][0]\); )Tj
T*
(      glVertex3fv\(&vdata[tindices[i][1]][0]\); )Tj
T*
(      glNormal3fv\(&vdata[tindices[i][2]][0]\); )Tj
T*
(      glVertex3fv\(&vdata[tindices[i][2]][0]\); )Tj
T*
(})Tj
T*
(glEnd\(\);)Tj
/F27 1 Tf
0 -3 TD
(Improving the Model)Tj
/F11 1 Tf
0 -2.1 TD
(A twenty-sided approximation to a sphere doesn't look good unless the image of the sphere on the screen)Tj
0 -1.5 TD
(is quite small, but there's an easy way to increase the accuracy of the approximation. Imagine the)Tj
T*
[(icosahedron inscribed in a sphere, and subdivide the triangles as shown in Figure 2-17)226(. The newly)]TJ
T*
(introduced vertices lie slightly inside the sphere, so push them to the surface by normalizing them)Tj
T*
(\(dividing them by a factor to make them have length 1\). This subdivision process can be repeated for)Tj
T*
[(arbitrary accuracy. The three objects shown in )-26(Figure 2-17)226( use 20, 80, and 320 approximating triangles,)]TJ
T*
(respectively.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 47)Tj
ET
endstream
endobj
266 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
267 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im23
/Width 833
/Height 295
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.22)
>>
stream
endstream
endobj
269 0 obj
<<
/Length 1684
>>
stream
q
1 i 
124.000 720.000 422.990 -149.800 re
W n
/GS1 gs
q
423 0 0 150 124 570 cm
/Im23 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 557.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 2-17 )Tj
/F11 1 Tf
5.6 0 TD
(Subdividing to Improve a Polygonal Approximation to a Surface)Tj
-5.6 -2.1 TD
(Example 2-16)Tj
5.6 0 TD
( performs a single subdivision, creating an 80-sided spherical approximation.)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 2-16 )Tj
/F11 1 Tf
6.7 0 TD
(Single Subdivision)Tj
/F7 1 Tf
-6.7 -2.3 TD
(void drawtriangle\(float *v1, float *v2, float *v3\) )Tj
0 -1.5 TD
({ )Tj
T*
(   glBegin\(GL_TRIANGLES\); )Tj
T*
(      glNormal3fv\(v1\); vlVertex3fv\(v1\);    )Tj
T*
(      glNormal3fv\(v2\); vlVertex3fv\(v2\);    )Tj
T*
(      glNormal3fv\(v3\); vlVertex3fv\(v3\);    )Tj
T*
(   glEnd\(\); )Tj
T*
(})Tj
0 -3 TD
(void subdivide\(float *v1, float *v2, float *v3\) )Tj
0 -1.5 TD
({ )Tj
T*
(   GLfloat v12[3], v23[3], v31[3];    )Tj
T*
(   GLint i;)Tj
0 -3 TD
(   for \(i = 0; i < 3; i++\) { )Tj
0 -1.5 TD
(      v12[i] = v1[i]+v2[i]; )Tj
T*
(      v23[i] = v2[i]+v3[i];     )Tj
T*
(      v31[i] = v3[i]+v1[i];    )Tj
T*
(   } )Tj
T*
(   normalize\(v12\);    )Tj
T*
(   normalize\(v23\); )Tj
T*
(   normalize\(v31\); )Tj
T*
(   drawtriangle\(v1, v12, v31\);    )Tj
T*
(   drawtriangle\(v2, v23, v12\);    )Tj
T*
(   drawtriangle\(v3, v31, v23\);    )Tj
T*
(   drawtriangle\(v12, v23, v31\); )Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 48)Tj
ET
endstream
endobj
270 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im23 267 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
272 0 obj
<<
/Length 2560
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(for \(i = 0; i < 20; i++\) { )Tj
0 -1.5 TD
(   subdivide\(&vdata[tindices[i][0]][0],       )Tj
T*
(             &vdata[tindices[i][1]][0],       )Tj
T*
(             &vdata[tindices[i][2]][0]\); )Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Example 2-17)Tj
5.6 0 TD
[( is a slight modification of )-21(Example 2-16)170( which recursively subdivides the triangles to the)]TJ
-5.6 -1.5 TD
(proper depth. If the depth value is 0, no subdivisions are performed, and the triangle is drawn as is. If the)Tj
T*
(depth is 1, a single subdivision is performed, and so on.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 2-17 )Tj
/F11 1 Tf
6.7 0 TD
(Recursive Subdivision)Tj
/F7 1 Tf
-6.7 -2.4 TD
(void subdivide\(float *v1, float *v2, float *v3, long depth\))Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat v12[3], v23[3], v31[3];)Tj
T*
(   GLint i;)Tj
0 -3 TD
(   if \(depth == 0\) {)Tj
0 -1.5 TD
(      drawtriangle\(v1, v2, v3\);)Tj
T*
(      return;)Tj
T*
(   })Tj
T*
(   for \(i = 0; i < 3; i++\) {)Tj
T*
(      v12[i] = v1[i]+v2[i];)Tj
T*
(      v23[i] = v2[i]+v3[i];)Tj
T*
(      v31[i] = v3[i]+v1[i];)Tj
T*
(   })Tj
T*
(   normalize\(v12\);)Tj
T*
(   normalize\(v23\);)Tj
T*
(   normalize\(v31\);)Tj
T*
(   subdivide\(v1, v12, v31, depth-1\);)Tj
T*
(   subdivide\(v2, v23, v12, depth-1\);)Tj
T*
(   subdivide\(v3, v31, v23, depth-1\);)Tj
T*
(   subdivide\(v12, v23, v31, depth-1\);)Tj
T*
(})Tj
/F27 1 Tf
0 -3 TD
(Generalized Subdivision)Tj
/F11 1 Tf
0 -2.1 TD
[(A recursive subdivision technique such as the one described in )32(Example 2-17)170( can be used for other types)]TJ
0 -1.5 TD
(of surfaces. Typically, the recursion ends either if a certain depth is reached or if some condition on the)Tj
T*
(curvature is satisfied \(highly curved parts of surfaces look better with more subdivision\).)Tj
0 -2.1 TD
(To look at a more general solution to the problem of subdivision, consider an arbitrary surface)Tj
0 -1.5 TD
(parameterized by two variables )Tj
/F15 1 Tf
12.8 0 TD
(u[0])Tj
/F11 1 Tf
1.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(u[1])Tj
/F11 1 Tf
1.8 0 TD
(. Suppose that two routines are provided:)Tj
/F7 1 Tf
-18.3 -2.1 TD
(void surf\(GLfloat u[2], GLfloat vertex[3], GLfloat normal[3]\); )Tj
0 -1.5 TD
(float curv\(GLfloat u[2]\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 2,  State Management and Drawing Geometric Objects - 49)Tj
ET
endstream
endobj
273 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
275 0 obj
<<
/Length 2441
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(If )Tj
/F15 1 Tf
0.9 0 TD
(surf\(\))Tj
/F11 1 Tf
2.2 0 TD
0.000 Tw
( is passed )Tj
/F15 1 Tf
4.1 0 TD
(u[])Tj
/F11 1 Tf
1.3 0 TD
(, the corresponding three-dimensional vertex and normal vectors \(of length 1\) are)Tj
-8.5 -1.5 TD
(returned. If )Tj
/F15 1 Tf
4.7 0 TD
(u[])Tj
/F11 1 Tf
1.3 0 TD
( is passed to )Tj
/F15 1 Tf
5.1 0 TD
(curv\(\))Tj
/F11 1 Tf
2.5 0 TD
(, the curvature of the surface at that point is calculated and returned.)Tj
-13.6 -1.5 TD
(\(See an introductory textbook on differential geometry for more information about measuring surface)Tj
T*
(curvature.\))Tj
0 -2.1 TD
(Example 2-18)Tj
5.6 0 TD
( shows the recursive routine that subdivides a triangle either until the maximum depth is)Tj
-5.6 -1.5 TD
(reached or until the maximum curvature at the three vertices is less than some cutoff.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 2-18 )Tj
/F11 1 Tf
6.7 0 TD
(Generalized Subdivision)Tj
/F7 1 Tf
-6.7 -2.4 TD
(void subdivide\(float u1[2], float u2[2], float u3[2],)Tj
0 -1.5 TD
(                float cutoff, long depth\))Tj
T*
({)Tj
T*
(   GLfloat v1[3], v2[3], v3[3], n1[3], n2[3], n3[3];)Tj
T*
(   GLfloat u12[2], u23[2], u32[2];)Tj
T*
(   GLint i;)Tj
0 -3 TD
(   if \(depth == maxdepth || \(curv\(u1\) < cutoff &&)Tj
0 -1.5 TD
(       curv\(u2\) < cutoff && curv\(u3\) < cutoff\)\) {)Tj
T*
(      surf\(u1, v1, n1\); surf\(u2, v2, n2\); surf\(u3, v3, n3\);)Tj
T*
(      glBegin\(GL_POLYGON\);)Tj
T*
(         glNormal3fv\(n1\); glVertex3fv\(v1\);)Tj
T*
(         glNormal3fv\(n2\); glVertex3fv\(v2\);)Tj
T*
(         glNormal3fv\(n3\); glVertex3fv\(v3\);)Tj
T*
(      glEnd\(\);)Tj
T*
(      return;)Tj
T*
(   })Tj
T*
(   for \(i = 0; i < 2; i++\) {)Tj
T*
(      u12[i] = \(u1[i] + u2[i]\)/2.0;)Tj
T*
(      u23[i] = \(u2[i] + u3[i]\)/2.0;)Tj
T*
(      u31[i] = \(u3[i] + u1[i]\)/2.0;)Tj
T*
(   })Tj
T*
(   subdivide\(u1, u12, u31, cutoff, depth+1\);)Tj
T*
(   subdivide\(u2, u23, u12, cutoff, depth+1\);)Tj
T*
(   subdivide\(u3, u31, u23, cutoff, depth+1\);)Tj
T*
(   subdivide\(u12, u23, u31, cutoff, depth+1\);)Tj
T*
(})Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 162.350 m
547.000 162.350 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 50)Tj
ET
endstream
endobj
276 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
278 0 obj
<<
/Length 4241
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 3)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Viewing)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(View a )Tj
/F15 1 Tf
3.1 0 TD
(geometric model)Tj
/F11 1 Tf
6.7 0 TD
( in any orientation by transforming it in three-dimensional space)Tj
/F33 1 Tf
-11.6 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Control the location in three-dimensional space from which the model is viewed)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Clip undesired portions of the model out of the scene that's to be viewed)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Manipulate the appropriate matrix stacks that control model transformation for viewing and project)Tj
0 -1.6 TD
(the model onto the screen)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Combine multiple transformations to mimic sophisticated systems in motion, such as a solar system)Tj
0 -1.6 TD
(or an articulated robot arm)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Reverse or mimic the operations of the geometric processing pipeline)Tj
-1.9 -2.8 TD
[(Chapter 2)16( explained how to instruct OpenGL to draw the geometric models you want displayed in your)]TJ
0 -1.5 TD
(scene. Now you must decide how you want to position the models in the scene, and you must choose a)Tj
T*
(vantage point from which to view the scene. You can use the default positioning and vantage point, but)Tj
T*
(most likely you want to specify them.)Tj
0 -2.1 TD
(Look at the image on the cover of this book. The program that produced that image contained a single)Tj
0 -1.5 TD
(geometric description of a building block. Each block was carefully positioned in the scene: Some blocks)Tj
T*
(were scattered on the floor, some were stacked on top of each other on the table, and some were)Tj
T*
(assembled to make the globe. Also, a particular viewpoint had to be chosen. Obviously, we wanted to)Tj
0 -1.6 TD
(look at the corner of the room containing the globe. But how far away from the scene)Tj
/F33 1 Tf
34.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(and where)Tj
-35.1 -1.7 TD
(exactly)Tj
/F33 1 Tf
2.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(should the viewer be? We wanted to make sure that the final image of the scene contained a)Tj
-3.9 -1.6 TD
(good view out the window, that a portion of the floor was visible, and that all the objects in the scene)Tj
0 -1.5 TD
(were not only visible but presented in an interesting arrangement. This chapter explains how to use)Tj
T*
(OpenGL to accomplish these tasks: how to position and orient models in three-dimensional space and)Tj
0 -1.6 TD
(how to establish the location)Tj
/F33 1 Tf
11.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(also in three-dimensional space)Tj
/F33 1 Tf
12.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(of the viewpoint. All of these factors)Tj
-26 -1.6 TD
(help determine exactly what image appears on the screen.)Tj
0 -2.1 TD
(You want to remember that the point of computer graphics is to create a two-dimensional image of)Tj
0 -1.5 TD
(three-dimensional objects \(it has to be two-dimensional because it's drawn on a flat screen\), but you need)Tj
T*
(to think in three-dimensional coordinates while making many of the decisions that determine what gets)Tj
T*
(drawn on the screen. A common mistake people make when creating three-dimensional graphics is to)Tj
T*
(start thinking too soon that the final image appears on a flat, two-dimensional screen. Avoid thinking)Tj
T*
(about which pixels need to be drawn, and instead try to visualize three-dimensional space. Create your)Tj
T*
(models in some three-dimensional universe that lies deep inside your computer, and let the computer do)Tj
T*
(its job of calculating which pixels to color.)Tj
0 -2.1 TD
(A series of three computer operations convert an object's three-dimensional coordinates to pixel)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 1)Tj
ET
endstream
endobj
279 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
281 0 obj
<<
/Length 4024
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(positions on the screen.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Transformations, which are represented by matrix multiplication, include modeling, viewing, and)Tj
0 -1.6 TD
(projection operations. Such operations include rotation, translation, scaling, reflecting, orthographic)Tj
0 -1.5 TD
(projection, and perspective projection. Generally, you use a combination of several transformations)Tj
T*
(to draw a scene.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Since the scene is rendered on a rectangular window, objects \(or parts of objects\) that lie outside the)Tj
0 -1.6 TD
(window must be clipped. In three-dimensional computer graphics, clipping occurs by throwing out)Tj
0 -1.5 TD
(objects on one side of a clipping plane.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Finally, a correspondence must be established between the transformed coordinates and screen)Tj
0 -1.6 TD
(pixels. This is known as a )Tj
/F15 1 Tf
10.6 0 TD
(viewport)Tj
/F11 1 Tf
3.5 0 TD
( transformation.)Tj
-16 -2.7 TD
(This chapter describes all of these operations, and how to control them, in the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Overview: The Camera Analogy" gives an overview of the transformation process by describing)Tj
0 -1.5 TD
(the analogy of taking a photograph with a camera, presents a simple example program that)Tj
T*
(transforms an object, and briefly describes the basic OpenGL transformation commands.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Viewing and Modeling Transformations")-45( explains in detail how to specify and to imagine the effect)]TJ
0 -1.5 TD
(of viewing and modeling transformations. These transformations orient the model and the camera)Tj
T*
(relative to each other to obtain the desired final image.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Projection Transformations")-12( describes how to specify the shape and orientation of the )]TJ
/F15 1 Tf
35 0 TD
(viewing)Tj
-35 -1.6 TD
(volume)Tj
/F11 1 Tf
2.9 0 TD
(. The viewing volume determines how a scene is projected onto the screen \(with a)Tj
-2.9 -1.5 TD
(perspective or orthographic projection\) and which objects or parts of objects are clipped out of the)Tj
T*
(scene.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Viewport Transformation")-35( explains how to control the conversion of three-dimensional model)]TJ
0 -1.6 TD
(coordinates to screen coordinates.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Troubleshooting Transformations")-11( presents some tips for discovering why you might not be getting)]TJ
0 -1.6 TD
(the desired effect from your modeling, viewing, projection, and viewport transformations.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Manipulating the Matrix Stacks")12( discusses how to save and restore certain transformations. This is)]TJ
0 -1.6 TD
(particularly useful when you're drawing complicated objects that are built up from simpler ones.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Additional Clipping Planes")7( describes how to specify additional clipping planes beyond those)]TJ
0 -1.6 TD
(defined by the viewing volume.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Examples of Composing Several Transformations")16( walks you through a couple of more)]TJ
0 -1.6 TD
(complicated uses for transformations.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Reversing or Mimicking Transformations")11( shows you how to take a transformed point in window)]TJ
0 -1.5 TD
(coordinates and reverse the transformation to obtain its original object coordinates. The)Tj
T*
(transformation itself \(without reversal\) can also be emulated.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 2)Tj
ET
endstream
endobj
282 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
285 0 obj
<<
/Length 1277
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Overview: The Camera Analogy)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 685.000 Tm
(The transformation process to produce the desired scene for viewing is analogous to taking a photograph)Tj
0 -1.5 TD
[(with a camera. As shown in )-40(Figure 3-1)225(, the steps with a camera \(or a computer\) might be the following.)]TJ
0 -2.1 TD
[(1.)-1050(Set up your tripod and pointing the camera at the scene \(viewing transformation\).)]TJ
T*
[(2.)-1050(Arrange the scene to be photographed into the desired composition \(modeling transformation\).)]TJ
T*
[(3.)-1050(Choose a camera lens or adjust the zoom \(projection transformation\).)]TJ
0 -2.3 TD
[(4.)-1050(Determine how large you want the final photograph to be)]TJ
/F33 1 Tf
24.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, you might want it enlarged)Tj
-24 -1.5 TD
(\(viewport transformation\).)Tj
-1.8 -2.6 TD
(After these steps are performed, the picture can be snapped or the scene can be drawn.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 3)Tj
ET
endstream
endobj
286 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
287 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im24
/Width 408
/Height 656
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.23)
>>
stream
endstream
endobj
289 0 obj
<<
/Length 198
>>
stream
/GS1 gs
q
403 0 0 648 124 72 cm
/Im24 Do
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 4)Tj
ET
endstream
endobj
290 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
>>
/XObject <<
/Im24 287 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
291 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im25
/Width 526
/Height 200
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.24)
>>
stream
endstream
endobj
293 0 obj
<<
/Length 4408
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 3-1 )Tj
/F11 1 Tf
5.1 0 TD
(The Camera Analogy)Tj
-5.1 -2.1 TD
(Note that these steps correspond to the order in which you specify the desired transformations in your)Tj
0 -1.5 TD
(program, not necessarily the order in which the relevant mathematical operations are performed on an)Tj
T*
(object's vertices. The viewing transformations must precede the modeling transformations in your code,)Tj
T*
(but you can specify the projection and viewport transformations at any point before drawing occurs.)Tj
T*
[(Figure 3-2)225( shows the order in which these operations occur on your computer.)]TJ
ET
Q
q
1 i 
124.000 612.010 423.000 -160.830 re
W n
/GS1 gs
q
423 0 0 161 124 451.01 cm
/Im25 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 438.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 3-2 )Tj
/F11 1 Tf
5.1 0 TD
(Stages of Vertex Transformation)Tj
-5.1 -2.2 TD
(To specify viewing, modeling, and projection transformations, you construct a 4)Tj
/F33 1 Tf
32.1 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(4 matrix )Tj
/F15 1 Tf
3.6 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
(, which is)Tj
-37.1 -1.6 TD
(then multiplied by the coordinates of each vertex )Tj
/F15 1 Tf
19.8 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( in the scene to accomplish the transformation)Tj
/F15 1 Tf
-20.3 -2 TD
(v'=Mv)Tj
/F11 1 Tf
0 -2.1 TD
(\(Remember that vertices always have four coordinates \()Tj
/F15 1 Tf
22.4 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.4 0 TD
(\), though in most cases )Tj
/F15 1 Tf
9.4 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( is 1 and for)Tj
-35.9 -1.5 TD
(two-dimensional data )Tj
/F15 1 Tf
8.9 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( is 0.\) Note that viewing and modeling transformations are automatically applied)Tj
-9.3 -1.6 TD
(to surface normal vectors, in addition to vertices. \(Normal vectors are used only in )Tj
/F13 1 Tf
33.2 0 TD
(eye coordinates)Tj
/F11 1 Tf
6.6 0 TD
(.\))Tj
-39.8 -1.5 TD
(This ensures that the normal vector's relationship to the vertex data is properly preserved.)Tj
0 -2.1 TD
(The viewing and modeling transformations you specify are combined to form the modelview matrix,)Tj
0 -1.5 TD
(which is applied to the incoming )Tj
/F13 1 Tf
13.3 0 TD
(object coordinates)Tj
/F11 1 Tf
7.8 0 TD
( to yield eye coordinates. Next, if you've specified)Tj
-21.1 -1.5 TD
(additional clipping planes to remove certain objects from the scene or to provide cutaway views of)Tj
T*
(objects, these clipping planes are applied.)Tj
0 -2.1 TD
(After that, OpenGL applies the projection matrix to yield )Tj
/F15 1 Tf
23.1 0 TD
(clip coordinates)Tj
/F11 1 Tf
6.5 0 TD
(. This transformation defines a)Tj
-29.6 -1.5 TD
(viewing volume; objects outside this volume are clipped so that they're not drawn in the final scene.)Tj
T*
(After this point, the )Tj
/F13 1 Tf
8.1 0 TD
(perspective division)Tj
/F11 1 Tf
8.4 0 TD
( is performed by dividing coordinate values by )Tj
/F15 1 Tf
18.9 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(, to produce)Tj
/F15 1 Tf
-36.1 -1.5 TD
(normalized device coordinates)Tj
/F11 1 Tf
12.3 0 TD
[(. \(See )27(Appendix F)-49( for more information about the meaning of the )]TJ
/F15 1 Tf
26.4 0 TD
(w)Tj
/F11 1 Tf
-38.7 -1.5 TD
(coordinate and how it affects matrix transformations.\) Finally, the transformed coordinates are converted)Tj
0 -1.6 TD
(to )Tj
/F13 1 Tf
1 0 TD
(window coordinates)Tj
/F11 1 Tf
8.6 0 TD
( by applying the viewport transformation. You can manipulate the dimensions of)Tj
-9.6 -1.5 TD
(the viewport to cause the final image to be enlarged, shrunk, or stretched.)Tj
0 -2.1 TD
(You might correctly suppose that the )Tj
/F15 1 Tf
15.1 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
( coordinates are sufficient to determine which pixels need to)Tj
-17.9 -1.5 TD
(be drawn on the screen. However, all the transformations are performed on the )Tj
/F15 1 Tf
31.7 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinates as well.)Tj
-32.1 -1.5 TD
(This way, at the end of this transformation process, the )Tj
/F15 1 Tf
22.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( values correctly reflect the depth of a given)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 5)Tj
ET
endstream
endobj
294 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im25 291 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
295 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im26
/Width 99
/Height 100
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.25)
>>
stream
endstream
endobj
297 0 obj
<<
/Length 2962
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(vertex \(measured in distance away from the screen\). One use for this depth value is to eliminate)Tj
0 -1.5 TD
(unnecessary drawing. For example, suppose two vertices have the same )Tj
/F15 1 Tf
28.9 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
( values but different )Tj
/F15 1 Tf
8.2 0 TD
(z)Tj
/F11 1 Tf
-40 -1.5 TD
(values. OpenGL can use this information to determine which surfaces are obscured by other surfaces and)Tj
T*
[(can then avoid drawing the hidden surfaces. \(See )-42(Chapter 10)16( for more information about this technique,)]TJ
T*
(which is called )Tj
/F15 1 Tf
6.2 0 TD
(hidden-surface removal)Tj
/F11 1 Tf
9.6 0 TD
(.\))Tj
-15.8 -2.1 TD
(As you've probably guessed by now, you need to know a few things about matrix mathematics to get the)Tj
0 -1.5 TD
(most out of this chapter. If you want to brush up on your knowledge in this area, you might consult a)Tj
T*
(textbook on linear algebra.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 571.000 Tm
(A Simple Example: Drawing a Cube)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 550.000 Tm
(Example 3-1)Tj
5.1 0 TD
[( draws a cube that's scaled by a modeling transformation \(see )14(Figure 3-3)225(\). The viewing)]TJ
-5.1 -1.5 TD
(transformation, )Tj
/F15 1 Tf
6.4 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
(, positions and aims the camera towards where the cube is drawn. A)Tj
-11.2 -1.5 TD
(projection transformation and a viewport transformation are also specified. The rest of this section walks)Tj
T*
[(you through )12(Example 3-1)]TJ
10.2 0 TD
( and briefly explains the transformation commands it uses. The succeeding)Tj
-10.2 -1.5 TD
(sections contain the complete, detailed discussion of all OpenGL's transformation commands.)Tj
ET
Q
/GS1 gs
q
99 0 0 100 124 375.57 cm
/Im26 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 363.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-3 )Tj
/F11 1 Tf
5.1 0 TD
(Transformed Cube)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 3-1 )Tj
/F11 1 Tf
6.1 0 TD
(Transformed Cube: cube.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
0 -3 TD
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear \(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
T*
(   glLoadIdentity \(\);             /* clear the matrix */)Tj
T*
(           /* viewing transformation  */)Tj
T*
(   gluLookAt \(0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 6)Tj
ET
endstream
endobj
298 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im26 295 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
300 0 obj
<<
/Length 2923
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glScalef \(1.0, 2.0, 1.0\);      /* modeling transformation */ )Tj
0 -1.5 TD
(   glutWireCube \(1.0\);)Tj
T*
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\); )Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   glFrustum \(-1.0, 1.0, -1.0, 1.0, 1.5, 20.0\);)Tj
T*
(   glMatrixMode \(GL_MODELVIEW\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
0 -3 TD
(The Viewing Transformation)Tj
/F11 1 Tf
0 -2.1 TD
(Recall that the viewing transformation is analogous to positioning and aiming a camera. In this code)Tj
0 -1.6 TD
(example, before the viewing transformation can be specified, the )Tj
/F13 1 Tf
26.2 0 TD
(current matrix)Tj
/F11 1 Tf
6.3 0 TD
( is set to the identity)Tj
-32.5 -1.5 TD
(matrix with  )Tj
/F15 1 Tf
5.1 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
(. This step is necessary since most of the transformation commands)Tj
-11.7 -1.5 TD
(multiply the current matrix by the specified matrix and then set the result to be the current matrix. If you)Tj
T*
(don't clear the current matrix by loading it with the identity matrix, you continue to combine previous)Tj
T*
(transformation matrices with the new one you supply. In some cases, you do want to perform such)Tj
T*
(combinations, but you also need to clear the matrix sometimes.)Tj
0 -2.1 TD
0.017 Tw
[(In Example )17(3-1)]TJ
6.2 0 TD
0.000 Tw
(, after the matrix is initialized, the viewing transformation is specified with )Tj
/F15 1 Tf
30.2 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
(.)Tj
-41.3 -1.5 TD
(The arguments for this command indicate where the camera \(or eye position\) is placed, where it is aimed,)Tj
T*
(and which way is up. The arguments used here place the camera at \(0, 0, 5\), aim the camera lens towards)Tj
T*
(\(0, 0, 0\), and specify the )Tj
/F13 1 Tf
10 0 TD
(up-vector)Tj
/F11 1 Tf
4.1 0 TD
( as \(0, 1, 0\). The up-vector defines a unique orientation for the)Tj
-14.1 -1.5 TD
(camera.)Tj
0 -2.1 TD
(If )Tj
/F15 1 Tf
0.9 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
( was not called, the camera has a default position and orientation. By default, the camera is)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 7)Tj
ET
endstream
endobj
301 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
303 0 obj
<<
/Length 5098
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(situated at the origin, points down the negative )Tj
/F15 1 Tf
19 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis, and has an up-vector of \(0, 1, 0\). So in )Tj
18 0 TD
(Example)Tj
-37.4 -1.5 TD
(3-1)Tj
1.3 0 TD
(, the overall effect is that )Tj
/F15 1 Tf
10.2 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
( moves the camera 5 units along the z-axis. \(See )Tj
19.5 0 TD
("Viewing and)Tj
-35.9 -1.5 TD
[(Modeling Transformations")-42( for more information about viewing transformations.\))]TJ
/F27 1 Tf
0 -3 TD
(The Modeling Transformation)Tj
/F11 1 Tf
0 -2.1 TD
(You use the modeling transformation to position and orient the model. For example, you can rotate,)Tj
0 -1.6 TD
(translate, or scale the model)Tj
/F33 1 Tf
11.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(or perform some combination of these operations. In Example 3-1)Tj
26.4 0 TD
(,)Tj
/F15 1 Tf
-38.6 -1.6 TD
(glScalef\(\))Tj
/F11 1 Tf
3.9 0 TD
( is the modeling transformation that is used. The arguments for this command specify how)Tj
-3.9 -1.5 TD
(scaling should occur along the three axes. If all the arguments are 1.0, this command has no effect. In)Tj
T*
(Example 3-1)Tj
5.1 0 TD
(, the cube is drawn twice as large in the )Tj
/F15 1 Tf
16.1 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( direction. Thus, if one corner of the cube had)Tj
-21.6 -1.5 TD
(originally been at \(3.0, 3.0, 3.0\), that corner would wind up being drawn at \(3.0, 6.0, 3.0\). The effect of)Tj
T*
(this modeling transformation is to transform the cube so that it isn't a cube but a rectangular box.)Tj
/F27 1 Tf
8 -2.1 TD
(Try This)Tj
/F11 1 Tf
-8 -2.2 TD
(Change the )Tj
/F15 1 Tf
4.8 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
[( call in )-28(Example 3-1)]TJ
8.1 0 TD
( to the modeling transformation )Tj
/F15 1 Tf
12.9 0 TD
(glTranslatef\(\) )Tj
/F11 1 Tf
5.8 0 TD
(with)Tj
-36.4 -1.5 TD
(parameters \(0.0, 0.0, -5.0\). The result should look exactly the same as when you used )Tj
/F15 1 Tf
34.4 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
(. Why)Tj
-39.2 -1.5 TD
(are the effects of these two commands similar?)Tj
0 -2.1 TD
(Note that instead of moving the camera \(with a viewing transformation\) so that the cube could be)Tj
0 -1.5 TD
(viewed, you could have moved the cube away from the camera \(with a modeling transformation\). This)Tj
T*
(duality in the nature of viewing and modeling transformations is why you need to think about the effect)Tj
T*
(of both types of transformations simultaneously. It doesn't make sense to try to separate the effects, but)Tj
T*
(sometimes it's easier to think about them one way rather than the other. This is also why modeling and)Tj
T*
(viewing transformations are combined into the )Tj
/F15 1 Tf
18.9 0 TD
(modelview matrix)Tj
/F11 1 Tf
7.2 0 TD
( before the transformations are applied.)Tj
-26.1 -1.5 TD
[(\(See )27("Viewing and Modeling Transformations")-45( for more detail on how to think about modeling and)]TJ
T*
(viewing transformations and how to specify them to get the result you want.\))Tj
0 -2.1 TD
(Also note that the modeling and viewing transformations are included in the )Tj
/F15 1 Tf
30.7 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
( routine, along with)Tj
-34.3 -1.5 TD
(the call that's used to draw the cube, )Tj
/F15 1 Tf
14.9 0 TD
(glutWireCube\(\))Tj
/F11 1 Tf
6.2 0 TD
(. This way, )Tj
/F15 1 Tf
4.7 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
( can be used repeatedly to draw)Tj
-29.4 -1.5 TD
(the contents of the window if, for example, the window is moved or uncovered, and you've ensured that)Tj
T*
(each time, the cube is drawn in the desired way, with the appropriate transformations. The potential)Tj
T*
(repeated use of )Tj
/F15 1 Tf
6.3 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
( underscores the need to load the identity matrix before performing the viewing)Tj
-9.9 -1.5 TD
(and modeling transformations, especially when other transformations might be performed between calls)Tj
T*
(to )Tj
/F15 1 Tf
1 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
(.)Tj
/F27 1 Tf
-4.6 -2.9 TD
(The Projection Transformation)Tj
/F11 1 Tf
0 -2.2 TD
(Specifying the projection transformation is like choosing a lens for a camera. You can think of this)Tj
0 -1.5 TD
(transformation as determining what the field of view or viewing volume is and therefore what objects are)Tj
T*
(inside it and to some extent how they look. This is equivalent to choosing among wide-angle, normal,)Tj
T*
(and telephoto lenses, for example. With a wide-angle lens, you can include a wider scene in the final)Tj
T*
(photograph than with a telephoto lens, but a telephoto lens allows you to photograph objects as though)Tj
T*
(they're closer to you than they actually are. In computer graphics, you don't have to pay $10,000 for a)Tj
T*
(2000-millimeter telephoto lens; once you've bought your graphics workstation, all you need to do is use)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 8)Tj
ET
endstream
endobj
304 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
306 0 obj
<<
/Length 5115
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(a smaller number for your field of view.)Tj
0 -2.1 TD
(In addition to the field-of-view considerations, the projection transformation determines how objects are)Tj
/F15 1 Tf
0 -1.5 TD
(projected)Tj
/F11 1 Tf
3.8 0 TD
( onto the screen, as its name suggests. Two basic types of projections are provided for you by)Tj
-3.8 -1.5 TD
(OpenGL, along with several corresponding commands for describing the relevant parameters in different)Tj
T*
(ways. One type is the )Tj
/F15 1 Tf
8.8 0 TD
(perspective)Tj
/F11 1 Tf
4.6 0 TD
( projection, which matches how you see things in daily life. Perspective)Tj
-13.4 -1.5 TD
(makes objects that are farther away appear smaller; for example, it makes railroad tracks appear to)Tj
T*
(converge in the distance. If you're trying to make realistic pictures, you'll want to choose perspective)Tj
T*
(projection, which is specified with the )Tj
/F15 1 Tf
15.5 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.9 0 TD
( command in this code example.)Tj
-20.4 -2.1 TD
(The other type of projection is )Tj
/F13 1 Tf
12.4 0 TD
(orthographic)Tj
/F11 1 Tf
5.6 0 TD
(, which maps objects directly onto the screen without)Tj
-18 -1.5 TD
(affecting their relative size. Orthographic projection is used in architectural and computer-aided design)Tj
T*
(applications where the final image needs to reflect the measurements of objects rather than how they)Tj
T*
(might look. Architects create perspective drawings to show how particular buildings or interior spaces)Tj
T*
(look when viewed from various vantage points; the need for orthographic projection arises when)Tj
T*
(blueprint plans or elevations are generated, which are used in the construction of buildings. \(See)Tj
T*
[("Projection Transformations")-12( for a discussion of ways to specify both kinds of projection)]TJ
T*
(transformations.\))Tj
0 -2.1 TD
(Before )Tj
/F15 1 Tf
3 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
( can be called to set the projection transformation, some preparation needs to happen.)Tj
-7.8 -1.5 TD
(As shown in the )Tj
/F15 1 Tf
6.7 0 TD
(reshape\(\))Tj
/F11 1 Tf
3.9 0 TD
[( routine in )62(Example 3-1)170(, the command called )]TJ
/F15 1 Tf
18.3 0 TD
(glMatrixMode\(\))Tj
/F11 1 Tf
6.4 0 TD
( is used first,)Tj
-35.3 -1.5 TD
(with the argument GL_PROJECTION. This indicates that the current matrix specifies the projection)Tj
0 -1.6 TD
(transformation; the following transformation calls then affect the )Tj
/F13 1 Tf
26.2 0 TD
(projection matrix)Tj
/F11 1 Tf
7.5 0 TD
(. As you can see, a)Tj
-33.7 -1.5 TD
(few lines later )Tj
/F15 1 Tf
5.9 0 TD
(glMatrixMode\(\))Tj
/F11 1 Tf
6.5 0 TD
( is called again, this time with GL_MODELVIEW as the argument. This)Tj
-12.4 -1.5 TD
(indicates that succeeding transformations now affect the modelview matrix instead of the projection)Tj
T*
[(matrix. \(See )39("Manipulating the Matrix Stacks")12( for more information about how to control the projection)]TJ
T*
(and modelview matrices.\))Tj
0 -2.1 TD
(Note that )Tj
/F15 1 Tf
3.9 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( is used to initialize the current projection matrix so that only the specified)Tj
-10.5 -1.5 TD
(projection transformation has an effect. Now )Tj
/F15 1 Tf
18.2 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
( can be called, with arguments that define the)Tj
-23 -1.5 TD
(parameters of the projection transformation. In this example, both the projection transformation and the)Tj
T*
(viewport transformation are contained in the )Tj
/F15 1 Tf
18.1 0 TD
(reshape\(\))Tj
/F11 1 Tf
3.8 0 TD
( routine, which is called when the window is first)Tj
-21.9 -1.5 TD
(created and whenever the window is moved or reshaped. This makes sense, since both projecting \(the)Tj
T*
(width to height aspect ratio of the projection viewing volume\) and applying the viewport relate directly)Tj
T*
(to the screen, and specifically to the size or aspect ratio of the window on the screen.)Tj
/F27 1 Tf
8 -2.1 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
(Change the )Tj
/F15 1 Tf
4.8 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
[( call in )-28(Example 3-1)]TJ
8.1 0 TD
( to the more commonly used Utility Library routine)Tj
/F15 1 Tf
-17.7 -1.5 TD
(gluPerspective\(\) )Tj
/F11 1 Tf
6.9 0 TD
(with parameters \(60.0, 1.0, 1.5, 20.0\). Then experiment with different values, especially)Tj
-6.9 -1.5 TD
(for )Tj
/F15 1 Tf
1.4 0 TD
(fovy)Tj
/F11 1 Tf
1.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(aspect)Tj
/F11 1 Tf
2.6 0 TD
(.)Tj
/F27 1 Tf
-7.6 -3 TD
(The Viewport Transformation)Tj
/F11 1 Tf
0 -2.1 TD
(Together, the projection transformation and the viewport transformation determine how a scene gets)Tj
0 -1.5 TD
(mapped onto the computer screen. The projection transformation specifies the mechanics of how the)Tj
T*
(mapping should occur, and the viewport indicates the shape of the available screen area into which the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 9)Tj
ET
endstream
endobj
307 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
309 0 obj
<<
/Length 5092
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(scene is mapped. Since the viewport specifies the region the image occupies on the computer screen, you)Tj
0 -1.5 TD
(can think of the viewport transformation as defining the size and location of the final processed)Tj
0 -1.6 TD
(photograph)Tj
/F33 1 Tf
4.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, whether the photograph should be enlarged or shrunk.)Tj
-5.6 -2.3 TD
(The arguments to )Tj
/F15 1 Tf
7.2 0 TD
(glViewport\(\))Tj
/F11 1 Tf
5.2 0 TD
( describe the origin of the available screen space within the window)Tj
/F33 1 Tf
27.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(\(0,)Tj
-40.5 -1.7 TD
(0\) in this example)Tj
/F33 1 Tf
7.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(and the width and height of the available screen area, all measured in pixels on the)Tj
-8.2 -1.7 TD
(screen. This is why this command needs to be called within )Tj
/F15 1 Tf
24.1 0 TD
(reshape\(\))Tj
/F33 1 Tf
3.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(if the window changes size, the)Tj
-28.9 -1.5 TD
(viewport needs to change accordingly. Note that the width and height are specified using the actual width)Tj
T*
(and height of the window; often, you want to specify the viewport this way rather than giving an absolute)Tj
T*
[(size. \(See )-18("Viewport Transformation")65( for more information about how to define the viewport.\))]TJ
/F27 1 Tf
0 -3 TD
(Drawing the Scene)Tj
/F11 1 Tf
0 -2.1 TD
(Once all the necessary transformations have been specified, you can draw the scene \(that is, take the)Tj
0 -1.5 TD
(photograph\). As the scene is drawn, OpenGL transforms each vertex of every object in the scene by the)Tj
T*
(modeling and viewing transformations. Each vertex is then transformed as specified by the projection)Tj
T*
(transformation and clipped if it lies outside the viewing volume described by the projection)Tj
T*
(transformation. Finally, the remaining transformed vertices are divided by )Tj
/F15 1 Tf
29.9 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( and mapped onto the)Tj
-30.6 -1.5 TD
(viewport.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 423.000 Tm
(General-Purpose Transformation Commands)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 401.000 Tm
(This section discusses some OpenGL commands that you might find useful as you specify desired)Tj
T*
(transformations. You've already seen a couple of these commands, )Tj
/F15 1 Tf
27.1 0 TD
(glMatrixMode\(\))Tj
/F11 1 Tf
6.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.5 0 TD
(.)Tj
-42 -1.6 TD
(The other two commands described here)Tj
/F33 1 Tf
16.2 0 TD
(\276)Tj
/F15 1 Tf
1 0 TD
(glLoadMatrix*\(\))Tj
/F11 1 Tf
6.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glMultMatrix*\(\))Tj
/F33 1 Tf
6.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(allow you to specify)Tj
-33.5 -1.6 TD
(any transformation matrix directly and then to multiply the current matrix by that specified matrix. More)Tj
T*
(specific transformation commands)Tj
/F33 1 Tf
13.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(such as )Tj
/F15 1 Tf
3.2 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glScale*\(\))Tj
/F33 1 Tf
4.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(are described in later sections.)Tj
-29.9 -2.1 TD
(As described in the preceding section, you need to state whether you want to modify the modelview or)Tj
0 -1.5 TD
(projection matrix before supplying a transformation command. You choose the matrix with)Tj
/F15 1 Tf
T*
(glMatrixMode\(\))Tj
/F11 1 Tf
6.4 0 TD
(. When you use nested sets of OpenGL commands that might be called repeatedly,)Tj
-6.4 -1.5 TD
(remember to reset the matrix mode correctly. \(The )Tj
/F15 1 Tf
20.5 0 TD
(glMatrixMode\(\))Tj
/F11 1 Tf
6.4 0 TD
( command can also be used to)Tj
-26.9 -1.6 TD
(indicate the )Tj
/F13 1 Tf
4.9 0 TD
(texture matrix)Tj
/F11 1 Tf
6.2 0 TD
[(; texturing is discussed in detail in )19("The Texture Matrix Stack" in Chapter 9)-29(.)0(\))]TJ
/F15 1 Tf
-11.1 -2.1 TD
0.028 Tw
[(void glMatrixMode)78(\(GLenum )-45(mode)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Specifies whether the modelview, projection, or texture matrix will be modified, using the argument)Tj
T*
[(GL_MODELVIEW, GL_PROJECTION, or GL_TEXTURE for mode)-34(. Subsequent transformation)]TJ
T*
(commands affect the specified matrix. Note that only one matrix can be modified at a time. By)Tj
T*
(default, the modelview matrix is the one that's modifiable, and all three matrices contain the identity)Tj
T*
(matrix.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(You use the )Tj
/F15 1 Tf
5 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( command to clear the currently modifiable matrix for future transformation)Tj
-11.6 -1.5 TD
(commands, since these commands modify the current matrix. Typically, you always call this command)Tj
T*
(before specifying projection or viewing transformations, but you might also call it before specifying a)Tj
T*
(modeling transformation.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 10)Tj
ET
endstream
endobj
310 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
311 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im27
/Width 162
/Height 92
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.26)
>>
stream
endstream
endobj
313 0 obj
<<
/Length 4820
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.028 Tw
[(void glLoadIdentity)-10(\(void\);)]TJ
1.8 -1.6 TD
0.000 Tw
(Sets the currently modifiable matrix to the 4)Tj
/F33 1 Tf
17.6 0 TD
(\264)Tj
/F15 1 Tf
0.6 0 TD
(4 identity matrix.)Tj
/F11 1 Tf
-20 -2.2 TD
(If you want to specify explicitly a particular matrix to be loaded as the current matrix, use)Tj
/F15 1 Tf
0 -1.5 TD
(glLoadMatrix*\(\))Tj
/F11 1 Tf
6.7 0 TD
(. Similarly, use )Tj
/F15 1 Tf
6.3 0 TD
(glMultMatrix*\(\))Tj
/F11 1 Tf
6.6 0 TD
( to multiply the current matrix by the matrix passed in as)Tj
-19.6 -1.5 TD
(an argument. The argument for both these commands is a vector of sixteen values \()Tj
/F15 1 Tf
33.3 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
(1, )Tj
/F15 1 Tf
1 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
(2, ... , )Tj
/F15 1 Tf
2.5 0 TD
(m)Tj
/F11 1 Tf
0.8 0 TD
(16\) that)Tj
-39 -1.5 TD
(specifies a matrix )Tj
/F15 1 Tf
7.3 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
( as follows:)Tj
ET
Q
/GS1 gs
q
162 0 0 92 124 521.97 cm
/Im27 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 503.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Remember that you might be able to maximize efficiency by using display lists to store frequently used)Tj
0 -1.5 TD
(matrices \(and their inverses\) rather than recomputing them. \(See "Display-List Design Philosophy" in)Tj
T*
[(Chapter 7)16(.\) \(OpenGL implementations often must compute the inverse of the modelview matrix so that)]TJ
T*
(normals and clipping planes can be correctly transformed to eye coordinates.\))Tj
/F27 1 Tf
0 -2.1 TD
[(Caution)22(: )]TJ
/F11 1 Tf
4.3 0 TD
(If you're programming in C and you declare a matrix as )Tj
/F15 1 Tf
22.7 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
([4][4], then the element )Tj
/F15 1 Tf
9.7 0 TD
(m[i][j])Tj
/F11 1 Tf
2.8 0 TD
( is in)Tj
-40.2 -1.4 TD
(the )Tj
/F15 1 Tf
1.5 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
(th column and )Tj
/F15 1 Tf
5.9 0 TD
(j)Tj
/F11 1 Tf
0.3 0 TD
(th row of the OpenGL transformation matrix. This is the reverse of the standard C)Tj
-8 -1.4 TD
(convention in which )Tj
/F15 1 Tf
8.4 0 TD
(m[i][j])Tj
/F11 1 Tf
2.9 0 TD
( is in row )Tj
/F15 1 Tf
4 0 TD
(i)Tj
/F11 1 Tf
0.2 0 TD
( and column)Tj
/F15 1 Tf
5 0 TD
( j)Tj
/F11 1 Tf
0.5 0 TD
(. To avoid confusion, you should declare your)Tj
-21 -1.5 TD
(matrices as )Tj
/F15 1 Tf
4.7 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
([16].)Tj
/F15 1 Tf
-5.4 -2.1 TD
0.028 Tw
[(void glLoadMatrix)57({fd}\(const TYPE)34( )28(*)-50(m)22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Sets the sixteen values of the current matrix to those specified by )11(m)22(.)]TJ
-1.8 -2.1 TD
0.028 Tw
[(void glMultMatrix)-10({fd}\(const )100(TYPE)-66( )28(*)50(m)22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Multiplies the matrix specified by the sixteen values pointed to by )17(m)22( by the current matrix and stores)]TJ
T*
(the result as the current matrix.)Tj
/F27 1 Tf
-1.8 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(All matrix multiplication with OpenGL occurs as follows: Suppose the current matrix is )Tj
/F15 1 Tf
35.5 0 TD
(C)Tj
/F11 1 Tf
0.7 0 TD
( and the)Tj
-39 -1.4 TD
(matrix specified with )Tj
/F15 1 Tf
8.7 0 TD
(glMultMatrix*\(\))Tj
/F11 1 Tf
6.6 0 TD
( or any of the transformation commands is )Tj
/F15 1 Tf
17.2 0 TD
(M)Tj
/F11 1 Tf
0.9 0 TD
(. After multiplication,)Tj
-33.4 -1.4 TD
(the final matrix is always )Tj
/F15 1 Tf
10.4 0 TD
(CM)Tj
/F11 1 Tf
1.5 0 TD
(. Since matrix multiplication isn't generally commutative, the order makes)Tj
-11.9 -1.4 TD
(a difference.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 210.000 Tm
(Viewing and Modeling Transformations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 188.000 Tm
(Viewing and modeling transformations are inextricably related in OpenGL and are in fact combined into)Tj
0 -1.5 TD
[(a single modelview matrix. \(See )-33("A Simple Example: Drawing a Cube.")61(\) One of the toughest problems)]TJ
T*
(newcomers to computer graphics face is understanding the effects of combined three-dimensional)Tj
0 -1.6 TD
(transformations. As you've already seen, there are alternative ways to think about transformations)Tj
/F33 1 Tf
39.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(do)Tj
-40.2 -1.6 TD
(you want to move the camera in one direction, or move the object in the opposite direction? Each way of)Tj
0 -1.5 TD
(thinking about transformations has advantages and disadvantages, but in some cases one way more)Tj
T*
(naturally matches the effect of the intended transformation. If you can find a natural approach for your)Tj
T*
(particular application, it's easier to visualize the necessary transformations and then write the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 11)Tj
ET
endstream
endobj
314 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im27 311 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
315 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im28
/Width 488
/Height 223
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.27)
>>
stream
endstream
endobj
317 0 obj
<<
/Length 3720
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(corresponding code to specify the matrix manipulations. The first part of this section discusses how to)Tj
0 -1.5 TD
(think about transformations; later, specific commands are presented. For now, we use only the)Tj
T*
(matrix-manipulation commands you've already seen. Finally, keep in mind that you must call)Tj
/F15 1 Tf
T*
(glMatrixMode\(\) )Tj
/F11 1 Tf
6.7 0 TD
(with GL_MODELVIEW as its argument prior to performing modeling or viewing)Tj
-6.7 -1.5 TD
(transformations.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 622.000 Tm
(Thinking about Transformations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 601.000 Tm
(Let's start with a simple case of two transformations: a 45-degree counterclockwise rotation about the)Tj
T*
(origin around the )Tj
/F15 1 Tf
7.1 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis, and a translation down the )Tj
/F15 1 Tf
13.3 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(-axis. Suppose that the object you're drawing is)Tj
-21.2 -1.5 TD
(small compared to the translation \(so that you can see the effect of the translation\), and that it's originally)Tj
T*
(located at the origin. If you rotate the object first and then translate it, the rotated object appears on the)Tj
/F15 1 Tf
T*
(x)Tj
/F11 1 Tf
0.4 0 TD
(-axis. If you translate it down the )Tj
/F15 1 Tf
13.5 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(-axis first, however, and then rotate about the origin, the object is on)Tj
-14.4 -1.5 TD
(the line )Tj
/F15 1 Tf
3.2 0 TD
(y=x)Tj
/F11 1 Tf
1.6 0 TD
[(, as shown in )-27(Figure 3-4)225(. In general, the order of transformations is critical. If you do)]TJ
-4.8 -1.5 TD
(transformation A and then transformation B, you almost always get something different than if you do)Tj
T*
(them in the opposite order.)Tj
ET
Q
/GS1 gs
q
423 0 0 193 124 288.57 cm
/Im28 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 276.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-4 )Tj
/F11 1 Tf
5.1 0 TD
(Rotating First or Translating First)Tj
-5.1 -2.2 TD
(Now let's talk about the order in which you specify a series of transformations. All viewing and)Tj
0 -1.6 TD
(modeling transformations are represented as 4)Tj
/F33 1 Tf
18.5 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 matrices. Each successive )Tj
/F15 1 Tf
11.4 0 TD
(glMultMatrix*\(\))Tj
/F11 1 Tf
6.5 0 TD
( or)Tj
-36.9 -1.7 TD
(transformation command multiplies a new 4)Tj
/F33 1 Tf
17.7 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 matrix )Tj
/F15 1 Tf
3.7 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
( by the current modelview matrix )Tj
/F15 1 Tf
13.6 0 TD
(C)Tj
/F11 1 Tf
0.7 0 TD
( to yield )Tj
/F15 1 Tf
3.5 0 TD
(CM)Tj
/F11 1 Tf
1.5 0 TD
(.)Tj
-42 -1.5 TD
(Finally, vertices )Tj
/F15 1 Tf
6.7 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( are multiplied by the current modelview matrix. This process means that the last)Tj
-7.1 -1.5 TD
(transformation command called in your program is actually the first one applied to the vertices: )Tj
/F15 1 Tf
38.4 0 TD
(CMv)Tj
/F11 1 Tf
2 0 TD
(.)Tj
-40.4 -1.5 TD
(Thus, one way of looking at it is to say that you have to specify the matrices in the reverse order. Like)Tj
T*
(many other things, however, once you've gotten used to thinking about this correctly, backward will)Tj
T*
(seem like forward.)Tj
0 -2.1 TD
(Consider the following code sequence, which draws a single point using three transformations:)Tj
/F7 1 Tf
T*
(glMatrixMode\(GL_MODELVIEW\);)Tj
0 -1.5 TD
(glLoadIdentity\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 12)Tj
ET
endstream
endobj
318 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im28 315 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
321 0 obj
<<
/Length 5056
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(glMultMatrixf\(N\);                /* apply transformation N */)Tj
0 -1.5 TD
(glMultMatrixf\(M\);                /* apply transformation M */)Tj
T*
(glMultMatrixf\(L\);                /* apply transformation L */)Tj
T*
(glBegin\(GL_POINTS\);)Tj
T*
(glVertex3f\(v\);                   /* draw transformed vertex v */)Tj
T*
(glEnd\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(With this code, the modelview matrix successively contains )Tj
/F15 1 Tf
24.2 0 TD
(I)Tj
/F11 1 Tf
0.3 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(N)Tj
/F11 1 Tf
0.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(NM)Tj
/F11 1 Tf
1.5 0 TD
(, and finally )Tj
/F15 1 Tf
5 0 TD
(NML)Tj
/F11 1 Tf
2.1 0 TD
(, where )Tj
/F15 1 Tf
3.2 0 TD
(I)Tj
/F11 1 Tf
-38 -1.5 TD
(represents the identity matrix. The transformed vertex is )Tj
/F15 1 Tf
22.7 0 TD
(NMLv)Tj
/F11 1 Tf
2.5 0 TD
(. Thus, the vertex transformation is)Tj
/F15 1 Tf
-25.2 -1.6 TD
(N\(M\(Lv\)\))Tj
/F33 1 Tf
3.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, )Tj
/F15 1 Tf
2.9 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( is multiplied first by )Tj
/F15 1 Tf
8.6 0 TD
(L)Tj
/F11 1 Tf
0.6 0 TD
(, the resulting )Tj
/F15 1 Tf
5.7 0 TD
(Lv)Tj
/F11 1 Tf
1 0 TD
( is multiplied by )Tj
/F15 1 Tf
6.8 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
(, and the resulting )Tj
/F15 1 Tf
7.4 0 TD
(MLv)Tj
/F11 1 Tf
1.9 0 TD
( is)Tj
-41 -1.6 TD
(multiplied by )Tj
/F15 1 Tf
5.6 0 TD
(N)Tj
/F11 1 Tf
0.7 0 TD
(. Notice that the transformations to vertex )Tj
/F15 1 Tf
16.9 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( effectively occur in the opposite order than)Tj
-23.7 -1.5 TD
(they were specified. \(Actually, only a single multiplication of a vertex by the modelview matrix occurs;)Tj
T*
(in this example, the )Tj
/F15 1 Tf
8.1 0 TD
(N)Tj
/F11 1 Tf
0.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(L)Tj
/F11 1 Tf
0.5 0 TD
( matrices are already multiplied into a single matrix before it's applied to)Tj
/F15 1 Tf
-12.8 -1.5 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
(.\))Tj
/F27 1 Tf
-0.4 -3 TD
(Grand, Fixed Coordinate System)Tj
/F11 1 Tf
0 -2.2 TD
(Thus, if you like to think in terms of a grand, fixed coordinate system)Tj
/F33 1 Tf
27.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in which matrix multiplications)Tj
-28.8 -1.7 TD
(affect the position, orientation, and scaling of your model)Tj
/F33 1 Tf
23 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(you have to think of the multiplications as)Tj
-24 -1.6 TD
(occurring in the opposite order from how they appear in the code. Using the simple example shown on)Tj
0 -1.5 TD
[(the left side of Figure 3-4)225( \(a rotation about the origin and a translation along the )]TJ
/F15 1 Tf
32.2 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(-axis\), if you want the)Tj
-32.7 -1.5 TD
(object to appear on the axis after the operations, the rotation must occur first, followed by the translation.)Tj
T*
(To do this, you'll need to reverse the order of operations, so the code looks something like this \(where )Tj
/F15 1 Tf
41.1 0 TD
(R)Tj
/F11 1 Tf
-41.1 -1.5 TD
(is the rotation matrix and )Tj
/F15 1 Tf
10.3 0 TD
(T)Tj
/F11 1 Tf
0.6 0 TD
( is the translation matrix\):)Tj
/F7 1 Tf
-10.9 -2.1 TD
(glMatrixMode\(GL_MODELVIEW\);)Tj
0 -1.5 TD
(glLoadIdentity\(\);)Tj
T*
(glMultMatrixf\(T\);                /* translation */)Tj
T*
(glMultMatrixf\(R\);                /* rotation */)Tj
T*
(draw_the_object\(\);)Tj
/F27 1 Tf
0 -3 TD
(Moving a Local Coordinate System)Tj
/F11 1 Tf
0 -2.1 TD
(Another way to view matrix multiplications is to forget about a grand, fixed coordinate system in which)Tj
0 -1.5 TD
(your model is transformed and instead imagine that a local coordinate system is tied to the object you're)Tj
T*
(drawing. All operations occur relative to this changing coordinate system. With this approach, the matrix)Tj
T*
(multiplications now appear in the natural order in the code. \(Regardless of which analogy you're using,)Tj
T*
(the code is the same, but how you think about it differs.\) To see this in the translation-rotation example,)Tj
T*
(begin by visualizing the object with a coordinate system tied to it. The translation operation moves the)Tj
T*
(object and its coordinate system down the )Tj
/F15 1 Tf
17 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(-axis. Then, the rotation occurs about the \(now-translated\))Tj
-17.5 -1.5 TD
(origin, so the object rotates in place in its position on the axis.)Tj
0 -2.1 TD
(This approach is what you should use for applications such as articulated robot arms, where there are)Tj
0 -1.5 TD
(joints at the shoulder, elbow, and wrist, and on each of the fingers. To figure out where the tips of the)Tj
T*
(fingers go relative to the body, you'd like to start at the shoulder, go down to the wrist, and so on,)Tj
T*
(applying the appropriate rotations and translations at each joint. Thinking about it in reverse would be far)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 13)Tj
ET
endstream
endobj
322 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
324 0 obj
<<
/Length 4431
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(more confusing.)Tj
0 -2.1 TD
(This second approach can be problematic, however, in cases where scaling occurs, and especially so)Tj
0 -1.5 TD
(when the scaling is nonuniform \(scaling different amounts along the different axes\). After uniform)Tj
T*
(scaling, translations move a vertex by a multiple of what they did before, since the coordinate system is)Tj
T*
(stretched. Nonuniform scaling mixed with rotations may make the axes of the local coordinate system)Tj
T*
(nonperpendicular.)Tj
0 -2.1 TD
(As mentioned earlier, you normally issue viewing transformation commands in your program before any)Tj
0 -1.5 TD
(modeling transformations. This way, a vertex in a model is first transformed into the desired orientation)Tj
T*
(and then transformed by the viewing operation. Since the matrix multiplications must be specified in)Tj
T*
(reverse order, the viewing commands need to come first. Note, however, that you don't need to specify)Tj
T*
(either viewing or modeling transformations if you're satisfied with the default conditions. If there's no)Tj
T*
(viewing transformation, the "camera" is left in the default position at the origin, pointed toward the)Tj
T*
(negative )Tj
/F15 1 Tf
3.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis; if there's no modeling transformation, the model isn't moved, and it retains its specified)Tj
-4 -1.5 TD
(position, orientation, and size.)Tj
0 -2.1 TD
(Since the commands for performing modeling transformations can be used to perform viewing)Tj
0 -1.5 TD
(transformations, modeling transformations are )Tj
/F15 1 Tf
18.8 0 TD
(discussed)Tj
/F11 1 Tf
3.8 0 TD
( first, even if viewing transformations are)Tj
-22.6 -1.5 TD
(actually )Tj
/F15 1 Tf
3.4 0 TD
(issued)Tj
/F11 1 Tf
2.5 0 TD
( first. This order for discussion also matches the way many programmers think when)Tj
-5.9 -1.5 TD
(planning their code: Often, they write all the code necessary to compose the scene, which involves)Tj
T*
(transformations to position and orient objects correctly relative to each other. Next, they decide where)Tj
T*
(they want the viewpoint to be relative to the scene they've composed, and then they write the viewing)Tj
T*
(transformations accordingly.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 362.000 Tm
(Modeling Transformations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 341.000 Tm
(The three OpenGL routines for modeling transformations are )Tj
/F15 1 Tf
24.7 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
(, and )Tj
/F15 1 Tf
2.1 0 TD
(glScale*\(\))Tj
/F11 1 Tf
4.2 0 TD
(.)Tj
-41.9 -1.5 TD
(As you might suspect, these routines transform an object \(or coordinate system, if you're thinking of it)Tj
T*
(that way\) by moving, rotating, stretching, shrinking, or reflecting it. All three commands are equivalent)Tj
T*
(to producing an appropriate translation, rotation, or scaling matrix, and then calling )Tj
/F15 1 Tf
33.6 0 TD
(glMultMatrix*\(\))Tj
/F11 1 Tf
6.5 0 TD
( with)Tj
-40.1 -1.5 TD
(that matrix as the argument. However, these three routines might be faster than using )Tj
/F15 1 Tf
34.3 0 TD
(glMultMatrix*\(\))Tj
/F11 1 Tf
6.5 0 TD
(.)Tj
-40.8 -1.5 TD
[(OpenGL automatically computes the matrices for you. \(See )-18(Appendix F)51( if you're interested in the)]TJ
T*
(details.\))Tj
0 -2.1 TD
(In the command summaries that follow, each matrix multiplication is described in terms of what it does)Tj
0 -1.5 TD
(to the vertices of a geometric object using the fixed coordinate system approach, and in terms of what it)Tj
T*
(does to the local coordinate system that's attached to an object.)Tj
/F27 1 Tf
0 -3 TD
(Translate)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glTranslate)13({fd}\()11(TYPE)34(x)-56(,)0( TYPE y)28(,)0( TYPE)34(z)-11(\))0(;)]TJ
1.8 -1.5 TD
[(Multiplies the current matrix by a matrix that moves \(translates\) an object by the given )-16(x)44(,)-50( y)-6(,)0( and )50(z)]TJ
T*
(values \(or moves the local coordinate system by the same amounts\).)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(Figure 3-5)225( shows the effect of )]TJ
/F15 1 Tf
12.3 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
(.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 14)Tj
ET
endstream
endobj
325 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
326 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im29
/Width 185
/Height 228
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.28)
>>
stream
endstream
endobj
327 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im30
/Width 252
/Height 211
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.29)
>>
stream
endstream
endobj
329 0 obj
<<
/Length 1528
>>
stream
/GS1 gs
q
185 0 0 228 124 492 cm
/Im29 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 479.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-5 )Tj
/F11 1 Tf
5.1 0 TD
(Translating an Object)Tj
-5.1 -2.2 TD
(Note that using \(0.0, 0.0, 0.0\) as the argument for )Tj
/F15 1 Tf
20 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
( is the identity operation)Tj
/F33 1 Tf
9.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, it has)Tj
-36.5 -1.6 TD
(no effect on an object or its local coordinate system.)Tj
/F27 1 Tf
0 -3 TD
(Rotate)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glRotate)-11({fd}\(TYPE angle)22(, TYPE )-16(x)44(,)0( TYPE)34( y)-6(,)0( TYPE )-16(z)-11(\))0(;)]TJ
1.8 -1.5 TD
(Multiplies the current matrix by a matrix that rotates an object \(or the local coordinate system\) in a)Tj
T*
[(counterclockwise direction about the ray from the origin through the point \()-25(x, y, z)77(\). The )-17(angle)]TJ
T*
(parameter specifies the angle of rotation in degrees.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The effect of )Tj
/F15 1 Tf
5.4 0 TD
(glRotatef\()Tj
/F11 1 Tf
4 0 TD
(45.0, 0.0, 0.0, 1.0)Tj
/F15 1 Tf
7 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
(, which is a rotation of 45 degrees about the )Tj
/F15 1 Tf
17.8 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis, is shown in)Tj
-34.9 -1.5 TD
[(Figure 3-6)225(.)]TJ
ET
Q
q
252 0 0 211 124 84.13 cm
/Im30 Do
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 15)Tj
ET
endstream
endobj
330 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im29 326 0 R
/Im30 327 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
331 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im31
/Width 265
/Height 222
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.30)
>>
stream
endstream
endobj
333 0 obj
<<
/Length 3368
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 3-6 )Tj
/F11 1 Tf
5.1 0 TD
(Rotating an Object)Tj
-5.1 -2.1 TD
(Note that an object that lies farther from the axis of rotation is more dramatically rotated \(has a larger)Tj
0 -1.5 TD
(orbit\) than an object drawn near the axis. Also, if the )Tj
/F15 1 Tf
21.4 0 TD
(angle)Tj
/F11 1 Tf
2.2 0 TD
( argument is zero, the )Tj
/F15 1 Tf
8.9 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.5 0 TD
( command)Tj
-37 -1.5 TD
(has no effect.)Tj
/F27 1 Tf
0 -3 TD
(Scale)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glScale)44({fd}\()11(TYPE)-66(x)44(,)0( TYPE y)28(,)0( TYPE)-66(z)-11(\))0(;)]TJ
1.8 -1.5 TD
(Multiplies the current matrix by a matrix that stretches, shrinks, or reflects an object along the axes.)Tj
T*
[(Each x)44(,)0( y)-56(,)0( and z)39( coordinate of every point in the object is multiplied by the corresponding argument)]TJ
T*
[(x)44(,)0( y)-56(,)0( or )39(z)-11(.)0( With the local coordinate system approach, the local coordinate axes are stretched,)]TJ
T*
[(shrunk, or reflected by the )-23(x)44(,)0( y)-56(,)0( and )50(z)-11( factors, and the associated object is transformed with them.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
[(Figure 3-7)225( shows the effect of )]TJ
/F15 1 Tf
12.3 0 TD
(glScalef\()Tj
/F11 1 Tf
3.5 0 TD
(2.0, -0.5, 1.0)Tj
/F15 1 Tf
5.1 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
(.)Tj
ET
Q
/GS1 gs
q
265 0 0 222 124 291.1 cm
/Im31 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 278.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-7 )Tj
/F11 1 Tf
5.1 0 TD
(Scaling and Reflecting an Object)Tj
/F15 1 Tf
-5.1 -2.1 TD
(glScale*\(\))Tj
/F11 1 Tf
4.1 0 TD
( is the only one of the three modeling transformations that changes the apparent size of an)Tj
-4.1 -1.5 TD
(object: Scaling with values greater than 1.0 stretches an object, and using values less than 1.0 shrinks it.)Tj
T*
(Scaling with a -1.0 value reflects an object across an axis. The identity values for scaling are \(1.0, 1.0,)Tj
T*
(1.0\). In general, you should limit your use of )Tj
/F15 1 Tf
18.2 0 TD
(glScale*\(\))Tj
/F11 1 Tf
4.1 0 TD
( to those cases where it is necessary. Using)Tj
/F15 1 Tf
-22.3 -1.5 TD
(glScale*\(\))Tj
/F11 1 Tf
4.1 0 TD
( decreases the performance of lighting calculations, because the normal vectors have to be)Tj
-4.1 -1.5 TD
(renormalized after transformation.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(A scale value of zero collapses all object coordinates along that axis to zero. It's usually not a)Tj
-2.8 -1.4 TD
(good idea to do this, because such an operation cannot be undone. Mathematically speaking, the matrix)Tj
T*
[(cannot be inverted, and inverse matrices are required for certain lighting operations. \(See )-44(Chapter 5)16(.)0(\))]TJ
T*
(Sometimes collapsing coordinates does make sense, however; the calculation of shadows on a planar)Tj
0 -1.5 TD
[(surface is a typical application. \(See )-7("Shadows" in Chapter 14)22(.\) In general, if a coordinate system is to be)]TJ
0 -1.4 TD
(collapsed, the projection matrix should be used rather than the modelview matrix.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 16)Tj
ET
endstream
endobj
334 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im31 331 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
335 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im32
/Width 98
/Height 99
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.31)
>>
stream
endstream
endobj
337 0 obj
<<
/Length 2437
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(A Modeling Transformation Code Example)Tj
/F11 1 Tf
0 -2.1 TD
(Example 3-2)Tj
5.1 0 TD
[( is a portion of a program that renders a triangle four times, as shown in )-85(Figure 3-8)]TJ
33.1 0 TD
(. These)Tj
-38.2 -1.5 TD
(are the four transformed triangles.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A solid wireframe triangle is drawn with no modeling transformation.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The same triangle is drawn again, but with a dashed line stipple and translated \(to the left)Tj
/F33 1 Tf
35.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(along the)Tj
-36.7 -1.6 TD
(negative x-axis\).)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A triangle is drawn with a long dashed line stipple, with its height \()Tj
/F15 1 Tf
26.9 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(-axis\) halved and its width)Tj
-27.4 -1.6 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(-axis\) increased by 50%.)Tj
/F33 1 Tf
-2.6 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A rotated triangle, made of dotted lines, is drawn.)Tj
ET
Q
/GS1 gs
q
98 0 0 99 143 437.32 cm
/Im32 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 143.000 425.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-8 )Tj
/F11 1 Tf
5.1 0 TD
(Modeling Transformation Example)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 3-2 )Tj
/F11 1 Tf
6.1 0 TD
(Using Modeling Transformations: model.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(glLoadIdentity\(\);)Tj
0 -1.5 TD
(glColor3f\(1.0, 1.0, 1.0\);)Tj
T*
(draw_triangle\(\);                   /* solid lines */)Tj
0 -3 TD
(glEnable\(GL_LINE_STIPPLE\);         /* dashed lines */)Tj
0 -1.5 TD
(glLineStipple\(1, 0xF0F0\); )Tj
T*
(glLoadIdentity\(\);)Tj
T*
(glTranslatef\(-20.0, 0.0, 0.0\);)Tj
T*
(draw_triangle\(\);)Tj
0 -3 TD
(glLineStipple\(1, 0xF00F\);          /*long dashed lines */)Tj
0 -1.5 TD
(glLoadIdentity\(\);)Tj
T*
(glScalef\(1.5, 0.5, 1.0\);)Tj
T*
(draw_triangle\(\);)Tj
0 -3 TD
(glLineStipple\(1, 0x8888\);          /* dotted lines */)Tj
0 -1.5 TD
(glLoadIdentity\(\);)Tj
T*
(glRotatef \(90.0, 0.0, 0.0, 1.0\);)Tj
T*
(draw_triangle \(\);)Tj
T*
(glDisable \(GL_LINE_STIPPLE\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 17)Tj
ET
endstream
endobj
338 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im32 335 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
340 0 obj
<<
/Length 4607
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Note the use of )Tj
/F15 1 Tf
6.3 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( to isolate the effects of modeling transformations; initializing the matrix)Tj
-12.9 -1.5 TD
(values prevents successive transformations from having a cumulative effect. Even though using)Tj
/F15 1 Tf
T*
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( repeatedly has the desired effect, it may be inefficient, because you may have to)Tj
-6.6 -1.5 TD
[(respecify viewing or modeling transformations. \(See "Manipulating the Matrix Stacks")12( for a better way)]TJ
T*
(to isolate transformations.\))Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Sometimes, programmers who want a continuously rotating object attempt to achieve this by)Tj
-2.8 -1.4 TD
(repeatedly applying a rotation matrix that has small values. The problem with this technique is that)Tj
T*
(because of round-off errors, the product of thousands of tiny rotations gradually drifts away from the)Tj
0 -1.5 TD
(value you really want \(it might even become something that isn't a rotation\). Instead of using this)Tj
0 -1.4 TD
(technique, increment the angle and issue a new rotation command with the new angle at each update step.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 544.000 Tm
(Viewing Transformations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 523.000 Tm
(A viewing transformation changes the position and orientation of the viewpoint. If you recall the camera)Tj
0 -1.5 TD
(analogy, the viewing transformation positions the camera tripod, pointing the camera toward the model.)Tj
T*
(Just as you move the camera to some position and rotate it until it points in the desired direction, viewing)Tj
T*
(transformations are generally composed of translations and rotations. Also remember that to achieve a)Tj
T*
(certain scene composition in the final image or photograph, you can either move the camera or move all)Tj
T*
(the objects in the opposite direction. Thus, a modeling transformation that rotates an object)Tj
T*
(counterclockwise is equivalent to a viewing transformation that rotates the camera clockwise, for)Tj
T*
(example. Finally, keep in mind that the viewing transformation commands must be called before any)Tj
T*
(modeling transformations are performed, so that the modeling transformations take effect on the objects)Tj
T*
(first.)Tj
0 -2.1 TD
(You can manufacture a viewing transformation in any of several ways, as described next. You can also)Tj
0 -1.5 TD
(choose to use the default location and orientation of the viewpoint, which is at the origin, looking down)Tj
T*
(the negative)Tj
/F15 1 Tf
4.9 0 TD
( z)Tj
/F11 1 Tf
0.6 0 TD
(-axis.)Tj
/F33 1 Tf
-5.4 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use one or more modeling transformation commands \(that is, )Tj
/F15 1 Tf
24.9 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
(\). You)Tj
-37.2 -1.6 TD
(can think of the effect of these transformations as moving the camera position or as moving all the)Tj
0 -1.5 TD
(objects in the world, relative to a stationary camera.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use the Utility Library routine )Tj
/F15 1 Tf
12.5 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
( to define a line of sight. This routine encapsulates a)Tj
-17.3 -1.6 TD
(series of rotation and translation commands.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Create your own utility routine that encapsulates rotations and translations. Some applications might)Tj
0 -1.6 TD
(require custom routines that allow you to specify the viewing transformation in a convenient way.)Tj
0 -1.5 TD
(For example, you might want to specify the roll, pitch, and heading rotation angles of a plane in)Tj
T*
(flight, or you might want to specify a transformation in terms of polar coordinates for a camera)Tj
T*
(that's orbiting around an object.)Tj
/F27 1 Tf
-1.9 -3.6 TD
(Using glTranslate*\(\) and glRotate*\(\))Tj
/F11 1 Tf
0 -2.1 TD
(When you use modeling transformation commands to emulate viewing transformations, you're trying to)Tj
0 -1.5 TD
(move the viewpoint in a desired way while keeping the objects in the world stationary. Since the)Tj
T*
(viewpoint is initially located at the origin and since objects are often most easily constructed there as well)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 18)Tj
ET
endstream
endobj
341 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
342 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im33
/Width 209
/Height 215
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.32)
>>
stream
endstream
endobj
344 0 obj
<<
/Length 1772
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(\(see )-40(Figure 3-9)225(\), in general you have to perform some transformation so that the objects can be viewed.)]TJ
0 -1.5 TD
(Note that, as shown in the figure, the camera initially points down the negative )Tj
/F15 1 Tf
31.8 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis. \(You're seeing the)Tj
-32.2 -1.5 TD
(back of the camera.\))Tj
ET
Q
/GS1 gs
q
209 0 0 215 124 449.92 cm
/Im33 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 437.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-9 )Tj
/F11 1 Tf
5.1 0 TD
(Object and Viewpoint at the Origin)Tj
-5.1 -2.1 TD
(In the simplest case, you can move the viewpoint backward, away from the objects; this has the same)Tj
0 -1.5 TD
(effect as moving the objects forward, or away from the viewpoint. Remember that by default forward is)Tj
T*
(down the negative)Tj
/F15 1 Tf
7.3 0 TD
( z)Tj
/F11 1 Tf
0.7 0 TD
(-axis; if you rotate the viewpoint, forward has a different meaning. So, to put 5 units)Tj
-8 -1.5 TD
[(of distance between the viewpoint and the objects by moving the viewpoint, as shown in )-33(Figure 3-10)226(, use)]TJ
/F7 1 Tf
0 -2.1 TD
(glTranslatef\(0.0, 0.0, -5.0\);)Tj
/F11 1 Tf
T*
(This routine moves the objects in the scene -5 units along the )Tj
/F15 1 Tf
24.7 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( axis. This is also equivalent to moving the)Tj
-25.1 -1.5 TD
(camera +5 units along the )Tj
/F15 1 Tf
10.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( axis.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 19)Tj
ET
endstream
endobj
345 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im33 342 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
346 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im34
/Width 494
/Height 292
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.33)
>>
stream
endstream
endobj
348 0 obj
<<
/Length 2615
>>
stream
/GS1 gs
q
423 0 0 250 124 470 cm
/Im34 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 457.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-10 )Tj
/F11 1 Tf
5.6 0 TD
(Separating the Viewpoint and the Object)Tj
-5.6 -2.1 TD
(Now suppose you want to view the objects from the side. Should you issue a rotate command before or)Tj
0 -1.5 TD
(after the translate command? If you're thinking in terms of a grand, fixed coordinate system, first)Tj
T*
(imagine both the object and the camera at the origin. You could rotate the object first and then move it)Tj
T*
(away from the camera so that the desired side is visible. Since you know that with the fixed coordinate)Tj
T*
(system approach, commands have to be issued in the opposite order in which they should take effect, you)Tj
T*
(know that you need to write the translate command first in your code and follow it with the rotate)Tj
T*
(command.)Tj
0 -2.1 TD
(Now let's use the local coordinate system approach. In this case, think about moving the object and its)Tj
0 -1.5 TD
(local coordinate system away from the origin; then, the rotate command is carried out using the)Tj
T*
(now-translated coordinate system. With this approach, commands are issued in the order in which they're)Tj
T*
(applied, so once again the translate command comes first. Thus, the sequence of transformation)Tj
T*
(commands to produce the desired result is)Tj
/F7 1 Tf
0 -2.1 TD
(glTranslatef\(0.0, 0.0, -5.0\);)Tj
0 -1.5 TD
(glRotatef\(90.0, 0.0, 1.0, 0.0\);)Tj
/F11 1 Tf
0 -2.1 TD
(If you're having trouble keeping track of the effect of successive matrix multiplications, try using both)Tj
0 -1.5 TD
(the fixed and local coordinate system approaches and see whether one makes more sense to you. Note)Tj
T*
(that with the fixed coordinate system, rotations always occur about the grand origin, whereas with the)Tj
T*
(local coordinate system, rotations occur about the origin of the local system. You might also try using the)Tj
/F15 1 Tf
T*
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
( utility routine described in the next section.)Tj
/F27 1 Tf
-4.8 -3 TD
(Using the gluLookAt\(\) Utility Routine)Tj
/F11 1 Tf
0 -2.1 TD
(Often, programmers construct a scene around the origin or some other convenient location, then they)Tj
0 -1.5 TD
(want to look at it from an arbitrary point to get a good view of it. As its name suggests, the )Tj
/F15 1 Tf
36.5 0 TD
(gluLookAt\(\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 20)Tj
ET
endstream
endobj
349 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im34 346 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
351 0 obj
<<
/Length 3801
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(utility routine is designed for just this purpose. It takes three sets of arguments, which specify the)Tj
0 -1.5 TD
(location of the viewpoint, define a reference point toward which the camera is aimed, and indicate which)Tj
T*
(direction is up. Choose the viewpoint to yield the desired view of the scene. The reference point is)Tj
T*
(typically somewhere in the middle of the scene. \(If you've built your scene at the origin, the reference)Tj
T*
(point is probably the origin.\) It might be a little trickier to specify the correct up-vector. Again, if you've)Tj
T*
(built some real-world scene at or around the origin and if you've been taking the positive )Tj
/F15 1 Tf
35.9 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(-axis to point)Tj
-36.3 -1.5 TD
(upward, then that's your up-vector for )Tj
/F15 1 Tf
15.5 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
(. However, if you're designing a flight simulator, up is)Tj
-20.4 -1.5 TD
(the direction perpendicular to the plane's wings, from the plane toward the sky when the plane is)Tj
T*
(right-side up on the ground.)Tj
0 -2.1 TD
(The )Tj
/F15 1 Tf
1.8 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
( routine is particularly useful when you want to pan across a landscape, for instance.)Tj
-6.6 -1.5 TD
(With a viewing volume that's symmetric in both )Tj
/F15 1 Tf
19.7 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(, the \()Tj
/F15 1 Tf
2.3 0 TD
(eyex, eyey, eyez)Tj
/F11 1 Tf
6.3 0 TD
(\) point specified is always)Tj
-31.1 -1.5 TD
(in the center of the image on the screen, so you can use a series of commands to move this point slightly,)Tj
T*
(thereby panning across the scene.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluLookAt)67(\(GLdouble )-16(eyex)-24(, GLdouble )51(eyey)-24(, GLdouble )-49(eyez)21(, GLdouble )51(centerx)-57(, GLdouble )51(centery)-57(,)]TJ
0 -1.5 TD
[(GLdouble )-50(centerz)88(, GLdouble )-49(upx)44(, GLdouble )-49(upy)44(, GLdouble )-49(upz)-11(\);)]TJ
1.8 -1.5 TD
(Defines a viewing matrix and multiplies it to the right of the current matrix. The desired viewpoint is)Tj
T*
[(specified by eyex)-24(, eyey)-24(, and )50(eyez)21(. The )-50(centerx)43(, centery)-57(, and )50(centerz)-12( arguments specify any point)]TJ
T*
(along the desired line of sight, but typically they're some point in the center of the scene being)Tj
T*
[(looked at. The )45(upx)-56(, upy)44(, and )-50(upz)-11( arguments indicate which direction is up \(that is, the direction from)]TJ
T*
(the bottom to the top of the viewing volume\).)Tj
/F11 1 Tf
-1.8 -2.1 TD
(In the default position, the camera is at the origin, is looking down the negative )Tj
/F15 1 Tf
32 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis, and has the)Tj
-32.4 -1.5 TD
(positive )Tj
/F15 1 Tf
3.4 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(-axis as straight up. This is the same as calling)Tj
/F7 1 Tf
-3.9 -2.1 TD
(gluLookat \(0.0, 0.0, 0.0, 0.0, 0.0, -100.0, 0.0, 1.0, 0.0\);)Tj
/F11 1 Tf
T*
(The )Tj
/F15 1 Tf
1.8 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( value of the reference point is -100.0, but could be any negative )Tj
/F15 1 Tf
26 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(, because the line of sight will)Tj
-28.6 -1.5 TD
(remain the same.  In this case, you don't actually want to call )Tj
/F15 1 Tf
24.7 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
(, because this is the default \(see)Tj
-29.6 -1.5 TD
[(Figure 3-11)226(\) and you are already there!  \(The lines extending from the camera represent the viewing)]TJ
T*
(volume, which indicates its field of view.\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 21)Tj
ET
endstream
endobj
352 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
353 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im35
/Width 209
/Height 215
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.34)
>>
stream
endstream
endobj
354 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im36
/Width 215
/Height 217
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.35)
>>
stream
endstream
endobj
356 0 obj
<<
/Length 1977
>>
stream
/GS1 gs
q
209 0 0 215 124 505 cm
/Im35 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 492.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-11 )Tj
/F11 1 Tf
5.6 0 TD
(Default Camera Position)Tj
-5.6 -2.1 TD
[(Figure 3-12)226( shows the effect of a typical )]TJ
/F15 1 Tf
16.4 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
( routine. The camera position \()Tj
/F15 1 Tf
12.3 0 TD
(eyex, eyey, eyez)Tj
/F11 1 Tf
6.3 0 TD
(\) is at)Tj
-39.9 -1.5 TD
(\(4, 2, 1\). In this case, the camera is looking right at the model, so the reference point is at \(2, 4, -3\). An)Tj
T*
(orientation vector of \(2, 2, -1\) is chosen to rotate the viewpoint to this 45-degree angle.)Tj
ET
Q
q
215 0 0 217 124 210 cm
/Im36 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 197.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-12 )Tj
/F11 1 Tf
5.6 0 TD
(Using gluLookAt\(\))Tj
-5.6 -2.1 TD
(So, to achieve this effect, call)Tj
/F7 1 Tf
0 -2 TD
(gluLookAt\(4.0, 2.0, 1.0, 2.0, 4.0, -3.0, 2.0, 2.0, -1.0\);)Tj
/F11 1 Tf
0 -2.2 TD
(Note that )Tj
/F15 1 Tf
3.9 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
( is part of the Utility Library rather than the basic OpenGL library. This isn't)Tj
-8.8 -1.6 TD
(because it's not useful, but because it encapsulates several basic OpenGL commands)Tj
/F33 1 Tf
33.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(specifically,)Tj
/F15 1 Tf
-34.9 -1.6 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
(. To see this, imagine a camera located at an arbitrary viewpoint and)Tj
-12.3 -1.5 TD
(oriented according to a line of sight, both as specified with )Tj
/F15 1 Tf
23.7 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
( and a scene located at the origin.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 22)Tj
ET
endstream
endobj
357 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im35 353 0 R
/Im36 354 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
361 0 obj
<<
/Length 4144
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(To "undo" what )Tj
/F15 1 Tf
6.6 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
( does, you need to transform the camera so that it sits at the origin and points)Tj
-11.5 -1.5 TD
(down the negative )Tj
/F15 1 Tf
7.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis, the default position. A simple translate moves the camera to the origin. You)Tj
-8 -1.5 TD
(can easily imagine a series of rotations about each of the three axes of a fixed coordinate system that)Tj
T*
(would orient the camera so that it pointed toward negative )Tj
/F15 1 Tf
23.6 0 TD
(z)Tj
/F11 1 Tf
0.3 0 TD
( values. Since OpenGL allows rotation about)Tj
-23.9 -1.5 TD
(an arbitrary axis, you can accomplish any desired rotation of the camera with a single )Tj
/F15 1 Tf
34.4 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
-34.4 -1.5 TD
(command.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(You can have only one active viewing transformation. You cannot try to combine the effects of)Tj
-2.8 -1.4 TD
(two viewing transformations, any more than a camera can have two tripods. If you want to change the)Tj
T*
(position of the camera, make sure you call )Tj
/F15 1 Tf
17.2 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.5 0 TD
( to wipe away the effects of any current)Tj
-23.7 -1.5 TD
(viewing transformation.)Tj
/F27 1 Tf
8 -2.1 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(To transform any arbitrary vector so that it's coincident with another arbitrary vector \(for instance, the)Tj
0 -1.5 TD
(negative )Tj
/F15 1 Tf
3.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis\), you need to do a little mathematics. The axis about which you want to rotate is given by)Tj
-4 -1.5 TD
(the cross product of the two normalized vectors. To find the angle of rotation, normalize the initial two)Tj
T*
(vectors. The cosine of the desired angle between the vectors is equal to the dot product of the normalized)Tj
T*
(vectors. The angle of rotation around the axis given by the cross product is always between 0 and 180)Tj
T*
[(degrees. \(See )-18(Appendix E)6( for definitions of cross and dot products.\))]TJ
0 -2.1 TD
(Note that computing the angle between two normalized vectors by taking the inverse cosine of their dot)Tj
0 -1.5 TD
(product is not very accurate, especially for small angles. But it should work well enough to get you)Tj
T*
(started.)Tj
/F27 1 Tf
0 -3 TD
(Creating a Custom Utility Routine)Tj
8 -2.2 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(For some specialized applications, you might want to define your own transformation routine. Since this)Tj
0 -1.5 TD
(is rarely done and in any case is a fairly advanced topic, it's left mostly as an exercise for the reader. The)Tj
T*
(following exercises suggest two custom viewing transformations that might be useful.)Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F33 1 Tf
-7.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Suppose you're writing a flight simulator and you'd like to display the world from the point of view)Tj
0 -1.6 TD
(of the pilot of a plane. The world is described in a coordinate system with the origin on the runway)Tj
0 -1.5 TD
(and the plane at coordinates \()Tj
/F15 1 Tf
11.7 0 TD
(x, y, z)Tj
/F11 1 Tf
2.3 0 TD
(\). Suppose further that the plane has some )Tj
/F15 1 Tf
17 0 TD
(roll)Tj
/F11 1 Tf
1.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(pitch)Tj
/F11 1 Tf
2 0 TD
(, and)Tj
/F15 1 Tf
-35 -1.5 TD
(heading)Tj
/F11 1 Tf
3.2 0 TD
( \(these are rotation angles of the plane relative to its center of gravity\).)Tj
-3.2 -2.1 TD
(Show that the following routine could serve as the viewing transformation:)Tj
/F7 1 Tf
T*
(void pilotView{GLdouble planex, GLdouble planey,)Tj
0 -1.5 TD
(               GLdouble planez, GLdouble roll,)Tj
T*
(               GLdouble pitch, GLdouble heading\))Tj
T*
({)Tj
T*
(      glRotated\(roll, 0.0, 0.0, 1.0\);)Tj
T*
(      glRotated\(pitch, 0.0, 1.0, 0.0\);)Tj
T*
(      glRotated\(heading, 1.0, 0.0, 0.0\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 23)Tj
ET
endstream
endobj
362 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
364 0 obj
<<
/Length 4103
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 143.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      glTranslated\(-planex, -planey, -planez\);)Tj
0 -1.5 TD
(})Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Suppose your application involves orbiting the camera around an object that's centered at the origin.)Tj
0 -1.6 TD
(In this case, you'd like to specify the viewing transformation by using polar coordinates. Let the)Tj
/F15 1 Tf
0 -1.5 TD
(distance)Tj
/F11 1 Tf
3.3 0 TD
( variable define the radius of the orbit, or how far the camera is from the origin. \(Initially,)Tj
-3.3 -1.5 TD
(the camera is moved )Tj
/F15 1 Tf
8.5 0 TD
(distance)Tj
/F11 1 Tf
3.3 0 TD
( units along the positive )Tj
/F15 1 Tf
9.8 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis.\) The )Tj
/F15 1 Tf
4.6 0 TD
(azimuth)Tj
/F11 1 Tf
3.2 0 TD
( describes the angle of)Tj
-29.8 -1.5 TD
(rotation of the camera about the object in the )Tj
/F15 1 Tf
18.2 0 TD
(x-y)Tj
/F11 1 Tf
1.2 0 TD
( plane, measured from the positive )Tj
/F15 1 Tf
14.1 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(-axis. Similarly,)Tj
/F15 1 Tf
-33.9 -1.5 TD
(elevation)Tj
/F11 1 Tf
3.7 0 TD
( is the angle of rotation of the camera in the )Tj
/F15 1 Tf
17.7 0 TD
(y-z)Tj
/F11 1 Tf
1.1 0 TD
( plane, measured from the positive )Tj
/F15 1 Tf
14.1 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis.)Tj
-37 -1.5 TD
(Finally, )Tj
/F15 1 Tf
3.3 0 TD
(twist)Tj
/F11 1 Tf
1.9 0 TD
( represents the rotation of the viewing volume around its line of sight.)Tj
-5.2 -2.1 TD
(Show that the following routine could serve as the viewing transformation:)Tj
/F7 1 Tf
T*
(void polarView{GLdouble distance, GLdouble twist, )Tj
0 -1.5 TD
(                 GLdouble elevation, GLdouble azimuth\))Tj
T*
({)Tj
T*
(      glTranslated\(0.0, 0.0, -distance\);)Tj
T*
(      glRotated\(-twist, 0.0, 0.0, 1.0\);)Tj
T*
(      glRotated\(-elevation, 1.0, 0.0, 0.0\);)Tj
T*
(      glRotated\(azimuth, 0.0, 0.0, 1.0\);)Tj
T*
(})Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 397.000 Tm
(Projection Transformations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 375.000 Tm
(The previous section described how to compose the desired modelview matrix so that the correct)Tj
T*
(modeling and viewing transformations are applied. This section explains how to define the desired)Tj
T*
(projection matrix, which is also used to transform the vertices in your scene. Before you issue any of the)Tj
T*
(transformation commands described in this section, remember to call)Tj
/F7 1 Tf
0 -2.1 TD
(glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(glLoadIdentity\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(so that the commands affect the projection matrix rather than the modelview matrix and so that you avoid)Tj
0 -1.5 TD
(compound projection transformations. Since each projection transformation command completely)Tj
T*
(describes a particular transformation, typically you don't want to combine a projection transformation)Tj
T*
(with another transformation.)Tj
0 -2.1 TD
(The purpose of the projection transformation is to define a )Tj
/F15 1 Tf
23.6 0 TD
(viewing volume)Tj
/F11 1 Tf
6.3 0 TD
(, which is used in two ways.)Tj
-29.9 -1.5 TD
(The viewing volume determines how an object is projected onto the screen \(that is, by using a)Tj
T*
(perspective or an orthographic projection\), and it defines which objects or portions of objects are clipped)Tj
T*
(out of the final image. You can think of the viewpoint we've been talking about as existing at one end of)Tj
T*
[(the viewing volume. At this point, you might want to reread )52("A Simple Example: Drawing a Cube")-89( for)]TJ
T*
(its overview of all the transformations, including projection transformations.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 103.000 Tm
(Perspective Projection)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 82.000 Tm
(The most unmistakable characteristic of perspective projection is foreshortening: the farther an object is)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 24)Tj
ET
endstream
endobj
365 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
366 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im37
/Width 505
/Height 242
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.36)
>>
stream
endstream
endobj
368 0 obj
<<
/Length 3542
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(from the camera, the smaller it appears in the final image. This occurs because the viewing volume for a)Tj
0 -1.5 TD
(perspective projection is a )Tj
/F13 1 Tf
10.7 0 TD
(frustum)Tj
/F11 1 Tf
3.5 0 TD
( of a pyramid \(a truncated pyramid whose top has been cut off by a)Tj
-14.2 -1.5 TD
(plane parallel to its base\). Objects that fall within the viewing volume are projected toward the apex of)Tj
T*
(the pyramid, where the camera or viewpoint is. Objects that are closer to the viewpoint appear larger)Tj
T*
(because they occupy a proportionally larger amount of the viewing volume than those that are farther)Tj
T*
(away, in the larger part of the frustum. This method of projection is commonly used for animation, visual)Tj
T*
(simulation, and any other applications that strive for some degree of realism because it's similar to how)Tj
T*
(our eye \(or a camera\) works.)Tj
0 -2.1 TD
(The command to define a frustum, )Tj
/F15 1 Tf
14.1 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
(, calculates a matrix that accomplishes perspective)Tj
-18.9 -1.5 TD
(projection and multiplies the current projection matrix \(typically the identity matrix\) by it. Recall that the)Tj
T*
(viewing volume is used to clip objects that lie outside of it; the four sides of the frustum, its top, and its)Tj
T*
[(base correspond to the six clipping planes of the viewing volume, as shown in )-27(Figure 3-13)226(. Objects or)]TJ
T*
(parts of objects outside these planes are clipped from the final image. Note that )Tj
/F15 1 Tf
31.9 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
( doesn't)Tj
-36.7 -1.5 TD
(require you to define a symmetric viewing volume.)Tj
ET
Q
q
1 i 
124.000 495.470 422.980 -202.700 re
W n
/GS1 gs
q
423 0 0 203 124 292.47 cm
/Im37 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 280.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 3-13 )Tj
/F11 1 Tf
5.6 0 TD
(Perspective Viewing Volume Specified by glFrustum\(\))Tj
/F15 1 Tf
-5.6 -2.1 TD
[(void )-28(glFrustum)67(\(GLdouble )-16(left)-22(, GLdouble )-49(right)45(, GLdouble )51(bottom)-22(,)]TJ
0 -1.1 TD
[(GLdouble )-50(top)78(, GLdouble )-49(near)33(, GLdouble )-49(far)67(\);)]TJ
1.8 -1.5 TD
(Creates a matrix for a perspective-view frustum and multiplies the current matrix by it. The)Tj
T*
[(frustum's viewing volume is defined by the parameters: \()-22(left, bottom)56(, -near)]TJ
30 0 TD
[(\) and \()-34(right, top, -near)]TJ
9.1 0 TD
(\))Tj
-39.1 -1.5 TD
[(specify the \()33(x, y, z)-23(\))0( coordinates of the lower-left and upper-right corners of the near clipping plane;)]TJ
T*
[(near)33( and far)-33( give the distances from the viewpoint to the near and far clipping planes. They should)]TJ
T*
(always be positive.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The frustum has a default orientation in three-dimensional space. You can perform rotations or)Tj
0 -1.5 TD
(translations on the projection matrix to alter this orientation, but this is tricky and nearly always)Tj
T*
(avoidable.)Tj
/F27 1 Tf
8 -2.2 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(Also, the frustum doesn't have to be symmetrical, and its axis isn't necessarily aligned with the )Tj
/F15 1 Tf
38.4 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 25)Tj
ET
endstream
endobj
369 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im37 366 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
370 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im38
/Width 515
/Height 224
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.37)
>>
stream
endstream
endobj
372 0 obj
<<
/Length 4259
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(For example, you can use )Tj
/F15 1 Tf
10.5 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
( to draw a picture as if you were looking through a rectangular)Tj
-15.3 -1.5 TD
(window of a house, where the window was above and to the right of you. Photographers use such a)Tj
T*
(viewing volume to create false perspectives. You might use it to have the hardware calculate images at)Tj
T*
(much higher than normal resolutions, perhaps for use on a printer. For example, if you want an image)Tj
T*
(that has twice the resolution of your screen, draw the same picture four times, each time using the)Tj
T*
(frustum to cover the entire screen with one-quarter of the image. After each quarter of the image is)Tj
T*
(rendered, you can read the pixels back to collect the data for the higher-resolution image. \(See )Tj
37.9 0 TD
(Chapter 8)Tj
-37.9 -1.5 TD
(for more information about reading pixel data.\))Tj
0 -2.1 TD
(Although it's easy to understand conceptually, )Tj
/F15 1 Tf
18.9 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
( isn't intuitive to use. Instead, you might try)Tj
-23.7 -1.5 TD
(the Utility Library routine )Tj
/F15 1 Tf
10.7 0 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
(. This routine creates a viewing volume of the same shape as)Tj
/F15 1 Tf
-17.3 -1.5 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
( does, but you specify it in a different way. Rather than specifying corners of the near)Tj
-4.8 -1.6 TD
(clipping plane, you specify the angle of the field of view \()Tj
/F33 1 Tf
23.2 0 TD
(Q)Tj
/F11 1 Tf
0.8 0 TD
[(, or theta, in )56(Figure 3-14)226(\) in the)]TJ
/F15 1 Tf
12.5 0 TD
( y )Tj
/F11 1 Tf
1 0 TD
(direction)Tj
-37.5 -1.6 TD
(and the aspect ratio of the width to height \()Tj
/F15 1 Tf
17.2 0 TD
(x/y)Tj
/F11 1 Tf
1.2 0 TD
(\). \(For a square portion of the screen, the aspect ratio is)Tj
-18.4 -1.5 TD
(1.0.\) These two parameters are enough to determine an untruncated pyramid along the line of sight, as)Tj
T*
[(shown in )-11(Figure 3-14)226(. You also specify the distance between the viewpoint and the near and far clipping)]TJ
T*
(planes, thereby truncating the pyramid. Note that )Tj
/F15 1 Tf
19.9 0 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
( is limited to creating frustums that are)Tj
-26.5 -1.5 TD
(symmetric in both the )Tj
/F15 1 Tf
9 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(- and )Tj
/F15 1 Tf
2.3 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(-axes along the line of sight, but this is usually what you want.)Tj
ET
Q
/GS1 gs
q
423 0 0 184 124 264.97 cm
/Im38 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 252.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-14 )Tj
/F11 1 Tf
5.6 0 TD
(Perspective Viewing Volume Specified by gluPerspective\(\))Tj
/F15 1 Tf
-5.6 -2.1 TD
0.028 Tw
[(void gluPerspective)44(\(GLdouble )12(fovy)-34(, )28(GLdouble )79(aspect)-45(,)]TJ
0 -1.1 TD
0.050 Tw
[(GLdouble near)33(, )50(GLdouble )101(far)-33(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Creates a matrix for a symmetric perspective-view frustum and multiplies the current matrix by it.)Tj
T*
[(fovy)-34( is the angle of the field of view in the )52(x)-56(-)]TJ
17.7 0 TD
[(z)-11( plane; its value must be in the range [0.0,180.0].)]TJ
-17.7 -1.5 TD
[(aspect)-45( is the aspect ratio of the frustum, its width divided by its height. )49(near)33( and far)-33( values the)]TJ
T*
[(distances between the viewpoint and the clipping planes, along the negative )13(z)-11(-axis. They should)]TJ
T*
(always be positive.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(Just as with )Tj
/F15 1 Tf
4.9 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.9 0 TD
(, you can apply rotations or translations to change the default orientation of the)Tj
-9.8 -1.5 TD
(viewing volume created by )Tj
/F15 1 Tf
11.1 0 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
(. With no such transformations, the viewpoint remains at the)Tj
-17.7 -1.5 TD
(origin, and the line of sight points down the negative )Tj
/F15 1 Tf
21.4 0 TD
(z)Tj
/F11 1 Tf
0.3 0 TD
(-axis.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 26)Tj
ET
endstream
endobj
373 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im38 370 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
374 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im39
/Width 372
/Height 230
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.38)
>>
stream
endstream
endobj
376 0 obj
<<
/Length 3298
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(With )Tj
/F15 1 Tf
2.3 0 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
0.000 Tw
(, you need to pick appropriate values for the field of view, or the image may look)Tj
-8.9 -1.5 TD
(distorted. For example, suppose you're drawing to the entire screen, which happens to be 11 inches high.)Tj
T*
(If you choose a field of view of 90 degrees, your eye has to be about 7.8 inches from the screen for the)Tj
T*
(image to appear undistorted. \(This is the distance that makes the screen subtend 90 degrees.\) If your eye)Tj
T*
(is farther from the screen, as it usually is, the perspective doesn't look right. If your drawing area)Tj
T*
(occupies less than the full screen, your eye has to be even closer. To get a perfect field of view, figure out)Tj
T*
(how far your eye normally is from the screen and how big the window is, and calculate the angle the)Tj
T*
(window subtends at that size and distance. It's probably smaller than you would guess. Another way to)Tj
T*
(think about it is that a 94-degree field of view with a 35-millimeter camera requires a 20-millimeter lens,)Tj
T*
[(which is a very wide-angle lens. \(See )196("Troubleshooting Transformations")-11( for more details on how to)]TJ
T*
(calculate the desired field of view.\))Tj
0 -2.2 TD
(The preceding paragraph mentions inches and millimeters)Tj
/F33 1 Tf
23.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(do these really have anything to do with)Tj
-24.2 -1.6 TD
(OpenGL? The answer is, in a word, no. The projection and other transformations are inherently unitless.)Tj
0 -1.5 TD
(If you want to think of the near and far clipping planes as located at 1.0 and 20.0 meters, inches,)Tj
T*
(kilometers, or leagues, it's up to you. The only rule is that you have to use a consistent unit of)Tj
T*
(measurement. Then the resulting image is drawn to scale.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 449.000 Tm
(Orthographic Projection)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 428.000 Tm
(With an orthographic projection, the viewing volume is a rectangular parallelepiped, or more informally,)Tj
T*
[(a box \(see Figure 3-15)226(\). Unlike perspective projection, the size of the viewing volume doesn't change)]TJ
T*
(from one end to the other, so distance from the camera doesn't affect how large an object appears. This)Tj
T*
(type of projection is used for applications such as creating architectural blueprints and computer-aided)Tj
T*
(design, where it's crucial to maintain the actual sizes of objects and angles between them as they're)Tj
T*
(projected.)Tj
ET
Q
/GS1 gs
q
372 0 0 230 124 108.7 cm
/Im39 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 96.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-15 )Tj
/F11 1 Tf
5.6 0 TD
(Orthographic Viewing Volume)Tj
-5.6 -2.1 TD
(The command )Tj
/F15 1 Tf
6 0 TD
(glOrtho\(\))Tj
/F11 1 Tf
3.8 0 TD
( creates an orthographic parallel viewing volume. As with )Tj
/F15 1 Tf
23.5 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
(, you)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 27)Tj
ET
endstream
endobj
377 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im39 374 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
379 0 obj
<<
/Length 4876
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(specify the corners of the near clipping plane and the distance to the far clipping plane.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glOrtho)67(\(GLdouble )-16(left)-22(, GLdouble )-49(right)45(, GLdouble )51(bottom)-22(,)]TJ
0 -1.1 TD
[(GLdouble top)28(, GLdouble near)-17(, GLdouble )-49(far)67(\);)]TJ
1.8 -1.5 TD
(Creates a matrix for an orthographic parallel viewing volume and multiplies the current matrix by)Tj
T*
[(it. \()-11(left, bottom, -near)]TJ
8.6 0 TD
[(\) and \()-34(right, top, -near)]TJ
9.1 0 TD
(\) are points on the near clipping plane that are mapped)Tj
-17.7 -1.5 TD
(to the lower-left and upper-right corners of the viewport window, respectively. \()Tj
32 0 TD
(left, bottom, -far)Tj
6.6 0 TD
(\))Tj
-38.6 -1.5 TD
[(and \()-17(right, top, -far)]TJ
7.8 0 TD
(\) are points on the far clipping plane that are mapped to the same respective)Tj
-7.8 -1.5 TD
[(corners of the viewport. Both )45(near)-67( and far)67( can be positive or negative.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(With no other transformations, the direction of projection is parallel to the )Tj
/F15 1 Tf
29.9 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis, and the viewpoint faces)Tj
-30.3 -1.5 TD
(toward the negative)Tj
/F15 1 Tf
7.9 0 TD
( z)Tj
/F11 1 Tf
0.6 0 TD
(-axis. Note that this means that the values passed in for )Tj
/F15 1 Tf
22.3 0 TD
(far)Tj
/F11 1 Tf
1.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(near)Tj
/F11 1 Tf
1.8 0 TD
( are used as)Tj
-35.7 -1.5 TD
(negative)Tj
/F15 1 Tf
3.4 0 TD
( z)Tj
/F11 1 Tf
0.6 0 TD
( values if these planes are in front of the viewpoint, and positive if they're behind the)Tj
-4 -1.5 TD
(viewpoint.)Tj
0 -2.1 TD
(For the special case of projecting a two-dimensional image onto a two-dimensional screen, use the Utility)Tj
0 -1.5 TD
(Library routine )Tj
/F15 1 Tf
6.3 0 TD
(gluOrtho2D\(\))Tj
/F11 1 Tf
5.6 0 TD
(. This routine is identical to the three-dimensional version, )Tj
/F15 1 Tf
23.6 0 TD
(glOrtho\(\))Tj
/F11 1 Tf
3.9 0 TD
(,)Tj
-39.4 -1.5 TD
(except that all the )Tj
/F15 1 Tf
7.3 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinates for objects in the scene are assumed to lie between -1.0 and 1.0. If you're)Tj
-7.7 -1.5 TD
(drawing two-dimensional objects using the two-dimensional vertex commands, all the )Tj
/F15 1 Tf
34.7 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinates are)Tj
-35.1 -1.5 TD
(zero; thus, none of the objects are clipped because of their )Tj
/F15 1 Tf
23.5 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( values.)Tj
/F15 1 Tf
-23.9 -2.1 TD
0.028 Tw
[(void gluOrtho2D)-10(\(GLdouble )112(left)-22(, )28(GLdouble )-21(right)45(,)]TJ
0 -1.1 TD
0.049 Tw
[(GLdouble bottom)78(, )49(GLdouble top)-22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Creates a matrix for projecting two-dimensional coordinates onto the screen and multiplies the)Tj
T*
(current projection matrix by it. The clipping region is a rectangle with the lower-left corner at \()Tj
38.4 0 TD
(left,)Tj
-38.4 -1.5 TD
[(bottom)-22(\) and the upper-right corner at \()]TJ
15.7 0 TD
[(right, top)23(\).)]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 348.000 Tm
(Viewing Volume Clipping)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 327.000 Tm
(After the vertices of the objects in the scene have been transformed by the modelview and projection)Tj
0 -1.5 TD
(matrices, any primitives that lie outside the viewing volume are clipped. The six clipping planes used are)Tj
T*
(those that define the sides and ends of the viewing volume. You can specify additional clipping planes)Tj
T*
[(and locate them wherever you choose. \(See )8("Additional Clipping Planes")7( for information about this)]TJ
T*
(relatively advanced topic.\) Keep in mind that OpenGL reconstructs the edges of polygons that get)Tj
T*
(clipped.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 218.000 Tm
(Viewport Transformation)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 196.000 Tm
(Recalling the camera analogy, you know that the viewport transformation corresponds to the stage where)Tj
T*
(the size of the developed photograph is chosen. Do you want a wallet-size or a poster-size photograph?)Tj
T*
(Since this is computer graphics, the viewport is the rectangular region of the window where the image is)Tj
T*
[(drawn. Figure 3-16)226( shows a viewport that occupies most of the screen. The viewport is measured in)]TJ
T*
(window coordinates, which reflect the position of pixels on the screen relative to the lower-left corner of)Tj
T*
(the window. Keep in mind that all vertices have been transformed by the modelview and projection)Tj
T*
(matrices by this point, and vertices outside the viewing volume have been clipped.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 28)Tj
ET
endstream
endobj
380 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
381 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im40
/Width 393
/Height 161
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.39)
>>
stream
endstream
endobj
383 0 obj
<<
/Length 2030
>>
stream
/GS1 gs
q
393 0 0 161 124 559 cm
/Im40 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 546.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-16 )Tj
/F11 1 Tf
5.6 0 TD
(Viewport Rectangle)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 517.000 Tm
(Defining the Viewport)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 496.000 Tm
(The window system, not OpenGL, is responsible for opening a window on the screen. However, by)Tj
0 -1.5 TD
(default the viewport is set to the entire pixel rectangle of the window that's opened. You use the)Tj
/F15 1 Tf
T*
(glViewport\(\))Tj
/F11 1 Tf
5.1 0 TD
( command to choose a smaller drawing region; for example, you can subdivide the window)Tj
-5.1 -1.5 TD
(to create a split-screen effect for multiple views in the same window.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glViewport)46(\(GLint )17(x)-56(,)0( GLint )-16(y)44(,)0( GLsizei )6(width)23(, GLsizei )6(height\);)]TJ
1.8 -1.5 TD
[(Defines a pixel rectangle in the window into which the final image is mapped. The \(x, y)-12(\))0( parameter)]TJ
T*
(specifies the lower-left corner of the viewport, and )Tj
20.5 0 TD
[(width)23( and height are the size of the viewport)]TJ
-20.5 -1.5 TD
[(rectangle. By default, the initial viewport values are \()46(0, 0, winWidth, winHeight\), where )-73(winWidth)]TJ
T*
[(and )-50(winHeight)67( are the size of the window.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(The aspect ratio of a viewport should generally equal the aspect ratio of the viewing volume. If the two)Tj
0 -1.5 TD
(ratios are different, the projected image will be distorted when mapped to the viewport, as shown in)Tj
T*
[(Figure 3-17)226(. Note that subsequent changes to the size of the window don't explicitly affect the viewport.)]TJ
T*
(Your application should detect window resize events and modify the viewport appropriately.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 29)Tj
ET
endstream
endobj
384 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im40 381 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
385 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im41
/Width 515
/Height 306
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.40)
>>
stream
endstream
endobj
387 0 obj
<<
/Length 1925
>>
stream
/GS1 gs
q
423 0 0 251 124 469 cm
/Im41 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 456.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-17 )Tj
/F11 1 Tf
5.6 0 TD
(Mapping the Viewing Volume to the Viewport)Tj
-5.6 -2.1 TD
[(In )-17(Figure 3-17)226(, the left figure shows a projection that maps a square image onto a square viewport using)]TJ
0 -1.5 TD
(these routines:)Tj
/F7 1 Tf
0 -2.1 TD
(gluPerspective\(fovy, 1.0, near, far\); )Tj
0 -1.5 TD
(glViewport\(0, 0, 400, 400\);)Tj
/F11 1 Tf
0 -2.1 TD
(However, in the right figure, the window has been resized to a nonequilateral rectangular viewport, but)Tj
0 -1.5 TD
(the projection is unchanged. The image appears compressed along the )Tj
/F15 1 Tf
28.2 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(-axis.)Tj
/F7 1 Tf
-28.7 -2.1 TD
(gluPerspective\(fovy, 1.0, near, far\);)Tj
0 -1.5 TD
(glViewport \(0, 0, 400, 200\);)Tj
/F11 1 Tf
0 -2.1 TD
(To avoid the distortion, modify the aspect ratio of the projection to match the viewport:)Tj
/F7 1 Tf
T*
(gluPerspective\(fovy, 2.0, near, far\);)Tj
0 -1.5 TD
(glViewport\(0, 0, 400, 200\);)Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
(Modify an existing program so that an object is drawn twice, in different viewports. You might draw the)Tj
0 -1.5 TD
(object with different projection and/or viewing transformations for each viewport. To create two)Tj
T*
(side-by-side viewports, you might issue these commands, along with the appropriate modeling, viewing,)Tj
T*
(and projection transformations:)Tj
/F7 1 Tf
0 -2.1 TD
(glViewport \(0, 0, sizex/2, sizey\); )Tj
0 -1.5 TD
(                    . )Tj
T*
(                    . )Tj
T*
(                    . )Tj
T*
(glViewport \(sizex/2, 0, sizex/2, sizey\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 30)Tj
ET
endstream
endobj
388 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im41 385 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
389 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im42
/Width 409
/Height 168
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.41)
>>
stream
endstream
endobj
391 0 obj
<<
/Length 3814
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 705.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The Transformed Depth Coordinate)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 684.000 Tm
(The depth \()Tj
/F15 1 Tf
4.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(\)  coordinate is encoded during the viewport transformation \(and later stored in the depth)Tj
-5 -1.5 TD
(buffer\). You can scale )Tj
/F15 1 Tf
9.1 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( values to lie within a desired range with the )Tj
/F15 1 Tf
18 0 TD
(glDepthRange\(\))Tj
/F11 1 Tf
6.4 0 TD
[( command. \()28(Chapter)]TJ
-33.9 -1.5 TD
(10 discusses the depth buffer and the corresponding uses for the depth coordinate.\) Unlike )Tj
/F15 1 Tf
36.4 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(y)Tj
/F11 1 Tf
-38.7 -1.5 TD
(window coordinates, )Tj
/F15 1 Tf
8.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( window coordinates are treated by OpenGL as though they always range from 0.0)Tj
-9 -1.5 TD
(to 1.0.)Tj
/F15 1 Tf
0 -2.1 TD
0.027 Tw
[(void glDepthRange)78(\(GLclampd )-67(near)33(, )27(GLclampd far)67(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Defines an encoding for )-11(z)-11( coordinates that's performed during the viewport transformation. The)]TJ
T*
[(near)33( and far)-33( values represent adjustments to the minimum and maximum values that can be stored in)]TJ
T*
(the depth buffer. By default, they're 0.0 and 1.0, respectively, which work for most applications.)Tj
T*
(These parameters are clamped to lie within [0,1].)Tj
/F11 1 Tf
-1.8 -2.1 TD
(In perspective projection, the transformed depth coordinate \(like the )Tj
/F15 1 Tf
27.5 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( coordinates\) is subject to)Tj
-30.3 -1.5 TD
(perspective division by the )Tj
/F15 1 Tf
11 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( coordinate. As the transformed depth coordinate moves farther away from)Tj
-11.7 -1.5 TD
[(the near clipping plane, its location becomes increasingly less precise. \(See Figure 3-18)226(.\))]TJ
ET
Q
/GS1 gs
q
409 0 0 168 124 309.65 cm
/Im42 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 297.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-18 )Tj
/F11 1 Tf
5.6 0 TD
(Perspective Projection and Transformed Depth Coordinates)Tj
-5.6 -2.1 TD
(Therefore, perspective division affects the accuracy of operations which rely upon the transformed depth)Tj
0 -1.5 TD
(coordinate, especially depth-buffering, which is used for hidden surface removal.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 227.000 Tm
(Troubleshooting Transformations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 205.000 Tm
(It's pretty easy to get a camera pointed in the right direction, but in computer graphics, you have to)Tj
T*
(specify position and direction with coordinates and angles. As we can attest, it's all too easy to achieve)Tj
T*
(the well-known black-screen effect. Although any number of things can go wrong, often you get this)Tj
0 -1.6 TD
(effect)Tj
/F33 1 Tf
2.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(which results in absolutely nothing being drawn in the window you open on the screen)Tj
/F33 1 Tf
34.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(from)Tj
-38.9 -1.6 TD
(incorrectly aiming the "camera" and taking a picture with the model behind you. A similar problem arises)Tj
0 -1.5 TD
(if you don't choose a field of view that's wide enough to view your objects but narrow enough so they)Tj
T*
(appear reasonably large.)Tj
0 -2.1 TD
(If you find yourself exerting great programming effort only to create a black window, try these diagnostic)Tj
0 -1.5 TD
(steps.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 31)Tj
ET
endstream
endobj
392 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im42 389 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
394 0 obj
<<
/Length 3916
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 704.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(1.)-1050(Check the obvious possibilities. Make sure your system is plugged in. Make sure you're drawing)]TJ
1.8 -1.5 TD
(your objects with a color that's different from the color with which you're clearing the screen. Make)Tj
T*
(sure that whatever states you're using \(such as lighting, texturing, alpha blending, logical operations,)Tj
T*
(or antialiasing\) are correctly turned on or off, as desired.)Tj
-1.8 -2.1 TD
[(2.)-1050(Remember that with the projection commands, the near and far coordinates measure distance from)]TJ
1.8 -1.5 TD
(the viewpoint and that \(by default\) you're looking down the negative )Tj
/F15 1 Tf
27.9 0 TD
(z)Tj
/F11 1 Tf
0.3 0 TD
( axis. Thus, if the near value is)Tj
-28.2 -1.5 TD
(1.0 and the far 3.0, objects must have )Tj
/F15 1 Tf
15.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinates between -1.0 and -3.0 in order to be visible. To)Tj
-15.6 -1.5 TD
(ensure that you haven't clipped everything out of your scene, temporarily set the near and far)Tj
T*
(clipping planes to some absurdly inclusive values, such as 0.001 and 1000000.0. This alters)Tj
T*
(appearance for operations such as depth-buffering and fog, but it might uncover inadvertently)Tj
T*
(clipped objects.)Tj
-1.8 -2.1 TD
[(3.)-1050(Determine where the viewpoint is, in which direction you're looking, and where your objects are. It)]TJ
1.8 -1.6 TD
(might help to create a real three-dimensional space)Tj
/F33 1 Tf
20.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(using your hands, for instance)Tj
/F33 1 Tf
12 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(to figure these)Tj
-34.4 -1.6 TD
(things out.)Tj
-1.8 -2.1 TD
[(4.)-1050(Make sure you know where you're rotating about. You might be rotating about some arbitrary)]TJ
1.8 -1.5 TD
(location unless you translated back to the origin first. It's OK to rotate about any point unless you're)Tj
T*
(expecting to rotate about the origin.)Tj
-1.8 -2.1 TD
[(5.)-1050(Check your aim. Use )]TJ
/F15 1 Tf
10.5 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
( to aim the viewing volume at your objects. Or draw your objects)Tj
-13.5 -1.5 TD
(at or near the origin, and use )Tj
/F15 1 Tf
11.7 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.7 0 TD
( as a viewing transformation to move the camera far)Tj
-17.4 -1.5 TD
(enough in the )Tj
/F15 1 Tf
5.7 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( direction only so that the objects fall within the viewing volume. Once you've)Tj
-6.1 -1.5 TD
(managed to make your objects visible, try to change the viewing volume incrementally to achieve)Tj
T*
(the exact result you want, as described next.)Tj
-1.8 -2.6 TD
(Even after you've aimed the camera in the correct direction and you can see your objects, they might)Tj
0 -1.5 TD
(appear too small or too large. If you're using )Tj
/F15 1 Tf
18.2 0 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
(, you might need to alter the angle defining)Tj
-24.8 -1.5 TD
(the field of view by changing the value of the first parameter for this command. You can use)Tj
T*
(trigonometry to calculate the desired field of view given the size of the object and its distance from the)Tj
T*
(viewpoint: The tangent of half the desired angle is half the size of the object divided by the distance to)Tj
T*
[(the object \(see )27(Figure 3-19)226(\). Thus, you can use an arctangent routine to compute half the desired angle.)]TJ
T*
(Example 3-3)Tj
5.1 0 TD
( assumes such a routine, )Tj
/F15 1 Tf
10 0 TD
(atan2\(\))Tj
/F11 1 Tf
2.9 0 TD
(, which calculates the arctangent given the length of the)Tj
-18 -1.5 TD
(opposite and adjacent sides of a right triangle. This result then needs to be converted from radians to)Tj
T*
(degrees.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 32)Tj
ET
endstream
endobj
395 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
398 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im43
/Width 420
/Height 189
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.42)
>>
stream
endstream
endobj
399 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im44
/Width 291
/Height 46
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.43)
>>
stream
endstream
endobj
401 0 obj
<<
/Length 2550
>>
stream
/GS1 gs
q
420 0 0 189 124 531 cm
/Im43 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 518.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-19 )Tj
/F11 1 Tf
5.6 0 TD
(Using Trigonometry to Calculate the Field of View)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 3-3 )Tj
/F11 1 Tf
6.1 0 TD
(Calculating Field of View)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#define PI 3.1415926535)Tj
0 -3 TD
(double calculateAngle\(double size, double distance\))Tj
0 -1.5 TD
({)Tj
T*
(    double radtheta, degtheta; )Tj
0 -3 TD
(    radtheta = 2.0 * atan2 \(size/2.0, distance\);)Tj
0 -1.5 TD
(    degtheta = \(180.0 * radtheta\) / PI;)Tj
T*
(    return \(degtheta\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.2 TD
(Of course, typically you don't know the exact size of an object, and the distance can only be determined)Tj
0 -1.5 TD
(between the viewpoint and a single point in your scene. To obtain a fairly good approximate value, find)Tj
T*
(the bounding box for your scene by determining the maximum and minimum )Tj
/F15 1 Tf
31.2 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(, and )Tj
/F15 1 Tf
2.1 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinates of)Tj
-35.1 -1.5 TD
(all the objects in your scene. Then calculate the radius of a bounding sphere for that box, and use the)Tj
T*
(center of the sphere to determine the distance and the radius to determine the size.)Tj
0 -2.2 TD
(For example, suppose all the coordinates in your object satisfy the equations -1 )Tj
/F33 1 Tf
31.9 0 TD
(\243)Tj
/F15 1 Tf
0.5 0 TD
(x)Tj
/F33 1 Tf
0.5 0 TD
(\243)Tj
/F11 1 Tf
0.5 0 TD
( 3, 5 )Tj
/F33 1 Tf
2 0 TD
(\243)Tj
/F15 1 Tf
0.6 0 TD
(y)Tj
/F33 1 Tf
0.4 0 TD
(\243)Tj
/F11 1 Tf
0.6 0 TD
( 7, and -5)Tj
/F33 1 Tf
-37 -1.7 TD
(\243)Tj
/F15 1 Tf
0.5 0 TD
(z)Tj
/F33 1 Tf
0.4 0 TD
(\243)Tj
/F11 1 Tf
0.6 0 TD
( 5. Then the center of the bounding box is \(1, 6, 0\), and the radius of a bounding sphere is the)Tj
-1.5 -1.7 TD
(distance from the center of the box to any corner)Tj
/F33 1 Tf
19.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(say \(3, 7, 5\))Tj
/F33 1 Tf
4.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(or)Tj
ET
Q
q
291 0 0 46 124 140.39 cm
/Im44 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 122.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(If the viewpoint is at \(8, 9, 10\), the distance between it and the center is)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 33)Tj
ET
endstream
endobj
402 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im43 398 0 R
/Im44 399 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
403 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im45
/Width 315
/Height 46
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.44)
>>
stream
endstream
endobj
404 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im46
/Width 498
/Height 183
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.45)
>>
stream
endstream
endobj
406 0 obj
<<
/Length 3138
>>
stream
/GS1 gs
q
315 0 0 46 124 674 cm
/Im45 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 655.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(The tangent of the half angle is 5.477 divided by 12.570, which equals 0.4357, so the half angle is 23.54)Tj
0 -1.5 TD
(degrees.)Tj
0 -2.1 TD
(Remember that the field-of-view angle affects the optimal position for the viewpoint, if you're trying to)Tj
0 -1.5 TD
(achieve a realistic image. For example, if your calculations indicate that you need a 179-degree field of)Tj
T*
(view, the viewpoint must be a fraction of an inch from the screen to achieve realism. If your calculated)Tj
T*
(field of view is too large, you might need to move the viewpoint farther away from the object.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 541.000 Tm
(Manipulating the Matrix Stacks)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 519.000 Tm
(The modelview and projection matrices you've been creating, loading, and multiplying have only been)Tj
T*
(the visible tips of their respective icebergs. Each of these matrices is actually the topmost member of a)Tj
T*
[(stack of matrices \(see )-13(Figure 3-20)226(\).)]TJ
ET
Q
q
423 0 0 155 124 319.35 cm
/Im46 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 306.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-20 )Tj
/F11 1 Tf
5.6 0 TD
(Modelview and Projection Matrix Stacks)Tj
-5.6 -2.1 TD
(A stack of matrices is useful for constructing hierarchical models, in which complicated objects are)Tj
0 -1.5 TD
(constructed from simpler ones. For example, suppose you're drawing an automobile that has four wheels,)Tj
T*
(each of which is attached to the car with five bolts. You have a single routine to draw a wheel and)Tj
T*
(another to draw a bolt, since all the wheels and all the bolts look the same. These routines draw a wheel)Tj
T*
(or a bolt in some convenient position and orientation, say centered at the origin with its axis coincident)Tj
T*
(with the )Tj
/F15 1 Tf
3.5 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( axis. When you draw the car, including the wheels and bolts, you want to call the)Tj
-3.9 -1.5 TD
(wheel-drawing routine four times with different transformations in effect each time to position the)Tj
T*
(wheels correctly. As you draw each wheel, you want to draw the bolts five times, each time translated)Tj
T*
(appropriately relative to the wheel.)Tj
0 -2.1 TD
(Suppose for a minute that all you have to do is draw the car body and the wheels. The English description)Tj
0 -1.5 TD
(of what you want to do might be something like this:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Draw the car body. Remember where you are, and translate to the right front wheel. Draw the wheel)Tj
0 -1.6 TD
(and throw away the last translation so your current position is back at the origin of the car body.)Tj
0 -1.5 TD
(Remember where you are, and translate to the left front wheel....)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 34)Tj
ET
endstream
endobj
407 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im45 403 0 R
/Im46 404 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
408 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im47
/Width 319
/Height 159
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.46)
>>
stream
endstream
endobj
410 0 obj
<<
/Length 3281
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 697.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Similarly, for each wheel, you want to draw the wheel, remember where you are, and successively)Tj
0 -1.5 TD
(translate to each of the positions that bolts are drawn, throwing away the transformations after each bolt)Tj
T*
(is drawn.)Tj
0 -2.1 TD
(Since the transformations are stored as matrices, a matrix stack provides an ideal mechanism for doing)Tj
0 -1.5 TD
(this sort of successive remembering, translating, and throwing away. All the matrix operations that have)Tj
T*
(been described so far \()Tj
/F15 1 Tf
9.1 0 TD
(glLoadMatrix\(\))Tj
/F11 1 Tf
6.2 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glMultMatrix\(\))Tj
/F11 1 Tf
6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( and the commands that create)Tj
-28.9 -1.5 TD
(specific transformation matrices\) deal with the current matrix, or the top matrix on the stack. You can)Tj
T*
(control which matrix is on top with the commands that perform stack operations: )Tj
/F15 1 Tf
32.6 0 TD
(glPushMatrix\(\))Tj
/F11 1 Tf
6.2 0 TD
(, which)Tj
-38.8 -1.5 TD
(copies the current matrix and adds the copy to the top of the stack, and )Tj
/F15 1 Tf
28.5 0 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
(, which discards the)Tj
-34.3 -1.5 TD
[(top matrix on the stack, as shown in )40(Figure 3-21)226(. \(Remember that the current matrix is always the matrix)]TJ
T*
(on the top.\) In effect, )Tj
/F15 1 Tf
8.7 0 TD
(glPushMatrix\(\))Tj
/F11 1 Tf
6.2 0 TD
( means "remember where you are" and )Tj
/F15 1 Tf
15.7 0 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
( means "go)Tj
-36.4 -1.5 TD
(back to where you were.")Tj
ET
Q
/GS1 gs
q
319 0 0 159 124 353.04 cm
/Im47 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 340.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-21 )Tj
/F11 1 Tf
5.6 0 TD
(Pushing and Popping the Matrix Stack)Tj
/F15 1 Tf
-5.6 -2.1 TD
0.028 Tw
(void glPushMatrix\(void\);)Tj
1.8 -1.5 TD
0.000 Tw
(Pushes all matrices in the current stack down one level. The current stack is determined by)Tj
T*
[(glMatrixMode\(\))44(. The topmost matrix is copied, so its contents are duplicated in both the top and)]TJ
T*
(second-from-the-top matrix. If too many matrices are pushed, an error is generated.)Tj
-1.8 -2.1 TD
0.028 Tw
[(void glPopMatrix)12(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Pops the top matrix off the stack, destroying the contents of the popped matrix. What was the)Tj
T*
(second-from-the-top matrix becomes the top matrix. The current stack is determined by)Tj
T*
[(glMatrixMode\(\))44(. If the stack contains a single matrix, calling )7(glPopMatrix\(\))-22( generates an error.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(Example 3-4)Tj
5.1 0 TD
( draws an automobile, assuming the existence of routines that draw the car body, a wheel,)Tj
-5.1 -1.5 TD
(and a bolt.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 3-4 )Tj
/F11 1 Tf
6.1 0 TD
(Pushing and Popping the Matrix)Tj
/F7 1 Tf
-6.1 -2.3 TD
(draw_wheel_and_bolts\(\))Tj
0 -1.5 TD
({)Tj
T*
(   long i;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 35)Tj
ET
endstream
endobj
411 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im47 408 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
413 0 obj
<<
/Length 3130
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   draw_wheel\(\);)Tj
0 -1.5 TD
(   for\(i=0;i<5;i++\){)Tj
T*
(      glPushMatrix\(\);)Tj
T*
(         glRotatef\(72.0*i,0.0,0.0,1.0\);)Tj
T*
(         glTranslatef\(3.0,0.0,0.0\);)Tj
T*
(         draw_bolt\(\);)Tj
T*
(      glPopMatrix\(\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(draw_body_and_wheel_and_bolts\(\))Tj
0 -1.5 TD
({)Tj
T*
(   draw_car_body\(\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(      glTranslatef\(40,0,30\);    /*move to first wheel position*/)Tj
T*
(      draw_wheel_and_bolts\(\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(      glTranslatef\(40,0,-30\);   /*move to 2nd wheel position*/)Tj
T*
(      draw_wheel_and_bolts\(\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   ...                    /*draw last two wheels similarly*/)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(This code assumes the wheel and bolt axes are coincident with the )Tj
/F15 1 Tf
26.8 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis, that the bolts are evenly spaced)Tj
-27.2 -1.5 TD
(every 72 degrees, 3 units \(maybe inches\) from the center of the wheel, and that the front wheels are 40)Tj
T*
(units in front of and 30 units to the right and left of the car's origin.)Tj
0 -2.1 TD
(A stack is more efficient than an individual matrix, especially if the stack is implemented in hardware.)Tj
0 -1.5 TD
(When you push a matrix, you don't need to copy the current data back to the main process, and the)Tj
T*
(hardware may be able to copy more than one element of the matrix at a time. Sometimes you might want)Tj
T*
(to keep an identity matrix at the bottom of the stack so that you don't need to call )Tj
/F15 1 Tf
32.8 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
-32.8 -1.5 TD
(repeatedly.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 221.000 Tm
(The Modelview Matrix Stack)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 199.000 Tm
[(As you've seen earlier in )48("Viewing and Modeling Transformations,")-95( the modelview matrix contains the)]TJ
T*
(cumulative product of multiplying viewing and modeling transformation matrices. Each viewing or)Tj
T*
(modeling transformation creates a new matrix that multiplies the current modelview matrix; the result,)Tj
T*
(which becomes the new current matrix, represents the composite transformation. The modelview matrix)Tj
0 -1.6 TD
(stack contains at least thirty-two 4)Tj
/F33 1 Tf
13.7 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 matrices; initially, the topmost matrix is the identity matrix. Some)Tj
-14.2 -1.6 TD
(implementations of OpenGL may support more than thirty-two matrices on the stack. To find the)Tj
0 -1.5 TD
(maximum allowable number of matrices, you can use the query command)Tj
/F15 1 Tf
T*
(glGetIntegerv)Tj
/F11 1 Tf
5.6 0 TD
(\(GL_MAX_MODELVIEW_STACK_DEPTH)Tj
/F15 1 Tf
18.6 0 TD
(, )Tj
/F11 1 Tf
0.5 0 TD
(GLint *)Tj
/F15 1 Tf
3.2 0 TD
(params)Tj
/F11 1 Tf
3 0 TD
(\).)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 36)Tj
ET
endstream
endobj
414 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
416 0 obj
<<
/Length 3731
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The Projection Matrix Stack)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 687.000 Tm
(The projection matrix contains a matrix for the projection transformation, which describes the viewing)Tj
0 -1.5 TD
(volume. Generally, you don't want to compose projection matrices, so you issue )Tj
/F15 1 Tf
32.4 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( before)Tj
-39 -1.5 TD
(performing a projection transformation. Also for this reason, the projection matrix stack need be only two)Tj
0 -1.6 TD
(levels deep; some OpenGL implementations may allow more than two 4)Tj
/F33 1 Tf
29 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 matrices. To find the stack)Tj
-29.5 -1.6 TD
(depth, call )Tj
/F15 1 Tf
4.4 0 TD
(glGetIntegerv)Tj
/F11 1 Tf
5.6 0 TD
(\(GL_MAX_PROJECTION_STACK_DEPTH)Tj
/F15 1 Tf
18.5 0 TD
(, )Tj
/F11 1 Tf
0.5 0 TD
(GLint *)Tj
/F15 1 Tf
3.1 0 TD
(params)Tj
/F11 1 Tf
3 0 TD
(\).)Tj
-35.1 -2.1 TD
(One use for a second matrix in the stack would be an application that needs to display a help window)Tj
0 -1.5 TD
(with text in it, in addition to its normal window showing a three-dimensional scene. Since text is most)Tj
T*
(easily positioned with an orthographic projection, you could change temporarily to an orthographic)Tj
T*
(projection, display the help, and then return to your previous projection:)Tj
/F7 1 Tf
0 -2.1 TD
(glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(glPushMatrix\(\);                  /*save the current projection*/)Tj
T*
(    glLoadIdentity\(\);)Tj
T*
(    glOrtho\(...\);                /*set up for displaying help*/)Tj
T*
(    display_the_help\(\);)Tj
T*
(glPopMatrix\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(Note that you'd probably have to also change the modelview matrix appropriately.)Tj
/F27 1 Tf
8 -2.2 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(If you know enough mathematics, you can create custom projection matrices that perform arbitrary)Tj
0 -1.5 TD
(projective transformations. For example, the OpenGL and its Utility Library have no built-in mechanism)Tj
T*
(for two-point perspective. If you were trying to emulate the drawings in drafting texts, you might need)Tj
T*
(such a projection matrix.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 321.000 Tm
(Additional Clipping Planes)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 299.000 Tm
(In addition to the six clipping planes of the viewing volume \(left, right, bottom, top, near, and far\), you)Tj
T*
[(can define up to six additional clipping planes to further restrict the viewing volume, as shown in )12(Figure)]TJ
0 -1.6 TD
(3-22)Tj
1.8 0 TD
(. This is useful for removing extraneous objects in a scene)Tj
/F33 1 Tf
23.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, if you want to display a)Tj
-26.1 -1.6 TD
(cutaway view of an object.)Tj
0 -2.1 TD
(Each plane is specified by the coefficients of its equation: A)Tj
/F15 1 Tf
24.1 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(+B)Tj
/F15 1 Tf
1.2 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(+C)Tj
/F15 1 Tf
1.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(+D = 0. The clipping planes are)Tj
-27.8 -1.5 TD
(automatically transformed appropriately by modeling and viewing transformations. The clipping volume)Tj
0 -1.6 TD
(becomes the intersection of the viewing volume and all )Tj
/F13 1 Tf
22.4 0 TD
(half-spaces)Tj
/F11 1 Tf
4.7 0 TD
( defined by the additional clipping)Tj
-27.1 -1.5 TD
(planes. Remember that polygons that get clipped automatically have their edges reconstructed)Tj
T*
(appropriately by OpenGL.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 37)Tj
ET
endstream
endobj
417 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
418 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im48
/Width 472
/Height 186
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.47)
>>
stream
endstream
endobj
420 0 obj
<<
/Length 3258
>>
stream
q
1 i 
124.000 720.000 422.990 -166.690 re
W n
/GS1 gs
q
423 0 0 167 124 553 cm
/Im48 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 541.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 3-22 )Tj
/F11 1 Tf
5.6 0 TD
(Additional Clipping Planes and the Viewing Volume)Tj
/F15 1 Tf
-5.6 -2.2 TD
[(void )-28(glClipPlane)35(\(GLenum )27(plane)-78(, const GLdouble )12(*equation\);)]TJ
1.8 -1.5 TD
[(Defines a clipping plane. The )-44(equation argument points to the four coefficients of the plane)]TJ
T*
[(equation, A)11(x)-56(+B)86(y)-56(+)0(C)42(z)-11(+D = 0. All points with eye coordinates \(x)]TJ
25.5 -0.2 TD
(e)Tj
0.4 0.2 TD
(, y)Tj
1 -0.2 TD
(e)Tj
0.4 0.2 TD
(, z)Tj
0.9 -0.2 TD
(e)Tj
0.5 0.2 TD
(, w)Tj
1.1 -0.2 TD
(e)Tj
0.5 0.2 TD
(\) that satisfy \(A B C)Tj
-30.3 -1.7 TD
(D\)M-1 \(x)Tj
3.7 -0.2 TD
(e)Tj
0.5 0.2 TD
( y)Tj
0.7 -0.2 TD
(e)Tj
0.4 0.2 TD
( z)Tj
0.7 -0.2 TD
(e)Tj
0.4 0.2 TD
( w)Tj
0.9 -0.2 TD
(e)Tj
0.5 0.2 TD
(\)T >= 0 lie in the half-space defined by the plane, where M is the current)Tj
-7.8 -1.7 TD
[(modelview matrix at the time )-39(glClipPlane\(\) is called. All points not in this half-space are clipped)]TJ
0 -1.5 TD
[(away. The )-38(plane)22( argument is GL_CLIP_PLANE)52(i)-22(,)0( where )-6(i)-22( is an integer specifying which of the)]TJ
T*
[(available clipping planes to define. )35(i)-22( is a number between 0 and one less than the maximum number)]TJ
T*
(of additional clipping planes.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(You need to enable each additional clipping plane you define:)Tj
/F7 1 Tf
0 -2 TD
(glEnable\(GL_CLIP_PLANE)Tj
10.000 0.000 2.126 10.000 256.000 369.000 Tm
(i)Tj
10.000 0.000 0.000 10.000 262.000 369.000 Tm
(\);)Tj
/F11 1 Tf
-13.8 -2.2 TD
(You can disable a plane with)Tj
/F7 1 Tf
0 -2 TD
(glDisable\(GL_CLIP_PLANE)Tj
10.000 0.000 2.126 10.000 262.000 327.000 Tm
(i)Tj
10.000 0.000 0.000 10.000 268.000 327.000 Tm
(\);)Tj
/F11 1 Tf
-14.4 -2.2 TD
(All implementations of OpenGL must support at least six additional clipping planes, although some)Tj
0 -1.5 TD
(implementations may allow more. You can use )Tj
/F15 1 Tf
19.1 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
( with GL_MAX_CLIP_PLANES to find)Tj
-25.3 -1.5 TD
(how many clipping planes are supported.)Tj
/F27 1 Tf
0 -2 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Clipping performed as a result of )Tj
/F15 1 Tf
13.5 0 TD
(glClipPlane\(\))Tj
/F11 1 Tf
5.5 0 TD
( is done in eye coordinates, not in clip coordinates.)Tj
-21.8 -1.5 TD
(This difference is noticeable if the projection matrix is singular \(that is, a real projection matrix that)Tj
0 -1.4 TD
(flattens three-dimensional coordinates to two-dimensional ones\). Clipping performed in eye coordinates)Tj
T*
(continues to take place in three dimensions even when the projection matrix is singular.)Tj
/F27 1 Tf
0 -3 TD
(A Clipping Plane Code Example)Tj
/F11 1 Tf
0 -2.1 TD
(Example 3-5)Tj
5.1 0 TD
( renders a wireframe sphere with two clipping planes that slice away three-quarters of the)Tj
-5.1 -1.5 TD
[(original sphere, as shown in )44(Figure 3-23)226(.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 38)Tj
ET
endstream
endobj
421 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im48 418 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
422 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im49
/Width 131
/Height 127
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.48)
>>
stream
endstream
endobj
424 0 obj
<<
/Length 1520
>>
stream
/GS1 gs
q
131 0 0 127 124 593 cm
/Im49 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 580.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-23 )Tj
/F11 1 Tf
5.6 0 TD
(Clipped Wireframe Sphere)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 3-5 )Tj
/F11 1 Tf
6.1 0 TD
(Wireframe Sphere with Two Clipping Planes: clip.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
0 -3 TD
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLdouble eqn[4] = {0.0, 1.0, 0.0, 0.0};)Tj
T*
(   GLdouble eqn2[4] = {1.0, 0.0, 0.0, 0.0};)Tj
0 -3 TD
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glTranslatef \(0.0, 0.0, -5.0\);)Tj
0 -3 TD
(/*    clip lower half -- y < 0          */)Tj
0 -1.5 TD
(   glClipPlane \(GL_CLIP_PLANE0, eqn\);)Tj
T*
(   glEnable \(GL_CLIP_PLANE0\);)Tj
T*
(/*    clip left half -- x < 0           */)Tj
T*
(   glClipPlane \(GL_CLIP_PLANE1, eqn2\);)Tj
T*
(   glEnable \(GL_CLIP_PLANE1\);)Tj
0 -3 TD
(   glRotatef \(90.0, 1.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glutWireSphere\(1.0, 20, 16\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glFlush \(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 39)Tj
ET
endstream
endobj
425 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im49 422 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
427 0 obj
<<
/Length 2840
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\); )Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   gluPerspective\(60.0, \(GLfloat\) w/\(GLfloat\) h, 1.0, 20.0\);)Tj
T*
(   glMatrixMode \(GL_MODELVIEW\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F33 1 Tf
-7.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[(Try changing the coefficients that describe the clipping planes in )-35(Example 3-5)]TJ
31.3 0 TD
(.)Tj
/F33 1 Tf
-33.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Try calling a modeling transformation, such as )Tj
/F15 1 Tf
18.9 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
(, to affect )Tj
/F15 1 Tf
4.1 0 TD
(glClipPlane\(\))Tj
/F11 1 Tf
5.5 0 TD
(. Make the)Tj
-33.1 -1.6 TD
(clipping plane move independently of the objects in the scene.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 245.000 Tm
(Examples of Composing Several Transformations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 223.000 Tm
(This section demonstrates how to combine several transformations to achieve a particular result. The two)Tj
0 -1.5 TD
(examples discussed are a solar system, in which objects need to rotate on their axes as well as in orbit)Tj
T*
(around each other, and a robot arm, which has several joints that effectively transform coordinate)Tj
T*
(systems as they move relative to each other.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 149.000 Tm
(Building a Solar System)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 127.000 Tm
(The program described in this section draws a simple solar system with a planet and a sun, both using the)Tj
T*
(same sphere-drawing routine. To write this program, you need to use )Tj
/F15 1 Tf
27.9 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.5 0 TD
( for the revolution of the)Tj
-32.4 -1.5 TD
(planet around the sun and for the rotation of the planet around its own axis. You also need )Tj
/F15 1 Tf
36.3 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
-36.3 -1.5 TD
(to move the planet out to its orbit, away from the origin of the solar system. Remember that you can)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 40)Tj
ET
endstream
endobj
428 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
429 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im50
/Width 431
/Height 146
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.49)
>>
stream
endstream
endobj
431 0 obj
<<
/Length 3342
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(specify the desired size of the two spheres by supplying the appropriate arguments for the)Tj
/F15 1 Tf
0 -1.5 TD
(glutWireSphere\(\))Tj
/F11 1 Tf
6.9 0 TD
( routine.)Tj
-6.9 -2.1 TD
(To draw the solar system, you first want to set up a projection and a viewing transformation. For this)Tj
0 -1.5 TD
(example, )Tj
/F15 1 Tf
3.9 0 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
( are used.)Tj
-17.3 -2.1 TD
(Drawing the sun is straightforward, since it should be located at the origin of the grand, fixed coordinate)Tj
0 -1.5 TD
(system, which is where the sphere routine places it. Thus, drawing the sun doesn't require translation;)Tj
T*
(you can use )Tj
/F15 1 Tf
5 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.5 0 TD
( to make the sun rotate about an arbitrary axis. To draw a planet rotating around)Tj
-9.5 -1.5 TD
[(the sun, as shown in )34(Figure 3-24)226(, requires several modeling transformations. The planet needs to rotate)]TJ
T*
(about its own axis once a day. And once a year, the planet completes one revolution around the sun.)Tj
ET
Q
/GS1 gs
q
423 0 0 143 124 421.84 cm
/Im50 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 409.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-24 )Tj
/F11 1 Tf
5.6 0 TD
(Planet and Sun)Tj
-5.6 -2.1 TD
(To determine the order of modeling transformations, visualize what happens to the local coordinate)Tj
0 -1.5 TD
(system. An initial )Tj
/F15 1 Tf
7.3 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
( rotates the local coordinate system that initially coincides with the grand)Tj
-11.9 -1.5 TD
(coordinate system. Next, )Tj
/F15 1 Tf
10.2 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
( moves the local coordinate system to a position on the planet's)Tj
-16 -1.5 TD
(orbit; the distance moved should equal the radius of the orbit. Thus, the initial )Tj
/F15 1 Tf
31.4 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.5 0 TD
( actually)Tj
-35.9 -1.5 TD
(determines where along the orbit the planet is \(or what time of year it is\).)Tj
0 -2.1 TD
(A second )Tj
/F15 1 Tf
4 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
( rotates the local coordinate system around the local axes, thus determining the time)Tj
-8.6 -1.5 TD
(of day for the planet. Once you've issued all these transformation commands, the planet can be drawn.)Tj
0 -2.1 TD
(In summary, these are the OpenGL commands to draw the sun and planet; the full program is shown in)Tj
0 -1.5 TD
(Example 3-6)Tj
5.1 0 TD
(.)Tj
/F7 1 Tf
-5.1 -2.1 TD
(glPushMatrix\(\);)Tj
0 -1.5 TD
(glutWireSphere\(1.0, 20, 16\);     /* draw sun */)Tj
T*
(glRotatef \(\(GLfloat\) year, 0.0, 1.0, 0.0\);)Tj
T*
(glTranslatef \(2.0, 0.0, 0.0\);)Tj
T*
(glRotatef \(\(GLfloat\) day, 0.0, 1.0, 0.0\);)Tj
T*
(glutWireSphere\(0.2, 10, 8\);      /* draw smaller planet */)Tj
T*
(glPopMatrix\(\);)Tj
/F27 1 Tf
0 -2.1 TD
(Example 3-6 )Tj
/F11 1 Tf
6.1 0 TD
(Planetary System: planet.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 41)Tj
ET
endstream
endobj
432 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im50 429 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
434 0 obj
<<
/Length 1687
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(#include <GL/glut.h>)Tj
0 -3 TD
(static int year = 0, day = 0;)Tj
T*
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear \(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
0 -3 TD
(   glPushMatrix\(\);)Tj
0 -1.5 TD
(   glutWireSphere\(1.0, 20, 16\);   /* draw sun */)Tj
T*
(   glRotatef \(\(GLfloat\) year, 0.0, 1.0, 0.0\);)Tj
T*
(   glTranslatef \(2.0, 0.0, 0.0\);)Tj
T*
(   glRotatef \(\(GLfloat\) day, 0.0, 1.0, 0.0\);)Tj
T*
(   glutWireSphere\(0.2, 10, 8\);    /* draw smaller planet */)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glutSwapBuffers\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\); )Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   gluPerspective\(60.0, \(GLfloat\) w/\(GLfloat\) h, 1.0, 20.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluLookAt \(0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard \(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `d':)Tj
T*
(         day = \(day + 10\) % 360;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 42)Tj
ET
endstream
endobj
435 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
438 0 obj
<<
/Length 2211
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      case `D':)Tj
0 -1.5 TD
(         day = \(day - 10\) % 360;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `y':)Tj
T*
(         year = \(year + 5\) % 360;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `Y':)Tj
T*
(         year = \(year - 5\) % 360;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_DOUBLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F33 1 Tf
-7.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Try adding a moon to the planet. Or try several moons and additional planets. Hint: Use)Tj
/F15 1 Tf
0 -1.6 TD
(glPushMatrix\(\))Tj
/F11 1 Tf
6.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
( to save and restore the position and orientation of the coordinate)Tj
-13.9 -1.5 TD
(system at appropriate moments. If you're going to draw several moons around a planet, you need to)Tj
T*
(save the coordinate system prior to positioning each moon and restore the coordinate system after)Tj
T*
(each moon is drawn.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Try tilting the planet's axis.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 99.000 Tm
(Building an Articulated Robot Arm)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 78.000 Tm
(This section discusses a program that creates an articulated robot arm with two or more segments. The)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 43)Tj
ET
endstream
endobj
439 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
440 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im51
/Width 137
/Height 92
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.50)
>>
stream
endstream
endobj
442 0 obj
<<
/Length 3237
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(arm should be connected with pivot points at the shoulder, elbow, or other joints. Figure 3-25)226( shows a)]TJ
0 -1.5 TD
(single joint of such an arm.)Tj
ET
Q
/GS1 gs
q
137 0 0 92 124 589.7 cm
/Im51 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 577.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-25 )Tj
/F11 1 Tf
5.6 0 TD
(Robot Arm)Tj
-5.6 -2.1 TD
(You can use a scaled cube as a segment of the robot arm, but first you must call the appropriate modeling)Tj
0 -1.5 TD
(transformations to orient each segment. Since the origin of the local coordinate system is initially at the)Tj
T*
(center of the cube, you need to move the local coordinate system to one edge of the cube. Otherwise, the)Tj
T*
(cube rotates about its center rather than the pivot point.)Tj
0 -2.1 TD
(After you call )Tj
/F15 1 Tf
5.8 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
( to establish the pivot point and )Tj
/F15 1 Tf
12.8 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.5 0 TD
( to pivot the cube, translate back)Tj
-28.9 -1.5 TD
(to the center of the cube. Then the cube is scaled \(flattened and widened\) before it is drawn. The)Tj
/F15 1 Tf
T*
(glPushMatrix\(\))Tj
/F11 1 Tf
6.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
( restrict the effect of )Tj
/F15 1 Tf
8.3 0 TD
(glScale*\(\))Tj
/F11 1 Tf
4.2 0 TD
(. Here's what your code might look like)Tj
-26.4 -1.5 TD
[(for this first segment of the arm \(the entire program is shown in )-6(Example 3-7)]TJ
30.8 0 TD
(\):)Tj
/F7 1 Tf
-30.8 -2.1 TD
(glTranslatef \(-1.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(glRotatef \(\(GLfloat\) shoulder, 0.0, 0.0, 1.0\);)Tj
T*
(glTranslatef \(1.0, 0.0, 0.0\);)Tj
T*
(glPushMatrix\(\);)Tj
T*
(glScalef \(2.0, 0.4, 1.0\);)Tj
T*
(glutWireCube \(1.0\);)Tj
T*
(glPopMatrix\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(To build a second segment, you need to move the local coordinate system to the next pivot point. Since)Tj
0 -1.5 TD
(the coordinate system has previously been rotated, the )Tj
/F15 1 Tf
21.9 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(-axis is already oriented along the length of the)Tj
-22.4 -1.5 TD
(rotated arm. Therefore, translating along the )Tj
/F15 1 Tf
17.9 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(-axis moves the local coordinate system to the next pivot)Tj
-18.4 -1.5 TD
(point. Once it's at that pivot point, you can use the same code to draw the second segment as you used)Tj
T*
(for the first one. This can be continued for an indefinite number of segments \(shoulder, elbow, wrist,)Tj
T*
(fingers\).)Tj
/F7 1 Tf
0 -2.1 TD
(glTranslatef \(1.0, 0.0, 0.0\); )Tj
0 -1.5 TD
(glRotatef \(\(GLfloat\) elbow, 0.0, 0.0, 1.0\);)Tj
T*
(glTranslatef \(1.0, 0.0, 0.0\);)Tj
T*
(glPushMatrix\(\);)Tj
T*
(glScalef \(2.0, 0.4, 1.0\);)Tj
T*
(glutWireCube \(1.0\);)Tj
T*
(glPopMatrix\(\);)Tj
/F27 1 Tf
0 -2.1 TD
(Example 3-7 )Tj
/F11 1 Tf
6.1 0 TD
(Robot Arm: robot.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 44)Tj
ET
endstream
endobj
443 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im51 440 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
445 0 obj
<<
/Length 1644
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(#include <GL/glu.h>)Tj
0 -1.5 TD
(#include <GL/glut.h>)Tj
0 -3 TD
(static int shoulder = 0, elbow = 0;)Tj
T*
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(  glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(  glShadeModel \(GL_FLAT\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear \(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glTranslatef \(-1.0, 0.0, 0.0\);)Tj
T*
(   glRotatef \(\(GLfloat\) shoulder, 0.0, 0.0, 1.0\);)Tj
T*
(   glTranslatef \(1.0, 0.0, 0.0\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glScalef \(2.0, 0.4, 1.0\);)Tj
T*
(   glutWireCube \(1.0\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(   glTranslatef \(1.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glRotatef \(\(GLfloat\) elbow, 0.0, 0.0, 1.0\);)Tj
T*
(   glTranslatef \(1.0, 0.0, 0.0\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glScalef \(2.0, 0.4, 1.0\);)Tj
T*
(   glutWireCube \(1.0\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(   glPopMatrix\(\);)Tj
0 -1.5 TD
(   glutSwapBuffers\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\); )Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   gluPerspective\(65.0, \(GLfloat\) w/\(GLfloat\) h, 1.0, 20.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 45)Tj
ET
endstream
endobj
446 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
448 0 obj
<<
/Length 1660
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glTranslatef \(0.0, 0.0, -5.0\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void keyboard \(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `s':   /*  s key rotates at shoulder  */)Tj
T*
(         shoulder = \(shoulder + 5\) % 360;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `S':)Tj
T*
(         shoulder = \(shoulder - 5\) % 360;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `e':  /*  e key rotates at elbow  */)Tj
T*
(         elbow = \(elbow + 5\) % 360;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `E':)Tj
T*
(         elbow = \(elbow - 5\) % 360;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_DOUBLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 46)Tj
ET
endstream
endobj
449 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
450 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im52
/Width 216
/Height 157
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.51)
>>
stream
endstream
endobj
452 0 obj
<<
/Length 3775
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
0.050 Tw
[(Modify Example )50(3-7)]TJ
8.4 0 TD
0.000 Tw
( to add additional segments onto the robot arm.)Tj
/F33 1 Tf
-10.2 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
0.050 Tw
[(Modify Example )50(3-7)]TJ
8.4 0 TD
0.000 Tw
( to add additional segments at the same position. For example, give the robot)Tj
-8.4 -1.6 TD
[(arm several "fingers" at the wrist, as shown in )48(Figure 3-26)226(. Hint: Use )]TJ
/F15 1 Tf
28 0 TD
(glPushMatrix\(\))Tj
/F11 1 Tf
6.1 0 TD
( and)Tj
/F15 1 Tf
-34.1 -1.5 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
( to save and restore the position and orientation of the coordinate system at the wrist.)Tj
-5.8 -1.5 TD
(If you're going to draw fingers at the wrist, you need to save the current matrix prior to positioning)Tj
T*
(each finger and restore the current matrix after each finger is drawn.)Tj
ET
Q
/GS1 gs
q
216 0 0 157 143 455.1 cm
/Im52 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 143.000 442.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 3-26 )Tj
/F11 1 Tf
5.6 0 TD
(Robot Arm with Fingers)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 403.000 Tm
(Reversing or Mimicking Transformations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 381.000 Tm
(The geometric processing pipeline is very good at using viewing and projection matrices and a viewport)Tj
0 -1.5 TD
(for clipping to transform the world \(or object\) coordinates of a vertex into window \(or screen\))Tj
T*
(coordinates. However, there are situations in which you want to reverse that process. A common)Tj
T*
(situation is when an application user utilizes the mouse to choose a location in three dimensions. The)Tj
T*
(mouse returns only a two-dimensional value, which is the screen location of the cursor. Therefore, the)Tj
T*
(application will have to reverse the transformation process to determine from where in three-dimensional)Tj
T*
(space this screen location originated.)Tj
0 -2.1 TD
(The Utility Library routine )Tj
/F15 1 Tf
11 0 TD
(gluUnProject\(\))Tj
/F11 1 Tf
6.1 0 TD
( performs this reversal of the transformations. Given the)Tj
-17.1 -1.5 TD
(three-dimensional window coordinates for a location and all the transformations that affected them,)Tj
/F15 1 Tf
T*
(gluUnProject\(\))Tj
/F11 1 Tf
6.1 0 TD
( returns the world coordinates from where it originated.)Tj
/F15 1 Tf
-6.1 -2.1 TD
[(int )6(gluUnProject)-55(\(GLdouble )84(winx)-11(, GLdouble )-49(winy)-11(, GLdouble )51(winz)34(, const GLdouble )-88(modelMatrix[16],)]TJ
0 -1.5 TD
[(const GLdouble )12(projMatrix[16], )-32(const GLint )46(viewport[4], )-21(GLdouble )-50(*objx)22(, GLdouble )51(*objy)22(, GLdouble)]TJ
T*
[(*objz)-33(\);)]TJ
1.8 -1.5 TD
[(Map the specified window coordinates \()29(winx, winy, winz)13(\) into object coordinates, using)]TJ
T*
[(transformations defined by a modelview matrix \(modelMatrix)-33(\), projection matrix \()-11(projMatrix)89(\), and)]TJ
T*
[(viewport \()-17(viewport\). The resulting object coordinates are returned in )62(objx, objy,)-6( and objz)-33(. The)]TJ
T*
(function returns GL_TRUE, indicating success, or GL_FALSE, indicating failure \(such as an)Tj
T*
(noninvertible matrix\). This operation does not attempt to clip the coordinates to the viewport or)Tj
T*
[(eliminate depth values that fall outside of )8(glDepthRange\(\))44(.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(There are inherent difficulties in trying to reverse the transformation process. A two-dimensional screen)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 47)Tj
ET
endstream
endobj
453 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im52 450 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
455 0 obj
<<
/Length 2803
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(location could have originated from anywhere on an entire line in three-dimensional space. To)Tj
0 -1.5 TD
(disambiguate the result, )Tj
/F15 1 Tf
9.8 0 TD
(gluUnProject\(\))Tj
/F11 1 Tf
6.1 0 TD
( requires that a window depth coordinate \()Tj
/F15 1 Tf
16.9 0 TD
(winz)Tj
/F11 1 Tf
1.8 0 TD
(\) be provided and)Tj
-34.6 -1.5 TD
(that )Tj
/F15 1 Tf
1.8 0 TD
(winz)Tj
/F11 1 Tf
1.8 0 TD
( be specified in terms of )Tj
/F15 1 Tf
9.9 0 TD
(glDepthRange\(\))Tj
/F11 1 Tf
6.4 0 TD
(. For the default values of )Tj
/F15 1 Tf
10.5 0 TD
(glDepthRange\(\))Tj
/F11 1 Tf
6.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(winz )Tj
/F11 1 Tf
2.1 0 TD
(at 0.0)Tj
-39.5 -1.5 TD
(will request the world coordinates of the transformed point at the near clipping plane, while )Tj
/F15 1 Tf
36.9 0 TD
(winz)Tj
/F11 1 Tf
1.8 0 TD
( at 1.0)Tj
-38.7 -1.5 TD
(will request the point at the far clipping plane.)Tj
0 -2.1 TD
(Example 3-8)Tj
5.1 0 TD
( demonstrates )Tj
/F15 1 Tf
5.8 0 TD
(gluUnProject\(\))Tj
/F11 1 Tf
6.1 0 TD
( by reading the mouse position and determining the)Tj
-17 -1.5 TD
(three-dimensional points at the near and far clipping planes from which it was transformed. The)Tj
T*
(computed world coordinates are printed to standard output, but the rendered window itself is just black.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 3-8 )Tj
/F11 1 Tf
6.1 0 TD
(Reversing the Geometric Processing Pipeline: unproject.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluPerspective \(45.0, \(GLfloat\) w/\(GLfloat\) h, 1.0, 100.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void mouse\(int button, int state, int x, int y\) )Tj
0 -1.5 TD
({)Tj
T*
(   GLint viewport[4];)Tj
T*
(   GLdouble mvmatrix[16], projmatrix[16];)Tj
T*
(   GLint realy;  /*  OpenGL y coordinate position  */)Tj
T*
(   GLdouble wx, wy, wz;  /*  returned world x, y, z coords  */)Tj
0 -3 TD
(   switch \(button\) {)Tj
0 -1.5 TD
(      case GLUT_LEFT_BUTTON:)Tj
T*
(         if \(state == GLUT_DOWN\) {)Tj
T*
(            glGetIntegerv \(GL_VIEWPORT, viewport\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 48)Tj
ET
endstream
endobj
456 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
458 0 obj
<<
/Length 2552
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(            glGetDoublev \(GL_MODELVIEW_MATRIX, mvmatrix\);)Tj
0 -1.5 TD
(            glGetDoublev \(GL_PROJECTION_MATRIX, projmatrix\);)Tj
T*
(/*  note viewport[3] is height of window in pixels  */)Tj
T*
(            realy = viewport[3] - \(GLint\) y - 1;)Tj
T*
(            printf \("Coordinates at cursor are \(%4d, %4d\)\\n", )Tj
T*
(               x, realy\);)Tj
T*
(            gluUnProject \(\(GLdouble\) x, \(GLdouble\) realy, 0.0,)Tj
T*
(               mvmatrix, projmatrix, viewport, &wx, &wy, &wz\);)Tj
T*
(            printf \("World coords at z=0.0 are \(%f, %f, %f\)\\n",)Tj
T*
(               wx, wy, wz\);)Tj
T*
(            gluUnProject \(\(GLdouble\) x, \(GLdouble\) realy, 1.0,)Tj
T*
(               mvmatrix, projmatrix, viewport, &wx, &wy, &wz\);)Tj
T*
(            printf \("World coords at z=1.0 are \(%f, %f, %f\)\\n",     )Tj
T*
(               wx, wy, wz\);)Tj
T*
(         })Tj
T*
(         break;)Tj
T*
(      case GLUT_RIGHT_BUTTON:)Tj
T*
(         if \(state == GLUT_DOWN\))Tj
T*
(            exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\); )Tj
T*
(   glutMouseFunc\(mouse\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F15 1 Tf
0 -2.1 TD
(gluProject\(\))Tj
/F11 1 Tf
4.9 0 TD
( is another Utility Library routine, which is related to )Tj
/F15 1 Tf
21.5 0 TD
[(gluUnProject\(\).)61(gluProject\(\))]TJ
/F11 1 Tf
11.2 0 TD
( mimics the)Tj
-37.6 -1.5 TD
(actions of the transformation pipeline. Given three-dimensional world coordinates and all the)Tj
T*
(transformations that affect them, )Tj
/F15 1 Tf
13.3 0 TD
(gluProject\(\))Tj
/F11 1 Tf
4.9 0 TD
( returns the transformed window coordinates.)Tj
/F15 1 Tf
-18.2 -2.1 TD
[(int )6(gluProject)22(\(GLdouble )-16(objx)22(, GLdouble )-49(objy)22(, GLdouble )-49(objz)67(, const GLdouble )12(modelMatrix[16], )-55(const)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 3,  Viewing - 49)Tj
ET
endstream
endobj
459 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
461 0 obj
<<
/Length 1019
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(GLdouble )-50(projMatrix[16], )68(const GLint )-54(viewport[4], )79(GLdouble )-50(*winx)-11(, GLdouble )51(*winy)-11(, GLdouble)]TJ
0 -1.5 TD
[(*winz)34(\);)]TJ
1.8 -1.5 TD
[(Map the specified object coordinates \()-39(objx, objy, objz)12(\) into window coordinates, using)]TJ
T*
[(transformations defined by a modelview matrix \(modelMatrix)-33(\), projection matrix \()-11(projMatrix)89(\), and)]TJ
T*
[(viewport \()-17(viewport\). The resulting window coordinates are returned in )31(winx, winy,)29( and winz)-66(. The)]TJ
T*
(function returns GL_TRUE, indicating success, or GL_FALSE, indicating failure.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 603.510 m
547.000 603.510 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 50)Tj
ET
endstream
endobj
462 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
464 0 obj
<<
/Length 4206
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 4)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Color)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Decide between using RGBA or color-index mode for your application)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Specify desired colors for drawing objects)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use smooth shading to draw a single polygon with more than one color)Tj
-1.9 -2.7 TD
(The goal of almost all OpenGL applications is to draw color pictures in a window on the screen. The)Tj
0 -1.5 TD
(window is a rectangular array of pixels, each of which contains and displays its own color. Thus, in a)Tj
0 -1.6 TD
(sense, the point of all the calculations performed by an OpenGL implementation)Tj
/F33 1 Tf
32.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(calculations that take)Tj
-33.2 -1.7 TD
(into account OpenGL commands, state information, and values of parameters)Tj
/F33 1 Tf
31 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(is to determine the final)Tj
-32 -1.6 TD
(color of every pixel that's to be drawn in the window. This chapter explains the commands for specifying)Tj
0 -1.5 TD
(colors and how OpenGL interprets them in the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Color Perception")22( discusses how the eye perceives color.)]TJ
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Computer Color")45( describes the relationship between pixels on a computer )]TJ
/F15 1 Tf
30.2 0 TD
(monitor)Tj
/F11 1 Tf
3.2 0 TD
( and their colors;)Tj
-33.4 -1.6 TD
(it also defines the two display modes, RGBA and color index.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("RGBA versus Color-Index Mode")Tj
14.1 0 TD
( explains how the two display modes use graphics hardware and)Tj
-14.1 -1.6 TD
(how to decide which mode to use.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Specifying a Color and a Shading Model")50( describes the OpenGL commands you use to specify the)]TJ
0 -1.6 TD
(desired color or shading model.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 301.000 Tm
(Color Perception)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 278.000 Tm
(Physically, light is composed of photons)Tj
/F33 1 Tf
16.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(tiny particles of light, each traveling along its own path, and)Tj
-17.2 -1.7 TD
(each vibrating at its own frequency \(or wavelength, or energy)Tj
/F33 1 Tf
24.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(any one of frequency, wavelength, or)Tj
-25.7 -1.6 TD
(energy determines the others\). A photon is completely characterized by its position, direction, and)Tj
0 -1.5 TD
(frequency/wavelength/energy. Photons with wavelengths ranging from about 390 nanometers \(nm\))Tj
T*
(\(violet\) and 720 nm \(red\) cover the colors of the visible spectrum, forming the colors of a rainbow)Tj
T*
(\(violet, indigo, blue, green, yellow, orange, red\). However, your eyes perceive lots of colors that aren't in)Tj
0 -1.6 TD
(the rainbow)Tj
/F33 1 Tf
4.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(white, black, brown, and pink, for example. How does this happen?)Tj
-5.7 -2.2 TD
(What your eye actually sees is a mixture of photons of different frequencies. Real light sources are)Tj
0 -1.5 TD
(characterized by the distribution of photon frequencies they emit. Ideal white light consists of an equal)Tj
T*
(amount of light of all frequencies. Laser light is usually very pure, and all photons have almost identical)Tj
T*
(frequencies \(and direction and phase, as well\). Light from a sodium-vapor lamp has more light in the)Tj
T*
(yellow frequency. Light from most stars in space has a distribution that depends heavily on their)Tj
T*
(temperatures \(black-body radiation\). The frequency distribution of light from most sources in your)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 1)Tj
ET
endstream
endobj
465 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
467 0 obj
<<
/Length 4722
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(immediate environment is more complicated.)Tj
0 -2.1 TD
(The human eye perceives color when certain cells in the retina \(called )Tj
/F15 1 Tf
28.2 0 TD
(cone cells)Tj
/F11 1 Tf
4 0 TD
(, or just )Tj
/F15 1 Tf
3.3 0 TD
(cones)Tj
/F11 1 Tf
2.2 0 TD
(\) become)Tj
-37.7 -1.5 TD
(excited after being struck by photons. The three different kinds of cone cells respond best to three)Tj
T*
(different wavelengths of light: one type of cone cell responds best to red light, one type to green, and the)Tj
T*
(other to blue. \(A person who is color-blind is usually missing one or more types of cone cells.\) When a)Tj
T*
(given mixture of photons enters the eye, the cone cells in the retina register different degrees of)Tj
T*
(excitation depending on their types, and if a different mixture of photons comes in that happens to excite)Tj
T*
(the three types of cone cells to the same degrees, its color is indistinguishable from that of the first)Tj
T*
(mixture.)Tj
0 -2.1 TD
(Since each color is recorded by the eye as the levels of excitation of the cone cells by the incoming)Tj
0 -1.5 TD
(photons, the eye can perceive colors that aren't in the spectrum produced by a prism or rainbow. For)Tj
T*
(example, if you send a mixture of red and blue photons so that both the red and blue cones in the retina)Tj
T*
(are excited, your eye sees it as magenta, which isn't in the spectrum. Other combinations give browns,)Tj
T*
(turquoises, and mauves, none of which appear in the color spectrum.)Tj
0 -2.1 TD
(A computer-graphics monitor emulates visible colors by lighting pixels with a combination of red, green,)Tj
0 -1.5 TD
(and blue light in proportions that excite the red-, green-, and blue-sensitive cones in the retina in such a)Tj
T*
(way that it matches the excitation levels generated by the photon mix it's trying to emulate. If humans)Tj
T*
(had more types of cone cells, some that were yellow-sensitive for example, color monitors would)Tj
T*
(probably have a yellow gun as well, and we'd use RGBY \(red, green, blue, yellow\) quadruples to specify)Tj
T*
(colors. And if everyone were color-blind in the same way, this chapter would be simpler.)Tj
0 -2.1 TD
(To display a particular color, the monitor sends the right amounts of red, green, and blue light to)Tj
0 -1.5 TD
(appropriately stimulate the different types of cone cells in your eye. A color monitor can send different)Tj
T*
(proportions of red, green, and blue to each of the pixels, and the eye sees a million or so pinpoints of)Tj
T*
(light, each with its own color.)Tj
0 -2.1 TD
(This section considers only how the eye perceives combinations of photons that enter it. The situation for)Tj
0 -1.6 TD
(light bouncing off materials and entering the eye is even more complex)Tj
/F33 1 Tf
28.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(white light bouncing off a red)Tj
-29.5 -1.6 TD
(ball will appear red, or yellow light shining through blue glass appears almost black, for example. \(See)Tj
0 -1.5 TD
[("Real-World and OpenGL Lighting" in Chapter 5)202( for a discussion of these effects.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 241.000 Tm
(Computer Color)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 219.000 Tm
(On a color computer screen, the hardware causes each pixel on the screen to emit different amounts of)Tj
T*
(red, green, and blue light. These are called the R, G, and B values. They're often packed together)Tj
T*
(\(sometimes with a fourth value, called alpha, or A\), and the packed value is called the RGB \(or RGBA\))Tj
T*
[(value. \(See )-6("Blending" in Chapter 6)-22( for an explanation of the alpha values.\) The color information at)]TJ
T*
(each pixel can be stored either in )Tj
/F15 1 Tf
13.4 0 TD
(RGBA mode)Tj
/F11 1 Tf
5 0 TD
(, in which the R, G, B, and possibly A values are kept for)Tj
-18.4 -1.6 TD
(each pixel, or in )Tj
/F13 1 Tf
6.7 0 TD
(color-index mode)Tj
/F11 1 Tf
7.4 0 TD
(, in which a single number \(called the color index\) is stored for each)Tj
-14.1 -1.5 TD
(pixel. Each color index indicates an entry in a table that defines a particular set of R, G, and B values.)Tj
T*
(Such a table is called a )Tj
/F15 1 Tf
9.4 0 TD
(color map)Tj
/F11 1 Tf
4.1 0 TD
(.)Tj
-13.5 -2.1 TD
(In color-index mode, you might want to alter the values in the color map. Since color maps are controlled)Tj
0 -1.5 TD
(by the window system, there are no OpenGL commands to do this. All the examples in this book)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 2)Tj
ET
endstream
endobj
468 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
470 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im53
/Width 225
/Height 226
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.52)
>>
stream
endstream
endobj
472 0 obj
<<
/Length 2958
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(initialize the color-display mode at the time the window is opened by using routines from the GLUT)Tj
0 -1.5 TD
[(library. \(See )-6(Appendix D)17( for details.\))]TJ
0 -2.1 TD
(There is a great deal of variation among the different graphics hardware platforms in both the size of the)Tj
0 -1.5 TD
(pixel array and the number of colors that can be displayed at each pixel. On any graphics system, each)Tj
T*
(pixel has the same amount of memory for storing its color, and all the memory for all the pixels is called)Tj
T*
(the )Tj
/F15 1 Tf
1.5 0 TD
(color buffer)Tj
/F11 1 Tf
4.7 0 TD
(. The size of a buffer is usually measured in bits, so an 8-bit buffer could store 8 bits of)Tj
-6.2 -1.5 TD
(data \(256 possible different colors\) for each pixel. The size of the possible buffers varies from machine to)Tj
T*
[(machine. \(See )16(Chapter 10)16( for more information.\))]TJ
0 -2.1 TD
(The R, G, and B values can range from 0.0 \(none\) to 1.0 \(full intensity\). For example, R = 0.0, G = 0.0,)Tj
0 -1.5 TD
(and B = 1.0 represents the brightest possible blue. If R, G, and B are all 0.0, the pixel is black; if all are)Tj
T*
(1.0, the pixel is drawn in the brightest white that can be displayed on the screen. )Tj
/F15 1 Tf
32.3 0 TD
(Blending)Tj
/F11 1 Tf
3.6 0 TD
( green and blue)Tj
-35.9 -1.5 TD
(creates shades of cyan. Blue and red combine for magenta. Red and green create yellow. To help you)Tj
T*
(create the colors you want from the R, G, and B components, look at the color cube shown in Plate 12.)Tj
T*
(The axes of this cube represent intensities of red, blue, and green. A black-and-white version of the cube)Tj
T*
[(is shown in )7(Figure 4-1)225(.)]TJ
ET
Q
/GS1 gs
q
225 0 0 226 124 247.95 cm
/Im53 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 235.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 4-1 )Tj
/F11 1 Tf
5.1 0 TD
(The Color Cube in Black and White)Tj
-5.1 -2.1 TD
(The commands to specify a color for an object \(in this case, a point\) can be as simple as this:)Tj
/F7 1 Tf
T*
(glColor3f \(1.0, 0.0, 0.0\);  /* the current RGB color is red: */)Tj
0 -1.5 TD
(                            /* full red, no green, no blue. */)Tj
T*
(glBegin \(GL_POINTS\);)Tj
T*
(    glVertex3fv \(point_array\);)Tj
T*
(glEnd \(\);)Tj
/F11 1 Tf
0 -2.1 TD
(In certain modes \(for example, if lighting or texturing calculations are performed\), the assigned color)Tj
0 -1.5 TD
(might go through other operations before arriving in the framebuffer as a value representing a color for a)Tj
T*
(pixel. In fact, the color of a pixel is determined by a lengthy sequence of operations.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 3)Tj
ET
endstream
endobj
473 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im53 470 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
475 0 obj
<<
/Length 5349
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Early in a program's execution, the color-display mode is set to either RGBA mode or color-index mode.)Tj
0 -1.5 TD
(Once the color-display mode is initialized, it can't be changed. As the program executes, a color \(either a)Tj
T*
(color index or an RGBA value\) is determined on a per-vertex basis for each geometric primitive. This)Tj
T*
(color is either a color you've explicitly specified for a vertex or, if lighting is enabled, is determined from)Tj
T*
(the interaction of the transformation matrices with the surface normals and other material properties. In)Tj
T*
(other words, a red ball with a blue light shining on it looks different from the same ball with no light on)Tj
T*
[(it. \(See )-17(Chapter 5)16( for details.\) After the relevant lighting calculations are performed, the chosen shading)]TJ
T*
[(model is applied. As explained in )40("Specifying a Color and a Shading Model," you can choose flat or)]TJ
T*
(smooth shading, each of which has different effects on the eventual color of a pixel.)Tj
0 -2.1 TD
(Next, the primitives are )Tj
/F15 1 Tf
9.7 0 TD
(rasterized)Tj
/F11 1 Tf
4 0 TD
(, or converted to a two-dimensional image. Rasterizing involves)Tj
-13.7 -1.5 TD
(determining which squares of an integer grid in window coordinates are occupied by the primitive and)Tj
T*
(then assigning color and other values to each such square. A grid square along with its associated values)Tj
T*
(of color, )Tj
/F15 1 Tf
3.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( \(depth\), and texture coordinates is called a )Tj
/F15 1 Tf
17.5 0 TD
(fragment)Tj
/F11 1 Tf
3.6 0 TD
(. Pixels are elements of the framebuffer; a)Tj
-25.1 -1.5 TD
(fragment comes from a primitive and is combined with its corresponding pixel to yield a new pixel. Once)Tj
0 -1.6 TD
(a fragment is constructed, texturing, fog, and antialiasing are applied)Tj
/F33 1 Tf
27.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(if they're enabled)Tj
/F33 1 Tf
7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(to the)Tj
-36.5 -1.6 TD
(fragments. After that, any specified alpha blending, )Tj
/F13 1 Tf
20.8 0 TD
(dithering)Tj
/F11 1 Tf
4 0 TD
(, and bitwise logical operations are carried)Tj
-24.8 -1.5 TD
(out using the fragment and the pixel already stored in the framebuffer. Finally, the fragment's color value)Tj
T*
(\(either color index or RGBA\) is written into the pixel and displayed in the window using the window's)Tj
T*
(color-display mode.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 397.000 Tm
(RGBA versus Color-Index Mode)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 375.000 Tm
(In either color-index or RGBA mode, a certain amount of color data is stored at each pixel. This amount)Tj
T*
(is determined by the number of bitplanes in the framebuffer. A )Tj
/F13 1 Tf
25.4 0 TD
(bitplane)Tj
/F11 1 Tf
3.5 0 TD
( contains 1 bit of data for each)Tj
-28.9 -1.8 TD
(pixel. If there are 8color bitplanes, there are 8 color bits per pixel, and hence 2)Tj
31.3 0.3 TD
(8)Tj
0.5 -0.3 TD
( = 256 different values or)Tj
-31.8 -1.5 TD
(colors that can be stored at the pixel.)Tj
0 -2.1 TD
(Bitplanes are often divided evenly into storage for R, G, and B components \(that is, a 24-bitplane system)Tj
0 -1.5 TD
(devotes 8 bits each to red, green, and blue\), but this isn't always true. To find out the number of bitplanes)Tj
T*
(available on your system for red, green, blue, alpha, or color-index values, use )Tj
/F15 1 Tf
31.6 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
( with)Tj
-37.8 -1.5 TD
(GL_RED_BITS, GL_GREEN_BITS, GL_BLUE_BITS, GL_ALPHA_BITS, and GL_INDEX_BITS.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Color intensities on most computer screens aren't perceived as linear by the human eye. Consider)Tj
-2.8 -1.4 TD
(colors consisting of just a red component, with green and blue set to zero. As the intensity varies from)Tj
0 -1.5 TD
(0.0 \(off\) to 1.0 \(full on\), the number of electrons striking the pixels increases, but the question is, does)Tj
0 -1.4 TD
(0.5 look like halfway between 0.0 and 1.0? To test this, write a program that draws alternate pixels in a)Tj
T*
(checkerboard pattern to intensities 0.0 and 1.0, and compare it with a region drawn solidly in color 0.5.)Tj
T*
(From a reasonable distance from the screen, the two regions should appear to have the same intensity. If)Tj
0 -1.5 TD
(they look noticeably different, you need to use whatever correction mechanism is provided on your)Tj
0 -1.4 TD
(particular system. For example, many systems have a table to adjust intensities so that 0.5 appears to be)Tj
T*
(halfway between 0.0 and 1.0. The mapping generally used is an exponential one, with the exponent)Tj
0 -1.5 TD
(referred to as gamma \(hence the term )Tj
/F13 1 Tf
15.2 0 TD
(gamma correction)Tj
/F11 1 Tf
7.8 0 TD
(\). Using the same gamma for the red, green, and)Tj
-23 -1.4 TD
(blue components gives pretty good results, but three different gamma values might give slightly better)Tj
T*
(results. \(For more details on this topic, see Foley, van Dam, et al. )Tj
/F15 1 Tf
26.3 0 TD
(Computer Graphics: Principles and)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 4)Tj
ET
endstream
endobj
476 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
477 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im54
/Width 433
/Height 218
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.53)
>>
stream
endstream
endobj
479 0 obj
<<
/Length 3095
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(Practice)Tj
/F11 1 Tf
3.4 0 TD
0.000 Tw
(. Reading, MA: Addison-Wesley Developers Press, 1990.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 682.000 Tm
(RGBA Display Mode)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 661.000 Tm
(In RGBA mode, the hardware sets aside a certain number of bitplanes for each of the R, G, B, and A)Tj
0 -1.5 TD
[(components \(not necessarily the same number for each component\) as shown in )20(Figure 4-2)225(. The R, G,)]TJ
T*
(and B values are typically stored as integers rather than floating-point numbers, and they're scaled to the)Tj
T*
(number of available bits for storage and retrieval. For example, if a system has 8 bits available for the R)Tj
T*
(component, integers between 0 and 255 can be stored; thus, 0, 1, 2, ..., 255 in the bitplanes would)Tj
T*
(correspond to R values of 0/255 = 0.0, 1/255, 2/255, ..., 255/255 = 1.0. Regardless of the number of)Tj
T*
(bitplanes, 0.0 specifies the minimum intensity, and 1.0 specifies the maximum intensity.)Tj
ET
Q
/GS1 gs
q
423 0 0 213 124 343.57 cm
/Im54 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 331.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 4-2 )Tj
/F11 1 Tf
5.1 0 TD
(RGB Values from the Bitplanes)Tj
/F27 1 Tf
-5.1 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(The alpha value \(the A in RGBA\) has no direct effect on the color displayed on the screen. It can)Tj
-2.8 -1.4 TD
(be used for many things, including blending and transparency, and it can have an effect on the values of)Tj
0 -1.5 TD
[(R, G, and B that are written. \(See )-17("Blending" in Chapter 6)-22( for more information about alpha values.\))]TJ
0 -2.1 TD
(The number of distinct colors that can be displayed at a single pixel depends on the number of bitplanes)Tj
0 -1.5 TD
(and the capacity of the hardware to interpret those bitplanes. The number of distinct colors can't exceed)Tj
0 -1.8 TD
(2)Tj
0.5 0.3 TD
(n)Tj
0.5 -0.3 TD
(, where )Tj
/F15 1 Tf
3.2 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( is the number of bitplanes. Thus, a machine with 24 bitplanes for RGB can display up to)Tj
-4.7 -1.5 TD
(16.77 million distinct colors.)Tj
/F27 1 Tf
0 -3 TD
(Dithering)Tj
8 -2.1 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(Some graphics hardware uses dithering to increase the number of apparent colors. Dithering is the)Tj
0 -1.5 TD
(technique of using combinations of some colors to create the effect of other colors. To illustrate how)Tj
T*
(dithering works, suppose your system has only 1 bit each for R, G, and B and thus can display only eight)Tj
T*
(colors: black, white, red, blue, green, yellow, cyan, and magenta. To display a pink region, the hardware)Tj
T*
(can fill the region in a checkerboard manner, alternating red and white pixels. If your eye is far enough)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 5)Tj
ET
endstream
endobj
480 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im54 477 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
481 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im55
/Width 502
/Height 313
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.54)
>>
stream
endstream
endobj
483 0 obj
<<
/Length 3196
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(away from the screen that it can't distinguish individual pixels, the region appears pink)Tj
/F33 1 Tf
34.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the average of)Tj
-35.8 -1.6 TD
(red and white. Redder pinks can be achieved by filling a higher proportion of the pixels with red, whiter)Tj
0 -1.5 TD
(pinks would use more white pixels, and so on.)Tj
0 -2.1 TD
(With this technique, there are no pink pixels. The only way to achieve the effect of "pinkness" is to cover)Tj
0 -1.6 TD
(a region consisting of multiple pixels)Tj
/F33 1 Tf
14.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(you can't dither a single pixel. If you specify an RGB value for)Tj
-15.9 -1.6 TD
(an unavailable color and fill a polygon, the hardware fills the pixels in the interior of the polygon with a)Tj
0 -1.5 TD
(mixture of nearby colors whose average appears to your eye to be the color you want. \(Remember,)Tj
T*
(though, that if you're reading pixel information out of the framebuffer, you get the actual red and white)Tj
T*
[(pixel values, since there aren't any pink ones. See )-8(Chapter 8)16( for more information about reading pixel)]TJ
T*
(values.\))Tj
0 -2.1 TD
[(Figure 4-3)225( illustrates some simple dithering of black and white pixels to make shades of gray. From left)]TJ
0 -1.6 TD
(to right, the 4)Tj
/F33 1 Tf
5.4 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 patterns at the top represent dithering patterns for 50 percent, 19 percent, and 69 percent)Tj
-5.9 -1.6 TD
(gray. Under each pattern, you can see repeated reduced copies of each pattern, but these black and white)Tj
0 -1.5 TD
(squares are still bigger than most pixels. If you look at them from across the room, you can see that they)Tj
T*
(blur together and appear as three levels of gray.)Tj
ET
Q
q
1 i 
124.000 469.230 422.990 -263.740 re
W n
/GS1 gs
q
423 0 0 264 124 205.23 cm
/Im55 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 193.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 4-3 )Tj
/F11 1 Tf
5.1 0 TD
(Dithering Black and White to Create Gray)Tj
-5.1 -2.1 TD
(With about 8 bits each of R, G, and B, you can get a fairly high-quality image without dithering. Just)Tj
0 -1.5 TD
(because your machine has 24 color bitplanes, however, doesn't mean that dithering won't be desirable.)Tj
T*
(For example, if you are running in double-buffer mode, the bitplanes might be divided into two sets of)Tj
T*
(twelve, so there are really only 4 bits each per R, G, and B component. Without dithering,)Tj
T*
(4-bit-per-component color can give less than satisfactory results in many situations.)Tj
0 -2.1 TD
(You enable or disable dithering by passing GL_DITHER to )Tj
/F15 1 Tf
24.1 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.6 0 TD
(. Note that)Tj
-34.3 -1.5 TD
(dithering, unlike many other features, is enabled by default.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 6)Tj
ET
endstream
endobj
484 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im55 481 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
485 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im56
/Width 438
/Height 191
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.55)
>>
stream
endstream
endobj
486 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im57
/Width 344
/Height 232
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.56)
>>
stream
endstream
endobj
488 0 obj
<<
/Length 1789
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 695.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Color-Index Display Mode)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 673.000 Tm
(With color-index mode, OpenGL uses a color map \(or )Tj
/F15 1 Tf
21.9 0 TD
(lookup table)Tj
/F11 1 Tf
5 0 TD
(\), which is similar to using a palette to)Tj
-26.9 -1.5 TD
(mix paints to prepare for a paint-by-number scene. A painter's palette provides spaces to mix paints)Tj
T*
(together; similarly, a computer's color map provides indices where the primary red, green, and blue)Tj
T*
[(values can be mixed, as shown in )11(Figure 4-4)225(.)]TJ
ET
Q
/GS1 gs
q
423 0 0 184 124 430.22 cm
/Im56 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 417.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 4-4 )Tj
/F11 1 Tf
5.1 0 TD
(A Color Map)Tj
-5.1 -2.1 TD
(A painter filling in a paint-by-number scene chooses a color from the color palette and fills the)Tj
0 -1.5 TD
(corresponding numbered regions with that color. A computer stores the color index in the bitplanes for)Tj
T*
(each pixel. Then those bitplane values reference the color map, and the screen is painted with the)Tj
T*
[(corresponding red, green, and blue values from the color map, as shown in )9(Figure 4-5)225(.)]TJ
ET
Q
q
344 0 0 232 124 104.76 cm
/Im57 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 92.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 4-5 )Tj
/F11 1 Tf
5.1 0 TD
(Using a Color Map to Paint a Picture)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 7)Tj
ET
endstream
endobj
489 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im56 485 0 R
/Im57 486 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
491 0 obj
<<
/Length 4339
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(In color-index mode, the number of simultaneously available colors is limited by the size of the color)Tj
0 -1.5 TD
(map and the number of bitplanes available. The size of the color map is determined by the amount of)Tj
T*
(hardware dedicated to it. The size of the color map is always a power of 2, and typical sizes range from)Tj
0 -1.8 TD
(256 \(2)Tj
2.6 0.3 TD
(8)Tj
0.5 -0.3 TD
(\) to 4096 \(2)Tj
4.7 0.3 TD
(12)Tj
1 -0.3 TD
(\), where the exponent is the number of bitplanes being used. If there are 2)Tj
29.5 0.3 TD
(n)Tj
0.5 -0.3 TD
( indices)Tj
-38.8 -1.8 TD
(in the color map and )Tj
/F15 1 Tf
8.5 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
( available bitplanes, the number of usable entries is the smaller of 2)Tj
27 0.3 TD
(n)Tj
0.5 -0.3 TD
( and 2)Tj
2.4 0.3 TD
(m)Tj
0.8 -0.3 TD
(.)Tj
-39.9 -2.1 TD
(With RGBA mode, each pixel's color is independent of other pixels. However, in color-index mode, each)Tj
0 -1.5 TD
(pixel with the same index stored in its bitplanes shares the same color-map location. If the contents of an)Tj
T*
(entry in the color map change, then all pixels of that color index change their color.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 565.000 Tm
(Choosing between RGBA and Color-Index Mode)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 544.000 Tm
(You should base your decision to use RGBA or color-index mode on what hardware is available and on)Tj
T*
(what your application needs. For most systems, more colors can be simultaneously represented with)Tj
T*
(RGBA mode than with color-index mode. Also, for several effects, such as shading, lighting, texture)Tj
T*
(mapping, and fog, RGBA provides more flexibility than color-index mode.)Tj
0 -2.1 TD
(You might prefer to use color-index mode in the following cases:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If you're porting an existing application that makes significant use of color-index mode, it might be)Tj
0 -1.6 TD
(easier to not change to RGBA mode.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If you have a small number of bitplanes available, RGBA mode may produce noticeably coarse)Tj
0 -1.6 TD
(shades of colors. For example, if you have only 8 bitplanes, in RGBA mode, you may have only 3)Tj
0 -1.8 TD
(bits for red, 3 bits for green, and 2 bits for blue. You'd only have 8 \(2)Tj
27.8 0.3 TD
(3)Tj
0.5 -0.3 TD
(\) shades of red and green, and)Tj
-28.3 -1.5 TD
(only 4 shades of blue. The gradients between color shades are likely to be very obvious.)Tj
0 -2.1 TD
(In this situation, if you have limited shading requirements, you can use the color lookup table to load)Tj
0 -1.5 TD
(more shades of colors. For example, if you need only shades of blue, you can use color-index mode)Tj
0 -1.8 TD
(and store up to 256 \(2)Tj
8.7 0.3 TD
(8)Tj
0.5 -0.3 TD
(\) shades of blue in the color-lookup table, which is much better than the 4)Tj
-9.2 -1.5 TD
(shades you would have in RGBA mode. Of course, this example would use up your entire)Tj
T*
(color-lookup table, so you would have no shades of red, green, or other combined colors.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Color-index mode can be useful for various tricks, such as color-map animation and drawing in)Tj
0 -1.6 TD
[(layers. \(See )16(Chapter 14)16( for more information.\))]TJ
-1.9 -2.7 TD
(In general, use RGBA mode wherever possible. It works with texture mapping and works better with)Tj
0 -1.5 TD
(lighting, shading, fog, antialiasing, and blending.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 176.000 Tm
(Changing between Display Modes)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 155.000 Tm
(In the best of all possible worlds, you might want to avoid making a choice between RGBA and)Tj
T*
(color-index display mode. For example, you may want to use color-index mode for a color-map)Tj
T*
(animation effect and then, when needed, immediately change the scene to RGBA mode for texture)Tj
T*
(mapping.)Tj
0 -2.1 TD
(Or similarly, you may desire to switch between single and double buffering. For example, you may have)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 8)Tj
ET
endstream
endobj
492 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
494 0 obj
<<
/Length 3951
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(very few bitplanes; let's say 8 bitplanes. In single-buffer mode, you'll have 256 \(28\) colors, but if you are)Tj
0 -1.5 TD
(using double-buffer mode to eliminate flickering from your animated program, you may only have 16)Tj
T*
(\(24\) colors. Perhaps you want to draw a moving object without flicker and are willing to sacrifice colors)Tj
T*
(for using double-buffer mode \(maybe the object is moving so fast that the viewer won't notice the)Tj
T*
(details\). But when the object comes to rest, you will want to draw it in single-buffer mode so that you can)Tj
T*
(use more colors.)Tj
0 -2.1 TD
(Unfortunately, most window systems won't allow an easy switch. For example, with the X Window)Tj
0 -1.5 TD
(System, the color-display mode is an attribute of the X Visual. An X Visual must be specified before the)Tj
T*
(window is created. Once it is specified, it cannot be changed for the life of the window. After you create)Tj
T*
(a window with a double-buffered, RGBA display mode, you're stuck with it.)Tj
0 -2.1 TD
(A tricky solution to this problem is to create more than one window, each with a different display mode.)Tj
0 -1.5 TD
(Then you must control the visibility of the windows \(for example, mapping or unmapping an X Window,)Tj
T*
(or managing or unmanaging a Motif or Athena widget\) and draw the object into the appropriate, visible)Tj
T*
(window.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 470.000 Tm
(Specifying a Color and a Shading Model)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 448.000 Tm
(OpenGL maintains a current color \(in RGBA mode\) and a current color index \(in color-index mode\).)Tj
T*
(Unless you're using a more complicated coloring model such as lighting or texture mapping, each object)Tj
T*
(is drawn using the current color \(or color index\). Look at the following pseudocode sequence:)Tj
/F7 1 Tf
0 -2 TD
(set_color\(RED\);)Tj
0 -1.5 TD
(draw_item\(A\);)Tj
T*
(draw_item\(B\);)Tj
T*
(set_color\(GREEN\);)Tj
T*
(set_color\(BLUE\);)Tj
T*
(draw_item\(C\);)Tj
/F11 1 Tf
0 -2.2 TD
(Items A and B are drawn in red, and item C is drawn in blue. The fourth line, which sets the current color)Tj
0 -1.5 TD
(to green, has no effect \(except to waste a bit of time\). With no lighting or texturing, when the current)Tj
T*
(color is set, all items drawn afterward are drawn in that color until the current color is changed to)Tj
T*
(something else.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 228.000 Tm
(Specifying a Color in RGBA Mode)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 206.000 Tm
(In RGBA mode, use the )Tj
/F15 1 Tf
9.9 0 TD
(glColor*\(\))Tj
/F11 1 Tf
4.3 0 TD
( command to select a current color.)Tj
/F15 1 Tf
-14.2 -2.1 TD
[(void )-28(glColor3)12({b s i f d ub us ui} \()46(TYPE)-66(r)-11(,)0( TYPE)34(g, TYPE)34(b\);)]TJ
0 -1.1 TD
[(void )-28(glColor4)12({b s i f d ub us ui} \()46(TYPE)-66(r)-11(,)0( TYPE)34(g, TYPE)34(b, TYPE)-66(a\);)]TJ
T*
[(void )-28(glColor3)12({b s i f d ub us ui})63(v)-56( \(const )44(TYPE)-66(*v)44(\);)]TJ
T*
[(void )-28(glColor4)12({b s i f d ub us ui})63(v)-56( \(const )44(TYPE)-66(*v)44(\);)]TJ
1.8 -1.5 TD
(Sets the current red, green, blue, and alpha values. This command can have up to three suffixes,)Tj
T*
(which differentiate variations of the parameters accepted. The first suffix is either 3 or 4, to indicate)Tj
T*
(whether you supply an alpha value in addition to the red, green, and blue values. If you don't supply)Tj
T*
(an alpha value, it's automatically set to 1.0. The second suffix indicates the data type for)Tj
T*
(parameters: byte, short, integer, float, double, unsigned byte, unsigned short, or unsigned integer.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 9)Tj
ET
endstream
endobj
495 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
497 0 obj
<<
/Length 4751
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(The third suffix is an optional )14(v)-56(,)0( which indicates that the argument is a pointer to an array of values)]TJ
0 -1.5 TD
(of the given data type.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(For the versions of )Tj
/F15 1 Tf
7.8 0 TD
(glColor*\(\))Tj
/F11 1 Tf
4.3 0 TD
( that accept floating-point data types, the values should typically range)Tj
-12.1 -1.5 TD
(between 0.0 and 1.0, the minimum and maximum values that can be stored in the framebuffer.)Tj
T*
(Unsigned-integer color components, when specified, are linearly mapped to floating-point values such)Tj
T*
(that the largest representable value maps to 1.0 \(full intensity\), and zero maps to 0.0 \(zero intensity\).)Tj
T*
(Signed-integer color components, when specified, are linearly mapped to floating-point values such that)Tj
T*
(the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0)Tj
T*
0.040 Tw
[(\(see Table )40(4-1)]TJ
5.7 0 TD
(\).)Tj
-5.7 -2.1 TD
0.000 Tw
(Neither floating-point nor signed-integer values are clamped to the range [0,1] before updating the)Tj
0 -1.5 TD
(current color or current lighting material parameters. After lighting calculations, resulting color values)Tj
T*
(outside the range [0,1] are clamped to the range [0,1] before they are interpolated or written into a color)Tj
T*
(buffer. Even if lighting is disabled, the color components are clamped before rasterization.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 506.920 m
490.000 506.920 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 499.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Suffix)-1972(Data Type)-4720(Minimum Value)-2664(Min Value)]TJ
24.25 -1.5 TD
(Maps to)Tj
6 1.5 TD
[(Maximum Value)-1941(Max Value)]TJ
9.5 -1.5 TD
(Maps to)Tj
ET
Q
124.000 481.400 m
490.000 481.400 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 473.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(b)-3722(1-byte integer)-2631(-128)-6825(-1.0)-3519(127)-6944(1.0)]TJ
0 -1.4444 TD
[(s)-3833(2-byte integer)-2631(-32,768)-5574(-1.0)-3519(32,767)-5694(1.0)]TJ
T*
[(i)-3944(4-byte integer)-2631(-2,147,483,648)-2574(-1.0)-3519(2,147,483,647)-2694(1.0)]TJ
T*
[(ub)-3222(unsigned 1-byte)]TJ
4.2222 -1.3333 TD
(integer)Tj
8.4444 1.3333 TD
[(0)-8389(0.0)-4083(255)-6944(1.0)]TJ
-12.6667 -2.7778 TD
[(us)-3333(unsigned 2-byte)]TJ
4.2222 -1.3333 TD
(integer)Tj
8.4444 1.3333 TD
[(0)-8389(0.0)-4083(65,535)-5694(1.0)]TJ
-12.6667 -2.7778 TD
[(ui)-3444(unsigned 4-byte)]TJ
4.2222 -1.3333 TD
(integer)Tj
8.4444 1.3333 TD
[(0)-8389(0.0)-4083(4,294,967,295)-2694(1.0)]TJ
ET
Q
124.000 364.590 m
490.010 364.590 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 348.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 4-1 )Tj
/F11 1 Tf
4.6 0 TD
(Converting Color Values to Floating-Point Numbers)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 320.000 Tm
(Specifying a Color in Color-Index Mode)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 298.000 Tm
(In color-index mode, use the )Tj
/F15 1 Tf
11.7 0 TD
(glIndex*\(\))Tj
/F11 1 Tf
4.2 0 TD
( command to select a single-valued color index as the current)Tj
-15.9 -1.5 TD
(color index.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glIndex{sifd )28(ub}\(TYPE )41(c)44(\))0(;)]TJ
0 -1.1 TD
0.000 Tw
[(void )-28(glIndex{sifd ub}v)44(\(const TYPE )-21(*c)44(\);)]TJ
1.8 -1.5 TD
[(Sets the current color index to )33(c)-56(.)0( The first suffix for this command indicates the data type for)]TJ
T*
[(parameters: short, integer, float, double, or unsigned byte. The second, optional suffix is v)44(,)0( which)]TJ
T*
(indicates that the argument is an array of values of the given data type \(the array contains only one)Tj
T*
(value\).)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(In )-17("Clearing the Window" in Chapter 2)22(,)0( you saw the specification of )]TJ
/F15 1 Tf
27.7 0 TD
(glClearColor\(\))Tj
/F11 1 Tf
6 0 TD
(. For color-index)Tj
-33.7 -1.5 TD
(mode, there is a corresponding )Tj
/F15 1 Tf
12.6 0 TD
(glClearIndex\(\))Tj
/F11 1 Tf
5.9 0 TD
(.)Tj
/F15 1 Tf
-18.5 -2.1 TD
0.028 Tw
[(void glClearIndex)78(\(GLfloat )23(cindex)-90(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Sets the current clearing color in color-index mode. In a color-index mode window, a call to)Tj
T*
[(glClear)-44(\(GL_COLOR_BUFFER_BIT\) will use )85(cindex)10( to clear the buffer. The default clearing index)]TJ
T*
(is 0.0.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 10)Tj
ET
endstream
endobj
498 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
500 0 obj
<<
/Length 3189
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
0.000 Tw
(OpenGL does not have any routines to load values into the color-lookup table. Window systems)Tj
-2.8 -1.4 TD
(typically already have such operations. GLUT has the routine )Tj
/F15 1 Tf
24.9 0 TD
(glutSetColor\(\))Tj
/F11 1 Tf
5.8 0 TD
( to call the window-system)Tj
-30.7 -1.4 TD
(specific commands.)Tj
/F27 1 Tf
8 -2.2 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(The current index is stored as a floating-point value. Integer values are converted directly to)Tj
0 -1.5 TD
(floating-point values, with no special mapping. Index values outside the representable range of the)Tj
T*
(color-index buffer aren't clamped. However, before an index is dithered \(if enabled\) and written to the)Tj
T*
(framebuffer, it's converted to fixed-point format. Any bits in the integer portion of the resulting)Tj
T*
(fixed-point value that don't correspond to bits in the framebuffer are masked out.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 550.000 Tm
(Specifying a Shading Model)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 529.000 Tm
(A line or a filled polygon primitive can be drawn with a single color \(flat shading\) or with many different)Tj
0 -1.6 TD
(colors \(smooth shading, also called )Tj
/F13 1 Tf
14.3 0 TD
(Gouraud shading)Tj
/F11 1 Tf
7.5 0 TD
(\). You specify the desired shading technique with)Tj
/F15 1 Tf
-21.8 -1.5 TD
(glShadeModel\(\))Tj
/F11 1 Tf
6.4 0 TD
(.)Tj
/F15 1 Tf
-6.4 -2.1 TD
0.025 Tw
[(void glShadeModel)78( )25(\(GLenum mode)-34(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Sets the shading model. The mode parameter can be either GL_SMOOTH \(the default\) or GL_FLAT.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(With flat shading, the color of one particular vertex of an independent primitive is duplicated across all)Tj
0 -1.5 TD
(the primitive's vertices to render that primitive. With smooth shading, the color at each vertex is treated)Tj
T*
(individually. For a line primitive, the colors along the line segment are interpolated between the vertex)Tj
T*
(colors. For a polygon primitive, the colors for the interior of the polygon are interpolated between the)Tj
T*
[(vertex colors. )-6(Example 4-1)]TJ
10.8 0 TD
[( draws a smooth-shaded triangle, as shown in )247("Plate 11" in Appendix I)-28(.)]TJ
/F27 1 Tf
-10.8 -2.1 TD
(Example 4-1 )Tj
/F11 1 Tf
6.1 0 TD
(Drawing a Smooth-Shaded Triangle: smooth.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glut.h>)Tj
0 -3 TD
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel \(GL_SMOOTH\);)Tj
T*
(})Tj
0 -3 TD
(void triangle\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glBegin \(GL_TRIANGLES\);)Tj
T*
(   glColor3f \(1.0, 0.0, 0.0\);)Tj
T*
(   glVertex2f \(5.0, 5.0\);)Tj
T*
(   glColor3f \(0.0, 1.0, 0.0\);)Tj
T*
(   glVertex2f \(25.0, 5.0\);)Tj
T*
(   glColor3f \(0.0, 0.0, 1.0\);)Tj
T*
(   glVertex2f \(5.0, 25.0\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 11)Tj
ET
endstream
endobj
501 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
503 0 obj
<<
/Length 2153
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glEnd\(\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear \(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   triangle \(\);)Tj
T*
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      gluOrtho2D \(0.0, 30.0, 0.0, 30.0*\(GLfloat\) h/\(GLfloat\) w\);)Tj
T*
(   else)Tj
T*
(      gluOrtho2D \(0.0, 30.0*\(GLfloat\) w/\(GLfloat\) h, 0.0, 30.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(With smooth shading, neighboring pixels have slightly different color values. In RGBA mode, adjacent)Tj
0 -1.5 TD
(pixels with slightly different values look similar, so the color changes across a polygon appear gradual.)Tj
T*
(In color-index mode, adjacent pixels may reference different locations in the color-index table, which)Tj
T*
(may not have similar colors at all. Adjacent color-index entries may contain wildly different colors, so a)Tj
T*
(smooth-shaded polygon in color-index mode can look psychedelic.)Tj
0 -2.1 TD
(To avoid this problem, you have to create a color ramp of smoothly changing colors among a contiguous)Tj
0 -1.5 TD
(set of indices in the color map. Remember that loading colors into a color map is performed through your)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 4,  Color - 12)Tj
ET
endstream
endobj
504 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
507 0 obj
<<
/Length 2821
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(window system rather than OpenGL. If you use GLUT, you can use )Tj
/F15 1 Tf
27.4 0 TD
(glutSetColor\(\))Tj
/F11 1 Tf
5.8 0 TD
( to load a single index)Tj
-33.2 -1.5 TD
(in the color map with specified red, green, and blue values. The first argument for )Tj
/F15 1 Tf
33 0 TD
(glutSetColor\(\))Tj
/F11 1 Tf
5.8 0 TD
( is the)Tj
-38.8 -1.5 TD
(index, and the others are the red, green, and blue values. To load thirty-two contiguous color indices)Tj
T*
(\(from color index 16 to 47\) with slightly differing shades of yellow, you might call)Tj
/F7 1 Tf
0 -2.1 TD
(for \(i = 0; i < 32; i++\) {)Tj
0 -1.5 TD
(   glutSetColor \(16+i, 1.0*\(i/32.0\), 1.0*\(i/32.0\), 0.0\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Now, if you render smooth-shaded polygons that use only the colors from index 16 to 47, those polygons)Tj
0 -1.5 TD
(have gradually differing shades of yellow.)Tj
0 -2.1 TD
(With flat shading, the color of a single vertex defines the color of an entire primitive. For a line segment,)Tj
0 -1.5 TD
(the color of the line is the current color when the second \(ending\) vertex is specified. For a polygon, the)Tj
T*
[(color used is the one that's in effect when a particular vertex is specified, as shown in )41(Table 4-2)191(. The)]TJ
T*
(table counts vertices and polygons starting from 1. OpenGL follows these rules consistently, but the best)Tj
T*
(way to avoid uncertainty about how a flat-shaded primitive will be drawn is to specify only one color for)Tj
T*
(the primitive.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 471.840 m
467.000 471.840 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 464.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Type of Polygon)-8844(Vertex Used to Select the Color for the ith Polygon)]TJ
ET
Q
124.000 458.320 m
467.000 458.320 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 450.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(single polygon)-8860(1)]TJ
0 -1.4444 TD
[(triangle strip)-9694(i+2)]TJ
T*
[(triangle fan)-10195(i+2)]TJ
T*
[(independent triangle)-6584(3i)]TJ
T*
[(quad strip)-10805(2i+2)]TJ
T*
[(independent quad)-7695(4i)]TJ
ET
Q
124.000 377.510 m
467.010 377.510 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 361.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 4-2 )Tj
/F11 1 Tf
4.6 0 TD
(How OpenGL Selects a Color for the ith Flat-Shaded Polygon)Tj
ET
Q
124.000 328.510 m
547.000 328.510 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 13)Tj
ET
endstream
endobj
508 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
509 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im58
/Width 497
/Height 239
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.57)
>>
stream
endstream
endobj
511 0 obj
<<
/Length 2923
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 5)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Lighting)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Understand how real-world lighting conditions are approximated by OpenGL)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Render illuminated objects by defining the desired light sources and lighting model)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Define the material properties of the objects being illuminated)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Manipulate the matrix stack to control the position of light sources)Tj
-1.9 -2.8 TD
[(As you saw in )45(Chapter 4)-84(,)0( OpenGL computes the color of each pixel in a final, displayed scene that's held)]TJ
0 -1.5 TD
(in the framebuffer. Part of this computation depends on what lighting is used in the scene and on how)Tj
T*
(objects in the scene reflect or absorb that light. As an example of this, recall that the ocean has a different)Tj
T*
(color on a bright, sunny day than it does on a gray, cloudy day. The presence of sunlight or clouds)Tj
T*
(determines whether you see the ocean as bright turquoise or murky gray-green. In fact, most objects)Tj
T*
[(don't even look three-dimensional until they're lit. )232(Figure 5-1)225( shows two versions of the exact same)]TJ
T*
(scene \(a single sphere\), one with lighting and one without.)Tj
ET
Q
/GS1 gs
q
423 0 0 203 124 225.6 cm
/Im58 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 212.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 5-1 )Tj
/F11 1 Tf
5.1 0 TD
(A Lit and an Unlit Sphere)Tj
-5.1 -2.1 TD
(As you can see, an unlit sphere looks no different from a two-dimensional disk. This demonstrates how)Tj
0 -1.5 TD
(critical the interaction between objects and light is in creating a three-dimensional scene.)Tj
0 -2.1 TD
(With OpenGL, you can manipulate the lighting and objects in a scene to create many different kinds of)Tj
0 -1.5 TD
(effects. This chapter begins with a primer on hidden-surface removal. Then it explains how to control the)Tj
T*
(lighting in a scene, discusses the OpenGL conceptual model of lighting, and describes in detail how to)Tj
T*
(set the numerous illumination parameters to achieve certain effects. Toward the end of the chapter, the)Tj
T*
(mathematical computations that determine how lighting affects color are presented.)Tj
0 -2.1 TD
(This chapter contains the following major sections:)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 1)Tj
ET
endstream
endobj
512 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im58 509 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
514 0 obj
<<
/Length 3572
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 700.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
("A Hidden-Surface Removal Survival Kit")Tj
17.1 0 TD
( describes the basics of removing hidden surfaces from)Tj
-17.1 -1.5 TD
(view.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Real-World and OpenGL Lighting")208( explains in general terms how light behaves in the world and)]TJ
0 -1.5 TD
(how OpenGL models this behavior.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("A Simple Example: Rendering a Lit Sphere")-39( introduces the OpenGL lighting facility by presenting)]TJ
0 -1.6 TD
(a short program that renders a lit sphere.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Creating Light Sources")-6( explains how to define and position light sources.)]TJ
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Selecting a Lighting Model")-11( discusses the elements of a lighting model and how to specify them.)]TJ
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Defining Material Properties")15( explains how to describe the properties of objects so that they)]TJ
0 -1.6 TD
(interact with light in a desired way.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("The Mathematics of Lighting")-34( presents the mathematical calculations used by OpenGL to)]TJ
0 -1.6 TD
(determine the effect of lights in a scene.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Lighting in Color-Index Mode")243( discusses the differences between using RGBA mode and)]TJ
0 -1.6 TD
(color-index mode for lighting.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 410.000 Tm
(A Hidden-Surface Removal Survival Kit)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 388.000 Tm
(With this section, you begin to draw shaded, three-dimensional objects, in earnest. With shaded)Tj
0 -1.5 TD
(polygons, it becomes very important to draw the objects that are closer to our viewing position and to)Tj
T*
(eliminate objects obscured by others nearer to the eye.)Tj
0 -2.1 TD
(When you draw a scene composed of three-dimensional objects, some of them might obscure all or parts)Tj
0 -1.5 TD
(of others. Changing your viewpoint can change the obscuring relationship. For example, if you view the)Tj
T*
(scene from the opposite direction, any object that was previously in front of another is now behind it. To)Tj
T*
(draw a realistic scene, these obscuring relationships must be maintained. Suppose your code works like)Tj
T*
(this:)Tj
/F7 1 Tf
0 -2.1 TD
(while \(1\) { )Tj
0 -1.5 TD
(   get_viewing_point_from_mouse_position\(\); )Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\); )Tj
T*
(   draw_3d_object_A\(\); )Tj
T*
(   draw_3d_object_B\(\); )Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(For some mouse positions, object A might obscure object B. For others, the reverse may hold. If nothing)Tj
0 -1.5 TD
(special is done, the preceding code always draws object B second \(and thus on top of object A\) no matter)Tj
T*
(what viewing position is selected. In a worst case scenario, if objects A and B intersect one another so)Tj
T*
(that part of object A obscures object B and part of B obscures A, changing the drawing order does not)Tj
T*
(provide a solution.)Tj
0 -2.1 TD
(The elimination of parts of solid objects that are obscured by others is called )Tj
/F15 1 Tf
30.8 0 TD
(hidden-surface removal)Tj
/F11 1 Tf
9.6 0 TD
(.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 2)Tj
ET
endstream
endobj
515 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
517 0 obj
<<
/Length 3693
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(\(Hidden-line removal, which does the same job for objects represented as wireframe skeletons, is a bit)Tj
0 -1.5 TD
[(trickier and isn't discussed here. See )-40("Hidden-Line Removal" in Chapter 14)]TJ
30.3 0 TD
( for details.\) The easiest way)Tj
-30.3 -1.5 TD
(to achieve hidden-surface removal is to use the depth buffer \(sometimes called a z-buffer\). \(Also see)Tj
T*
[(Chapter 10)16(.\))]TJ
0 -2.1 TD
(A depth buffer works by associating a depth, or distance, from the view plane \(usually the near clipping)Tj
0 -1.5 TD
(plane\), with each pixel on the window. Initially, the depth values for all pixels are set to the largest)Tj
T*
(possible distance \(usually the far clipping plane\) using the )Tj
/F15 1 Tf
23.5 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.7 0 TD
( command with)Tj
-27.2 -1.5 TD
(GL_DEPTH_BUFFER_BIT. Then the objects in the scene are drawn in any order.)Tj
0 -2.1 TD
(Graphical calculations in hardware or software convert each surface that's drawn to a set of pixels on the)Tj
0 -1.5 TD
(window where the surface will appear if it isn't obscured by something else. In addition, the distance)Tj
T*
(from the view plane is computed. With depth buffering enabled, before each pixel is drawn a comparison)Tj
T*
(is done with the depth value already stored at the pixel. If the new pixel is closer than \(in front of\) what's)Tj
T*
(there, the new pixel's color and depth values replace those that are currently written into the pixel. If the)Tj
T*
(new pixel's depth is greater than what's currently there, the new pixel is obscured, and the color and)Tj
T*
(depth information for the incoming pixel is discarded.)Tj
0 -2.1 TD
(To use depth buffering, you need to enable depth buffering. This has to be done only once. Before)Tj
0 -1.5 TD
(drawing, each time you draw the scene, you need to clear the depth buffer and then draw the objects in)Tj
T*
(the scene in any order.)Tj
0 -2.1 TD
(To convert the preceding code example so that it performs hidden-surface removal, modify it to the)Tj
0 -1.5 TD
(following:)Tj
/F7 1 Tf
0 -2.1 TD
(glutInitDisplayMode \(GLUT_DEPTH | .... \);)Tj
0 -1.5 TD
(glEnable\(GL_DEPTH_TEST\); )Tj
T*
(... )Tj
T*
(while \(1\) { )Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\); )Tj
T*
(   get_viewing_point_from_mouse_position\(\); )Tj
T*
(   draw_3d_object_A\(\); )Tj
T*
(   draw_3d_object_B\(\); )Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(The argument to )Tj
/F15 1 Tf
6.9 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.7 0 TD
( clears both the depth and color buffers.)Tj
-10.6 -2.1 TD
(Depth-buffer testing can affect the performance of your application. Since information is discarded rather)Tj
0 -1.5 TD
(than used for drawing, hidden-surface removal can increase your performance slightly. However, the)Tj
T*
(implementation of your depth buffer probably has the greatest effect on performance. A "software" depth)Tj
T*
(buffer \(implemented with processor memory\) may be much slower than one implemented with a)Tj
T*
(specialized hardware depth buffer.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 125.000 Tm
(Real-World and OpenGL Lighting)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 103.000 Tm
(When you look at a physical surface, your eye's perception of the color depends on the distribution of)Tj
T*
[(photon energies that arrive and trigger your cone cells. \(See )36("Color Perception" in Chapter 4)17(.\) Those)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 3)Tj
ET
endstream
endobj
518 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
520 0 obj
<<
/Length 4620
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(photons come from a light source or combination of sources, some of which are absorbed and some of)Tj
0 -1.5 TD
(which are reflected by the surface. In addition, different surfaces may have very different)Tj
0 -1.6 TD
(properties)Tj
/F33 1 Tf
4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(some are shiny and preferentially reflect light in certain directions, while others scatter)Tj
-5 -1.6 TD
(incoming light equally in all directions. Most surfaces are somewhere in between.)Tj
0 -2.1 TD
(OpenGL approximates light and lighting as if light can be broken into red, green, and blue components.)Tj
0 -1.5 TD
(Thus, the color of light sources is characterized by the amount of red, green, and blue light they emit, and)Tj
T*
(the material of surfaces is characterized by the percentage of the incoming red, green, and blue)Tj
T*
(components that is reflected in various directions. The OpenGL lighting equations are just an)Tj
T*
(approximation but one that works fairly well and can be computed relatively quickly. If you desire a)Tj
T*
(more accurate \(or just different\) lighting model, you have to do your own calculations in software. Such)Tj
T*
(software can be enormously complex, as a few hours of reading any optics textbook should convince)Tj
T*
(you.)Tj
0 -2.1 TD
(In the OpenGL lighting model, the light in a scene comes from several light sources that can be)Tj
0 -1.5 TD
(individually turned on and off. Some light comes from a particular direction or position, and some light)Tj
T*
(is generally scattered about the scene. For example, when you turn on a light bulb in a room, most of the)Tj
T*
(light comes from the bulb, but some light comes after bouncing off one, two, three, or more walls. This)Tj
T*
(bounced light \(called )Tj
/F13 1 Tf
8.7 0 TD
(ambient)Tj
/F11 1 Tf
3.5 0 TD
(\) is assumed to be so scattered that there is no way to tell its original)Tj
-12.2 -1.5 TD
(direction, but it disappears if a particular light source is turned off.)Tj
0 -2.1 TD
(Finally, there might be a general ambient light in the scene that comes from no particular source, as if it)Tj
0 -1.5 TD
(had been scattered so many times that its original source is impossible to determine.)Tj
0 -2.1 TD
(In the OpenGL model, the light sources have an effect only when there are surfaces that absorb and)Tj
0 -1.5 TD
(reflect light. Each surface is assumed to be composed of a material with various properties. A material)Tj
T*
(might emit its own light \(like headlights on an automobile\), it might scatter some incoming light in all)Tj
T*
(directions, and it might reflect some portion of the incoming light in a preferential direction like a mirror)Tj
T*
(or other shiny surface.)Tj
0 -2.1 TD
(The OpenGL lighting model considers the lighting to be divided into four independent components:)Tj
0 -1.5 TD
(emissive, ambient, diffuse, and specular. All four components are computed independently and then)Tj
T*
(added together.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 245.000 Tm
(Ambient, Diffuse, and Specular Light)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 224.000 Tm
(A)Tj
/F15 1 Tf
0.7 0 TD
(mbient)Tj
/F11 1 Tf
2.7 0 TD
( illumination is light that's been scattered so much by the environment that its direction is)Tj
-3.4 -1.7 TD
(impossible to determine)Tj
/F33 1 Tf
9.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(it seems to come from all directions. Backlighting in a room has a large)Tj
-10.6 -1.5 TD
(ambient component, since most of the light that reaches your eye has first bounced off many surfaces. A)Tj
T*
(spotlight outdoors has a tiny ambient component; most of the light travels in the same direction, and)Tj
T*
(since you're outdoors, very little of the light reaches your eye after bouncing off other objects. When)Tj
T*
(ambient light strikes a surface, it's scattered equally in all directions.)Tj
0 -2.2 TD
(The )Tj
/F13 1 Tf
1.8 0 TD
(diffuse)Tj
/F11 1 Tf
2.9 0 TD
( component is the light that comes from one direction, so it's brighter if it comes squarely)Tj
-4.7 -1.5 TD
(down on a surface than if it barely glances off the surface. Once it hits a surface, however, it's scattered)Tj
T*
(equally in all directions, so it appears equally bright, no matter where the eye is located. Any light)Tj
T*
(coming from a particular position or direction probably has a diffuse component.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 4)Tj
ET
endstream
endobj
521 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
523 0 obj
<<
/Length 4429
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(Finally, )Tj
/F13 1 Tf
3.3 0 TD
(specular)Tj
/F11 1 Tf
3.6 0 TD
0.000 Tw
( light comes from a particular direction, and it tends to bounce off the surface in a)Tj
-6.9 -1.5 TD
(preferred direction. A well-collimated laser beam bouncing off a high-quality mirror produces almost)Tj
T*
(100 percent specular reflection. Shiny metal or plastic has a high specular component, and chalk or)Tj
T*
(carpet has almost none. You can think of specularity as shininess.)Tj
0 -2.1 TD
(Although a light source delivers a single distribution of frequencies, the ambient, diffuse, and specular)Tj
0 -1.5 TD
(components might be different. For example, if you have a white light in a room with red walls, the)Tj
T*
(scattered light tends to be red, although the light directly striking objects is white. OpenGL allows you to)Tj
T*
(set the red, green, and blue values for each component of light independently.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 567.000 Tm
(Material Colors)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 546.000 Tm
(The OpenGL lighting model makes the approximation that a material's color depends on the percentages)Tj
T*
(of the incoming red, green, and blue light it reflects. For example, a perfectly red ball reflects all the)Tj
T*
(incoming red light and absorbs all the green and blue light that strikes it. If you view such a ball in white)Tj
T*
(light \(composed of equal amounts of red, green, and blue light\), all the red is reflected, and you see a red)Tj
T*
(ball. If the ball is viewed in pure red light, it also appears to be red. If, however, the red ball is viewed in)Tj
T*
(pure green light, it appears black \(all the green is absorbed, and there's no incoming red, so no light is)Tj
T*
(reflected\).)Tj
0 -2.1 TD
(Like lights, materials have different ambient, diffuse, and specular colors, which determine the ambient,)Tj
0 -1.5 TD
(diffuse, and specular reflectances of the material. A material's ambient reflectance is combined with the)Tj
T*
(ambient component of each incoming light source, the diffuse reflectance with the light's diffuse)Tj
T*
(component, and similarly for the specular reflectance and component. Ambient and diffuse reflectances)Tj
T*
(define the color of the material and are typically similar if not identical. Specular reflectance is usually)Tj
T*
(white or gray, so that specular highlights end up being the color of the light source's specular intensity. If)Tj
T*
(you think of a white light shining on a shiny red plastic sphere, most of the sphere appears red, but the)Tj
T*
(shiny highlight is white.)Tj
0 -2.1 TD
(In addition to ambient, diffuse, and specular colors, materials have an )Tj
/F15 1 Tf
28.1 0 TD
(emissive)Tj
/F11 1 Tf
3.4 0 TD
( color, which simulates)Tj
-31.5 -1.5 TD
(light originating from an object. In the OpenGL lighting model, the emissive color of a surface adds)Tj
T*
(intensity to the object, but is unaffected by any light sources. Also, the emissive color does not introduce)Tj
T*
(any additional light into the overall scene.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 235.000 Tm
(RGB Values for Lights and Materials)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 213.000 Tm
(The color components specified for lights mean something different than for materials. For a light, the)Tj
T*
(numbers correspond to a percentage of full intensity for each color. If the R, G, and B values for a light's)Tj
T*
(color are all 1.0, the light is the brightest possible white. If the values are 0.5, the color is still white, but)Tj
T*
(only at half intensity, so it appears gray. If R=G=1 and B=0 \(full red and green with no blue\), the light)Tj
T*
(appears yellow.)Tj
0 -2.1 TD
(For materials, the numbers correspond to the reflected proportions of those colors. So if R=1, G=0.5, and)Tj
0 -1.5 TD
(B=0 for a material, that material reflects all the incoming red light, half the incoming green, and none of)Tj
T*
(the incoming blue light. In other words, if an OpenGL light has components \(LR, LG, LB\), and a)Tj
T*
(material has corresponding components \(MR, MG, MB\), then, ignoring all other reflectivity effects, the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 5)Tj
ET
endstream
endobj
524 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
526 0 obj
<<
/Length 2605
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(light that arrives at the eye is given by \(LR*MR, LG*MG, LB*MB\).)Tj
0 -2.1 TD
(Similarly, if you have two lights that send \(R1, G1, B1\) and \(R2, G2, B2\) to the eye, OpenGL adds the)Tj
0 -1.5 TD
(components, giving \(R1+R2, G1+G2, B1+B2\). If any of the sums are greater than 1 \(corresponding to a)Tj
T*
(color brighter than the equipment can display\), the component is clamped to 1.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 626.000 Tm
(A Simple Example: Rendering a Lit Sphere)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 604.000 Tm
(These are the steps required to add lighting to your scene.)Tj
0 -2.1 TD
[(1.)-1050(Define normal vectors for each vertex of all the objects. These normals determine the orientation of)]TJ
1.8 -1.5 TD
(the object relative to the light sources.)Tj
-1.8 -2.1 TD
[(2.)-1050(Create, select, and position one or more light sources.)]TJ
T*
[(3.)-1050(Create and select a )]TJ
/F15 1 Tf
9.6 0 TD
(lighting model)Tj
/F11 1 Tf
5.8 0 TD
(, which defines the level of global ambient light and the effective)Tj
-13.6 -1.5 TD
(location of the viewpoint \(for the purposes of lighting calculations\).)Tj
-1.8 -2.1 TD
[(4.)-1050(Define material properties for the objects in the scene.)]TJ
0 -2.6 TD
(Example 5-1)Tj
5.1 0 TD
( accomplishes these tasks. It displays a sphere illuminated by a single light source, as shown)Tj
-5.1 -1.5 TD
[(earlier in )32(Figure 5-1)225(.)]TJ
/F27 1 Tf
0 -2.1 TD
(Example 5-1 )Tj
/F11 1 Tf
6.1 0 TD
(Drawing a Lit Sphere: light.c )Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
0 -3 TD
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(   GLfloat mat_shininess[] = { 50.0 };)Tj
T*
(   GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel \(GL_SMOOTH\);)Tj
0 -3 TD
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
0 -1.5 TD
(   glMaterialfv\(GL_FRONT, GL_SHININESS, mat_shininess\);)Tj
T*
(   glLightfv\(GL_LIGHT0, GL_POSITION, light_position\);)Tj
0 -3 TD
(   glEnable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 6)Tj
ET
endstream
endobj
527 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
529 0 obj
<<
/Length 2428
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glClear \(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glutSolidSphere \(1.0, 20, 16\);)Tj
T*
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho \(-1.5, 1.5, -1.5*\(GLfloat\)h/\(GLfloat\)w,)Tj
T*
(         1.5*\(GLfloat\)h/\(GLfloat\)w, -10.0, 10.0\);)Tj
T*
(   else)Tj
T*
(      glOrtho \(-1.5*\(GLfloat\)w/\(GLfloat\)h,)Tj
T*
(         1.5*\(GLfloat\)w/\(GLfloat\)h, -1.5, 1.5, -10.0, 10.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.2 TD
(The lighting-related calls are in the )Tj
/F15 1 Tf
14.3 0 TD
(init\(\))Tj
/F11 1 Tf
2 0 TD
( command; they're discussed briefly in the following paragraphs)Tj
-16.3 -1.5 TD
[(and in more detail later in the chapter. One thing to note about )-34(Example 5-1)]TJ
30.3 0 TD
( is that it uses RGBA color)Tj
-30.3 -1.5 TD
(mode, not color-index mode. The OpenGL lighting calculation is different for the two modes, and in fact)Tj
T*
(the lighting capabilities are more limited in color-index mode. Thus, RGBA is the preferred mode when)Tj
T*
[(doing lighting, and all the examples in this chapter use it. \(See )-32("Lighting in Color-Index Mode")243( for more)]TJ
T*
(information about lighting in color-index mode.\))Tj
/F27 1 Tf
0 -3 TD
(Define Normal Vectors for Each Vertex of Every Object)Tj
/F11 1 Tf
0 -2.1 TD
(An object's normals determine its orientation relative to the light sources. For each vertex, OpenGL uses)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 7)Tj
ET
endstream
endobj
530 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
532 0 obj
<<
/Length 4982
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(the assigned normal to determine how much light that particular vertex receives from each light source.)Tj
0 -1.5 TD
(In this example, the normals for the sphere are defined as part of the )Tj
/F15 1 Tf
27.5 0 TD
(glutSolidSphere\(\))Tj
/F11 1 Tf
7.1 0 TD
( routine. \(See)Tj
-34.6 -1.5 TD
[("Normal Vectors" in Chapter 2)26( for more details on how to define normals.\))]TJ
/F27 1 Tf
0 -3 TD
(Create, Position, and Enable One or More Light Sources)Tj
/F11 1 Tf
0 -2.1 TD
(Example 5-1)Tj
5.1 0 TD
( uses only one, white light source; its location is specified by the )Tj
/F15 1 Tf
26.1 0 TD
(glLightfv\(\))Tj
/F11 1 Tf
4.3 0 TD
( call. This)Tj
-35.5 -1.5 TD
(example uses the default color for light zero \(GL_LIGHT0\), which is white; if you want a differently)Tj
T*
(colored light, use )Tj
/F15 1 Tf
7.2 0 TD
(glLight*\(\))Tj
/F11 1 Tf
4 0 TD
( to indicate this. You can include at least eight different light sources in your)Tj
-11.2 -1.5 TD
(scene of various colors; the default color of these other lights is black. \(The particular implementation of)Tj
T*
(OpenGL you're using might allow more than eight.\) You can also locate the lights wherever you)Tj
0 -1.6 TD
(desire)Tj
/F33 1 Tf
2.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(you can position them near the scene, as a desk lamp would be, or an infinite distance away, like)Tj
-3.4 -1.6 TD
(the sun. In addition, you can control whether a light produces a narrow, focused beam or a wider beam.)Tj
0 -1.5 TD
(Remember that each light source adds significantly to the calculations needed to render the scene, so)Tj
T*
[(performance is affected by the number of lights in the scene. \(See )24("Creating Light Sources")-6( for more)]TJ
T*
(information about how to create lights with the desired characteristics.\))Tj
0 -2.1 TD
(After you've defined the characteristics of the lights you want, you have to turn them on with the)Tj
/F15 1 Tf
0 -1.5 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( command. You also need to call )Tj
/F15 1 Tf
13.4 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.2 0 TD
( with GL_LIGHTING as a parameter to prepare)Tj
-21.9 -1.5 TD
[(OpenGL to perform lighting calculations. \(See )16("Enabling Lighting")23( for more information.\))]TJ
/F27 1 Tf
0 -3 TD
(Select a Lighting Model)Tj
/F11 1 Tf
0 -2.1 TD
(As you might expect, the )Tj
/F15 1 Tf
10.3 0 TD
(glLightModel*\(\))Tj
/F11 1 Tf
6.6 0 TD
( command describes the parameters of a lighting model. In)Tj
-16.9 -1.5 TD
(Example 5-1)Tj
5.1 0 TD
(, the only element of the lighting model that's defined explicitly is the global ambient light.)Tj
-5.1 -1.5 TD
(The lighting model also defines whether the viewer of the scene should be considered to be an infinite)Tj
T*
(distance away or local to the scene, and whether lighting calculations should be performed differently for)Tj
T*
[(the front and back surfaces of objects in the scene. )13(Example 5-1)]TJ
25.5 0 TD
( uses the default settings for these two)Tj
-25.5 -1.6 TD
(aspects of the model)Tj
/F33 1 Tf
8.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(an infinite viewer and one-sided lighting. Using a local viewer adds significantly)Tj
-9.2 -1.6 TD
(to the complexity of the calculations that must be performed, because OpenGL must calculate the angle)Tj
0 -1.5 TD
(between the viewpoint and each object. With an infinite viewer, however, the angle is ignored, and the)Tj
T*
(results are slightly less realistic. Further, since in this example, the back surface of the sphere is never)Tj
T*
(seen \(it's the inside of the sphere\), one-sided lighting is sufficient. \(See )Tj
28.7 0 TD
[("Selecting a Lighting Model")-11( for)]TJ
-28.7 -1.5 TD
(a more detailed description of the elements of an OpenGL lighting model.\))Tj
/F27 1 Tf
0 -3 TD
(Define Material Properties for the Objects in the Scene)Tj
/F11 1 Tf
0 -2.1 TD
(An object's material properties determine how it reflects light and therefore what material it seems to be)Tj
0 -1.5 TD
(made of. Because the interaction between an object's material surface and incident light is complex,)Tj
T*
(specifying material properties so that an object has a certain desired appearance is an art. You can specify)Tj
T*
(a material's ambient, diffuse, and specular colors and how shiny it is. In this example, only these last two)Tj
0 -1.6 TD
(material properties)Tj
/F33 1 Tf
7.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the specular material color and shininess)Tj
/F33 1 Tf
16.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(are explicitly specified \(with the)Tj
/F15 1 Tf
-25.8 -1.6 TD
(glMaterialfv\(\))Tj
/F11 1 Tf
5.7 0 TD
[( calls\). \(See )44("Defining Material Properties")15( for a description and examples of all the)]TJ
-5.7 -1.5 TD
(material-property parameters.\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 8)Tj
ET
endstream
endobj
533 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
535 0 obj
<<
/Length 4832
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Some Important Notes)Tj
/F11 1 Tf
0 -2.1 TD
(As you write your own lighting program, remember that you can use the default values for some lighting)Tj
0 -1.5 TD
(parameters; others need to be changed. Also, don't forget to enable whatever lights you define and to)Tj
T*
(enable lighting calculations. Finally, remember that you might be able to use display lists to maximize)Tj
T*
[(efficiency as you change lighting conditions. \(See )21("Display-List Design Philosophy" in Chapter 7)177(.)0(\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 611.000 Tm
(Creating Light Sources)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 589.000 Tm
(Light sources have a number of properties, such as color, position, and direction. The following sections)Tj
T*
(explain how to control these properties and what the resulting light looks like. The command used to)Tj
T*
(specify all properties of lights is )Tj
/F15 1 Tf
13.1 0 TD
(glLight*\(\))Tj
/F11 1 Tf
4.1 0 TD
(; it takes three arguments: to identify the light whose property)Tj
-17.2 -1.5 TD
(is being specified, the property, and the desired value for that property.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glLight)-10({if}\(GLenum )84(light)-66(, GLenum )-6(pname)66(, TYPE)-66(param)11(\);)]TJ
0 -1.1 TD
[(void )-28(glLight)-10({if})56(v)-56(\(GLenum )27(light)34(, GLenum )-6(pname)-34(, TYPE)34( *)-50(param)11(\);)]TJ
1.8 -1.5 TD
[(Creates the light specified by )17(light)-66(, which can be GL_LIGHT0, GL_LIGHT1, ... , or GL_LIGHT7.)]TJ
T*
[(The characteristic of the light being set is defined by )-20(pname)66(, which specifies a named parameter \(see)]TJ
T*
(Table 5-1)Tj
3.9 0 TD
[(\). )33(param)11( indicates the values to which the )29(pname)-34( characteristic is set; it's a pointer to a)]TJ
-3.9 -1.5 TD
(group of values if the vector version is used, or the value itself if the nonvector version is used. The)Tj
T*
(nonvector version can be used to set only single-valued light characteristics.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 425.450 m
468.000 425.450 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 418.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Parameter Name)-10481(Default Value)-3789(Meaning)]TJ
ET
Q
124.000 411.930 m
468.000 411.930 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 404.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_AMBIENT)-9944(\(0.0, 0.0, 0.0, 1.0\))-1833(ambient RGBA intensity of)]TJ
25.3333 -1.3333 TD
(light)Tj
-25.3333 -1.4444 TD
[(GL_DIFFUSE)-10443(\(1.0, 1.0, 1.0, 1.0\))-1833(diffuse RGBA intensity of)]TJ
25.3333 -1.3333 TD
(light)Tj
-25.3333 -1.4444 TD
[(GL_SPECULAR)-9387(\(1.0, 1.0, 1.0, 1.0\))-1833(specular RGBA intensity of)]TJ
25.3333 -1.3333 TD
(light)Tj
-25.3333 -1.4444 TD
[(GL_POSITION)-9944(\(0.0, 0.0, 1.0, 0.0\))-1833(\()]TJ
/F15 1 Tf
25.6667 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.4444 0 TD
(\) position of light)Tj
-29.1111 -1.4444 TD
[(GL_SPOT_DIRECTION)-6166(\(0.0, 0.0, -1.0\))-3019(\()]TJ
/F15 1 Tf
25.6667 0 TD
(x, y, z)Tj
/F11 1 Tf
2.2222 0 TD
(\) direction of spotlight)Tj
-27.8889 -1.4444 TD
[(GL_SPOT_EXPONENT)-6277(0.0)-7750(spotlight exponent)]TJ
T*
[(GL_SPOT_CUTOFF)-7720(180.0)-6750(spotlight cutoff angle)]TJ
0 -1.5556 TD
[(GL_CONSTANT_ATTENUATION)-1556(1.0)-7750(constant attenuation factor)]TJ
0 -1.4444 TD
[(GL_LINEAR_ATTENUATION)-3223(0.0)-7750(linear attenuation factor)]TJ
T*
[(GL_QUADRATIC_ATTENUATION)-1001(0.0)-7750(quadratic attenuation factor)]TJ
ET
Q
124.000 242.920 m
468.010 242.920 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 227.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 5-1 )Tj
/F11 1 Tf
4.6 0 TD
(Default Values for pname Parameter of glLight*\(\))Tj
/F27 1 Tf
-4.6 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
[(The default values listed for GL_DIFFUSE and GL_SPECULAR in )-71(Table 5-1)]TJ
31.4 0 TD
( apply only to)Tj
-34.2 -1.5 TD
(GL_LIGHT0. For other lights, the default value is \(0.0, 0.0, 0.0, 1.0\) for both GL_DIFFUSE and)Tj
0 -1.4 TD
(GL_SPECULAR.)Tj
0 -2.1 TD
(Example 5-2)Tj
5.1 0 TD
( shows how to use )Tj
/F15 1 Tf
7.6 0 TD
(glLight*\(\))Tj
/F11 1 Tf
4.1 0 TD
(:)Tj
/F27 1 Tf
-16.8 -2.1 TD
(Example 5-2 )Tj
/F11 1 Tf
6.1 0 TD
(Defining Colors and Position for a Light Source)Tj
/F7 1 Tf
-6.1 -2.4 TD
(GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };)Tj
0 -1.5 TD
(GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 9)Tj
ET
endstream
endobj
536 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
539 0 obj
<<
/Length 4245
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };)Tj
0 -3 TD
(glLightfv\(GL_LIGHT0, GL_AMBIENT, light_ambient\);)Tj
0 -1.5 TD
(glLightfv\(GL_LIGHT0, GL_DIFFUSE, light_diffuse\);)Tj
T*
(glLightfv\(GL_LIGHT0, GL_SPECULAR, light_specular\);)Tj
T*
(glLightfv\(GL_LIGHT0, GL_POSITION, light_position\);)Tj
/F11 1 Tf
0 -2.1 TD
(As you can see, arrays are defined for the parameter values, and )Tj
/F15 1 Tf
25.8 0 TD
(glLightfv\(\))Tj
/F11 1 Tf
4.3 0 TD
( is called repeatedly to set the)Tj
-30.1 -1.5 TD
(various parameters. In this example, the first three calls to )Tj
/F15 1 Tf
23.4 0 TD
(glLightfv\(\))Tj
/F11 1 Tf
4.3 0 TD
( are superfluous, since they're being)Tj
-27.7 -1.5 TD
(used to specify the default values for the GL_AMBIENT, GL_DIFFUSE, and GL_SPECULAR)Tj
T*
(parameters.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Remember to turn on each light with )Tj
/F15 1 Tf
15 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
[(. \(See )27("Enabling Lighting")23( for more information)]TJ
-22.1 -1.5 TD
(about how to do this.\))Tj
0 -2.1 TD
(All the parameters for )Tj
/F15 1 Tf
9.1 0 TD
(glLight*\(\))Tj
/F11 1 Tf
4 0 TD
( and their possible values are explained in the following sections. These)Tj
-13.1 -1.5 TD
(parameters interact with those that define the overall lighting model for a particular scene and an object's)Tj
T*
[(material properties. \(See )-46("Selecting a Lighting Model")89( and )-56("Defining Material Properties")15( for more)]TJ
T*
[(information about these two topics. )-10("The Mathematics of Lighting")-34( explains how all these parameters)]TJ
T*
(interact mathematically.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 426.000 Tm
(Color)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 403.000 Tm
(OpenGL allows you to associate three different color-related parameters)Tj
/F33 1 Tf
28.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(GL_AMBIENT,)Tj
-29.9 -1.7 TD
(GL_DIFFUSE, and GL_SPECULAR)Tj
/F33 1 Tf
15 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(with any particular light. The GL_AMBIENT parameter refers to)Tj
-16 -1.6 TD
(the RGBA intensity of the ambient light that a particular light source adds to the scene. As you can see in)Tj
0 -1.5 TD
[(Table 5-1)191(, by default there is no ambient light since GL_AMBIENT is \(0.0, 0.0, 0.0, 1.0\). This value was)]TJ
T*
[(used in )11(Example 5-1)]TJ
8.2 0 TD
(. If this program had specified blue ambient light as)Tj
/F7 1 Tf
-8.2 -2 TD
(GLfloat light_ambient[] = { 0.0, 0.0, 1.0, 1.0};)Tj
0 -1.5 TD
(glLightfv\(GL_LIGHT0, GL_AMBIENT, light_ambient\);)Tj
/F11 1 Tf
0 -2.2 TD
[(the result would have been as shown in the left side of )44("Plate 13" in Appendix I)-28(.)]TJ
0 -2.1 TD
(The GL_DIFFUSE parameter probably most closely correlates with what you naturally think of as "the)Tj
0 -1.5 TD
(color of a light." It defines the RGBA color of the diffuse light that a particular light source adds to a)Tj
T*
(scene. By default, GL_DIFFUSE is \(1.0, 1.0, 1.0, 1.0\) for GL_LIGHT0, which produces a bright, white)Tj
T*
[(light as shown in the left side of )-43("Plate 13" in Appendix I)72(.)0( The default value for any other light)]TJ
T*
(\(GL_LIGHT1, ... , GL_LIGHT7\) is \(0.0, 0.0, 0.0, 0.0\).)Tj
0 -2.1 TD
(The GL_SPECULAR parameter affects the color of the specular highlight on an object. Typically, a)Tj
0 -1.5 TD
(real-world object such as a glass bottle has a specular highlight that's the color of the light shining on it)Tj
T*
(\(which is often white\). Therefore, if you want to create a realistic effect, set the GL_SPECULAR)Tj
T*
(parameter to the same value as the GL_DIFFUSE parameter. By default, GL_SPECULAR is \(1.0, 1.0,)Tj
T*
(1.0, 1.0\) for GL_LIGHT0 and \(0.0, 0.0, 0.0, 0.0\) for any other light.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
[(The alpha component of these colors is not used until blending is enabled. \(See )17(Chapter 6)-84(.\) Until)]TJ
-2.8 -1.4 TD
(then, the alpha value can be safely ignored.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 10)Tj
ET
endstream
endobj
540 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
541 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im59
/Width 263
/Height 58
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.58)
>>
stream
endstream
endobj
543 0 obj
<<
/Length 4577
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 705.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Position and Attenuation)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 684.000 Tm
(As previously mentioned, you can choose whether to have a light source that's treated as though it's)Tj
0 -1.5 TD
(located infinitely far away from the scene or one that's nearer to the scene. The first type is referred to as)Tj
T*
(a )Tj
/F15 1 Tf
0.7 0 TD
(directional)Tj
/F11 1 Tf
4.4 0 TD
( light source; the effect of an infinite location is that the rays of light can be considered)Tj
-5.1 -1.5 TD
(parallel by the time they reach an object. An example of a real-world directional light source is the sun.)Tj
T*
(The second type is called a )Tj
/F15 1 Tf
11.1 0 TD
(positional)Tj
/F11 1 Tf
4 0 TD
( light source, since its exact position within the scene determines)Tj
-15.1 -1.5 TD
(the effect it has on a scene and, specifically, the direction from which the light rays come. A desk lamp is)Tj
T*
(an example of a positional light source. You can see the difference between directional and positional)Tj
T*
[(lights in "Plate 12" in Appendix I)-28(.)0( The light used in Example 5-1)]TJ
26 0 TD
( is a directional one:)Tj
/F7 1 Tf
-26 -2.1 TD
(GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };)Tj
0 -1.5 TD
(glLightfv\(GL_LIGHT0, GL_POSITION, light_position\);)Tj
/F11 1 Tf
0 -2.1 TD
(As shown, you supply a vector of four values \()Tj
/F15 1 Tf
18.7 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.5 0 TD
(\) for the GL_POSITION parameter. If the last)Tj
-22.2 -1.5 TD
(value, )Tj
/F15 1 Tf
2.7 0 TD
(w)Tj
/F11 1 Tf
0.6 0 TD
(, is zero, the corresponding light source is a directional one, and the \()Tj
/F15 1 Tf
27.6 0 TD
(x, y, z)Tj
/F11 1 Tf
2.3 0 TD
(\) values describe its)Tj
-33.2 -1.5 TD
(direction. This direction is transformed by the modelview matrix. By default, GL_POSITION is \(0, 0, 1,)Tj
T*
(0\), which defines a directional light that points along the negative )Tj
/F15 1 Tf
26.5 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(-axis. \(Note that nothing prevents you)Tj
-26.9 -1.5 TD
(from creating a directional light with the direction of \(0, 0, 0\), but such a light won't help you much.\))Tj
0 -2.1 TD
(If the )Tj
/F15 1 Tf
2.4 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( value is nonzero, the light is positional, and the \()Tj
/F15 1 Tf
19.7 0 TD
(x, y, z)Tj
/F11 1 Tf
2.3 0 TD
(\) values specify the location of the light in)Tj
-25.1 -1.5 TD
[(homogeneous object coordinates. \(See )38(Appendix F)-49(.\) This location is transformed by the modelview)]TJ
T*
[(matrix and stored in eye coordinates. \(See )-46("Controlling a Light's Position and Direction")13( for more)]TJ
T*
(information about how to control the transformation of the light's location.\) Also, by default, a positional)Tj
T*
(light radiates in all directions, but you can restrict it to producing a cone of illumination by defining the)Tj
T*
[(light as a spotlight. \(See )-10("Spotlights")-26( for an explanation of how to define a light as a spotlight.\))]TJ
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Remember that the colors across the face of a smooth-shaded polygon are determined by the)Tj
-2.8 -1.4 TD
(colors calculated for the vertices. Because of this, you probably want to avoid using large polygons with)Tj
0 -1.5 TD
(local lights. If you locate the light near the middle of the polygon, the vertices might be too far away to)Tj
0 -1.4 TD
(receive much light, and the whole polygon will look darker than you intended. To avoid this problem,)Tj
T*
(break up the large polygon into smaller ones.)Tj
0 -2.1 TD
(For real-world lights, the intensity of light decreases as distance from the light increases. Since a)Tj
0 -1.5 TD
(directional light is infinitely far away, it doesn't make sense to attenuate its intensity over distance, so)Tj
T*
(attenuation is disabled for a directional light. However, you might want to attenuate the light from a)Tj
T*
(positional light. OpenGL attenuates a light source by multiplying the contribution of that source by an)Tj
T*
(attenuation factor:)Tj
ET
Q
/GS1 gs
q
263 0 0 58 124 134.61 cm
/Im59 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 116.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(where)Tj
/F15 1 Tf
0 -2.1 TD
0.000 Tw
(d)Tj
/F11 1 Tf
0.5 0 TD
( = distance between the light's position and the vertex)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 11)Tj
ET
endstream
endobj
544 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im59 541 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
545 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im60
/Width 331
/Height 199
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.59)
>>
stream
endstream
endobj
547 0 obj
<<
/Length 3115
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(k)Tj
/F11 1 Tf
0.4 -0.2 TD
(c)Tj
0.5 0.2 TD
( = GL_CONSTANT_ATTENUATION)Tj
/F15 1 Tf
-0.9 -2.3 TD
(k)Tj
/F11 1 Tf
0.4 -0.2 TD
(l)Tj
0.3 0.2 TD
( = GL_LINEAR_ATTENUATION)Tj
/F15 1 Tf
-0.7 -2.3 TD
(k)Tj
/F11 1 Tf
0.4 -0.2 TD
(q)Tj
0.5 0.2 TD
( = GL_QUADRATIC_ATTENUATION)Tj
-0.9 -2.3 TD
(By default,)Tj
/F15 1 Tf
4.4 0 TD
( k)Tj
/F11 1 Tf
0.7 -0.2 TD
(c)Tj
0.5 0.2 TD
( is 1.0 and both )Tj
/F15 1 Tf
6.4 0 TD
(k)Tj
/F11 1 Tf
0.4 -0.2 TD
(l)Tj
0.3 0.2 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(k)Tj
/F11 1 Tf
0.5 -0.2 TD
(q)Tj
0.5 0.2 TD
( are zero, but you can give these parameters different values:)Tj
/F7 1 Tf
-15.6 -2.3 TD
(glLightf\(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 2.0\);)Tj
0 -1.5 TD
(glLightf\(GL_LIGHT0, GL_LINEAR_ATTENUATION, 1.0\);)Tj
T*
(glLightf\(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.5\);)Tj
/F11 1 Tf
0 -2.1 TD
(Note that the ambient, diffuse, and specular contributions are all attenuated. Only the emission and global)Tj
0 -1.5 TD
(ambient values aren't attenuated. Also note that since attenuation requires an additional division \(and)Tj
T*
(possibly more math\) for each calculated color, using attenuated lights may slow down application)Tj
T*
(performance.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 494.000 Tm
(Spotlights)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 472.000 Tm
(As previously mentioned, you can have a positional light source act as a spotlight)Tj
/F33 1 Tf
32.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, by restricting)Tj
-33.6 -1.6 TD
(the shape of the light it emits to a cone. To create a spotlight, you need to determine the spread of the)Tj
0 -1.5 TD
(cone of light you desire. \(Remember that since spotlights are positional lights, you also have to locate)Tj
T*
(them where you want them. Again, note that nothing prevents you from creating a directional spotlight,)Tj
T*
(but it won't give you the result you want.\) To specify the angle between the axis of the cone and a ray)Tj
T*
(along the edge of the cone, use the GL_SPOT_CUTOFF parameter. The angle of the cone at the apex is)Tj
T*
[(then twice this value, as shown in )23(Figure 5-2)225(.)]TJ
ET
Q
/GS1 gs
q
331 0 0 199 124 167.7 cm
/Im60 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 155.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 5-2 )Tj
/F11 1 Tf
5.1 0 TD
(GL_SPOT_CUTOFF Parameter)Tj
-5.1 -2.1 TD
(Note that no light is emitted beyond the edges of the cone. By default, the spotlight feature is disabled)Tj
0 -1.5 TD
(because the GL_SPOT_CUTOFF parameter is 180.0. This value means that light is emitted in all)Tj
T*
(directions \(the angle at the cone's apex is 360 degrees, so it isn't a cone at all\). The value for)Tj
T*
(GL_SPOT_CUTOFF is restricted to being within the range [0.0,90.0] \(unless it has the special value)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 12)Tj
ET
endstream
endobj
548 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im60 545 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
550 0 obj
<<
/Length 3872
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(180.0\). The following line sets the cutoff parameter to 45 degrees:)Tj
/F7 1 Tf
0 -2.1 TD
(glLightf\(GL_LIGHT0, GL_SPOT_CUTOFF, 45.0\);)Tj
/F11 1 Tf
T*
(You also need to specify a spotlight's direction, which determines the axis of the cone of light:)Tj
/F7 1 Tf
T*
(GLfloat spot_direction[] = { -1.0, -1.0, 0.0 };)Tj
0 -1.5 TD
(glLightfv\(GL_LIGHT0, GL_SPOT_DIRECTION, spot_direction\);)Tj
/F11 1 Tf
0 -2.1 TD
(The direction is specified in object coordinates. By default, the direction is \(0.0, 0.0, -1.0\), so if you don't)Tj
0 -1.5 TD
(explicitly set the value of GL_SPOT_DIRECTION, the light points down the negative )Tj
/F15 1 Tf
34.9 0 TD
(z)Tj
/F11 1 Tf
0.3 0 TD
(-axis. Also, keep)Tj
-35.2 -1.5 TD
(in mind that a spotlight's direction is transformed by the modelview matrix just as though it were a)Tj
T*
[(normal vector, and the result is stored in eye coordinates. \(See )37("Controlling a Light's Position and)]TJ
T*
[(Direction")-15( for more information about such transformations.\))]TJ
0 -2.1 TD
(In addition to the spotlight's cutoff angle and direction, there are two ways you can control the intensity)Tj
0 -1.5 TD
(distribution of the light within the cone. First, you can set the attenuation factor described earlier, which)Tj
T*
(is multiplied by the light's intensity. You can also set the GL_SPOT_EXPONENT parameter, which by)Tj
T*
(default is zero, to control how concentrated the light is. The light's intensity is highest in the center of the)Tj
T*
(cone. It's attenuated toward the edges of the cone by the cosine of the angle between the direction of the)Tj
T*
(light and the direction from the light to the vertex being lit, raised to the power of the spot exponent.)Tj
T*
[(Thus, higher spot exponents result in a more focused light source. \(See )10("The Mathematics of Lighting")]TJ
T*
(for more details on the equations used to calculate light intensity.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 397.000 Tm
(Multiple Lights)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 376.000 Tm
(As mentioned, you can have at least eight lights in your scene \(possibly more, depending on your)Tj
T*
(OpenGL implementation\). Since OpenGL needs to perform calculations to determine how much light)Tj
T*
(each vertex receives from each light source, increasing the number of lights adversely affects)Tj
T*
(performance. The constants used to refer to the eight lights are GL_LIGHT0, GL_LIGHT1,)Tj
T*
(GL_LIGHT2, GL_LIGHT3, and so on. In the preceding discussions, parameters related to GL_LIGHT0)Tj
T*
(were set. If you want an additional light, you need to specify its parameters; also, remember that the)Tj
T*
[(default values are different for these other lights than they are for GL_LIGHT0, as explained in )12(Table)]TJ
T*
(5-1)Tj
1.3 0 TD
[(. Example 5-3)170( defines a white attenuated spotlight.)]TJ
/F27 1 Tf
-1.3 -2.1 TD
(Example 5-3 )Tj
/F11 1 Tf
6.1 0 TD
(Second Light Source)Tj
/F7 1 Tf
-6.1 -2.4 TD
(GLfloat light1_ambient[] = { 0.2, 0.2, 0.2, 1.0 };)Tj
0 -1.5 TD
(GLfloat light1_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(GLfloat light1_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(GLfloat light1_position[] = { -2.0, 2.0, 1.0, 1.0 };)Tj
T*
(GLfloat spot_direction[] = { -1.0, -1.0, 0.0 };)Tj
0 -3 TD
(glLightfv\(GL_LIGHT1, GL_AMBIENT, light1_ambient\);)Tj
0 -1.5 TD
(glLightfv\(GL_LIGHT1, GL_DIFFUSE, light1_diffuse\);)Tj
T*
(glLightfv\(GL_LIGHT1, GL_SPECULAR, light1_specular\);)Tj
T*
(glLightfv\(GL_LIGHT1, GL_POSITION, light1_position\);)Tj
T*
(glLightf\(GL_LIGHT1, GL_CONSTANT_ATTENUATION, 1.5\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 13)Tj
ET
endstream
endobj
551 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
553 0 obj
<<
/Length 3476
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(glLightf\(GL_LIGHT1, GL_LINEAR_ATTENUATION, 0.5\);)Tj
0 -1.5 TD
(glLightf\(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, 0.2\);)Tj
0 -3 TD
(glLightf\(GL_LIGHT1, GL_SPOT_CUTOFF, 45.0\);)Tj
0 -1.5 TD
(glLightfv\(GL_LIGHT1, GL_SPOT_DIRECTION, spot_direction\);)Tj
T*
(glLightf\(GL_LIGHT1, GL_SPOT_EXPONENT, 2.0\);)Tj
0 -3 TD
(glEnable\(GL_LIGHT1\);)Tj
/F11 1 Tf
0 -2.1 TD
[(If these lines were added to )20(Example 5-1)170(, the sphere would be lit with two lights, one directional and one)]TJ
0 -1.5 TD
(spotlight.)Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
0.050 Tw
[(Modify Example )50(5-1)]TJ
8.4 0 TD
0.000 Tw
( in the following manner:)Tj
/F33 1 Tf
-8.3 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Change the first light to be a positional colored light rather than a directional white one.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Add an additional colored spotlight. Hint: Use some of the code shown in the preceding section.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Measure how these two changes affect performance.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 422.000 Tm
(Controlling a Light's Position and Direction)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 400.000 Tm
(OpenGL treats the position and direction of a light source just as it treats the position of a geometric)Tj
0 -1.5 TD
(primitive. In other words, a light source is subject to the same matrix transformations as a primitive.)Tj
T*
(More specifically, when )Tj
/F15 1 Tf
9.9 0 TD
(glLight*\(\))Tj
/F11 1 Tf
4.1 0 TD
( is called to specify the position or the direction of a light source, the)Tj
-14 -1.5 TD
(position or direction is transformed by the current modelview matrix and stored in eye coordinates. This)Tj
T*
(means you can manipulate a light source's position or direction by changing the contents of the)Tj
T*
(modelview matrix. \(The projection matrix has no effect on a light's position or direction.\) This section)Tj
T*
(explains how to achieve the following three different effects by changing the point in the program at)Tj
T*
(which the light position is set, relative to modeling or viewing transformations:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A light position that remains fixed)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A light that moves around a stationary object)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A light that moves along with the viewpoint)Tj
/F27 1 Tf
-1.9 -3.6 TD
(Keeping the Light Stationary)Tj
/F11 1 Tf
0 -2.1 TD
[(In the simplest example, as in )39(Example 5-1)170(, the light position remains fixed. To achieve this effect, you)]TJ
0 -1.5 TD
[(need to set the light position after whatever viewing and/or modeling transformation you use. In )-33(Example)]TJ
T*
(5-4)Tj
1.3 0 TD
(, the relevant code from the )Tj
/F15 1 Tf
11.3 0 TD
(init\(\))Tj
/F11 1 Tf
2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(reshape\(\))Tj
/F11 1 Tf
3.9 0 TD
( routines might look like this.)Tj
/F27 1 Tf
-20.4 -2.1 TD
(Example 5-4 )Tj
/F11 1 Tf
6.1 0 TD
(Stationary Light Source)Tj
/F7 1 Tf
-6.1 -2.4 TD
(glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
0 -1.5 TD
(glMatrixMode \(GL_PROJECTION\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 14)Tj
ET
endstream
endobj
554 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
556 0 obj
<<
/Length 2799
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glLoadIdentity\(\);)Tj
0 -1.5 TD
0.000 Tw
(if \(w <= h\) )Tj
T*
(    glOrtho \(-1.5, 1.5, -1.5*h/w, 1.5*h/w, -10.0, 10.0\);)Tj
T*
(else )Tj
T*
(    glOrtho \(-1.5*w/h, 1.5*w/h, -1.5, 1.5, -10.0, 10.0\);)Tj
T*
(glMatrixMode \(GL_MODELVIEW\);)Tj
T*
(glLoadIdentity\(\);)Tj
0 -3 TD
(/* later in init\(\) */)Tj
0 -1.5 TD
(GLfloat light_position[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(glLightfv\(GL_LIGHT0, GL_POSITION, position\);)Tj
/F11 1 Tf
0 -2.1 TD
(As you can see, the viewport and projection matrices are established first. Then, the identity matrix is)Tj
0 -1.5 TD
(loaded as the modelview matrix, after which the light position is set. Since the identity matrix is used, the)Tj
T*
(originally specified light position \(1.0, 1.0, 1.0\) isn't changed by being multiplied by the modelview)Tj
T*
(matrix. Then, since neither the light position nor the modelview matrix is modified after this point, the)Tj
T*
(direction of the light remains \(1.0, 1.0, 1.0\).)Tj
/F27 1 Tf
0 -3 TD
(Independently Moving the Light)Tj
/F11 1 Tf
0 -2.1 TD
(Now suppose you want to rotate or translate the light position so that the light moves relative to a)Tj
0 -1.5 TD
(stationary object. One way to do this is to set the light position after the modeling transformation, which)Tj
T*
(is itself changed specifically to modify the light position. You can begin with the same series of calls in)Tj
/F15 1 Tf
T*
(init\(\))Tj
/F11 1 Tf
2 0 TD
( early in the program. Then you need to perform the desired modeling transformation \(on the)Tj
-2 -1.5 TD
(modelview stack\) and reset the light position, probably in )Tj
/F15 1 Tf
23.3 0 TD
(display\(\))Tj
/F11 1 Tf
3.5 0 TD
[(. Example 5-5)170( shows what )]TJ
/F15 1 Tf
10.9 0 TD
(display\(\))Tj
/F11 1 Tf
-37.7 -1.5 TD
(might be.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 5-5 )Tj
/F11 1 Tf
6.1 0 TD
(Independently Moving Light Source)Tj
/F7 1 Tf
-6.1 -2.4 TD
(static GLdouble spin;)Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(    GLfloat light_position[] = { 0.0, 0.0, 1.5, 1.0 };)Tj
T*
(    glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
0 -3 TD
(    glPushMatrix\(\);)Tj
0 -1.5 TD
(        gluLookAt \(0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0\);)Tj
T*
(        glPushMatrix\(\);)Tj
T*
(            glRotated\(spin, 1.0, 0.0, 0.0\);)Tj
T*
(            glLightfv\(GL_LIGHT0, GL_POSITION, light_position\);)Tj
T*
(        glPopMatrix\(\);)Tj
T*
(        glutSolidTorus \(0.275, 0.85, 8, 15\);)Tj
T*
(    glPopMatrix\(\);)Tj
T*
(    glFlush\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 15)Tj
ET
endstream
endobj
557 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
559 0 obj
<<
/Length 3013
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(})Tj
/F15 1 Tf
0 -2.1 TD
(spin)Tj
/F11 1 Tf
1.7 0 TD
( is a global variable and is probably controlled by an input device. )Tj
/F15 1 Tf
26.6 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
( causes the scene to be)Tj
-31.9 -1.5 TD
(redrawn with the light rotated )Tj
/F15 1 Tf
12.1 0 TD
(spin)Tj
/F11 1 Tf
1.7 0 TD
( degrees around a stationary torus. Note the two pairs of)Tj
/F15 1 Tf
-13.8 -1.5 TD
(glPushMatrix\(\))Tj
/F11 1 Tf
6.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
( calls, which are used to isolate the viewing and modeling)Tj
-13.9 -1.5 TD
[(transformations, all of which occur on the modelview stack. Since in )49(Example 5-5)170( the viewpoint remains)]TJ
T*
(constant, the current matrix is pushed down the stack and then the desired viewing transformation is)Tj
T*
(loaded with )Tj
/F15 1 Tf
4.9 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.9 0 TD
(. The matrix stack is pushed again before the modeling transformation)Tj
/F15 1 Tf
-9.8 -1.5 TD
(glRotated\(\))Tj
/F11 1 Tf
4.6 0 TD
( is specified. Then the light position is set in the new, rotated coordinate system so that the)Tj
-4.6 -1.5 TD
(light itself appears to be rotated from its previous position. \(Remember that the light position is stored in)Tj
T*
(eye coordinates, which are obtained after transformation by the modelview matrix.\) After the rotated)Tj
T*
(matrix is popped off the stack, the torus is drawn.)Tj
0 -2.1 TD
(Example 5-6)Tj
5.1 0 TD
( is a program that rotates a light source around an object. When the left mouse button is)Tj
-5.1 -1.5 TD
(pressed, the light position rotates an additional 30 degrees. A small, unlit, wireframe cube is drawn to)Tj
T*
(represent the position of the light in the scene.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 5-6 )Tj
/F11 1 Tf
6.1 0 TD
(Moving a Light with Modeling Transformations: movelight.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include "glut.h")Tj
0 -3 TD
(static int spin = 0;)Tj
T*
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel \(GL_SMOOTH\);)Tj
T*
(   glEnable\(GL_LIGHTING\);)Tj
T*
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(})Tj
0 -3 TD
(/*  Here is where the light position is reset after the modeling)Tj
0 -1.5 TD
( *  transformation \(glRotated\) is called.  This places the)Tj
T*
( *  light at a new position in world coordinates.  The cube)Tj
T*
( *  represents the position of the light.)Tj
T*
( */)Tj
T*
(void display\(void\))Tj
T*
({)Tj
T*
(   GLfloat position[] = { 0.0, 0.0, 1.5, 1.0 };)Tj
0 -3 TD
(   glClear \(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glPushMatrix \(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 16)Tj
ET
endstream
endobj
560 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
562 0 obj
<<
/Length 1643
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glTranslatef \(0.0, 0.0, -5.0\);)Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(   glRotated \(\(GLdouble\) spin, 1.0, 0.0, 0.0\);)Tj
T*
(   glLightfv \(GL_LIGHT0, GL_POSITION, position\);)Tj
0 -3 TD
(   glTranslated \(0.0, 0.0, 1.5\);)Tj
0 -1.5 TD
(   glDisable \(GL_LIGHTING\);)Tj
T*
(   glColor3f \(0.0, 1.0, 1.0\);)Tj
T*
(   glutWireCube \(0.1\);)Tj
T*
(   glEnable \(GL_LIGHTING\);)Tj
T*
(   glPopMatrix \(\);)Tj
0 -3 TD
(   glutSolidTorus \(0.275, 0.85, 8, 15\);)Tj
0 -1.5 TD
(   glPopMatrix \(\);)Tj
T*
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluPerspective\(40.0, \(GLfloat\) w/\(GLfloat\) h, 1.0, 20.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void mouse\(int button, int state, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(button\) {)Tj
T*
(      case GLUT_LEFT_BUTTON:)Tj
T*
(         if \(state == GLUT_DOWN\) {)Tj
T*
(            spin = \(spin + 30\) % 360;)Tj
T*
(            glutPostRedisplay\(\);)Tj
T*
(         })Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
T*
(int main\(int argc, char** argv\))Tj
T*
({)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 17)Tj
ET
endstream
endobj
563 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
565 0 obj
<<
/Length 3103
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glutInit\(&argc, argv\);)Tj
0 -1.5 TD
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMouseFunc\(mouse\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
0 -3 TD
(Moving the Light Source Together with Your Viewpoint)Tj
/F11 1 Tf
0 -2.1 TD
(To create a light that moves along with the viewpoint, you need to set the light position before the)Tj
0 -1.5 TD
(viewing transformation. Then the viewing transformation affects both the light and the viewpoint in the)Tj
T*
(same way. Remember that the light position is stored in eye coordinates, and this is one of the few times)Tj
T*
[(when eye coordinates are critical. In )47(Example 5-7)170(, the light position is defined in )]TJ
/F15 1 Tf
32.6 0 TD
(init\(\))Tj
/F11 1 Tf
2 0 TD
(, which stores the)Tj
-34.6 -1.5 TD
(light position at \(0, 0, 0\) in eye coordinates. In other words, the light is shining from the lens of the)Tj
T*
(camera.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 5-7 )Tj
/F11 1 Tf
6.1 0 TD
(Light Source That Moves with the Viewpoint)Tj
/F7 1 Tf
-6.1 -2.4 TD
(GLfloat light_position\(\) = { 0.0, 0.0, 0.0, 1.0 };)Tj
0 -3 TD
(glViewport\(0, 0, \(GLint\) w, \(GLint\) h\);)Tj
0 -1.5 TD
(glMatrixMode\(GL_PROJECTION\);)Tj
T*
(glLoadIdentity\(\);)Tj
T*
(gluPerspective\(40.0, \(GLfloat\) w/\(GLfloat\) h, 1.0, 100.0\);)Tj
T*
(glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(glLoadIdentity\(\);)Tj
T*
(glLightfv\(GL_LIGHT0, GL_POSITION, light_position\);)Tj
/F11 1 Tf
0 -2.1 TD
(If the viewpoint is now moved, the light will move along with it, maintaining \(0, 0, 0\) distance, relative)Tj
0 -1.5 TD
[(to the eye. In the continuation of )-22(Example 5-7)]TJ
18.4 0 TD
(, which follows next, the global variables \()Tj
/F15 1 Tf
17.1 0 TD
(ex)Tj
/F11 1 Tf
0.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(ey)Tj
/F11 1 Tf
0.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(ez)Tj
/F11 1 Tf
0.8 0 TD
(\) and)Tj
-39.1 -1.5 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(upx)Tj
/F11 1 Tf
1.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(upy)Tj
/F11 1 Tf
1.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(upz)Tj
/F11 1 Tf
1.4 0 TD
(\) control the position of the viewpoint and up vector. The )Tj
/F15 1 Tf
23.2 0 TD
(display\(\))Tj
/F11 1 Tf
3.5 0 TD
( routine that's called)Tj
-32.3 -1.5 TD
(from the event loop to redraw the scene might be this:)Tj
/F7 1 Tf
0 -2.1 TD
(static GLdouble ex, ey, ez, upx, upy, upz;)Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(    glClear\(GL_COLOR_BUFFER_MASK | GL_DEPTH_BUFFER_MASK\);)Tj
T*
(    glPushMatrix\(\);)Tj
T*
(        gluLookAt \(ex, ey, ez, 0.0, 0.0, 0.0, upx, upy, upz\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 18)Tj
ET
endstream
endobj
566 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
568 0 obj
<<
/Length 4184
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(        glutSolidTorus \(0.275, 0.85, 8, 15\);)Tj
0 -1.5 TD
(    glPopMatrix\(\);)Tj
T*
(    glFlush\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(When the lit torus is redrawn, both the light position and the viewpoint are moved to the same location.)Tj
0 -1.5 TD
(As the values passed to )Tj
/F15 1 Tf
9.6 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
( change and the eye moves, the object will never appear dark,)Tj
-14.4 -1.5 TD
(because it is always being illuminated from the eye position. Even though you haven't respecified the)Tj
T*
(light position, the light moves because the eye coordinate system has changed.)Tj
0 -2.1 TD
(This method of moving the light can be very useful for simulating the illumination from a miner's hat.)Tj
0 -1.5 TD
(Another example would be carrying a candle or lantern. The light position specified by the call to)Tj
/F15 1 Tf
T*
(glLightfv)Tj
/F11 1 Tf
3.6 0 TD
(\(GL_LIGHTi, GL_POSITION, position\) would be the x, y, and z distance from the eye position)Tj
-3.6 -1.5 TD
(to the illumination source. Then as the eye position moves, the light will remain the same relative)Tj
T*
(distance away.)Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
0.050 Tw
[(Modify Example )50(5-6)]TJ
8.4 0 TD
0.000 Tw
( in the following manner:)Tj
/F33 1 Tf
-8.3 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Make the light translate past the object instead of rotating around it. Hint: Use )Tj
/F15 1 Tf
31.5 0 TD
(glTranslated\(\))Tj
/F11 1 Tf
5.7 0 TD
( rather)Tj
-37.2 -1.6 TD
(than the first )Tj
/F15 1 Tf
5.3 0 TD
(glRotated\(\))Tj
/F11 1 Tf
4.6 0 TD
( in )Tj
/F15 1 Tf
1.2 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
(, and choose an appropriate value to use instead of )Tj
/F15 1 Tf
20.4 0 TD
(spin)Tj
/F11 1 Tf
1.7 0 TD
(.)Tj
/F33 1 Tf
-38.6 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Change the attenuation so that the light decreases in intensity as it's moved away from the object.)Tj
0 -1.6 TD
(Hint: Add calls to )Tj
/F15 1 Tf
7.4 0 TD
(glLight*\(\))Tj
/F11 1 Tf
4 0 TD
( to set the desired attenuation parameters.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 362.000 Tm
(Selecting a Lighting Model)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 340.000 Tm
(The OpenGL notion of a lighting model has three components:)Tj
/F33 1 Tf
0.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The global ambient light intensity)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Whether the viewpoint position is local to the scene or whether it should be considered to be an)Tj
0 -1.6 TD
(infinite distance away)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Whether lighting calculations should be performed differently for both the front and back faces of)Tj
0 -1.6 TD
(objects)Tj
-1.9 -2.8 TD
(This section explains how to specify a lighting model. It also discusses how to enable lighting)Tj
/F33 1 Tf
37.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is,)Tj
-38.6 -1.6 TD
(how to tell OpenGL that you want lighting calculations performed.)Tj
0 -2.1 TD
(The command used to specify all properties of the lighting model is )Tj
/F15 1 Tf
27.3 0 TD
(glLightModel*\(\))Tj
/F11 1 Tf
6.6 0 TD
(. )Tj
/F15 1 Tf
0.5 0 TD
(glLightModel*\(\))Tj
/F11 1 Tf
-34.4 -1.5 TD
(has two arguments: the lighting model property and the desired value for that property.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glLightModel)46({if}\(GLenum )12(pname)-34(, )28(TYPE)34(param)11(\);)]TJ
0 -1.1 TD
0.000 Tw
[(void )-28(glLightModel)46({if})-44(v)44(\(GLenum )27(pname)-34(, TYPE)34( *)-50(param)11(\);)]TJ
1.8 -1.5 TD
(Sets properties of the lighting model. The characteristic of the lighting model being set is defined by)Tj
T*
[(pname)-34(, which specifies a named parameter \(see )77(Table 5-2)]TJ
23.3 0 TD
[(\). )33(param)11( indicates the values to which the)]TJ
-23.3 -1.5 TD
[(pname)-34( characteristic is set; it's a pointer to a group of values if the vector version is used, or the)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 19)Tj
ET
endstream
endobj
569 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
572 0 obj
<<
/Length 4301
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(value itself if the nonvector version is used. The nonvector version can be used to set only)Tj
0 -1.5 TD
(single-valued lighting model characteristics, not for GL_LIGHT_MODEL_AMBIENT.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 685.000 m
466.000 685.000 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 677.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Parameter Name)-13481(Default Value)-3664(Meaning)]TJ
ET
Q
124.000 671.480 m
466.000 671.480 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 663.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_LIGHT_MODEL_AMBIENT)-5056(\(0.2, 0.2, 0.2, 1.0\))-1722(ambient RGBA)]TJ
27.8889 -1.3333 TD
(intensity  of the entire)Tj
T*
(scene)Tj
-27.8889 -1.4444 TD
[(GL_LIGHT_MODEL_LOCAL_VIEWER)-1889(0.0 or GL_FALSE)-1416(how specular reflection)]TJ
27.8889 -1.3333 TD
(angles are computed)Tj
-27.8889 -1.4444 TD
[(GL_LIGHT_MODEL_TWO_SIDE)-4612(0.0 or GL_FALSE)-1416(choose between)]TJ
27.8889 -1.3333 TD
(one-sided or two-sided)Tj
T*
(lighting)Tj
ET
Q
124.000 569.820 m
466.010 569.820 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 554.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 5-2 )Tj
/F11 1 Tf
4.6 0 TD
(Default Values for pname Parameter of glLightModel*\(\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 525.000 Tm
(Global Ambient Light)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 503.000 Tm
(As discussed earlier, each light source can contribute ambient light to a scene. In addition, there can be)Tj
0 -1.5 TD
(other ambient light that's not from any particular source. To specify the RGBA intensity of such global)Tj
T*
(ambient light, use the GL_LIGHT_MODEL_AMBIENT parameter as follows:)Tj
/F7 1 Tf
0 -2 TD
(GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };)Tj
0 -1.5 TD
(glLightModelfv\(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient\);)Tj
/F11 1 Tf
0 -2.2 TD
(In this example, the values used for )Tj
/F15 1 Tf
14.4 0 TD
(lmodel_ambient)Tj
/F11 1 Tf
6.5 0 TD
( are the default values for)Tj
-20.9 -1.5 TD
(GL_LIGHT_MODEL_AMBIENT. Since these numbers yield a small amount of white ambient light,)Tj
T*
(even if you don't add a specific light source to your scene, you can still see the objects in the scene.)Tj
T*
[("Plate 14" in Appendix I)-28( shows the effect of different amounts of global ambient light.)]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 343.000 Tm
(Local or Infinite Viewpoint)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 321.000 Tm
(The location of the viewpoint affects the calculations for highlights produced by specular reflectance.)Tj
T*
(More specifically, the intensity of the highlight at a particular vertex depends on the normal at that)Tj
T*
(vertex, the direction from the vertex to the light source, and the direction from the vertex to the)Tj
T*
(viewpoint. Keep in mind that the viewpoint isn't actually being moved by calls to lighting commands)Tj
T*
[(\(you need to change the projection transformation, as described in )-8("Projection Transformations" in)]TJ
T*
[(Chapter 3)16(\); instead, different assumptions are made for the lighting calculations as if the viewpoint were)]TJ
T*
(moved.)Tj
0 -2.1 TD
(With an infinite viewpoint, the direction between it and any vertex in the scene remains constant. A local)Tj
0 -1.5 TD
(viewpoint tends to yield more realistic results, but since the direction has to be calculated for each vertex,)Tj
T*
(overall performance is decreased with a local viewpoint. By default, an infinite viewpoint is assumed.)Tj
T*
(Here's how to change to a local viewpoint:)Tj
/F7 1 Tf
0 -2.1 TD
(glLightModeli\(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE\);)Tj
/F11 1 Tf
T*
(This call places the viewpoint at \(0, 0, 0\) in eye coordinates. To switch back to an infinite viewpoint, pass)Tj
0 -1.5 TD
(in GL_FALSE as the argument.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 79.000 Tm
(Two-sided Lighting)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 20)Tj
ET
endstream
endobj
573 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
575 0 obj
<<
/Length 4466
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 706.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Lighting calculations are performed for all polygons, whether they're front-facing or back-facing. Since)Tj
0 -1.5 TD
(you usually set up lighting conditions with the front-facing polygons in mind, however, the back-facing)Tj
T*
[(ones typically aren't correctly illuminated. In )-40(Example 5-1)]TJ
23.5 0 TD
( where the object is a sphere, only the front)Tj
-23.5 -1.5 TD
(faces are ever seen, since they're the ones on the outside of the sphere. So, in this case, it doesn't matter)Tj
T*
(what the back-facing polygons look like. If the sphere is going to be cut away so that its inside surface)Tj
T*
(will be visible, however, you might want to have the inside surface be fully lit according to the lighting)Tj
T*
(conditions you've defined; you might also want to supply a different material description for the back)Tj
T*
(faces. When you turn on two-sided lighting with)Tj
/F7 1 Tf
0 -2.1 TD
(glLightModeli\(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE\);)Tj
/F11 1 Tf
T*
(OpenGL reverses the surface normals for back-facing polygons; typically, this means that the surface)Tj
0 -1.5 TD
(normals of visible back- and front-facing polygons face the viewer, rather than pointing away. As a)Tj
T*
(result, all polygons are illuminated correctly. However, these additional operations usually make)Tj
T*
(two-sided lighting perform more slowly than the default one-sided lighting.)Tj
0 -2.1 TD
(To turn two-sided lighting off, pass in GL_FALSE as the argument in the preceding call. \(See )Tj
37.8 0 TD
("Defining)Tj
-37.8 -1.5 TD
(Material Properties" for information about how to supply material properties for both faces.\) You can)Tj
T*
(also control which faces OpenGL considers to be front-facing with the command )Tj
/F15 1 Tf
32.7 0 TD
(glFrontFace\(\))Tj
/F11 1 Tf
5.7 0 TD
(. \(See)Tj
-38.4 -1.5 TD
[("Reversing and Culling Polygon Faces" in Chapter 2)24( for more information.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 419.000 Tm
(Enabling Lighting)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 397.000 Tm
(With OpenGL, you need to explicitly enable \(or disable\) lighting. If lighting isn't enabled, the current)Tj
T*
(color is simply mapped onto the current vertex, and no calculations concerning normals, light sources,)Tj
T*
(the lighting model, and material properties are performed. Here's how to enable lighting:)Tj
/F7 1 Tf
0 -2 TD
(glEnable\(GL_LIGHTING\);)Tj
/F11 1 Tf
0 -2.2 TD
(To disable lighting, call )Tj
/F15 1 Tf
9.8 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.5 0 TD
( with GL_LIGHTING as the argument.)Tj
-14.3 -2.1 TD
(You also need to explicitly enable each light source that you define, after you've specified the parameters)Tj
0 -1.5 TD
[(for that source. )-23(Example 5-1)]TJ
11.4 0 TD
( uses only one light, GL_LIGHT0:)Tj
/F7 1 Tf
-11.4 -2 TD
(glEnable\(GL_LIGHT0\); )Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 235.000 Tm
(Defining Material Properties)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 213.000 Tm
(You've seen how to create light sources with certain characteristics and how to define the desired)Tj
0 -1.5 TD
(lighting model. This section describes how to define the material properties of the objects in the scene:)Tj
T*
[(the ambient, diffuse, and specular colors, the shininess, and the color of any emitted light. \(See )-6("The)]TJ
T*
[(Mathematics of Lighting")-47( for the equations used in the lighting and material-property calculations.\) Most)]TJ
T*
(of the material properties are conceptually similar to ones you've already used to create light sources.)Tj
T*
(The mechanism for setting them is similar, except that the command used is called )Tj
/F15 1 Tf
33.3 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
(.)Tj
/F15 1 Tf
-38.7 -2.1 TD
[(void )-28(glMaterial)-22({if}\(GLenum )84(face)-34(, GLenum )-6(pname)-34(, TYPE)34(param)11(\);)]TJ
0 -1.1 TD
[(void )-28(glMaterial)-22({if})56(v)-56(\(GLenum )27(face)66(, GLenum )-6(pname)-34(, TYPE)34( *)-50(param)11(\);)]TJ
1.8 -1.5 TD
[(Specifies a current material property for use in lighting calculations. )-36(face)66( can be GL_FRONT,)]TJ
T*
(GL_BACK, or GL_FRONT_AND_BACK to indicate which face of the object the material should be)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 21)Tj
ET
endstream
endobj
576 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
578 0 obj
<<
/Length 5184
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(applied to. The particular material property being set is identified by )-8(pname)-34( and the desired values)]TJ
0 -1.5 TD
[(for that property are given by )11(param)11(, which is either a pointer to a group of values \(if the vector)]TJ
T*
(version is used\) or the actual value \(if the nonvector version is used\). The nonvector version works)Tj
T*
[(only for setting GL_SHININESS. The possible values for pname are shown in )-46(Table 5-3)]TJ
35.1 0 TD
(. Note that)Tj
-35.1 -1.5 TD
(GL_AMBIENT_AND_DIFFUSE allows you to set both the ambient and diffuse material colors)Tj
T*
(simultaneously to the same RGBA value.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 622.580 m
472.000 622.580 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 615.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Parameter Name)-10481(Default Value)-4289(Meaning)]TJ
ET
Q
124.000 609.060 m
472.000 609.060 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 601.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_AMBIENT)-9944(\(0.2, 0.2, 0.2, 1.0\))-2277(ambient color of material)]TJ
0 -1.4444 TD
[(GL_DIFFUSE)-10443(\(0.8, 0.8, 0.8, 1.0\))-2277(diffuse color of material)]TJ
T*
[(GL_AMBIENT_AND_DIFFUSE)-12166(ambient and diffuse color of)]TJ
25.7778 -1.3333 TD
(material)Tj
-25.7778 -1.4444 TD
[(GL_SPECULAR)-9387(\(0.0, 0.0, 0.0, 1.0\))-2277(specular color of material)]TJ
T*
[(GL_SHININESS)-9388(0.0)-8194(specular exponent)]TJ
T*
[(GL_EMISSION)-9777(\(0.0, 0.0, 0.0, 1.0\))-2277(emissive color of material)]TJ
T*
[(GL_COLOR_INDEXES)-6333(\(0,1,1\))-6778(ambient, diffuse, and specular)]TJ
25.7778 -1.3333 TD
(color indices)Tj
ET
Q
124.000 491.200 m
472.010 491.200 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 475.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 5-3 )Tj
/F11 1 Tf
4.6 0 TD
(Default Values for pname Parameter of glMaterial*\(\))Tj
-4.6 -2.1 TD
[(As discussed in )-27("Selecting a Lighting Model,")39(  you can choose to have lighting calculations performed)]TJ
0 -1.5 TD
(differently for the front- and back-facing polygons of objects. If the back faces might indeed be seen, you)Tj
T*
(can supply different material properties for the front and the back surfaces by using the )Tj
/F15 1 Tf
35.1 0 TD
(face)Tj
/F11 1 Tf
1.6 0 TD
( parameter of)Tj
/F15 1 Tf
-36.7 -1.5 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
[(. See )-6("Plate 14" in Appendix I)-28( for an example of an object drawn with different inside and)]TJ
-5.4 -1.5 TD
(outside material properties.)Tj
0 -2.1 TD
(To give you an idea of the possible effects you can achieve by manipulating material properties, see)Tj
0 -1.5 TD
[("Plate 16" in Appendix I)-28(.)0( This figure shows the same object drawn with several different sets of material)]TJ
T*
(properties. The same light source and lighting model are used for the entire figure. The sections that)Tj
T*
(follow discuss the specific properties used to draw each of these spheres.)Tj
0 -2.1 TD
(Note that most of the material properties set with )Tj
/F15 1 Tf
19.9 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
( are \(R, G, B, A\) colors. Regardless of)Tj
-25.3 -1.5 TD
(what alpha values are supplied for other parameters, the alpha value at any particular vertex is the)Tj
T*
(diffuse-material alpha value \(that is, the alpha value given to GL_DIFFUSE with the )Tj
/F15 1 Tf
34.2 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
-34.2 -1.5 TD
[(command, as described in the next section\). \(See )-24("Blending" in Chapter 6)-22( for a complete discussion of)]TJ
T*
[(alpha values.\) Also, none of the RGBA material properties apply in color-index mode. \(See )190("Lighting in)]TJ
T*
[(Color-Index Mode")211( for more information about what parameters are relevant in color-index mode.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 203.000 Tm
(Diffuse and Ambient Reflection)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 182.000 Tm
(The GL_DIFFUSE and GL_AMBIENT parameters set with )Tj
/F15 1 Tf
24.3 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
( affect the color of the diffuse)Tj
-29.7 -1.5 TD
(and ambient light reflected by an object. Diffuse reflectance plays the most important role in determining)Tj
T*
(what you perceive the color of an object to be. It's affected by the color of the incident diffuse light and)Tj
T*
(the angle of the incident light relative to the normal direction. \(It's most intense where the incident light)Tj
T*
(falls perpendicular to the surface.\) The position of the viewpoint doesn't affect diffuse reflectance at all.)Tj
0 -2.1 TD
(Ambient reflectance affects the overall color of the object. Because diffuse reflectance is brightest where)Tj
0 -1.5 TD
(an object is directly illuminated, ambient reflectance is most noticeable where an object receives no)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 22)Tj
ET
endstream
endobj
579 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
581 0 obj
<<
/Length 3975
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(direct illumination. An object's total ambient reflectance is affected by the global ambient light and)Tj
0 -1.5 TD
(ambient light from individual light sources. Like diffuse reflectance, ambient reflectance isn't affected by)Tj
T*
(the position of the viewpoint.)Tj
0 -2.1 TD
(For real-world objects, diffuse and ambient reflectance are normally the same color. For this reason,)Tj
0 -1.5 TD
(OpenGL provides you with a convenient way of assigning the same value to both simultaneously with)Tj
/F15 1 Tf
T*
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
(:)Tj
/F7 1 Tf
-5.4 -2.1 TD
(GLfloat mat_amb_diff[] = { 0.1, 0.5, 0.8, 1.0 };)Tj
0 -1.5 TD
(glMaterialfv\(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, )Tj
T*
(            mat_amb_diff\);)Tj
/F11 1 Tf
0 -2.2 TD
(In this example, the RGBA color \(0.1, 0.5, 0.8, 1.0\))Tj
/F33 1 Tf
20.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(a deep blue color)Tj
/F33 1 Tf
6.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(represents the current ambient)Tj
-29.5 -1.6 TD
(and diffuse reflectance for both the front- and back-facing polygons.)Tj
0 -2.1 TD
[(In )-17("Plate 16" in Appendix I)-28(,)0( the first row of spheres has no ambient reflectance \(0.0, 0.0, 0.0, 0.0\), and)]TJ
0 -1.5 TD
(the second row has a significant amount of it \(0.7, 0.7, 0.7, 1.0\).)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 476.000 Tm
(Specular Reflection)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 455.000 Tm
(Specular reflection from an object produces highlights. Unlike ambient and diffuse reflection, the amount)Tj
0 -1.6 TD
(of specular reflection seen by a viewer does depend on the location of the viewpoint)Tj
/F33 1 Tf
33.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(it's brightest along)Tj
-34.7 -1.6 TD
(the direct angle of reflection. To see this, imagine looking at a metallic ball outdoors in the sunlight. As)Tj
0 -1.5 TD
(you move your head, the highlight created by the sunlight moves with you to some extent. However, if)Tj
T*
(you move your head too much, you lose the highlight entirely.)Tj
0 -2.1 TD
(OpenGL allows you to set the effect that the material has on reflected light \(with GL_SPECULAR\) and)Tj
0 -1.5 TD
(control the size and brightness of the highlight \(with GL_SHININESS\). You can assign a number in the)Tj
0 -1.6 TD
(range of [0.0, 128.0] to GL_SHININESS)Tj
/F33 1 Tf
16.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the higher the value, the smaller and brighter \(more focused\))Tj
-17.4 -1.6 TD
[(the highlight. \(See )12("The Mathematics of Lighting")-34( for the details of how specular highlights are)]TJ
0 -1.5 TD
(calculated.\))Tj
0 -2.1 TD
[(In )-17("Plate 16" in Appendix I)-28(,)0( the spheres in the first column have no specular reflection. In the second)]TJ
0 -1.5 TD
(column, GL_SPECULAR and GL_SHININESS are assigned values as follows:)Tj
/F7 1 Tf
0 -2.1 TD
(GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
0 -1.5 TD
(GLfloat low_shininess[] = { 5.0 };)Tj
T*
(glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
T*
(glMaterialfv\(GL_FRONT, GL_SHININESS, low_shininess\);)Tj
/F11 1 Tf
0 -2.1 TD
(In the third column, the GL_SHININESS parameter is increased to 100.0.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 158.000 Tm
(Emission)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 137.000 Tm
(By specifying an RGBA color for GL_EMISSION, you can make an object appear to be giving off light)Tj
0 -1.5 TD
(of that color. Since most real-world objects \(except lights\) don't emit light, you'll probably use this)Tj
T*
[(feature mostly to simulate lamps and other light sources in a scene. In )-34("Plate 16" in Appendix I)72(,)0( the)]TJ
T*
(spheres in the fourth column have a reddish, grey value for GL_EMISSION:)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 23)Tj
ET
endstream
endobj
582 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
584 0 obj
<<
/Length 2918
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0};)Tj
0 -1.5 TD
(glMaterialfv\(GL_FRONT, GL_EMISSION, mat_emission\);)Tj
/F11 1 Tf
0 -2.1 TD
(Notice that the spheres appear to be slightly glowing; however, they're not actually acting as light)Tj
0 -1.5 TD
(sources. You would need to create a light source and position it at the same location as the sphere to)Tj
T*
(create that effect.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 617.000 Tm
(Changing Material Properties)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 595.000 Tm
(Example 5-1)Tj
5.1 0 TD
( uses the same material properties for all vertices of the only object in the scene \(the sphere\).)Tj
-5.1 -1.5 TD
(In other situations, you might want to assign different material properties for different vertices on the)Tj
T*
(same object. More likely, you have more than one object in the scene, and each object has different)Tj
T*
[(material properties. For example, the code that produced )-13("Plate 16" in Appendix I)-28( has to draw twelve)]TJ
T*
[(different objects \(all spheres\), each with different material properties. )23(Example 5-8)170( shows a portion of the)]TJ
T*
(code in )Tj
/F15 1 Tf
3.2 0 TD
(display\(\))Tj
/F11 1 Tf
3.5 0 TD
(.)Tj
/F27 1 Tf
-6.7 -2.1 TD
(Example 5-8 )Tj
/F11 1 Tf
6.1 0 TD
(Different Material Properties: material.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(   GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };)Tj
0 -1.5 TD
(   GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };)Tj
T*
(   GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 };)Tj
T*
(   GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 };)Tj
T*
(   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(   GLfloat no_shininess[] = { 0.0 };)Tj
T*
(   GLfloat low_shininess[] = { 5.0 };)Tj
T*
(   GLfloat high_shininess[] = { 100.0 };)Tj
T*
(   GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0};)Tj
0 -3 TD
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(/*  draw sphere in first row, first column)Tj
0 -1.5 TD
( *  diffuse reflection only; no ambient or specular  )Tj
T*
( */)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glTranslatef \(-3.75, 3.0, 0.0\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_AMBIENT, no_mat\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, mat_diffuse\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, no_mat\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SHININESS, no_shininess\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_EMISSION, no_mat\);)Tj
T*
(   glutSolidSphere\(1.0, 16, 16\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(/*  draw sphere in first row, second column)Tj
0 -1.5 TD
( *  diffuse and specular reflection; low shininess; no ambient)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 24)Tj
ET
endstream
endobj
585 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
587 0 obj
<<
/Length 2749
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
( */)Tj
0 -1.5 TD
(   glPushMatrix\(\);)Tj
T*
(   glTranslatef \(-1.25, 3.0, 0.0\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_AMBIENT, no_mat\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, mat_diffuse\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SHININESS, low_shininess\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_EMISSION, no_mat\);)Tj
T*
(   glutSolidSphere\(1.0, 16, 16\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(/*  draw sphere in first row, third column)Tj
0 -1.5 TD
( *  diffuse and specular reflection; high shininess; no ambient)Tj
T*
( */)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glTranslatef \(1.25, 3.0, 0.0\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_AMBIENT, no_mat\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, mat_diffuse\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SHININESS, high_shininess\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_EMISSION, no_mat\);)Tj
T*
(   glutSolidSphere\(1.0, 16, 16\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(/*  draw sphere in first row, fourth column)Tj
0 -1.5 TD
( *  diffuse reflection; emission; no ambient or specular refl.)Tj
T*
( */)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glTranslatef \(3.75, 3.0, 0.0\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_AMBIENT, no_mat\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, mat_diffuse\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, no_mat\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SHININESS, no_shininess\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_EMISSION, mat_emission\);)Tj
T*
(   glutSolidSphere\(1.0, 16, 16\);)Tj
T*
(   glPopMatrix\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(As you can see, )Tj
/F15 1 Tf
6.5 0 TD
(glMaterialfv\(\))Tj
/F11 1 Tf
5.7 0 TD
( is called repeatedly to set the desired material property for each sphere.)Tj
-12.2 -1.5 TD
(Note that it only needs to be called to change a property that needs to be respecified. The second, third,)Tj
T*
(and fourth spheres use the same ambient and diffuse properties as the first sphere, so these properties do)Tj
T*
(not need to be respecified. Since )Tj
/F15 1 Tf
13.2 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.5 0 TD
[( has a performance cost associated with its use, )9(Example)]TJ
-18.7 -1.5 TD
(5-8)Tj
1.3 0 TD
( could be rewritten to minimize material-property changes.)Tj
-1.3 -2.1 TD
(Another technique for minimizing performance costs associated with changing material properties is to)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 25)Tj
ET
endstream
endobj
588 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
590 0 obj
<<
/Length 4162
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(use )Tj
/F15 1 Tf
1.6 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
7.3 0 TD
0.000 Tw
(.)Tj
/F15 1 Tf
-8.9 -2.1 TD
0.028 Tw
[(void glColorMaterial)13(\(GLenum )55(face)-34(, )28(GLenum )22(mode)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Causes the material property \(or properties\) specified by )12(mode)-34( of the specified material face \(or)]TJ
T*
[(faces\) specified by )38(face)-34( to track the value of the current color at all times. A change to the current)]TJ
T*
[(color \(using )12(glColor*\(\))-22(\) immediately updates the specified material properties. The )62(face)-34( parameter)]TJ
T*
[(can be GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK \(the default\). The )27(mode)-34( parameter can)]TJ
T*
(be GL_AMBIENT, GL_DIFFUSE, GL_AMBIENT_AND_DIFFUSE \(the default\), GL_SPECULAR,)Tj
T*
[(or GL_EMISSION. At any given time, only one mode is active. )-23(glColorMaterial\(\))-21( has no effect on)]TJ
T*
(color-index lighting.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(Note that )Tj
/F15 1 Tf
3.9 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
7.3 0 TD
( specifies two independent values: the first specifies which face or faces are)Tj
-11.2 -1.5 TD
(updated, and the second specifies which material property or properties of those faces are updated.)Tj
T*
(OpenGL does )Tj
/F15 1 Tf
5.8 0 TD
(not)Tj
/F11 1 Tf
1.3 0 TD
( maintain separate )Tj
/F15 1 Tf
7.5 0 TD
(mode)Tj
/F11 1 Tf
2.2 0 TD
( variables for each face.)Tj
-16.8 -2.1 TD
(After calling )Tj
/F15 1 Tf
5.3 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
7.3 0 TD
(, you need to call )Tj
/F15 1 Tf
7.1 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( with GL_COLOR_MATERIAL as the)Tj
-24 -1.5 TD
(parameter. Then, you can change the current color using )Tj
/F15 1 Tf
22.8 0 TD
(glColor*\(\))Tj
/F11 1 Tf
4.3 0 TD
( \(or other material properties, using)Tj
/F15 1 Tf
-27.1 -1.5 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
(\) as needed as you draw:)Tj
/F7 1 Tf
-5.4 -2.1 TD
(glEnable\(GL_COLOR_MATERIAL\);)Tj
0 -1.5 TD
(glColorMaterial\(GL_FRONT, GL_DIFFUSE\);)Tj
T*
(/* now glColor* changes diffuse reflection  */)Tj
T*
(glColor3f\(0.2, 0.5, 0.8\);)Tj
T*
(/* draw some objects here */)Tj
T*
(glColorMaterial\(GL_FRONT, GL_SPECULAR\);)Tj
T*
(/* glColor* no longer changes diffuse reflection  */)Tj
T*
(/* now glColor* changes specular reflection  */)Tj
T*
(glColor3f\(0.9, 0.0, 0.2\);)Tj
T*
(/* draw other objects here */)Tj
T*
(glDisable\(GL_COLOR_MATERIAL\);)Tj
/F11 1 Tf
0 -2.1 TD
(You should use )Tj
/F15 1 Tf
6.5 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
7.3 0 TD
( whenever you need to change a single material parameter for most)Tj
-13.8 -1.5 TD
[(vertices in your scene. If you need to change more than one material parameter, as was the case for )54("Plate)]TJ
T*
[(16" in Appendix I)14(,)0( use )]TJ
/F15 1 Tf
9.3 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
(. When you don't need the capabilities of )Tj
/F15 1 Tf
16.8 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
-31.5 -1.5 TD
(anymore, be sure to disable it so that you don't get undesired material properties and don't incur the)Tj
T*
(performance cost associated with it. The performance value in using )Tj
/F15 1 Tf
27.6 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
7.3 0 TD
( varies, depending)Tj
-34.9 -1.5 TD
(on your OpenGL implementation. Some implementations may be able to optimize the vertex routines so)Tj
T*
(that they can quickly update material properties based on the current color.)Tj
0 -2.1 TD
(Example 5-9)Tj
5.1 0 TD
( shows an interactive program that uses )Tj
/F15 1 Tf
16.1 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
7.2 0 TD
( to change material parameters.)Tj
-28.4 -1.5 TD
(Pressing each of the three mouse buttons changes the color of the diffuse reflection.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 5-9 )Tj
/F11 1 Tf
6.1 0 TD
(Using glColorMaterial\(\): colormat.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include "glut.h")Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 26)Tj
ET
endstream
endobj
591 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
593 0 obj
<<
/Length 1858
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(GLfloat diffuseMaterial[4] = { 0.5, 0.5, 0.5, 1.0 };)Tj
0 -3 TD
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(   GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };)Tj
0 -3 TD
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glShadeModel \(GL_SMOOTH\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, diffuseMaterial\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
T*
(   glMaterialf\(GL_FRONT, GL_SHININESS, 25.0\);)Tj
T*
(   glLightfv\(GL_LIGHT0, GL_POSITION, light_position\);)Tj
T*
(   glEnable\(GL_LIGHTING\);)Tj
T*
(   glEnable\(GL_LIGHT0\);)Tj
0 -3 TD
(   glColorMaterial\(GL_FRONT, GL_DIFFUSE\);)Tj
0 -1.5 TD
(   glEnable\(GL_COLOR_MATERIAL\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glutSolidSphere\(1.0, 20, 16\);)Tj
T*
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport \(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho \(-1.5, 1.5, -1.5*\(GLfloat\)h/\(GLfloat\)w,)Tj
T*
(         1.5*\(GLfloat\)h/\(GLfloat\)w, -10.0, 10.0\);)Tj
T*
(   else)Tj
T*
(      glOrtho \(-1.5*\(GLfloat\)w/\(GLfloat\)h,)Tj
T*
(         1.5*\(GLfloat\)w/\(GLfloat\)h, -1.5, 1.5, -10.0, 10.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 27)Tj
ET
endstream
endobj
594 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
596 0 obj
<<
/Length 1960
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void mouse\(int button, int state, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(button\) {)Tj
T*
(      case GLUT_LEFT_BUTTON:)Tj
T*
(         if \(state == GLUT_DOWN\) {       /*  change red  */)Tj
T*
(            diffuseMaterial[0] += 0.1;)Tj
T*
(            if \(diffuseMaterial[0] > 1.0\))Tj
T*
(               diffuseMaterial[0] = 0.0;)Tj
T*
(            glColor4fv\(diffuseMaterial\);)Tj
T*
(            glutPostRedisplay\(\);)Tj
T*
(         })Tj
T*
(         break;)Tj
T*
(      case GLUT_MIDDLE_BUTTON:)Tj
T*
(         if \(state == GLUT_DOWN\) {       /*  change green  */)Tj
T*
(            diffuseMaterial[1] += 0.1;)Tj
T*
(            if \(diffuseMaterial[1] > 1.0\))Tj
T*
(               diffuseMaterial[1] = 0.0;)Tj
T*
(            glColor4fv\(diffuseMaterial\);)Tj
T*
(            glutPostRedisplay\(\);)Tj
T*
(         })Tj
T*
(         break;)Tj
T*
(      case GLUT_RIGHT_BUTTON:)Tj
T*
(         if \(state == GLUT_DOWN\) {      /*  change blue  */)Tj
T*
(            diffuseMaterial[2] += 0.1;)Tj
T*
(            if \(diffuseMaterial[2] > 1.0\))Tj
T*
(               diffuseMaterial[2] = 0.0;)Tj
T*
(            glColor4fv\(diffuseMaterial\);)Tj
T*
(            glutPostRedisplay\(\);)Tj
T*
(         })Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize \(500, 500\); )Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 28)Tj
ET
endstream
endobj
597 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
599 0 obj
<<
/Length 4278
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glutDisplayFunc\(display\); )Tj
0 -1.5 TD
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMouseFunc\(mouse\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
0.050 Tw
[(Modify Example )50(5-8)]TJ
8.4 0 TD
0.000 Tw
( in the following manner:)Tj
/F33 1 Tf
-8.3 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Change the global ambient light in the scene. Hint: Alter the value of the)Tj
0 -1.6 TD
(GL_LIGHT_MODEL_AMBIENT parameter.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Change the diffuse, ambient, and specular reflection parameters, the shininess exponent, and the)Tj
0 -1.6 TD
(emission color. Hint: Use the )Tj
/F15 1 Tf
11.9 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.5 0 TD
( command, but avoid making excessive calls.)Tj
/F33 1 Tf
-19.2 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use two-sided materials and add a user-defined clipping plane so that you can see the inside and)Tj
0 -1.6 TD
[(outside of a row or column of spheres. \(See )-35("Additional Clipping Planes" in Chapter 3, if you need)]TJ
0 -1.5 TD
(to recall user-defined clipping planes.\) Hint: Turn on two-sided lighting with)Tj
T*
(GL_LIGHT_MODEL_TWO_SIDE, set the desired material properties, and add a clipping plane.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Remove all the )Tj
/F15 1 Tf
6.3 0 TD
(glMaterialfv\(\))Tj
/F11 1 Tf
5.7 0 TD
( calls, and use the more efficient )Tj
/F15 1 Tf
13.2 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
7.3 0 TD
( calls to achieve the)Tj
-32.5 -1.6 TD
(same lighting.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 373.000 Tm
(The Mathematics of Lighting)Tj
10.000 0.000 0.000 10.000 204.000 350.000 Tm
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(This section presents the equations used by OpenGL to perform lighting calculations to determine colors)Tj
0 -1.5 TD
[(when in RGBA mode. \(See )22("The Mathematics of Color-Index Mode Lighting")219( for corresponding)]TJ
T*
(calculations for color-index mode.\) You don't need to read this section if you're willing to experiment to)Tj
T*
(obtain the lighting conditions you want. Even after reading this section, you'll probably have to)Tj
T*
(experiment, but you'll have a better idea of how the values of parameters affect a vertex's color.)Tj
T*
(Remember that if lighting is not enabled, the color of a vertex is simply the current color; if it is enabled,)Tj
T*
(the lighting computations described here are carried out in eye coordinates.)Tj
0 -2.1 TD
(In the following equations, mathematical operations are performed separately on the R, G, and B)Tj
0 -1.5 TD
(components. Thus, for example, when three terms are shown as added together, the R values, the G)Tj
T*
(values, and the B values for each term are separately added to form the final RGB color \(R)Tj
36.3 -0.2 TD
(1)Tj
0.5 0.2 TD
(+R)Tj
1.3 -0.2 TD
(2)Tj
0.5 0.2 TD
(+R)Tj
1.2 -0.2 TD
(3)Tj
0.5 0.2 TD
(,)Tj
-40.3 -1.7 TD
(G)Tj
0.7 -0.2 TD
(1)Tj
0.5 0.2 TD
(+G)Tj
1.3 -0.2 TD
(2)Tj
0.5 0.2 TD
(+G)Tj
1.3 -0.2 TD
(3)Tj
0.5 0.2 TD
(, B)Tj
1.2 -0.2 TD
(1)Tj
0.5 0.2 TD
(+B)Tj
1.2 -0.2 TD
(2)Tj
0.5 0.2 TD
(+B)Tj
1.2 -0.2 TD
(3)Tj
0.5 0.2 TD
(\). When three terms are multiplied, the calculation is \(R)Tj
22.3 -0.2 TD
(1)Tj
0.5 0.2 TD
(R)Tj
0.7 -0.2 TD
(2)Tj
0.5 0.2 TD
(R)Tj
0.7 -0.2 TD
(3)Tj
0.5 0.2 TD
(, G)Tj
1.2 -0.2 TD
(1)Tj
0.5 0.2 TD
(G)Tj
0.7 -0.2 TD
(2)Tj
0.5 0.2 TD
(G)Tj
0.7 -0.2 TD
(3)Tj
0.5 0.2 TD
(,)Tj
-39.2 -1.7 TD
(B)Tj
0.7 -0.2 TD
(1)Tj
0.5 0.2 TD
(B)Tj
0.6 -0.2 TD
(2)Tj
0.5 0.2 TD
(B)Tj
0.7 -0.2 TD
(3)Tj
0.5 0.2 TD
(\). \(Remember that the final A or alpha component at a vertex is equal to the material's diffuse)Tj
-3.5 -1.7 TD
(alpha value at that vertex.\))Tj
0 -2.1 TD
(The color produced by lighting a vertex is computed as follows:)Tj
T*
[(vertex color = )-2131(the material emission at that vertex +   )-8(the global ambient light scaled by the)]TJ
8 -1.5 TD
[(material's ambient property at that vertex   +   )46(the ambient, diffuse, and specular)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 29)Tj
ET
endstream
endobj
600 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
602 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im61
/Width 263
/Height 58
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.60)
>>
stream
endstream
endobj
604 0 obj
<<
/Length 3214
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 204.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(contributions from all the light sources, properly attenuated)Tj
-8 -2.1 TD
(After lighting calculations are performed, the color values are clamped \(in RGBA mode\) to the range)Tj
0 -1.5 TD
([0,1].)Tj
0 -2.1 TD
(Note that OpenGL lighting calculations don't take into account the possibility of one object blocking)Tj
0 -1.5 TD
[(light from another; as a result shadows aren't automatically created. \(See )42("Shadows" in Chapter 14)-78( for a)]TJ
T*
(technique to create shadows.\) Also keep in mind that with OpenGL, illuminated objects don't radiate)Tj
T*
(light onto other objects.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 580.000 Tm
(Material Emission)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 559.000 Tm
(The material emission term is the simplest. It's the RGB value assigned to the GL_EMISSION)Tj
T*
(parameter.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 515.000 Tm
(Scaled Global Ambient Light)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 493.000 Tm
(The second term is computed by multiplying the global ambient light \(as defined by the)Tj
T*
(GL_LIGHT_MODEL_AMBIENT parameter\) by the material's ambient property \(GL_AMBIENT value)Tj
T*
(as assigned with )Tj
/F15 1 Tf
6.8 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
(\):)Tj
-12.2 -2.1 TD
(ambient)Tj
3.2 -0.2 TD
(light model )Tj
4.9 0.2 TD
(* ambient)Tj
3.9 -0.2 TD
(material)Tj
-12 -2.1 TD
(Each of the R, G, and B values for these two parameters are multiplied separately to compute the final)Tj
0 -1.5 TD
(RGB value for this term: \(R)Tj
11.2 -0.2 TD
(1)Tj
0.5 0.2 TD
(R)Tj
0.7 -0.2 TD
(2)Tj
0.5 0.2 TD
(, G)Tj
1.2 -0.2 TD
(1)Tj
0.5 0.2 TD
(G)Tj
0.7 -0.2 TD
(2)Tj
0.5 0.2 TD
(, B)Tj
1.2 -0.2 TD
(1)Tj
0.5 0.2 TD
(B)Tj
0.6 -0.2 TD
(2)Tj
0.5 0.2 TD
(\).)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 374.000 Tm
(Contributions from Light Sources)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 352.000 Tm
(Each light source may contribute to a vertex's color, and these contributions are added together. The)Tj
0 -1.5 TD
(equation for computing each light source's contribution is as follows:)Tj
0 -2.1 TD
(contribution = attenuation factor * spotlight effect *)Tj
T*
(\(ambient term + diffuse term + specular term\))Tj
/F27 1 Tf
0 -3 TD
(Attenuation Factor)Tj
/F11 1 Tf
0 -2.1 TD
(The )Tj
/F15 1 Tf
1.8 0 TD
(attenuation factor)Tj
/F11 1 Tf
7.2 0 TD
[( was described in )-34("Position and Attenuation")62(:)]TJ
ET
Q
/GS1 gs
q
263 0 0 58 124 172.03 cm
/Im61 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 153.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(where)Tj
/F15 1 Tf
0 -2.1 TD
0.000 Tw
(d)Tj
/F11 1 Tf
0.5 0 TD
( = distance between the light's position and the vertex)Tj
/F15 1 Tf
-0.5 -2.1 TD
(k)Tj
/F11 1 Tf
0.4 -0.2 TD
(c)Tj
0.5 0.2 TD
( = GL_CONSTANT_ATTENUATION)Tj
/F15 1 Tf
-0.9 -2.3 TD
(k)Tj
/F11 1 Tf
0.4 -0.2 TD
(l)Tj
0.3 0.2 TD
( = GL_LINEAR_ATTENUATION)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 30)Tj
ET
endstream
endobj
605 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im61 602 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
607 0 obj
<<
/Length 4465
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(k)Tj
/F11 1 Tf
0.4 -0.2 TD
(q)Tj
0.5 0.2 TD
( = GL_QUADRATIC_ATTENUATION)Tj
-0.9 -2.3 TD
(If the light is a directional one, the attenuation factor is 1.)Tj
/F27 1 Tf
0 -3 TD
(Spotlight Effect)Tj
/F11 1 Tf
0 -2.1 TD
(The )Tj
/F15 1 Tf
1.8 0 TD
(spotlight effect)Tj
/F11 1 Tf
5.9 0 TD
( evaluates to one of three possible values, depending on whether the light is actually a)Tj
-7.7 -1.5 TD
(spotlight and whether the vertex lies inside or outside the cone of illumination produced by the spotlight:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(1 if the light isn't a spotlight \(GL_SPOT_CUTOFF is 180.0\))Tj
/F15 1 Tf
24.3 0 TD
(.)Tj
/F33 1 Tf
-26.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(0 if the light is a spotlight, but the vertex lies outside the cone of illumination produced by the)Tj
0 -1.6 TD
(spotlight.)Tj
/F33 1 Tf
-1.8 -2.4 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(\(max {)Tj
/F15 1 Tf
2.8 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( \267 )Tj
/F15 1 Tf
0.9 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
(, 0}\))Tj
1.8 0.3 TD
(GL_SPOT_EXPONENT)Tj
10 -0.3 TD
( where:)Tj
/F15 1 Tf
-16.4 -2.1 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( = \()Tj
/F15 1 Tf
1.4 0 TD
(v)Tj
/F11 1 Tf
0.5 -0.2 TD
(x)Tj
/F15 1 Tf
0.5 0.2 TD
(, v)Tj
/F11 1 Tf
0.9 -0.2 TD
(y)Tj
/F15 1 Tf
0.5 0.2 TD
(, v)Tj
/F11 1 Tf
1 -0.2 TD
(z)Tj
0.4 0.2 TD
(\) is the unit vector that points from the spotlight \(GL_POSITION\) to the vertex.)Tj
/F15 1 Tf
-5.6 -2.3 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
( = \()Tj
/F15 1 Tf
1.4 0 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(x)Tj
/F15 1 Tf
0.5 0.2 TD
(, d)Tj
/F11 1 Tf
1 -0.2 TD
(y)Tj
/F15 1 Tf
0.5 0.2 TD
(, d)Tj
/F11 1 Tf
1 -0.2 TD
(z)Tj
0.4 0.2 TD
(\) is the spotlight's direction \(GL_SPOT_DIRECTION\), assuming the light is a)Tj
-5.8 -1.7 TD
(spotlight and the vertex lies inside the cone of illumination produced by the spotlight.)Tj
0 -2.1 TD
(The dot product of the two vectors )Tj
/F15 1 Tf
14.1 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
( varies as the cosine of the angle between them; hence,)Tj
-17 -1.5 TD
(objects directly in line get maximum illumination, and objects off the axis have their illumination)Tj
T*
(drop as the cosine of the angle.)Tj
-1.9 -2.7 TD
(To determine whether a particular vertex lies within the cone of illumination, OpenGL evaluates \(max {)Tj
/F15 1 Tf
41.6 0 TD
(v)Tj
/F11 1 Tf
-41.6 -1.5 TD
(\267 )Tj
/F15 1 Tf
0.6 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
(, 0}\) where )Tj
/F15 1 Tf
4.8 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
( are as defined in the preceding discussion. If this value is less than the cosine of)Tj
-8.7 -1.5 TD
(the spotlight's cutoff angle \(GL_SPOT_CUTOFF\), then the vertex lies outside the cone; otherwise, it's)Tj
T*
(inside the cone.)Tj
/F27 1 Tf
0 -3 TD
(Ambient Term)Tj
/F11 1 Tf
0 -2.1 TD
(The ambient term is simply the ambient color of the light scaled by the ambient material property:)Tj
T*
(ambient)Tj
3.2 -0.2 TD
(light)Tj
1.9 0.2 TD
( *ambient)Tj
3.9 -0.2 TD
(material)Tj
/F27 1 Tf
-9 -3 TD
(Diffuse Term)Tj
/F11 1 Tf
0 -2.1 TD
(The diffuse term needs to take into account whether light falls directly on the vertex, the diffuse color of)Tj
0 -1.5 TD
(the light, and the diffuse material property:)Tj
0 -2.1 TD
(\(max {)Tj
/F15 1 Tf
2.8 0 TD
(L)Tj
/F11 1 Tf
0.5 0 TD
( \267 )Tj
/F15 1 Tf
0.9 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(, 0}\) * diffuse)Tj
5.6 -0.2 TD
(light)Tj
1.8 0.2 TD
( * diffuse)Tj
3.8 -0.2 TD
(material)Tj
-15.9 -2.1 TD
(where:)Tj
/F15 1 Tf
T*
(L)Tj
/F11 1 Tf
0.6 0 TD
( = \()Tj
/F15 1 Tf
1.4 0 TD
(L)Tj
/F11 1 Tf
0.5 -0.2 TD
(x)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(L)Tj
/F11 1 Tf
0.6 -0.2 TD
(y)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(L)Tj
/F11 1 Tf
0.5 -0.2 TD
(z)Tj
0.5 0.2 TD
(\) is the unit vector that points from the vertex to the light position \(GL_POSITION\).)Tj
/F15 1 Tf
-6.1 -2.3 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( = \()Tj
/F15 1 Tf
1.4 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(x)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(y)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(z)Tj
0.4 0.2 TD
(\) is the unit normal vector at the vertex.)Tj
/F27 1 Tf
-5.8 -3.2 TD
(Specular Term)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 31)Tj
ET
endstream
endobj
608 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
609 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im62
/Width 294
/Height 70
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.61)
>>
stream
endstream
endobj
611 0 obj
<<
/Length 4138
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The specular term also depends on whether light falls directly on the vertex. If )Tj
/F13 1 Tf
31.6 0 TD
(L)Tj
/F11 1 Tf
0.6 0 TD
( \267 )Tj
/F13 1 Tf
0.9 0 TD
(n)Tj
/F11 1 Tf
0.6 0 TD
( is less than or equal)Tj
-33.7 -1.5 TD
(to zero, there is no specular component at the vertex. \(If it's less than zero, the light is on the wrong side)Tj
T*
(of the surface.\) If there's a specular component, it depends on the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The unit normal vector at the vertex \()Tj
/F15 1 Tf
15 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(x)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(y)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(z)Tj
0.4 0.2 TD
(\).)Tj
/F33 1 Tf
-20.7 -2.5 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The sum of the two unit vectors that point between \(1\) the vertex and the light position \(or light)Tj
0 -1.5 TD
(direction\) and \(2\) the vertex and the viewpoint \(assuming that)Tj
T*
(GL_LIGHT_MODEL_LOCAL_VIEWER is true; if it's not true, the vector \(0, 0, 1\) is used as the)Tj
T*
(second vector in the sum\). This vector sum is normalized \(by dividing each component by the)Tj
T*
(magnitude of the vector\) to yield )Tj
/F15 1 Tf
13.4 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( = \()Tj
/F15 1 Tf
1.4 0 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(x)Tj
0.5 0.2 TD
(, s)Tj
0.9 -0.2 TD
(y)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(s)Tj
/F11 1 Tf
0.3 -0.2 TD
(z)Tj
0.5 0.2 TD
(\).)Tj
/F33 1 Tf
-20.6 -2.4 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The specular exponent \(GL_SHININESS\).)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The specular color of the light \(GL_SPECULAR)Tj
19.6 -0.2 TD
(light)Tj
1.8 0.2 TD
(\).)Tj
/F33 1 Tf
-23.2 -2.4 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The specular property of the material \(GL_SPECULAR)Tj
22.4 -0.2 TD
(material\))Tj
3.6 0.2 TD
(.)Tj
-27.9 -2.9 TD
(Using these definitions, here's how OpenGL calculates the specular term:)Tj
0 -2.4 TD
(\(max {)Tj
/F15 1 Tf
2.8 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( \267 )Tj
/F15 1 Tf
0.8 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(, 0}\))Tj
1.8 0.3 TD
(shininess)Tj
3.7 -0.3 TD
( * specular)Tj
4.3 -0.2 TD
(light)Tj
1.9 0.2 TD
( * specular)Tj
4.3 -0.2 TD
(material)Tj
-20.5 -2.1 TD
(However, if )Tj
/F15 1 Tf
5 0 TD
(L)Tj
/F11 1 Tf
0.6 0 TD
( \267 )Tj
/F15 1 Tf
0.8 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( = 0, the specular term is 0.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 398.000 Tm
(Putting It All Together)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 376.000 Tm
(Using the definitions of terms described in the preceding paragraphs, the following represents the entire)Tj
0 -1.5 TD
(lighting calculation in RGBA mode:)Tj
0 -2.1 TD
(vertex color = emissionmaterial +)Tj
T*
(ambientlight model * ambientmaterial +)Tj
ET
Q
/GS1 gs
q
294 0 0 70 124 235.1 cm
/Im62 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 216.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
([ambientlight *ambientmaterial +)Tj
0 -2.1 TD
(\(max { )Tj
/F15 1 Tf
3 0 TD
(L)Tj
/F11 1 Tf
0.6 0 TD
( \267)Tj
/F15 1 Tf
0.6 0 TD
( n)Tj
/F11 1 Tf
0.7 0 TD
( , 0} \) * diffuselight * diffusematerial +)Tj
-4.9 -2.4 TD
(\(max { )Tj
/F15 1 Tf
3 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( \267)Tj
/F15 1 Tf
0.6 0 TD
( n)Tj
/F11 1 Tf
0.8 0 TD
( , 0} \))Tj
2.3 0.3 TD
(shininess)Tj
3.7 -0.3 TD
( * specularlight * specularmaterial ] i)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 138.000 Tm
(Lighting in Color-Index Mode)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 116.000 Tm
(In color-index mode, the parameters comprising RGBA values either have no effect or have a special)Tj
0 -1.5 TD
(interpretation. Since it's much harder to achieve certain effects in color-index mode, you should use)Tj
T*
(RGBA whenever possible. In fact, the only light-source, lighting-model, or material parameters in an)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 32)Tj
ET
endstream
endobj
612 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im62 609 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
614 0 obj
<<
/Length 4967
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(RGBA form that are used in color-index mode are the light-source parameters GL_DIFFUSE and)Tj
0 -1.5 TD
(GL_SPECULAR and the material parameter GL_SHININESS. GL_DIFFUSE and GL_SPECULAR \()Tj
/F15 1 Tf
40.9 0 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(l)Tj
-41.4 -1.5 TD
(and)Tj
/F15 1 Tf
1.4 0 TD
( s)Tj
/F11 1 Tf
0.7 -0.2 TD
(l)Tj
0.3 0.2 TD
(, respectively\) are used to compute color-index diffuse and specular light intensities \()Tj
/F15 1 Tf
34 0 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(ci)Tj
0.8 0.2 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(ci)Tj
0.7 0.2 TD
(\) as)Tj
-40.7 -1.7 TD
(follows:)Tj
/F15 1 Tf
0 -2.1 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(ci)Tj
0.7 0.2 TD
( = 0.30 R\()Tj
/F15 1 Tf
4.1 0 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(l)Tj
0.3 0.2 TD
(\) + 0.59 G\()Tj
/F15 1 Tf
4.4 0 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(l)Tj
0.3 0.2 TD
(\) + 0.11 B\()Tj
/F15 1 Tf
4.4 0 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(l)Tj
0.3 0.2 TD
(\))Tj
/F15 1 Tf
-16.5 -2.3 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(ci)Tj
0.7 0.2 TD
( = 0.30 R\()Tj
/F15 1 Tf
4.1 0 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(l)Tj
0.2 0.2 TD
(\) + 0.59 G\()Tj
/F15 1 Tf
4.5 0 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(l)Tj
0.3 0.2 TD
(\) + 0.11 B\()Tj
/F15 1 Tf
4.4 0 TD
(s)Tj
/F11 1 Tf
0.3 -0.2 TD
(l)Tj
0.3 0.2 TD
(\))Tj
-16 -2.3 TD
(where R\()Tj
/F15 1 Tf
3.7 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(\), G\()Tj
/F15 1 Tf
1.9 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(\), and B\()Tj
/F15 1 Tf
3.5 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(\) refer to the red, green, and blue components, respectively, of color )Tj
/F15 1 Tf
27.5 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(. The)Tj
-38.3 -1.5 TD
(weighting values 0.30, 0.59, and 0.11 reflect the "perceptual" weights that red, green, and blue have for)Tj
0 -1.6 TD
(your eye)Tj
/F33 1 Tf
3.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(your eye is most sensitive to green and least sensitive to blue.)Tj
-4.5 -2.2 TD
(To specify material colors in color-index mode, use )Tj
/F15 1 Tf
20.9 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.5 0 TD
( with the special parameter)Tj
-26.4 -1.5 TD
(GL_COLOR_INDEXES, as follows:)Tj
/F7 1 Tf
0 -2.1 TD
(GLfloat mat_colormap[] = { 16.0, 47.0, 79.0 };)Tj
0 -1.5 TD
(glMaterialfv\(GL_FRONT, GL_COLOR_INDEXES, mat_colormap\);)Tj
/F11 1 Tf
0 -2.1 TD
(The three numbers supplied for GL_COLOR_INDEXES specify the color indices for the ambient,)Tj
0 -1.5 TD
(diffuse, and specular material colors, respectively. In other words, OpenGL regards the color associated)Tj
T*
(with the first index \(16.0 in this example\) as the pure ambient color, with the second index \(47.0\) as the)Tj
T*
(pure diffuse color, and with the third index \(79.0\) as the pure specular color. \(By default, the ambient)Tj
T*
(color index is 0.0, and the diffuse and specular color indices are both 1.0. Note that )Tj
/F15 1 Tf
33.5 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
-33.5 -1.5 TD
(has no effect on color-index lighting.\))Tj
0 -2.1 TD
(As it draws a scene, OpenGL uses colors associated with indices in between these numbers to shade)Tj
0 -1.5 TD
(objects in the scene. Therefore, you must build a color ramp between the indicated indices \(in this)Tj
T*
(example, between indices 16 and 47, and then between 47 and 79\). Often, the color ramp is built)Tj
T*
(smoothly, but you might want to use other formulations to achieve different effects. Here's an example)Tj
T*
(of a smooth color ramp that starts with a black ambient color and goes through a magenta diffuse color to)Tj
T*
(a white specular color:)Tj
/F7 1 Tf
0 -2.1 TD
(for \(i = 0; i < 32; i++\) {)Tj
0 -1.5 TD
(   glutSetColor \(16 + i, 1.0 * \(i/32.0\), 0.0, 1.0 * \(i/32.0\)\);)Tj
T*
(   glutSetColor \(48 + i, 1.0, 1.0 * \(i/32.0\), 1.0\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(The GLUT library command )Tj
/F15 1 Tf
11.8 0 TD
(glutSetColor\(\))Tj
/F11 1 Tf
5.8 0 TD
( takes four arguments. It associates the color index indicated)Tj
-17.6 -1.5 TD
(by the first argument to the RGB triplet specified by the last three arguments. When )Tj
/F15 1 Tf
33.8 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
( = 0, the color index)Tj
-34.1 -1.5 TD
(16 is assigned the RGB value \(0.0, 0.0, 0.0\), or black. The color ramp builds smoothly up to the diffuse)Tj
T*
(material color at index 47 \(when )Tj
/F15 1 Tf
13.3 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
( = 31\), which is assigned the pure magenta RGB value \(1.0, 0.0, 1.0\).)Tj
-13.6 -1.5 TD
(The second loop builds the ramp between the magenta diffuse color and the white \(1.0, 1.0, 1.0\) specular)Tj
T*
[(color \(index 79\). )44("Plate 15" in Appendix I)-28( shows the result of using this color ramp with a single lit)]TJ
T*
(sphere.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 93.000 Tm
(The Mathematics of Color-Index Mode Lighting)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 5,  Lighting - 33)Tj
ET
endstream
endobj
615 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
617 0 obj
<<
/Length 3502
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 204.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
0.000 Tw
(As you might expect, since the allowable parameters are different for color-index mode than for RGBA)Tj
0 -1.5 TD
(mode, the calculations are different as well. Since there's no material emission and no ambient light, the)Tj
T*
(only terms of interest from the RGBA equations are the diffuse and specular contributions from the light)Tj
T*
(sources and the shininess. Even these need to be modified, however, as explained next.)Tj
0 -2.1 TD
(Begin with the diffuse and specular terms from the RGBA equations. In the diffuse term, instead of)Tj
0 -1.5 TD
(diffuse)Tj
2.8 -0.2 TD
(light)Tj
1.8 0.2 TD
( * diffuse)Tj
3.8 -0.2 TD
(material)Tj
3.3 0.2 TD
(, substitute )Tj
/F15 1 Tf
4.5 0 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(ci)Tj
0.8 0.2 TD
( as defined in the previous section for color-index mode.)Tj
-17.5 -1.7 TD
(Similarly, in the specular term, instead of specular)Tj
20.1 -0.2 TD
(light)Tj
1.9 0.2 TD
( * specular)Tj
4.3 -0.2 TD
(material)Tj
3.3 0.2 TD
(, use )Tj
/F15 1 Tf
2.1 0 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(ci)Tj
0.7 0.2 TD
( as defined in the)Tj
-32.8 -1.7 TD
(previous section. \(Calculate the attenuation, spotlight effect, and all other components of these terms as)Tj
0 -1.5 TD
(before.\) Call these modified diffuse and specular terms )Tj
/F15 1 Tf
22.2 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
(, respectively. Now let )Tj
/F15 1 Tf
9.3 0 TD
(s)Tj
/F11 1 Tf
0.3 0 TD
(' = min{ )Tj
/F15 1 Tf
3.7 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
(, 1 },)Tj
-38.8 -1.5 TD
(and then compute)Tj
/F15 1 Tf
0 -2.1 TD
(c)Tj
/F11 1 Tf
0.4 0 TD
( = )Tj
/F15 1 Tf
1.1 0 TD
(a)Tj
/F11 1 Tf
0.5 -0.2 TD
(m)Tj
0.8 0.2 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(d\()Tj
/F11 1 Tf
0.8 0 TD
(1)Tj
/F15 1 Tf
0.5 0 TD
(-s'\)\(d)Tj
/F11 1 Tf
2.2 -0.2 TD
(m)Tj
0.8 0.2 TD
(-)Tj
/F15 1 Tf
0.3 0 TD
(a)Tj
/F11 1 Tf
0.5 -0.2 TD
(m)Tj
0.8 0.2 TD
(\) + )Tj
/F15 1 Tf
1.4 0 TD
(s')Tj
/F11 1 Tf
0.7 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(m)Tj
0.8 0.2 TD
(-)Tj
/F15 1 Tf
0.3 0 TD
(a)Tj
/F11 1 Tf
0.5 -0.2 TD
(m)Tj
0.8 0.2 TD
(\))Tj
-15 -2.3 TD
(where )Tj
/F15 1 Tf
2.7 0 TD
(a)Tj
/F11 1 Tf
0.5 -0.2 TD
(m)Tj
0.8 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(d)Tj
/F11 1 Tf
0.5 -0.2 TD
(m)Tj
0.7 0.2 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(m)Tj
0.8 0.2 TD
( are the ambient, diffuse, and specular material indexes specified using)Tj
-9.1 -1.7 TD
(GL_COLOR_INDEXES. The final color index is)Tj
/F15 1 Tf
0 -2.1 TD
(c')Tj
/F11 1 Tf
0.8 0 TD
( = min {)Tj
/F15 1 Tf
3.3 0 TD
( c)Tj
/F11 1 Tf
0.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(s)Tj
/F11 1 Tf
0.4 -0.2 TD
(m)Tj
0.8 0.2 TD
( })Tj
-6.5 -2.3 TD
(After lighting calculations are performed, the color-index values are converted to fixed-point \(with an)Tj
0 -1.5 TD
(unspecified number of bits to the right of the binary point\). Then the integer portion is masked \(bitwise)Tj
0 -1.8 TD
(ANDed\) with 2)Tj
6.2 0.3 TD
(n)Tj
0.5 -0.3 TD
(-1, where )Tj
/F15 1 Tf
4 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( is the number of bits in a color in the color-index buffer.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 373.610 m
547.000 373.610 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 34)Tj
ET
endstream
endobj
618 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
620 0 obj
<<
/Length 4032
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 6)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Blending, Antialiasing, Fog, and Polygon Offset)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Blend colors to achieve such effects as making objects appear translucent)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Smooth jagged edges of lines and polygons with antialiasing)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Create scenes with realistic atmospheric effects)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Draw geometry at or near the same depth, but avoid unaesthetic artifacts from intersecting geometry)Tj
-1.9 -2.8 TD
(The preceding chapters have given you the basic information you need to create a computer-graphics)Tj
0 -1.5 TD
(scene; you've learned how to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Draw geometric shapes)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Transform those geometric shapes so that they can be viewed from whatever perspective you wish)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Specify how the geometric shapes in your scene should be colored and shaded)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Add lights and indicate how they should affect the shapes in your scene)Tj
-1.9 -2.8 TD
(Now you're ready to get a little fancier. This chapter discusses four techniques that can add extra detail)Tj
0 -1.6 TD
(and polish to your scene. None of these techniques is hard to use)Tj
/F33 1 Tf
25.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in fact, it's probably harder to explain)Tj
-26.9 -1.6 TD
(them than to use them. Each of these techniques is described in its own major section:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Blending")-17( tells you how to specify a blending function that combines color values from a source)]TJ
0 -1.5 TD
(and a destination. The final effect is that parts of your scene appear translucent.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Antialiasing")6( explains this relatively subtle technique that alters colors so that the edges of points,)]TJ
0 -1.5 TD
(lines, and polygons appear smooth rather than angular and jagged.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Fog")-28( describes how to create the illusion of depth by computing the color values of an object based)]TJ
0 -1.6 TD
(on its distance from the viewpoint. Thus, objects that are far away appear to fade into the)Tj
0 -1.5 TD
(background, just as they do in real life.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If you've tried to draw a wireframe outline atop a shaded object and used the same vertices, you've)Tj
0 -1.6 TD
[(probably noticed some ugly visual artifacts. )50("Polygon Offset" shows you how to tweak \(offset\))]TJ
0 -1.5 TD
(depth values to make an outlined, shaded object look beautiful.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 146.000 Tm
(Blending)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 124.000 Tm
(You've already seen alpha values \(alpha is the A in RGBA\), but they've been ignored until now. Alpha)Tj
T*
(values are specified with )Tj
/F15 1 Tf
10.2 0 TD
(glColor*\(\))Tj
/F11 1 Tf
4.2 0 TD
(, when using )Tj
/F15 1 Tf
5.4 0 TD
(glClearColor\(\))Tj
/F11 1 Tf
6 0 TD
( to specify a clearing color and when)Tj
-25.8 -1.5 TD
(specifying certain lighting parameters such as a material property or light-source intensity. As you)Tj
T*
[(learned in )21(Chapter 4)16(,)0( the pixels on a monitor screen emit red, green, and blue light, which is controlled)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 1)Tj
ET
endstream
endobj
621 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
623 0 obj
<<
/Length 5276
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(by the red, green, and blue color values. So how does an alpha value affect what gets drawn in a window)Tj
0 -1.5 TD
(on the screen?)Tj
0 -2.1 TD
(When blending is enabled, the alpha value is often used to combine the color value of the fragment being)Tj
0 -1.5 TD
(processed with that of the pixel already stored in the framebuffer. Blending occurs after your scene has)Tj
T*
(been rasterized and converted to fragments, but just before the final pixels are drawn in the framebuffer.)Tj
T*
(Alpha values can also be used in the alpha test to accept or reject a fragment based on its alpha value.)Tj
T*
[(\(See )27(Chapter 10)16( for more information about this process.\))]TJ
0 -2.1 TD
(Without blending, each new fragment overwrites any existing color values in the framebuffer, as though)Tj
0 -1.5 TD
(the fragment were opaque. With blending, you can control how \(and how much of\) the existing color)Tj
T*
(value should be combined with the new fragment's value. Thus you can use alpha blending to create a)Tj
T*
(translucent fragment that lets some of the previously stored color value "show through." Color blending)Tj
T*
(lies at the heart of techniques such as transparency, digital compositing, and painting.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Alpha values aren't specified in color-index mode, so blending operations aren't performed in)Tj
-2.8 -1.4 TD
(color-index mode.)Tj
0 -2.1 TD
(The most natural way to think of blending operations is to think of the RGB components of a fragment as)Tj
0 -1.5 TD
(representing its color and the alpha component as representing opacity. Transparent or translucent)Tj
T*
(surfaces have lower opacity than opaque ones and, therefore, lower alpha values. For example, if you're)Tj
T*
(viewing an object through green glass, the color you see is partly green from the glass and partly the)Tj
T*
(color of the object. The percentage varies depending on the transmission properties of the glass: If the)Tj
T*
(glass transmits 80 percent of the light that strikes it \(that is, has an opacity of 20 percent\), the color you)Tj
T*
(see is a combination of 20 percent glass color and 80 percent of the color of the object behind it. You can)Tj
T*
(easily imagine situations with multiple translucent surfaces. If you look at an automobile, for instance, its)Tj
T*
(interior has one piece of glass between it and your viewpoint; some objects behind the automobile are)Tj
T*
(visible through two pieces of glass.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 314.000 Tm
(The Source and Destination Factors)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 292.000 Tm
(During blending, color values of the incoming fragment \(the )Tj
/F15 1 Tf
24.4 0 TD
(source)Tj
/F11 1 Tf
2.7 0 TD
(\) are combined with the color values)Tj
-27.1 -1.5 TD
(of the corresponding currently stored pixel \(the )Tj
/F15 1 Tf
19.1 0 TD
(destination)Tj
/F11 1 Tf
4.5 0 TD
(\) in a two-stage process. First you specify how)Tj
-23.6 -1.5 TD
(to compute source and destination factors. These factors are RGBA quadruplets that are multiplied by)Tj
T*
(each component of the R, G, B, and A values in the source and destination, respectively. Then the)Tj
T*
(corresponding components in the two sets of RGBA quadruplets are added. To show this mathematically,)Tj
T*
(let the source and destination blending factors be \(S)Tj
20.7 -0.2 TD
(r)Tj
0.4 0.2 TD
(, S)Tj
1 -0.2 TD
(g)Tj
0.5 0.2 TD
(, S)Tj
1.1 -0.2 TD
(b)Tj
0.5 0.2 TD
(, S)Tj
1 -0.2 TD
(a)Tj
0.5 0.2 TD
(\) and \(D)Tj
3.3 -0.2 TD
(r)Tj
0.3 0.2 TD
(, D)Tj
1.3 -0.2 TD
(g)Tj
0.5 0.2 TD
(, D)Tj
1.2 -0.2 TD
(b)Tj
0.5 0.2 TD
(, D)Tj
1.2 -0.2 TD
(a)Tj
0.4 0.2 TD
(\), respectively, and)Tj
-34.4 -1.7 TD
(the RGBA values of the source and destination be indicated with a subscript of s or d. Then the final,)Tj
0 -1.5 TD
(blended RGBA values are given by)Tj
0 -2.1 TD
(\(R)Tj
1 -0.2 TD
(s)Tj
0.4 0.2 TD
(S)Tj
0.5 -0.2 TD
(r)Tj
0.4 0.2 TD
(+R)Tj
1.2 -0.2 TD
(d)Tj
0.5 0.2 TD
(D)Tj
0.7 -0.2 TD
(r)Tj
0.4 0.2 TD
(, G)Tj
1.2 -0.2 TD
(s)Tj
0.4 0.2 TD
(S)Tj
0.5 -0.2 TD
(g)Tj
0.5 0.2 TD
(+G)Tj
1.3 -0.2 TD
(d)Tj
0.5 0.2 TD
(D)Tj
0.7 -0.2 TD
(g)Tj
0.5 0.2 TD
(, B)Tj
1.2 -0.2 TD
(s)Tj
0.4 0.2 TD
(S)Tj
0.6 -0.2 TD
(b)Tj
0.5 0.2 TD
(+B)Tj
1.2 -0.2 TD
(d)Tj
0.5 0.2 TD
(D)Tj
0.7 -0.2 TD
(b)Tj
0.5 0.2 TD
(, A)Tj
1.2 -0.2 TD
(s)Tj
0.4 0.2 TD
(S)Tj
0.6 -0.2 TD
(a)Tj
0.4 0.2 TD
(+A)Tj
1.3 -0.2 TD
(d)Tj
0.5 0.2 TD
(D)Tj
0.7 -0.2 TD
(a)Tj
0.5 0.2 TD
(\))Tj
-21.9 -2.3 TD
(Each component of this quadruplet is eventually clamped to [0,1].)Tj
0 -2.1 TD
(Now consider how the source and destination blending factors are generated. You use )Tj
/F15 1 Tf
34.6 0 TD
(glBlendFunc\(\))Tj
/F11 1 Tf
5.8 0 TD
( to)Tj
-40.4 -1.5 TD
(supply two constants: one that specifies how the source factor should be computed and one that indicates)Tj
T*
(how the destination factor should be computed. To have blending take effect, you also need to enable it:)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 2)Tj
ET
endstream
endobj
624 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
626 0 obj
<<
/Length 6065
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glEnable\(GL_BLEND\); )Tj
/F11 1 Tf
0 -2.1 TD
(Use )Tj
/F15 1 Tf
1.8 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.6 0 TD
0.000 Tw
( with GL_BLEND to disable blending. Also note that using the constants GL_ONE)Tj
-6.4 -1.5 TD
(\(source\) and GL_ZERO \(destination\) gives the same results as when blending is disabled; these values)Tj
T*
(are the default.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glBlendFunc)67(\(GLenum )-45(sfactor)78(, )28(GLenum )22(dfactor)-11(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Controls how color values in the fragment being processed \(the source\) are combined with those)Tj
T*
[(already stored in the framebuffer \(the destination\). The argument )46(sfactor)-22( indicates how to compute a)]TJ
T*
[(source blending factor; )39(dfactor)-11( indicates how to compute a destination blending factor. The possible)]TJ
T*
[(values for these arguments are explained in )50(Table 6-1)]TJ
21.6 0 TD
(. The blend factors are assumed to lie in the)Tj
-21.6 -1.5 TD
(range [0,1]; after the color values in the source and destination are combined, they're clamped to)Tj
T*
(the range [0,1].)Tj
/F27 1 Tf
-1.8 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
[(In )-17(Table 6-1)191(, the RGBA values of the source and destination are indicated with the subscripts s)]TJ
-2.8 -1.5 TD
(and d, respectively. Subtraction of quadruplets means subtracting them componentwise. The Relevant)Tj
0 -1.4 TD
(Factor column indicates whether the corresponding constant can be used to specify the source or)Tj
T*
(destination blend factor.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 474.670 m
472.000 474.670 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 467.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Constant)-14041(Relevant Factor)-1996(Computed Blend Factor)]TJ
ET
Q
124.000 461.150 m
472.000 461.150 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 453.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_ZERO)-11889(source or)]TJ
16.3333 -1.3333 TD
(destination)Tj
8.4444 1.3333 TD
(\(0, 0, 0, 0\))Tj
-24.7778 -2.7778 TD
[(GL_ONE)-12445(source or)]TJ
16.3333 -1.3333 TD
(destination)Tj
8.4444 1.3333 TD
(\(1, 1, 1, 1\))Tj
-24.7778 -2.7778 TD
[(GL_DST_COLOR)-8721(source)-5834(\(R)]TJ
25.7778 -0.2222 TD
(d)Tj
0.5556 0.2222 TD
(, G)Tj
1.2222 -0.2222 TD
(d)Tj
0.4444 0.2222 TD
(, B)Tj
1.2222 -0.2222 TD
(d)Tj
0.4445 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(d)Tj
0.5556 0.2222 TD
(\))Tj
-31.4444 -1.6667 TD
[(GL_SRC_COLOR)-8720(destination)-4055(\(R)]TJ
25.7778 -0.2222 TD
(s)Tj
0.4444 0.2222 TD
(, G)Tj
1.2222 -0.2222 TD
(s)Tj
0.3333 0.2222 TD
(, B)Tj
1.2222 -0.2222 TD
(s)Tj
0.3333 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(s)Tj
0.4444 0.2222 TD
(\))Tj
-31 -1.6667 TD
[(GL_ONE_MINUS_DST_COLOR)-2443(source)-5834(\(1, 1, 1, 1\)-\(R)]TJ
30.2222 -0.2222 TD
(d)Tj
0.5556 0.2222 TD
(, G)Tj
1.2222 -0.2222 TD
(d)Tj
0.4444 0.2222 TD
(, B)Tj
1.2222 -0.2222 TD
(d)Tj
0.4444 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(d)Tj
0.5556 0.2222 TD
(\))Tj
-35.8889 -1.6667 TD
[(GL_ONE_MINUS_SRC_COLOR)-2442(destination)-4055(\(1, 1, 1, 1\)-\(R)]TJ
30.2222 -0.2222 TD
(s)Tj
0.4445 0.2222 TD
(, G)Tj
1.2222 -0.2222 TD
(s)Tj
0.3333 0.2222 TD
(, B)Tj
1.2222 -0.2222 TD
(s)Tj
0.3333 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(s)Tj
0.4444 0.2222 TD
(\))Tj
-35.4444 -1.6667 TD
[(GL_SRC_ALPHA)-8776(source or)]TJ
16.3333 -1.3333 TD
(destination)Tj
8.4444 1.3333 TD
(\(A)Tj
1.1111 -0.2222 TD
(s)Tj
0.3333 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(s)Tj
0.4444 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(s)Tj
0.3333 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(s)Tj
0.4444 0.2222 TD
(\))Tj
-31.1111 -2.7778 TD
[(GL_ONE_MINUS_SRC_ALPHA)-2498(source or)]TJ
16.3333 -1.3333 TD
(destination)Tj
8.4444 1.3333 TD
(\(1, 1, 1, 1\)-\(A)Tj
5.5556 -0.2222 TD
(s)Tj
0.3333 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(s)Tj
0.4444 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(s)Tj
0.3333 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(s)Tj
0.4444 0.2222 TD
(\))Tj
-35.5556 -2.7778 TD
[(GL_DST_ALPHA)-8777(source or)]TJ
16.3333 -1.3333 TD
(destination)Tj
8.4444 1.3333 TD
(\(A)Tj
1.1111 -0.2222 TD
(d)Tj
0.4444 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(d)Tj
0.5556 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(d)Tj
0.4444 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(d)Tj
0.5556 0.2222 TD
(\))Tj
-31.5556 -2.7778 TD
[(GL_ONE_MINUS_DST_ALPHA)-2499(source or)]TJ
16.3333 -1.3333 TD
(destination)Tj
8.4444 1.3333 TD
(\(1, 1, 1, 1\)-\(A)Tj
5.5556 -0.2222 TD
(d)Tj
0.4444 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(d)Tj
0.5556 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(d)Tj
0.4444 0.2222 TD
(, A)Tj
1.2222 -0.2222 TD
(d)Tj
0.5556 0.2222 TD
(\))Tj
-36 -2.7778 TD
[(GL_SRC_ALPHA_SATURATE)-3053(source)-5834(\(f, f, f, 1\); f=min\(As, 1-Ad\))]TJ
ET
Q
124.000 235.090 m
472.010 235.090 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 219.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 6-1 )Tj
/F11 1 Tf
4.6 0 TD
(Source and Destination Blending Factors)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 190.000 Tm
(Sample Uses of Blending)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 168.000 Tm
(Not all combinations of source and destination factors make sense. Most applications use a small number)Tj
0 -1.5 TD
(of combinations. The following paragraphs describe typical uses for particular combinations of source)Tj
T*
(and destination factors. Some of these examples use only the incoming alpha value, so they work even)Tj
T*
(when alpha values aren't stored in the framebuffer. Also note that often there's more than one way to)Tj
T*
(achieve some of these effects.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(One way to draw a picture composed half of one image and half of another, equally blended, is to)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 3)Tj
ET
endstream
endobj
627 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
629 0 obj
<<
/Length 4640
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(set the source factor to GL_ONE and the destination factor to GL_ZERO, and draw the first image.)Tj
0 -1.5 TD
(Then set the source factor to GL_SRC_ALPHA and destination factor to)Tj
T*
(GL_ONE_MINUS_SRC_ALPHA, and draw the second image with alpha equal to 0.5. This pair of)Tj
T*
(factors probably represents the most commonly used blending operation. If the picture is supposed)Tj
T*
(to be blended with 0.75 of the first image and 0.25 of the second, draw the first image as before, and)Tj
T*
(draw the second with an alpha of 0.25.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(To blend three different images equally, set the destination factor to GL_ONE and the source factor)Tj
0 -1.6 TD
(to GL_SRC_ALPHA. Draw each of the images with an alpha equal to 0.3333333. With this)Tj
0 -1.5 TD
(technique, each image is only one-third of its original brightness, which is noticeable where the)Tj
T*
(images don't overlap.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Suppose you're writing a paint program, and you want to have a brush that gradually adds color so)Tj
0 -1.6 TD
(that each brush stroke blends in a little more color with whatever is currently in the image \(say 10)Tj
0 -1.5 TD
(percent color with 90 percent image on each pass\). To do this, draw the image of the brush with)Tj
T*
(alpha of 10 percent and use GL_SRC_ALPHA \(source\) and GL_ONE_MINUS_SRC_ALPHA)Tj
T*
(\(destination\). Note that you can vary the alphas across the brush to make the brush add more of its)Tj
T*
[(color in the middle and less on the edges, for an antialiased brush shape. \(See )-7("Antialiasing.")56(\))]TJ
T*
(Similarly, erasers can be implemented by setting the eraser color to the background color.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The blending functions that use the source or destination colors)Tj
/F33 1 Tf
25.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(GL_DST_COLOR or)Tj
-26.4 -1.6 TD
(GL_ONE_MINUS_DST_COLOR for the source factor and GL_SRC_COLOR or)Tj
T*
(GL_ONE_MINUS_SRC_COLOR for the destination factor)Tj
/F33 1 Tf
24 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(effectively allow you to modulate)Tj
-25 -1.7 TD
(each color component individually. This operation is equivalent to applying a simple filter)Tj
/F33 1 Tf
36.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for)Tj
-37.1 -1.5 TD
(example, multiplying the red component by 80 percent, the green component by 40 percent, and the)Tj
T*
(blue component by 72 percent would simulate viewing the scene through a photographic filter that)Tj
T*
(blocks 20 percent of red light, 60 percent of green, and 28 percent of blue.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Suppose you want to draw a picture composed of three translucent surfaces, some obscuring others,)Tj
0 -1.6 TD
(and all over a solid background. Assume the farthest surface transmits 80 percent of the color behind)Tj
0 -1.5 TD
(it, the next transmits 40 percent, and the closest transmits 90 percent. To compose this picture, draw)Tj
T*
(the background first with the default source and destination factors, and then change the blending)Tj
T*
(factors to GL_SRC_ALPHA \(source\) and GL_ONE_MINUS_SRC_ALPHA \(destination\). Next,)Tj
T*
(draw the farthest surface with an alpha of 0.2, then the middle surface with an alpha of 0.6, and)Tj
T*
(finally the closest surface with an alpha of 0.1.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If your system has alpha planes, you can render objects one at a time \(including their alpha values\),)Tj
0 -1.6 TD
(read them back, and then perform interesting matting or compositing operations with the fully)Tj
0 -1.5 TD
(rendered objects. \(See "Compositing 3D Rendered Images" by Tom Duff, SIGGRAPH 1985)Tj
T*
(Proceedings, p. 41\25544, for examples of this technique.\) Note that objects used for picture)Tj
0 -1.6 TD
(composition can come from any source)Tj
/F33 1 Tf
15.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(they can be rendered using OpenGL commands, rendered)Tj
-16.7 -1.6 TD
(using techniques such as ray-tracing or radiosity that are implemented in another graphics library, or)Tj
0 -1.5 TD
(obtained by scanning in existing images.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(You can create the effect of a nonrectangular raster image by assigning different alpha values to)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 4)Tj
ET
endstream
endobj
630 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
631 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im63
/Width 536
/Height 558
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.62)
>>
stream
endstream
endobj
633 0 obj
<<
/Length 1951
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(individual fragments in the image. In most cases, you would assign an alpha of 0 to each "invisible")Tj
0 -1.5 TD
(fragment and an alpha of 1.0 to each opaque fragment. For example, you can draw a polygon in the)Tj
T*
(shape of a tree and apply a texture map of foliage; the viewer can see through parts of the)Tj
T*
(rectangular texture that aren't part of the tree if you've assigned them alpha values of 0. This)Tj
T*
(method, sometimes called )Tj
/F15 1 Tf
10.7 0 TD
(billboarding)Tj
/F11 1 Tf
5 0 TD
(, is much faster than creating the tree out of)Tj
-15.7 -1.5 TD
[(three-dimensional polygons. An example of this technique is shown in )204(Figure 6-1)225(: The tree is a)]TJ
T*
(single rectangular polygon that can be rotated about the center of the trunk, as shown by the)Tj
T*
[(outlines, so that it's always facing the viewer. \(See )-18("Texture Functions" in Chapter 9)17( for more)]TJ
T*
(information about blending textures.\))Tj
ET
Q
q
1 i 
143.000 576.840 403.990 -420.580 re
W n
/GS1 gs
q
404 0 0 421 143 155.84 cm
/Im63 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 143.000 144.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 6-1 )Tj
/F11 1 Tf
5.1 0 TD
(Creating a Nonrectangular Raster Image)Tj
/F33 1 Tf
-6.9 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Blending is also used for )Tj
/F13 1 Tf
10.2 0 TD
(antialiasing)Tj
/F11 1 Tf
4.9 0 TD
(, which is a rendering technique to reduce the jagged)Tj
-15.1 -1.5 TD
[(appearance of primitives drawn on a raster screen. \(See )-16("Antialiasing")6( for more information.\))]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 5)Tj
ET
endstream
endobj
634 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im63 631 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
637 0 obj
<<
/Length 2135
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(A Blending Example)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 687.000 Tm
(Example 6-1)Tj
5.1 0 TD
( draws two overlapping colored triangles, each with an alpha of 0.75. Blending is enabled)Tj
-5.1 -1.5 TD
(and the source and destination blending factors are set to GL_SRC_ALPHA and)Tj
T*
(GL_ONE_MINUS_SRC_ALPHA, respectively.)Tj
0 -2.1 TD
(When the program starts up, a yellow triangle is drawn on the left and then a cyan triangle is drawn on)Tj
0 -1.5 TD
(the right so that in the center of the window, where the triangles overlap, cyan is blended with the)Tj
T*
(original yellow. You can change which triangle is drawn first by typing `t' in the window.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 6-1 )Tj
/F11 1 Tf
6.1 0 TD
(Blending Example: alpha.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(static int leftFirst = GL_TRUE;)Tj
T*
(/*  Initialize alpha blending function.  */)Tj
0 -1.5 TD
(static void init\(void\))Tj
T*
({)Tj
T*
(   glEnable \(GL_BLEND\);)Tj
T*
(   glBlendFunc \(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA\);)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(})Tj
0 -3 TD
(static void drawLeftTriangle\(void\))Tj
0 -1.5 TD
({)Tj
T*
(/* draw yellow triangle on LHS of screen */)Tj
T*
(   glBegin \(GL_TRIANGLES\);)Tj
T*
(      glColor4f\(1.0, 1.0, 0.0, 0.75\);)Tj
T*
(      glVertex3f\(0.1, 0.9, 0.0\); )Tj
T*
(      glVertex3f\(0.1, 0.1, 0.0\); )Tj
T*
(      glVertex3f\(0.7, 0.5, 0.0\); )Tj
T*
(   glEnd\(\);)Tj
T*
(})Tj
0 -4.5 TD
(static void drawRightTriangle\(void\))Tj
0 -1.5 TD
({)Tj
T*
(/* draw cyan triangle on RHS of screen */)Tj
T*
(   glBegin \(GL_TRIANGLES\);)Tj
T*
(      glColor4f\(0.0, 1.0, 1.0, 0.75\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 6)Tj
ET
endstream
endobj
638 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
640 0 obj
<<
/Length 1601
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      glVertex3f\(0.9, 0.9, 0.0\); )Tj
0 -1.5 TD
(      glVertex3f\(0.3, 0.5, 0.0\); )Tj
T*
(      glVertex3f\(0.9, 0.1, 0.0\); )Tj
T*
(   glEnd\(\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -3 TD
(   if \(leftFirst\) {)Tj
0 -1.5 TD
(      drawLeftTriangle\(\);)Tj
T*
(      drawRightTriangle\(\);)Tj
T*
(   })Tj
T*
(   else {)Tj
T*
(      drawRightTriangle\(\);)Tj
T*
(      drawLeftTriangle\(\);)Tj
T*
(   })Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\) )Tj
T*
(      gluOrtho2D \(0.0, 1.0, 0.0, 1.0*\(GLfloat\)h/\(GLfloat\)w\);)Tj
T*
(   else )Tj
T*
(      gluOrtho2D \(0.0, 1.0*\(GLfloat\)w/\(GLfloat\)h, 0.0, 1.0\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `t':)Tj
T*
(      case `T':)Tj
T*
(         leftFirst = !leftFirst;)Tj
T*
(         glutPostRedisplay\(\);   )Tj
T*
(         break;)Tj
T*
(      case 27:  /*  Escape key  */)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 7)Tj
ET
endstream
endobj
641 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
643 0 obj
<<
/Length 3437
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      default:)Tj
0 -1.5 TD
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(200, 200\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc \(reshape\);)Tj
T*
(   glutKeyboardFunc \(keyboard\);)Tj
T*
(   glutDisplayFunc \(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(The order in which the triangles are drawn affects the color of the overlapping region. When the left)Tj
0 -1.5 TD
(triangle is drawn first, cyan fragments \(the source\) are blended with yellow fragments, which are already)Tj
T*
(in the framebuffer \(the destination\). When the right triangle is drawn first, yellow is blended with cyan.)Tj
T*
(Because the alpha values are all 0.75, the actual blending factors become 0.75 for the source and 1.0 -)Tj
T*
(0.75 = 0.25 for the destination. In other words, the source fragments are somewhat translucent, but they)Tj
T*
(have more effect on the final color than the destination fragments.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 332.000 Tm
(Three-Dimensional Blending with the Depth Buffer)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 310.000 Tm
(As you saw in the previous example, the order in which polygons are drawn greatly affects the blended)Tj
T*
(result. When drawing three-dimensional translucent objects, you can get different appearances depending)Tj
T*
(on whether you draw the polygons from back to front or from front to back. You also need to consider)Tj
T*
[(the effect of the depth buffer when determining the correct order. \(See )-45("A Hidden-Surface Removal)]TJ
T*
[(Survival Kit" in Chapter 5)20( for an introduction to the depth buffer. Also see )-18("Depth Test" in Chapter 10)]TJ
T*
(for more information.\) The depth buffer keeps track of the distance between the viewpoint and the)Tj
T*
(portion of the object occupying a given pixel in a window on the screen; when another candidate color)Tj
T*
(arrives for that pixel, it's drawn only if its object is closer to the viewpoint, in which case its depth value)Tj
T*
(is stored in the depth buffer. With this method, obscured \(or hidden\) portions of surfaces aren't)Tj
T*
(necessarily drawn and therefore aren't used for blending.)Tj
0 -2.1 TD
(If you want to render both opaque and translucent objects in the same scene, then you want to use the)Tj
0 -1.5 TD
(depth buffer to perform hidden-surface removal for any objects that lie behind the opaque objects. If an)Tj
T*
(opaque object hides either a translucent object or another opaque object, you want the depth buffer to)Tj
T*
(eliminate the more distant object. If the translucent object is closer, however, you want to blend it with)Tj
T*
(the opaque object. You can generally figure out the correct order to draw the polygons if everything in)Tj
T*
(the scene is stationary, but the problem can quickly become too hard if either the viewpoint or the object)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 8)Tj
ET
endstream
endobj
644 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
646 0 obj
<<
/Length 2793
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(is moving.)Tj
0 -2.1 TD
(The solution is to enable depth buffering but make the depth buffer read-only while drawing the)Tj
0 -1.5 TD
(translucent objects. First you draw all the opaque objects, with the depth buffer in normal operation.)Tj
T*
(Then you preserve these depth values by making the depth buffer read-only. When the translucent)Tj
T*
(objects are drawn, their depth values are still compared to the values established by the opaque objects,)Tj
T*
(so they aren't drawn if they're behind the opaque ones. If they're closer to the viewpoint, however, they)Tj
T*
(don't eliminate the opaque objects, since the depth-buffer values can't change. Instead, they're blended)Tj
T*
(with the opaque objects. To control whether the depth buffer is writable, use )Tj
/F15 1 Tf
30.8 0 TD
(glDepthMask\(\))Tj
/F11 1 Tf
6.1 0 TD
(; if you pass)Tj
-36.9 -1.5 TD
(GL_FALSE as the argument, the buffer becomes read-only, whereas GL_TRUE restores the normal,)Tj
T*
(writable operation.)Tj
0 -2.1 TD
(Example 6-2)Tj
5.1 0 TD
( demonstrates how to use this method to draw opaque and translucent three-dimensional)Tj
-5.1 -1.5 TD
(objects. In the program, typing `a' triggers an animation sequence in which a translucent cube moves)Tj
T*
(through an opaque sphere. Pressing the `r' key resets the objects in the scene to their initial positions. To)Tj
T*
(get the best results when transparent objects overlap, draw the objects from back to front.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 6-2 )Tj
/F11 1 Tf
6.1 0 TD
(Three-Dimensional Blending: alpha3D.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <stdlib.h>)Tj
0 -1.5 TD
(#include <stdio.h>)Tj
T*
(#include <GL/gl.h>)Tj
T*
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
0 -3 TD
(#define MAXZ 8.0)Tj
0 -1.5 TD
(#define MINZ -8.0)Tj
T*
(#define ZINC 0.4)Tj
T*
(static float solidZ = MAXZ;)Tj
T*
(static float transparentZ = MINZ;)Tj
T*
(static GLuint sphereList, cubeList;)Tj
0 -3 TD
(static void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 0.15 };)Tj
T*
(   GLfloat mat_shininess[] = { 100.0 };)Tj
T*
(   GLfloat position[] = { 0.5, 0.5, 1.0, 0.0 };)Tj
0 -3 TD
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
0 -1.5 TD
(   glMaterialfv\(GL_FRONT, GL_SHININESS, mat_shininess\);)Tj
T*
(   glLightfv\(GL_LIGHT0, GL_POSITION, position\);)Tj
0 -3 TD
(   glEnable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 9)Tj
ET
endstream
endobj
647 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
649 0 obj
<<
/Length 1949
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 697.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   sphereList = glGenLists\(1\);)Tj
0 -1.5 TD
(   glNewList\(sphereList, GL_COMPILE\);)Tj
T*
(      glutSolidSphere \(0.4, 16, 16\);)Tj
T*
(   glEndList\(\);)Tj
0 -3 TD
(   cubeList = glGenLists\(1\);)Tj
0 -1.5 TD
(   glNewList\(cubeList, GL_COMPILE\);)Tj
T*
(      glutSolidCube \(0.6\);)Tj
T*
(   glEndList\(\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat mat_solid[] = { 0.75, 0.75, 0.0, 1.0 };)Tj
T*
(   GLfloat mat_zero[] = { 0.0, 0.0, 0.0, 1.0 };)Tj
T*
(   GLfloat mat_transparent[] = { 0.0, 0.8, 0.8, 0.6 };)Tj
T*
(   GLfloat mat_emission[] = { 0.0, 0.3, 0.3, 0.6 };)Tj
0 -3 TD
(   glClear \(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(      glTranslatef \(-0.15, -0.15, solidZ\);)Tj
T*
(      glMaterialfv\(GL_FRONT, GL_EMISSION, mat_zero\);)Tj
T*
(      glMaterialfv\(GL_FRONT, GL_DIFFUSE, mat_solid\);)Tj
T*
(      glCallList \(sphereList\);)Tj
T*
(   glPopMatrix \(\);)Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(      glTranslatef \(0.15, 0.15, transparentZ\);)Tj
T*
(      glRotatef \(15.0, 1.0, 1.0, 0.0\);)Tj
T*
(      glRotatef \(30.0, 0.0, 1.0, 0.0\);)Tj
T*
(      glMaterialfv\(GL_FRONT, GL_EMISSION, mat_emission\);)Tj
T*
(      glMaterialfv\(GL_FRONT, GL_DIFFUSE, mat_transparent\);)Tj
T*
(      glEnable \(GL_BLEND\);)Tj
T*
(      glDepthMask \(GL_FALSE\);)Tj
T*
(      glBlendFunc \(GL_SRC_ALPHA, GL_ONE\);)Tj
T*
(      glCallList \(cubeList\);)Tj
T*
(      glDepthMask \(GL_TRUE\);)Tj
T*
(      glDisable \(GL_BLEND\);)Tj
T*
(   glPopMatrix \(\);)Tj
0 -3 TD
(   glutSwapBuffers\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 10)Tj
ET
endstream
endobj
650 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
652 0 obj
<<
/Length 1667
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLint\) w, \(GLint\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho \(-1.5, 1.5, -1.5*\(GLfloat\)h/\(GLfloat\)w,)Tj
T*
(             1.5*\(GLfloat\)h/\(GLfloat\)w, -10.0, 10.0\);)Tj
T*
(   else)Tj
T*
(      glOrtho \(-1.5*\(GLfloat\)w/\(GLfloat\)h,)Tj
T*
(             1.5*\(GLfloat\)w/\(GLfloat\)h, -1.5, 1.5, -10.0, 10.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void animate\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   if \(solidZ <= MINZ || transparentZ >= MAXZ\))Tj
T*
(      glutIdleFunc\(NULL\);)Tj
T*
(   else {)Tj
T*
(      solidZ -= ZINC;)Tj
T*
(      transparentZ += ZINC;)Tj
T*
(      glutPostRedisplay\(\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `a':)Tj
T*
(      case `A':)Tj
T*
(         solidZ = MAXZ;)Tj
T*
(         transparentZ = MINZ;)Tj
T*
(         glutIdleFunc\(animate\);)Tj
T*
(         break;)Tj
T*
(      case `r':)Tj
T*
(      case `R':)Tj
T*
(         solidZ = MAXZ;)Tj
T*
(         transparentZ = MINZ;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 11)Tj
ET
endstream
endobj
653 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
654 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im64
/Width 293
/Height 152
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.63)
>>
stream
endstream
endobj
656 0 obj
<<
/Length 2460
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      case 27:)Tj
0 -1.5 TD
(        exit\(0\);)Tj
T*
(    })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize\(500, 500\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 423.000 Tm
(Antialiasing)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 401.000 Tm
(You might have noticed in some of your OpenGL pictures that lines, especially nearly horizontal or)Tj
T*
(nearly vertical ones, appear jagged. These jaggies appear because the ideal line is approximated by a)Tj
T*
(series of pixels that must lie on the pixel grid. The jaggedness is called )Tj
/F13 1 Tf
28.5 0 TD
(aliasing)Tj
/F11 1 Tf
3.3 0 TD
(, and this section)Tj
-31.8 -1.5 TD
[(describes antialiasing techniques to reduce it. )-40(Figure 6-2)225( shows two intersecting lines, both aliased and)]TJ
T*
(antialiased. The pictures have been magnified to show the effect.)Tj
ET
Q
/GS1 gs
q
293 0 0 152 124 174.43 cm
/Im64 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 162.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 6-2 )Tj
/F11 1 Tf
5.1 0 TD
(Aliased and Antialiased Lines)Tj
-5.1 -2.1 TD
[(Figure 6-3)225( shows how a diagonal line 1 pixel wide covers more of some pixel squares than others. In)]TJ
0 -1.5 TD
(fact, when performing antialiasing, OpenGL calculates a )Tj
/F15 1 Tf
22.9 0 TD
(coverage)Tj
/F11 1 Tf
3.7 0 TD
( value for each fragment based on the)Tj
-26.6 -1.5 TD
(fraction of the pixel square on the screen that it would cover. The figure shows these coverage values for)Tj
T*
(the line. In RGBA mode, OpenGL multiplies the fragment's alpha value by its coverage. You can then)Tj
T*
(use the resulting alpha value to blend the fragment with the corresponding pixel already in the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 12)Tj
ET
endstream
endobj
657 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im64 654 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
658 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im65
/Width 304
/Height 194
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.64)
>>
stream
endstream
endobj
660 0 obj
<<
/Length 3775
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(framebuffer. In color-index mode, OpenGL sets the least significant 4 bits of the color index based on the)Tj
0 -1.5 TD
(fragment's coverage \(0000 for no coverage and 1111 for complete coverage\). It's up to you to load your)Tj
T*
(color map and apply it appropriately to take advantage of this coverage information.)Tj
ET
Q
/GS1 gs
q
304 0 0 194 124 472.84 cm
/Im65 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 460.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 6-3 )Tj
/F11 1 Tf
5.1 0 TD
(Determining Coverage Values)Tj
-5.1 -2.1 TD
(The details of calculating coverage values are complex, difficult to specify in general, and in fact may)Tj
0 -1.5 TD
(vary slightly depending on your particular implementation of OpenGL. You can use the )Tj
/F15 1 Tf
35.4 0 TD
(glHint\(\))Tj
/F11 1 Tf
-35.4 -1.5 TD
(command to exercise some control over the trade-off between image quality and speed, but not all)Tj
T*
(implementations will take the hint.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glHint)56(\(GLenum )-45(target)89(, )28(GLenum )22(hint)-44(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Controls certain aspects of OpenGL behavior. The )-43(target)89( parameter indicates which behavior is to)]TJ
T*
[(be controlled; its possible values are shown in )35(Table 6-2)]TJ
22.7 0 TD
[(. The )50(hint)-44( parameter can be GL_FASTEST)]TJ
-22.7 -1.5 TD
(to indicate that the most efficient option should be chosen, GL_NICEST to indicate the)Tj
T*
(highest-quality option, or GL_DONT_CARE to indicate no preference. The interpretation of hints is)Tj
T*
(implementation-dependent; an implementation can ignore them entirely. \(For more information)Tj
T*
[(about the relevant topics, see )44("Antialiasing")-69( for the details on sampling and )75("Fog")-49( for details on)]TJ
T*
(fog.\))Tj
T*
(The GL_PERSPECTIVE_CORRECTION_HINT target parameter refers to how color values and)Tj
T*
(texture coordinates are interpolated across a primitive: either linearly in screen space \(a relatively)Tj
T*
(simple calculation\) or in a perspective-correct manner \(which requires more computation\). Often,)Tj
T*
(systems perform linear color interpolation because the results, while not technically correct, are)Tj
T*
(visually acceptable; however, in most cases textures require perspective-correct interpolation to be)Tj
T*
(visually acceptable. Thus, an implementation can choose to use this parameter to control the method)Tj
T*
[(used for interpolation. \(See Chapter 3)28( for a discussion of perspective projection, )-21(Chapter 4)28( for a)]TJ
T*
[(discussion of color, and )7(Chapter 9)28( for a discussion of texture mapping.\))]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
1 i 
124.000 136.840 m
465.000 136.840 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 129.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Parameter)-18233(Meaning)]TJ
ET
Q
124.000 123.320 m
465.000 123.320 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 115.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(GL_POINT_SMOOTH_HINT,)Tj
0 -1.3333 TD
(GL_LINE_SMOOTH_HINT,)Tj
T*
(GL_POLYGON_SMOOTH_HINT)Tj
20.5556 2.6667 TD
0.000 Tw
(Specify the desired sampling quality of)Tj
0 -1.3333 TD
(points, lines, or polygons during)Tj
T*
(antialiasing operations)Tj
-20.5556 -1.4444 TD
[(GL_FOG_HINT)-13834(Specifies whether fog calculations are)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 13)Tj
ET
endstream
endobj
661 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im65 658 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
663 0 obj
<<
/Length 3440
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 309.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(done  per pixel \(GL_NICEST\) or per)Tj
0 -1.3333 TD
(vertex  \(GL_FASTEST\))Tj
-20.5556 -1.4444 TD
[(GL_PERSPECTIVE_CORRECTION_HINT)-2442(Specifies the desired quality of color and)]TJ
20.5556 -1.3333 TD
(texture-coordinate interpolation)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 667.410 m
465.010 667.410 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 651.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 6-2 )Tj
/F11 1 Tf
4.6 0 TD
(Values for Use with glHint\(\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 622.000 Tm
(Antialiasing Points or Lines)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 601.000 Tm
(To antialias points or lines, you need to turn on antialiasing with )Tj
/F15 1 Tf
26 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
(, passing in)Tj
-30.3 -1.5 TD
(GL_POINT_SMOOTH or GL_LINE_SMOOTH, as appropriate. You might also want to provide a)Tj
T*
(quality hint with )Tj
/F15 1 Tf
6.9 0 TD
(glHint\(\))Tj
/F11 1 Tf
3.2 0 TD
(. \(Remember that you can set the size of a point or the width of a line. You can)Tj
-10.1 -1.5 TD
[(also stipple a line. See )-33("Line Details" in Chapter 2)27(.\) Next follow the procedures described in one of the)]TJ
T*
(following sections, depending on whether you're in RGBA or color-index mode.)Tj
/F27 1 Tf
0 -3 TD
(Antialiasing in RGBA Mode)Tj
/F11 1 Tf
0 -2.1 TD
(In RGBA mode, you need to enable blending. The blending factors you most likely want to use are)Tj
0 -1.5 TD
(GL_SRC_ALPHA \(source\) and GL_ONE_MINUS_SRC_ALPHA \(destination\). Alternatively, you can)Tj
T*
(use GL_ONE for the destination factor to make lines a little brighter where they intersect. Now you're)Tj
T*
(ready to draw whatever points or lines you want antialiased. The antialiased effect is most noticeable if)Tj
T*
(you use a fairly high alpha value. Remember that since you're performing blending, you might need to)Tj
T*
[(consider the rendering order as described in )47("Three-Dimensional Blending with the Depth Buffer.")]TJ
T*
(However, in most cases, the ordering can be ignored without significant adverse effects. Example 6-3)Tj
T*
(initializes the necessary modes for antialiasing and then draws two intersecting diagonal lines. When you)Tj
T*
(run this program, press the `r' key to rotate the lines so that you can see the effect of antialiasing on lines)Tj
T*
(of different slopes. Note that the depth buffer isn't enabled in this example.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 6-3 )Tj
/F11 1 Tf
6.1 0 TD
(Antialiased lines: aargb.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(static float rotAngle = 0.;)Tj
T*
(/*  Initialize antialiasing for RGBA mode, including alpha)Tj
0 -1.5 TD
( *  blending, hint, and line width.  Print out implementation)Tj
T*
( *  specific info on line width granularity and width.)Tj
T*
( */)Tj
T*
(void init\(void\))Tj
T*
({)Tj
T*
(   GLfloat values[2];)Tj
T*
(   glGetFloatv \(GL_LINE_WIDTH_GRANULARITY, values\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 14)Tj
ET
endstream
endobj
664 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
666 0 obj
<<
/Length 1774
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   printf \("GL_LINE_WIDTH_GRANULARITY value is %3.1f\\n",)Tj
0 -1.5 TD
(      values[0]\);)Tj
T*
(   glGetFloatv \(GL_LINE_WIDTH_RANGE, values\);)Tj
T*
(   printf \("GL_LINE_WIDTH_RANGE values are %3.1f %3.1f\\n",)Tj
T*
(      values[0], values[1]\);)Tj
0 -3 TD
(   glEnable \(GL_LINE_SMOOTH\);)Tj
0 -1.5 TD
(   glEnable \(GL_BLEND\);)Tj
T*
(   glBlendFunc \(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA\);)Tj
T*
(   glHint \(GL_LINE_SMOOTH_HINT, GL_DONT_CARE\);)Tj
T*
(   glLineWidth \(1.5\);)Tj
0 -3 TD
(   glClearColor\(0.0, 0.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(/* Draw 2 diagonal lines to form an X */)Tj
0 -1.5 TD
(void display\(void\))Tj
T*
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -3 TD
(   glColor3f \(0.0, 1.0, 0.0\);)Tj
0 -1.5 TD
(   glPushMatrix\(\);)Tj
T*
(   glRotatef\(-rotAngle, 0.0, 0.0, 0.1\);)Tj
T*
(   glBegin \(GL_LINES\);)Tj
T*
(      glVertex2f \(-0.5, 0.5\);)Tj
T*
(      glVertex2f \(0.5, -0.5\);)Tj
T*
(   glEnd \(\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(   glColor3f \(0.0, 0.0, 1.0\);)Tj
0 -1.5 TD
(   glPushMatrix\(\);)Tj
T*
(   glRotatef\(rotAngle, 0.0, 0.0, 0.1\);)Tj
T*
(   glBegin \(GL_LINES\);)Tj
T*
(      glVertex2f \(0.5, 0.5\);)Tj
T*
(      glVertex2f \(-0.5, -0.5\);)Tj
T*
(   glEnd \(\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(   glFlush\(\);)Tj
0 -1.5 TD
(})Tj
T*
(void reshape\(int w, int h\))Tj
T*
({)Tj
T*
(   glViewport\(0, 0, \(GLint\) w, \(GLint\) h\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 15)Tj
ET
endstream
endobj
667 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
670 0 obj
<<
/Length 1688
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\) )Tj
T*
(      gluOrtho2D \(-1.0, 1.0, )Tj
T*
(         -1.0*\(GLfloat\)h/\(GLfloat\)w, 1.0*\(GLfloat\)h/\(GLfloat\)w\);)Tj
T*
(   else )Tj
T*
(      gluOrtho2D \(-1.0*\(GLfloat\)w/\(GLfloat\)h, )Tj
T*
(         1.0*\(GLfloat\)w/\(GLfloat\)h, -1.0, 1.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `r':)Tj
T*
(      case `R':)Tj
T*
(         rotAngle += 20.;)Tj
T*
(         if \(rotAngle >= 360.\) rotAngle = 0.;)Tj
T*
(         glutPostRedisplay\(\);   )Tj
T*
(         break;)Tj
T*
(      case 27:  /*  Escape Key  */)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(    })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(200, 200\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc \(reshape\);)Tj
T*
(   glutKeyboardFunc \(keyboard\);)Tj
T*
(   glutDisplayFunc \(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 16)Tj
ET
endstream
endobj
671 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
673 0 obj
<<
/Length 2380
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Antialiasing in Color-Index Mode)Tj
/F11 1 Tf
0 -2.1 TD
(The tricky part about antialiasing in color-index mode is loading and using the color map. Since the last 4)Tj
0 -1.5 TD
(bits of the color index indicate the coverage value, you need to load sixteen contiguous indices with a)Tj
T*
(color ramp from the background color to the object's color. \(The ramp has to start with an index value)Tj
T*
(that's a multiple of 16.\) Then you clear the color buffer to the first of the sixteen colors in the ramp and)Tj
T*
[(draw your points or lines using colors in the ramp. )17(Example 6-4)170( demonstrates how to construct the color)]TJ
T*
(ramp to draw antialiased lines in color-index mode. In this example, two color ramps are created: one)Tj
T*
(contains shades of green and the other shades of blue.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 6-4 )Tj
/F11 1 Tf
6.1 0 TD
(Antialiasing in Color-Index Mode: aaindex.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(#define RAMPSIZE 16)Tj
0 -1.5 TD
(#define RAMP1START 32)Tj
T*
(#define RAMP2START 48)Tj
0 -3 TD
(static float rotAngle = 0.;)Tj
T*
(/*  Initialize antialiasing for color-index mode,)Tj
0 -1.5 TD
( *  including loading a green color ramp starting)Tj
T*
( *  at RAMP1START, and a blue color ramp starting)Tj
T*
( *  at RAMP2START. The ramps must be a multiple of 16.)Tj
T*
( */)Tj
T*
(void init\(void\))Tj
T*
({)Tj
T*
(   int i;)Tj
0 -3 TD
(   for \(i = 0; i < RAMPSIZE; i++\) {)Tj
0 -1.5 TD
(      GLfloat shade;)Tj
T*
(      shade = \(GLfloat\) i/\(GLfloat\) RAMPSIZE;)Tj
T*
(      glutSetColor\(RAMP1START+\(GLint\)i, 0., shade, 0.\);)Tj
T*
(      glutSetColor\(RAMP2START+\(GLint\)i, 0., 0., shade\);)Tj
T*
(   })Tj
T*
(   glEnable \(GL_LINE_SMOOTH\);)Tj
T*
(   glHint \(GL_LINE_SMOOTH_HINT, GL_DONT_CARE\);)Tj
T*
(   glLineWidth \(1.5\);)Tj
0 -3 TD
(   glClearIndex \(\(GLfloat\) RAMP1START\);)Tj
0 -1.5 TD
(})Tj
T*
(/*  Draw 2 diagonal lines to form an X */)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 17)Tj
ET
endstream
endobj
674 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
676 0 obj
<<
/Length 1689
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -3 TD
(   glIndexi\(RAMP1START\);)Tj
0 -1.5 TD
(   glPushMatrix\(\);)Tj
T*
(   glRotatef\(-rotAngle, 0.0, 0.0, 0.1\);)Tj
T*
(   glBegin \(GL_LINES\);)Tj
T*
(      glVertex2f \(-0.5, 0.5\);)Tj
T*
(      glVertex2f \(0.5, -0.5\);)Tj
T*
(   glEnd \(\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(   glIndexi\(RAMP2START\);)Tj
0 -1.5 TD
(   glPushMatrix\(\);)Tj
T*
(   glRotatef\(rotAngle, 0.0, 0.0, 0.1\);)Tj
T*
(   glBegin \(GL_LINES\);)Tj
T*
(      glVertex2f \(0.5, 0.5\);)Tj
T*
(      glVertex2f \(-0.5, -0.5\);)Tj
T*
(   glEnd \(\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(   glFlush\(\);)Tj
0 -1.5 TD
(})Tj
0 -4.5 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\) )Tj
T*
(      gluOrtho2D \(-1.0, 1.0, )Tj
T*
(         -1.0*\(GLfloat\)h/\(GLfloat\)w, 1.0*\(GLfloat\)h/\(GLfloat\)w\);)Tj
T*
(   else )Tj
T*
(      gluOrtho2D \(-1.0*\(GLfloat\)w/\(GLfloat\)h, )Tj
T*
(         1.0*\(GLfloat\)w/\(GLfloat\)h, -1.0, 1.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
T*
(void keyboard\(unsigned char key, int x, int y\))Tj
T*
({)Tj
T*
(   switch \(key\) {)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 18)Tj
ET
endstream
endobj
677 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
679 0 obj
<<
/Length 2791
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      case `r':)Tj
0 -1.5 TD
(      case `R':)Tj
T*
(         rotAngle += 20.;)Tj
T*
(         if \(rotAngle >= 360.\) rotAngle = 0.;)Tj
T*
(         glutPostRedisplay\(\);   )Tj
T*
(         break;)Tj
T*
(      case 27:  /*  Escape Key */)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(    })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_INDEX\);)Tj
T*
(   glutInitWindowSize \(200, 200\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc \(reshape\);)Tj
T*
(   glutKeyboardFunc \(keyboard\);)Tj
T*
(   glutDisplayFunc \(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.2 TD
(Since the color ramp goes from the background color to the object's color, the antialiased lines look)Tj
0 -1.5 TD
(correct only in the areas where they are drawn on top of the background. When the blue line is drawn, it)Tj
T*
(erases part of the green line at the point where the lines intersect. To fix this, you would need to redraw)Tj
T*
(the area where the lines intersect using a ramp that goes from green \(the color of the line in the)Tj
T*
(framebuffer\) to blue \(the color of the line being drawn\). However, this requires additional calculations)Tj
T*
(and it is usually not worth the effort since the intersection area is small. Note that this is not a problem in)Tj
T*
(RGBA mode, since the colors of object being drawn are blended with the color already in the)Tj
T*
(framebuffer.)Tj
0 -2.1 TD
(You may also want to enable the depth test when drawing antialiased points and lines in color-index)Tj
0 -1.5 TD
(mode. In this example, the depth test is disabled since both of the lines lie in the same )Tj
/F15 1 Tf
34.6 0 TD
(z)Tj
/F11 1 Tf
0.3 0 TD
(-plane. However,)Tj
-34.9 -1.5 TD
(if you want to draw a three-dimensional scene, you should enable the depth buffer so that the resulting)Tj
T*
(pixel colors correspond to the "nearest" objects.)Tj
0 -2.1 TD
[(The trick described in "Three-Dimensional Blending with the Depth Buffer")197( can also be used to mix)]TJ
0 -1.5 TD
(antialiased points and lines with aliased, depth-buffered polygons. To do this, draw the polygons first,)Tj
T*
(then make the depth buffer read-only and draw the points and lines. The points and lines intersect nicely)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 19)Tj
ET
endstream
endobj
680 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
682 0 obj
<<
/Length 4658
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(with each other but will be obscured by nearer polygons.)Tj
/F27 1 Tf
8 -2.1 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
[(Take a previous program, such as the robot arm or solar system examples described in )-25("Examples of)]TJ
0 -1.5 TD
[(Composing Several Transformations" in Chapter 3)25(,)0( and draw wireframe objects with antialiasing. Try it)]TJ
T*
(in either RGBA or color-index mode. Also try different line widths or point sizes to see their effects.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 609.000 Tm
(Antialiasing Polygons)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 587.000 Tm
(Antialiasing the edges of filled polygons is similar to antialiasing points and lines. When different)Tj
T*
(polygons have overlapping edges, you need to blend the color values appropriately. You can either use)Tj
T*
(the method described in this section, or you can use the accumulation buffer to perform antialiasing for)Tj
T*
[(your entire scene. Using the accumulation buffer, which is described in )47(Chapter 10)-84(, is easier from your)]TJ
T*
(point of view, but it's much more computation-intensive and therefore slower. However, as you'll see,)Tj
T*
(the method described here is rather cumbersome.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(If you draw your polygons as points at the vertices or as outlines)Tj
/F33 1 Tf
25.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, by passing GL_POINT)Tj
-29.7 -1.6 TD
(or GL_LINE to )Tj
/F15 1 Tf
6.5 0 TD
(glPolygonMode\(\))Tj
/F33 1 Tf
7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(point or line antialiasing is applied, if enabled as described earlier.)Tj
-14.5 -1.5 TD
(The rest of this section addresses polygon antialiasing when you're using GL_FILL as the polygon mode.)Tj
0 -2.1 TD
(In theory, you can antialias polygons in either RGBA or color-index mode. However, object intersections)Tj
0 -1.5 TD
(affect polygon antialiasing more than they affect point or line antialiasing, so rendering order and)Tj
T*
(blending accuracy become more critical. In fact, they're so critical that if you're antialiasing more than)Tj
T*
(one polygon, you need to order the polygons from front to back and then use )Tj
/F15 1 Tf
30.9 0 TD
(glBlendFunc\(\))Tj
/F11 1 Tf
5.9 0 TD
( with)Tj
-36.8 -1.5 TD
(GL_SRC_ALPHA_SATURATE for the source factor and GL_ONE for the destination factor. Thus,)Tj
T*
(antialiasing polygons in color-index mode normally isn't practical.)Tj
0 -2.1 TD
(To antialias polygons in RGBA mode, you use the alpha value to represent coverage values of polygon)Tj
0 -1.5 TD
(edges. You need to enable polygon antialiasing by passing GL_POLYGON_SMOOTH to )Tj
/F15 1 Tf
36.3 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
(.)Tj
-40.6 -1.5 TD
(This causes pixels on the edges of the polygon to be assigned fractional alpha values based on their)Tj
T*
(coverage, as though they were lines being antialiased. Also, if you desire, you can supply a value for)Tj
T*
(GL_POLYGON_SMOOTH_HINT.)Tj
0 -2.1 TD
(Now you need to blend overlapping edges appropriately. First, turn off the depth buffer so that you have)Tj
0 -1.5 TD
(control over how overlapping pixels are drawn. Then set the blending factors to)Tj
T*
(GL_SRC_ALPHA_SATURATE \(source\) and GL_ONE \(destination\). With this specialized blending)Tj
T*
(function, the final color is the sum of the destination color and the scaled source color; the scale factor is)Tj
T*
(the smaller of either the incoming source alpha value or one minus the destination alpha value. This)Tj
T*
(means that for a pixel with a large alpha value, successive incoming pixels have little effect on the final)Tj
T*
(color because one minus the destination alpha is almost zero. With this method, a pixel on the edge of a)Tj
T*
(polygon might be blended eventually with the colors from another polygon that's drawn later. Finally,)Tj
T*
(you need to sort all the polygons in your scene so that they're ordered from front to back before drawing)Tj
T*
(them.)Tj
0 -2.1 TD
(Example 6-5)Tj
5.1 0 TD
( shows how to antialias filled polygons; clicking the left mouse button toggles the)Tj
-5.1 -1.5 TD
(antialiasing on and off. Note that backward-facing polygons are culled and that the alpha values in the)Tj
T*
(color buffer are cleared to zero before any drawing. Pressing the `t' key toggles the antialiasing on and)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 20)Tj
ET
endstream
endobj
683 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
685 0 obj
<<
/Length 2024
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(off.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
0.000 Tw
(Your color buffer must store alpha values for this technique to work correctly. Make sure you)Tj
-2.8 -1.5 TD
(request GLUT_ALPHA and receive a legitimate window.)Tj
/F27 1 Tf
0 -2 TD
(Example 6-5 )Tj
/F11 1 Tf
6.1 0 TD
(Antialiasing Filled Polygons: aapoly.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
T*
(#include <string.h>)Tj
0 -3 TD
(GLboolean polySmooth = GL_TRUE;)Tj
0 -1.5 TD
(static void init\(void\))Tj
T*
({)Tj
T*
(   glCullFace \(GL_BACK\);)Tj
T*
(   glEnable \(GL_CULL_FACE\);)Tj
T*
(   glBlendFunc \(GL_SRC_ALPHA_SATURATE, GL_ONE\);)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(})Tj
0 -3 TD
(#define NFACE 6)Tj
0 -1.5 TD
(#define NVERT 8)Tj
T*
(void drawCube\(GLdouble x0, GLdouble x1, GLdouble y0, )Tj
T*
(              GLdouble y1, GLdouble z0, GLdouble z1\))Tj
T*
({)Tj
T*
(   static GLfloat v[8][3];)Tj
T*
(   static GLfloat c[8][4] = {)Tj
T*
(      {0.0, 0.0, 0.0, 1.0}, {1.0, 0.0, 0.0, 1.0},)Tj
T*
(      {0.0, 1.0, 0.0, 1.0}, {1.0, 1.0, 0.0, 1.0},)Tj
T*
(      {0.0, 0.0, 1.0, 1.0}, {1.0, 0.0, 1.0, 1.0},)Tj
T*
(      {0.0, 1.0, 1.0, 1.0}, {1.0, 1.0, 1.0, 1.0})Tj
T*
(   };)Tj
0 -3 TD
(/*  indices of front, top, left, bottom, right, back faces  */)Tj
0 -1.5 TD
(   static GLubyte indices[NFACE][4] = {)Tj
T*
(      {4, 5, 6, 7}, {2, 3, 7, 6}, {0, 4, 7, 3},)Tj
T*
(      {0, 1, 5, 4}, {1, 5, 6, 2}, {0, 3, 2, 1})Tj
T*
(   };)Tj
0 -3 TD
(   v[0][0] = v[3][0] = v[4][0] = v[7][0] = x0;)Tj
0 -1.5 TD
(   v[1][0] = v[2][0] = v[5][0] = v[6][0] = x1;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 21)Tj
ET
endstream
endobj
686 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
688 0 obj
<<
/Length 2011
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   v[0][1] = v[1][1] = v[4][1] = v[5][1] = y0;)Tj
0 -1.5 TD
(   v[2][1] = v[3][1] = v[6][1] = v[7][1] = y1;)Tj
T*
(   v[0][2] = v[1][2] = v[2][2] = v[3][2] = z0;)Tj
T*
(   v[4][2] = v[5][2] = v[6][2] = v[7][2] = z1;)Tj
0 -3 TD
(#ifdef GL_VERSION_1_1)Tj
0 -1.5 TD
(   glEnableClientState \(GL_VERTEX_ARRAY\);)Tj
T*
(   glEnableClientState \(GL_COLOR_ARRAY\);)Tj
T*
(   glVertexPointer \(3, GL_FLOAT, 0, v\);)Tj
T*
(   glColorPointer \(4, GL_FLOAT, 0, c\);)Tj
T*
(   glDrawElements\(GL_QUADS, NFACE*4, GL_UNSIGNED_BYTE, indices\);)Tj
T*
(   glDisableClientState \(GL_VERTEX_ARRAY\);)Tj
T*
(   glDisableClientState \(GL_COLOR_ARRAY\);)Tj
T*
(#else)Tj
T*
(   printf \("If this is GL Version 1.0, "\);)Tj
T*
(   printf \("vertex arrays are not supported.\\n"\);)Tj
T*
(   exit\(1\);)Tj
T*
(#endif)Tj
T*
(})Tj
T*
(/*  Note:  polygons must be drawn from front to back)Tj
T*
( *  for proper blending.)Tj
T*
( */)Tj
T*
(void display\(void\))Tj
T*
({)Tj
T*
(   if \(polySmooth\) {)Tj
T*
(      glClear \(GL_COLOR_BUFFER_BIT\);)Tj
T*
(      glEnable \(GL_BLEND\);)Tj
T*
(      glEnable \(GL_POLYGON_SMOOTH\);)Tj
T*
(      glDisable \(GL_DEPTH_TEST\);)Tj
T*
(   })Tj
T*
(   else { )Tj
T*
(      glClear \(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(      glDisable \(GL_BLEND\);)Tj
T*
(      glDisable \(GL_POLYGON_SMOOTH\);)Tj
T*
(      glEnable \(GL_DEPTH_TEST\);)Tj
T*
(   })Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(      glTranslatef \(0.0, 0.0, -8.0\);    )Tj
T*
(      glRotatef \(30.0, 1.0, 0.0, 0.0\);)Tj
T*
(      glRotatef \(60.0, 0.0, 1.0, 0.0\); )Tj
T*
(      drawCube\(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5\);)Tj
T*
(   glPopMatrix \(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 22)Tj
ET
endstream
endobj
689 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
691 0 obj
<<
/Length 1628
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 697.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glFlush \(\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluPerspective\(30.0, \(GLfloat\) w/\(GLfloat\) h, 1.0, 20.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
T*
(void keyboard\(unsigned char key, int x, int y\))Tj
T*
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `t':)Tj
T*
(      case `T':)Tj
T*
(         polySmooth = !polySmooth;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);  /*  Escape key  */)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB )Tj
T*
(                        | GLUT_ALPHA | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize\(200, 200\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutReshapeFunc \(reshape\);)Tj
T*
(   glutKeyboardFunc \(keyboard\);)Tj
T*
(   glutDisplayFunc \(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 23)Tj
ET
endstream
endobj
692 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
694 0 obj
<<
/Length 3419
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 696.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(Fog)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 674.000 Tm
0.000 Tw
(Computer images sometimes seem unrealistically sharp and well defined. Antialiasing makes an object)Tj
0 -1.5 TD
(appear more realistic by smoothing its edges. Additionally, you can make an entire image appear more)Tj
T*
(natural by adding fog, which makes objects fade into the distance. )Tj
/F15 1 Tf
26.7 0 TD
(Fog)Tj
/F11 1 Tf
1.6 0 TD
( is a general term that describes)Tj
-28.3 -1.5 TD
(similar forms of atmospheric effects; it can be used to simulate haze, mist, smoke, or pollution. \(See)Tj
T*
(Plate 9.\) Fog is essential in visual-simulation applications, where limited visibility needs to be)Tj
T*
(approximated. It's often incorporated into flight-simulator displays.)Tj
0 -2.1 TD
(When fog is enabled, objects that are farther from the viewpoint begin to fade into the fog color. You can)Tj
0 -1.5 TD
(control the density of the fog, which determines the rate at which objects fade as the distance increases,)Tj
T*
(as well as the fog's color. Fog is available in both RGBA and color-index modes, although the)Tj
T*
(calculations are slightly different in the two modes. Since fog is applied after matrix transformations,)Tj
T*
(lighting, and texturing are performed, it affects transformed, lit, and textured objects. Note that with large)Tj
T*
(simulation programs, fog can improve performance, since you can choose not to draw objects that would)Tj
T*
(be too fogged to be visible.)Tj
0 -2.1 TD
(All types of geometric primitives can be fogged, including points and lines. Using the fog effect on)Tj
0 -1.5 TD
(points and lines is also called )Tj
/F13 1 Tf
11.9 0 TD
(depth-cuing)Tj
/F11 1 Tf
5.2 0 TD
( \(as shown in Plate 2\) and is popular in molecular modeling)Tj
-17.1 -1.5 TD
(and other applications.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 408.000 Tm
(Using Fog)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 386.000 Tm
(Using fog is easy. You enable it by passing GL_FOG to )Tj
/F15 1 Tf
22.7 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.2 0 TD
(, and you choose the color and the)Tj
-26.9 -1.5 TD
(equation that controls the density with )Tj
/F15 1 Tf
15.6 0 TD
(glFog*\(\))Tj
/F11 1 Tf
3.5 0 TD
(. If you want, you can supply a value for GL_FOG_HINT)Tj
-19.1 -1.5 TD
(with )Tj
/F15 1 Tf
2 0 TD
(glHint\(\))Tj
/F11 1 Tf
3.3 0 TD
[(, as described on )16(Table 6-2)]TJ
10.7 0 TD
[(. Example 6-6)170( draws five red spheres, each at a different distance)]TJ
-16 -1.5 TD
(from the viewpoint. Pressing the `f' key selects among the three different fog equations, which are)Tj
T*
(described in the next section.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 6-6 )Tj
/F11 1 Tf
6.1 0 TD
(Five Fogged Spheres in RGBA Mode: fog.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <math.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(static GLint fogMode;)Tj
T*
(static void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat position[] = { 0.5, 0.5, 3.0, 0.0 };)Tj
0 -3 TD
(   glEnable\(GL_DEPTH_TEST\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 24)Tj
ET
endstream
endobj
695 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
697 0 obj
<<
/Length 1931
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 697.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glLightfv\(GL_LIGHT0, GL_POSITION, position\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHTING\);)Tj
T*
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   {)Tj
T*
(      GLfloat mat[3] = {0.1745, 0.01175, 0.01175};      )Tj
T*
(      glMaterialfv \(GL_FRONT, GL_AMBIENT, mat\);)Tj
T*
(      mat[0] = 0.61424; mat[1] = 0.04136; mat[2] = 0.04136;     )Tj
T*
(      glMaterialfv \(GL_FRONT, GL_DIFFUSE, mat\);)Tj
T*
(      mat[0] = 0.727811; mat[1] = 0.626959; mat[2] = 0.626959;)Tj
T*
(      glMaterialfv \(GL_FRONT, GL_SPECULAR, mat\);)Tj
T*
(      glMaterialf \(GL_FRONT, GL_SHININESS, 0.6*128.0\);)Tj
T*
(   })Tj
0 -3 TD
(   glEnable\(GL_FOG\);)Tj
0 -1.5 TD
(   {)Tj
T*
(      GLfloat fogColor[4] = {0.5, 0.5, 0.5, 1.0};)Tj
0 -3 TD
(      fogMode = GL_EXP;)Tj
0 -1.5 TD
(      glFogi \(GL_FOG_MODE, fogMode\);)Tj
T*
(      glFogfv \(GL_FOG_COLOR, fogColor\);)Tj
T*
(      glFogf \(GL_FOG_DENSITY, 0.35\);)Tj
T*
(      glHint \(GL_FOG_HINT, GL_DONT_CARE\);)Tj
T*
(      glFogf \(GL_FOG_START, 1.0\);)Tj
T*
(      glFogf \(GL_FOG_END, 5.0\);)Tj
T*
(   })Tj
T*
(   glClearColor\(0.5, 0.5, 0.5, 1.0\);  /* fog color */)Tj
T*
(})Tj
0 -3 TD
(static void renderSphere \(GLfloat x, GLfloat y, GLfloat z\))Tj
0 -1.5 TD
({)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glTranslatef \(x, y, z\);)Tj
T*
(   glutSolidSphere\(0.4, 16, 16\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(})Tj
0 -3 TD
(/* display\(\) draws 5 spheres at different z positions.)Tj
0 -1.5 TD
( */)Tj
T*
(void display\(void\))Tj
T*
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   renderSphere \(-2., -0.5, -1.0\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 25)Tj
ET
endstream
endobj
698 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
701 0 obj
<<
/Length 1895
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   renderSphere \(-1., -0.5, -2.0\);)Tj
0 -1.5 TD
(   renderSphere \(0., -0.5, -3.0\);)Tj
T*
(   renderSphere \(1., -0.5, -4.0\);)Tj
T*
(   renderSphere \(2., -0.5, -5.0\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho \(-2.5, 2.5, -2.5*\(GLfloat\)h/\(GLfloat\)w,)Tj
T*
(         2.5*\(GLfloat\)h/\(GLfloat\)w, -10.0, 10.0\);)Tj
T*
(   else)Tj
T*
(      glOrtho \(-2.5*\(GLfloat\)w/\(GLfloat\)h,)Tj
T*
(         2.5*\(GLfloat\)w/\(GLfloat\)h, -2.5, 2.5, -10.0, 10.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `f':)Tj
T*
(      case `F':)Tj
T*
(         if \(fogMode == GL_EXP\) {)Tj
T*
(            fogMode = GL_EXP2;)Tj
T*
(            printf \("Fog mode is GL_EXP2\\n"\);)Tj
T*
(         })Tj
T*
(         else if \(fogMode == GL_EXP2\) {)Tj
T*
(            fogMode = GL_LINEAR;)Tj
T*
(            printf \("Fog mode is GL_LINEAR\\n"\);)Tj
T*
(         })Tj
T*
(         else if \(fogMode == GL_LINEAR\) {)Tj
T*
(            fogMode = GL_EXP;)Tj
T*
(            printf \("Fog mode is GL_EXP\\n"\);)Tj
T*
(         })Tj
T*
(         glFogi \(GL_FOG_MODE, fogMode\);)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case 27:)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 26)Tj
ET
endstream
endobj
702 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
703 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im66
/Width 203
/Height 85
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.65)
>>
stream
endstream
endobj
705 0 obj
<<
/Length 3076
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(         exit\(0\);)Tj
0 -1.5 TD
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize\(500, 500\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc \(reshape\);)Tj
T*
(   glutKeyboardFunc \(keyboard\);)Tj
T*
(   glutDisplayFunc \(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 398.000 Tm
(Fog Equations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 376.000 Tm
(Fog blends a fog color with an incoming fragment's color using a fog blending factor. This factor, )Tj
/F15 1 Tf
39.5 0 TD
(f)Tj
/F11 1 Tf
0.3 0 TD
(, is)Tj
-39.8 -1.5 TD
(computed with one of these three equations and then clamped to the range [0,1].)Tj
ET
Q
/GS1 gs
q
203 0 0 85 124 262.18 cm
/Im66 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 243.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(In these three equations,)Tj
/F15 1 Tf
9.7 0 TD
( z)Tj
/F11 1 Tf
0.7 0 TD
( is the eye-coordinate distance between the viewpoint and the fragment center.)Tj
-10.4 -1.5 TD
(The values for )Tj
/F15 1 Tf
6 0 TD
(density, start)Tj
/F11 1 Tf
5.2 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(end)Tj
/F11 1 Tf
1.4 0 TD
( are all specified with )Tj
/F15 1 Tf
8.9 0 TD
(glFog*\(\))Tj
/F11 1 Tf
3.5 0 TD
(. The)Tj
/F15 1 Tf
2.1 0 TD
( f)Tj
/F11 1 Tf
0.5 0 TD
( factor is used differently,)Tj
-29.8 -1.5 TD
(depending on whether you're in RGBA mode or color-index mode, as explained in the next subsections.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glFog)-11({if}\(GLenum )84(pname)-34(, TYPE param\);)]TJ
0 -1.1 TD
[(void )-28(glFog)-11({if})56(v)-56(\(GLenum )27(pname)-34(, TYPE *params)85(\);)]TJ
1.8 -1.5 TD
[(Sets the parameters and function for calculating fog. If )25(pname)-34( is GL_FOG_MODE, then )61(param)-89( is)]TJ
T*
(either GL_EXP \(the default\), GL_EXP2, or GL_LINEAR to select one of the three fog factors. If)Tj
T*
[(pname)-34( is GL_FOG_DENSITY, GL_FOG_START, or GL_FOG_END, then )59(param)11( is \(or points to,)]TJ
T*
[(with the vector version of the command\) a value for )45(density)-67(, start)34(, or )39(end)-56( in the equations. \(The)]TJ
T*
[(default values are 1, 0, and 1, respectively.\) In RGBA mode, )32(pname)-34( can be GL_FOG_COLOR, in)]TJ
T*
[(which case )-33(params points to four values that specify the fog's RGBA color values. The)]TJ
T*
[(corresponding value for )17(pname)-34( in color-index mode is GL_FOG_INDEX, for which )]TJ
33.9 0 TD
[(param)11( is a)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 27)Tj
ET
endstream
endobj
706 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im66 703 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
707 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im67
/Width 440
/Height 240
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.66)
>>
stream
endstream
endobj
709 0 obj
<<
/Length 3040
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(single value specifying the fog's color index.)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(Figure 6-4)225( plots the fog-density equations for various values of the parameters.)]TJ
ET
Q
q
1 i 
124.000 674.180 423.000 -230.720 re
W n
/GS1 gs
q
423 0 0 231 124 443.1801 cm
/Im67 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 431.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 6-4 )Tj
/F11 1 Tf
5.1 0 TD
(Fog-Density Equations)Tj
/F27 1 Tf
-5.1 -3 TD
(Fog in RGBA Mode)Tj
/F11 1 Tf
0 -2.1 TD
(In RGBA mode, the fog factor )Tj
/F15 1 Tf
12.5 0 TD
(f)Tj
/F11 1 Tf
0.2 0 TD
( is used as follows to calculate the final fogged color:)Tj
-12.7 -2.1 TD
(C = )Tj
/F15 1 Tf
1.7 0 TD
(f)Tj
/F11 1 Tf
0.3 0 TD
( C)Tj
0.9 -0.2 TD
(i)Tj
0.3 0.2 TD
( + \(1 - )Tj
/F15 1 Tf
2.7 0 TD
(f)Tj
/F11 1 Tf
0.3 0 TD
( \) C)Tj
1.5 -0.2 TD
(f)Tj
-7.7 -2.1 TD
(where C)Tj
3.4 -0.2 TD
(i)Tj
0.2 0.2 TD
( represents the incoming fragment's RGBA values and C)Tj
22.9 -0.2 TD
(f)Tj
0.3 0.2 TD
( the fog-color values assigned with)Tj
-26.8 -1.7 TD
(GL_FOG_COLOR.)Tj
/F27 1 Tf
0 -3 TD
(Fog in Color-Index Mode)Tj
/F11 1 Tf
0 -2.1 TD
(In color-index mode, the final fogged color index is computed as follows:)Tj
T*
(I = I)Tj
1.7 -0.2 TD
(i)Tj
0.3 0.2 TD
( + \(1 - )Tj
/F15 1 Tf
2.7 0 TD
(f)Tj
/F11 1 Tf
0.3 0 TD
( \) I)Tj
1.2 -0.2 TD
(f)Tj
-6.2 -2.1 TD
(where I)Tj
3 -0.2 TD
(i)Tj
0.3 0.2 TD
( is the incoming fragment's color index and I)Tj
18.1 -0.2 TD
(f)Tj
0.3 0.2 TD
( is the fog's color index as specified with)Tj
-21.7 -1.7 TD
(GL_FOG_INDEX.)Tj
0 -2.1 TD
(To use fog in color-index mode, you have to load appropriate values in a color ramp. The first color in)Tj
0 -1.5 TD
(the ramp is the color of the object without fog, and the last color in the ramp is the color of the)Tj
T*
(completely fogged object. You probably want to use )Tj
/F15 1 Tf
21.2 0 TD
(glClearIndex\(\))Tj
/F11 1 Tf
6 0 TD
( to initialize the background color)Tj
-27.2 -1.5 TD
(index so that it corresponds to the last color in the ramp; this way, totally fogged objects blend into the)Tj
T*
(background. Similarly, before objects are drawn, you should call )Tj
/F15 1 Tf
26.2 0 TD
(glIndex*\(\))Tj
/F11 1 Tf
4.1 0 TD
( and pass in the index of the)Tj
-30.3 -1.5 TD
(first color in the ramp \(the unfogged color\). Finally, to apply fog to different colored objects in the scene,)Tj
T*
(you need to create several color ramps and call )Tj
/F15 1 Tf
19 0 TD
(glIndex*\(\))Tj
/F11 1 Tf
4.2 0 TD
( before each object is drawn to set the current)Tj
-23.2 -1.5 TD
[(color index to the start of each color ramp. )-24(Example 6-7)]TJ
22.4 0 TD
( illustrates how to initialize appropriate)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 28)Tj
ET
endstream
endobj
710 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im67 707 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
712 0 obj
<<
/Length 1767
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(conditions and then apply fog in color-index mode.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 6-7 )Tj
/F11 1 Tf
6.1 0 TD
(Fog in Color-Index Mode: fogindex.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <math.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(/*  Initialize color map and fog.  Set screen clear color)Tj
0 -1.5 TD
( *  to end of color ramp.)Tj
T*
( */)Tj
T*
(#define NUMCOLORS 32)Tj
T*
(#define RAMPSTART 16)Tj
0 -3 TD
(static void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i;)Tj
0 -3 TD
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   for \(i = 0; i < NUMCOLORS; i++\) {)Tj
0 -1.5 TD
(      GLfloat shade;)Tj
T*
(      shade = \(GLfloat\) \(NUMCOLORS-i\)/\(GLfloat\) NUMCOLORS;)Tj
T*
(      glutSetColor \(RAMPSTART + i, shade, shade, shade\);)Tj
T*
(   })Tj
T*
(   glEnable\(GL_FOG\);)Tj
0 -3 TD
(   glFogi \(GL_FOG_MODE, GL_LINEAR\);)Tj
0 -1.5 TD
(   glFogi \(GL_FOG_INDEX, NUMCOLORS\);)Tj
T*
(   glFogf \(GL_FOG_START, 1.0\);)Tj
T*
(   glFogf \(GL_FOG_END, 6.0\);)Tj
T*
(   glHint \(GL_FOG_HINT, GL_NICEST\);)Tj
T*
(   glClearIndex\(\(GLfloat\) \(NUMCOLORS+RAMPSTART-1\)\);)Tj
T*
(})Tj
0 -3 TD
(static void renderSphere \(GLfloat x, GLfloat y, GLfloat z\))Tj
0 -1.5 TD
({)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glTranslatef \(x, y, z\);)Tj
T*
(   glutWireSphere\(0.4, 16, 16\);)Tj
T*
(   glPopMatrix\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 29)Tj
ET
endstream
endobj
713 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
715 0 obj
<<
/Length 1632
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(})Tj
0 -3 TD
(/*  display\(\) draws 5 spheres at different z positions.)Tj
0 -1.5 TD
( */)Tj
T*
(void display\(void\))Tj
T*
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glIndexi \(RAMPSTART\);)Tj
0 -3 TD
(   renderSphere \(-2., -0.5, -1.0\);)Tj
0 -1.5 TD
(   renderSphere \(-1., -0.5, -2.0\);)Tj
T*
(   renderSphere \(0., -0.5, -3.0\);)Tj
T*
(   renderSphere \(1., -0.5, -4.0\);)Tj
T*
(   renderSphere \(2., -0.5, -5.0\);)Tj
0 -3 TD
(   glFlush\(\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, w, h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho \(-2.5, 2.5, -2.5*\(GLfloat\)h/\(GLfloat\)w,)Tj
T*
(         2.5*\(GLfloat\)h/\(GLfloat\)w, -10.0, 10.0\);)Tj
T*
(   else)Tj
T*
(      glOrtho \(-2.5*\(GLfloat\)w/\(GLfloat\)h,)Tj
T*
(         2.5*\(GLfloat\)w/\(GLfloat\)h, -2.5, 2.5, -10.0, 10.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
0 -3 TD
(   switch \(key\) {)Tj
0 -1.5 TD
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 30)Tj
ET
endstream
endobj
716 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
718 0 obj
<<
/Length 3703
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
({)Tj
0 -1.5 TD
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_INDEX | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize\(500, 500\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc \(reshape\);)Tj
T*
(   glutKeyboardFunc \(keyboard\);)Tj
T*
(   glutDisplayFunc \(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 513.000 Tm
(Polygon Offset)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 491.000 Tm
(If you want to highlight the edges of a solid object, you might try to draw the object with polygon mode)Tj
T*
(GL_FILL and then draw it again, but in a different color with polygon mode GL_LINE. However,)Tj
T*
(because lines and filled polygons are not rasterized in exactly the same way, the depth values generated)Tj
T*
(for pixels on a line are usually not the same as the depth values for a polygon edge, even between the)Tj
T*
(same two vertices. The highlighting lines may fade in and out of the coincident polygons, which is)Tj
T*
(sometimes called "stitching" and is visually unpleasant.)Tj
0 -2.1 TD
(The visual unpleasantness can be eliminated by using polygon offset, which adds an appropriate offset to)Tj
0 -1.5 TD
(force coincident )Tj
/F15 1 Tf
6.7 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( values apart to cleanly separate a polygon edge from its highlighting line. \(The stencil)Tj
-7.1 -1.5 TD
[(buffer, described in )-46("Stencil Test" in Chapter 10)61(, can also be used to eliminate stitching. However,)]TJ
T*
(polygon offset is almost always faster than stenciling.\) Polygon offset is also useful for applying decals)Tj
T*
(to surfaces, rendering images with hidden-line removal. In addition to lines and filled polygons, this)Tj
T*
(technique can also be used with points.)Tj
0 -2.1 TD
(There are three different ways to turn on polygon offset, one for each type of polygon rasterization mode:)Tj
0 -1.5 TD
(GL_FILL, GL_LINE, or GL_POINT. You enable the polygon offset by passing the appropriate)Tj
T*
(parameter to )Tj
/F15 1 Tf
5.3 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
(, either GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_LINE, or)Tj
-9.6 -1.5 TD
(GL_POLYGON_OFFSET_POINT. You must also call )Tj
/F15 1 Tf
22.4 0 TD
(glPolygonMode\(\))Tj
/F11 1 Tf
7 0 TD
( to set the current polygon)Tj
-29.4 -1.5 TD
(rasterization method.)Tj
/F15 1 Tf
0 -2.1 TD
0.001 Tw
[(void )-27(glPolygonOffset\(GLfloat factor)-11(, GLfloat)12( units\);)]TJ
1.8 -1.5 TD
0.000 Tw
(When enabled, the depth value of each fragment is added to a calculated offset value. The offset is)Tj
T*
(added before the depth test is performed and before the depth value is written into the depth buffer.)Tj
T*
[(The offset value )-16(o is calculated by:)]TJ
T*
[(o = )-25(m)22( * factor)-11( + )-25(r)-11( * units)]TJ
T*
[(where )-6(m)22( is the maximum depth slope of the polygon and )34(r)-11( is the smallest value guaranteed to)]TJ
T*
[(produce a resolvable difference in window coordinate depth values. The value )12(r)-11( is an)]TJ
T*
(implementation-specific constant.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(To achieve a nice rendering of the highlighted solid object without visual artifacts, you can either add a)Tj
0 -1.5 TD
(positive offset to the solid object \(push it away from you\) or a negative offset to the wireframe \(pull it)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 31)Tj
ET
endstream
endobj
719 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
720 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im68
/Width 150
/Height 50
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.67)
>>
stream
endstream
endobj
721 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im69
/Width 351
/Height 160
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.68)
>>
stream
endstream
endobj
723 0 obj
<<
/Length 3617
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(towards you\). The big question is: "How much offset is enough?" Unfortunately, the offset required)Tj
0 -1.5 TD
(depends upon various factors, including the depth slope of each polygon and the width of the lines in the)Tj
T*
(wireframe.)Tj
0 -2.1 TD
[(OpenGL calculates the depth slope \(see )9(Figure 6-5)225(\) of a polygon for you, but it's important that you)]TJ
0 -1.5 TD
(understand what the depth slope is, so that you choose a reasonable value for )Tj
/F15 1 Tf
31 0 TD
(factor)Tj
/F11 1 Tf
2.4 0 TD
(. The depth slope is)Tj
-33.4 -1.5 TD
(the change in )Tj
/F15 1 Tf
5.6 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( \(depth\) values divided by the change in either )Tj
/F15 1 Tf
18.8 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( or )Tj
/F15 1 Tf
1.4 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( coordinates, as you traverse a)Tj
-27 -1.5 TD
(polygon. The depth values are in window coordinates, clamped to the range [0, 1]. To estimate the)Tj
T*
(maximum depth slope of a polygon \()Tj
/F15 1 Tf
14.8 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
( in the offset equation\), use this formula:)Tj
ET
Q
/GS1 gs
q
150 0 0 50 124 534.8 cm
/Im68 Do
Q
q
351 0 0 160 124 362.8 cm
/Im69 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 350.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 6-5 )Tj
/F11 1 Tf
5.1 0 TD
(Polygons and Their Depth Slopes)Tj
-5.1 -2.1 TD
(For polygons that are parallel to the near and far clipping planes, the depth slope is zero. For the)Tj
0 -1.5 TD
(polygons in your scene with a depth slope near zero, only a small, constant offset is needed. To create a)Tj
T*
(small, constant offset, you can pass )Tj
/F15 1 Tf
14.4 0 TD
(factor)Tj
/F11 1 Tf
2.4 0 TD
(=0.0 and )Tj
/F15 1 Tf
3.7 0 TD
(units)Tj
/F11 1 Tf
2 0 TD
(=1.0 to )Tj
/F15 1 Tf
3.1 0 TD
(glPolygonOffset\(\))Tj
/F11 1 Tf
7.1 0 TD
(.)Tj
-32.7 -2.1 TD
(For polygons that are at a great angle to the clipping planes, the depth slope can be significantly greater)Tj
0 -1.5 TD
(than zero, and a larger offset may be needed. Small, non-zero values for )Tj
/F15 1 Tf
29 0 TD
(factor,)Tj
/F11 1 Tf
2.7 0 TD
( such as 0.75 or 1.0, are)Tj
-31.7 -1.5 TD
(probably enough to generate distinct depth values and eliminate the unpleasant visual artifacts.)Tj
0 -2.1 TD
(Example 6-8)Tj
5.1 0 TD
( shows a portion of code, where a display list \(which presumably draws a solid object\) is)Tj
-5.1 -1.5 TD
(first rendered with lighting, the default GL_FILL polygon mode, and polygon offset with )Tj
/F15 1 Tf
36 0 TD
(factor)Tj
/F11 1 Tf
2.4 0 TD
( of 1.0)Tj
-38.4 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(units)Tj
/F11 1 Tf
1.9 0 TD
( of 1.0. These values ensure that the offset is enough for all polygons in your scene, regardless)Tj
-3.6 -1.5 TD
(of depth slope. \(These values may actually be a little more offset than the minimum needed, but too)Tj
T*
(much offset is less noticeable than too little.\) Then, to highlight the edges of the first object, the object is)Tj
T*
(rendered as an unlit wireframe with the offset disabled.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 6-8 )Tj
/F11 1 Tf
6.1 0 TD
(Polygon Offset to Eliminate Visual Artifacts: polyoff.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(   glEnable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_POLYGON_OFFSET_FILL\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 6,  Blending, Antialiasing, Fog, and Polygon Offset - 32)Tj
ET
endstream
endobj
724 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im68 720 0 R
/Im69 721 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
726 0 obj
<<
/Length 1682
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glPolygonOffset\(1.0, 1.0\);)Tj
0 -1.5 TD
(   glCallList \(list\);)Tj
T*
(   glDisable\(GL_POLYGON_OFFSET_FILL\);)Tj
0 -3 TD
(   glDisable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glDisable\(GL_LIGHT0\);)Tj
T*
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
T*
(   glPolygonMode\(GL_FRONT_AND_BACK, GL_LINE\);)Tj
T*
(   glCallList \(list\);)Tj
T*
(   glPolygonMode\(GL_FRONT_AND_BACK, GL_FILL\);)Tj
/F11 1 Tf
0 -2.1 TD
(In a few situations, the simplest values for )Tj
/F15 1 Tf
17.1 0 TD
(factor)Tj
/F11 1 Tf
2.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(units)Tj
/F11 1 Tf
1.9 0 TD
( \(1.0 and 1.0\) aren't the answers. For instance,)Tj
-23.4 -1.5 TD
(if the width of the lines that are highlighting the edges are greater than one, then increasing the value of)Tj
/F15 1 Tf
T*
(factor)Tj
/F11 1 Tf
2.4 0 TD
( may be necessary. Also, since depth values are unevenly transformed into window coordinates)Tj
-2.4 -1.5 TD
[(when using perspective projection \(see "The Transformed Depth Coordinate" in Chapter 3)-30(\), less offset is)]TJ
T*
(needed for polygons that are closer to the near clipping plane, and more offset is needed for polygons that)Tj
T*
(are further away. Once again, experimenting with the value of )Tj
/F15 1 Tf
25.1 0 TD
(factor)Tj
/F11 1 Tf
2.4 0 TD
( may be warranted.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 446.310 m
547.000 446.310 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 33)Tj
ET
endstream
endobj
727 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
729 0 obj
<<
/Length 3803
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 7)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Display Lists)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Understand how display lists can be used along with commands in immediate mode to organize your)Tj
0 -1.6 TD
(data and improve performance)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Maximize performance by knowing how and when to use display lists)Tj
-1.9 -2.7 TD
(A )Tj
/F15 1 Tf
1 0 TD
(display list)Tj
/F11 1 Tf
4.3 0 TD
( is a group of OpenGL commands that have been stored for later execution. When a display)Tj
-5.3 -1.5 TD
(list is invoked, the commands in it are executed in the order in which they were issued. Most OpenGL)Tj
T*
(commands can be either stored in a display list or issued in )Tj
/F15 1 Tf
23.8 0 TD
(immediate mode)Tj
/F11 1 Tf
6.6 0 TD
(, which causes them to be)Tj
-30.4 -1.5 TD
(executed immediately. You can freely mix immediate-mode programming and display lists within a)Tj
T*
(single program. The programming examples you've seen so far have used immediate mode. This chapter)Tj
T*
(discusses what display lists are and how best to use them. It has the following major sections:)Tj
/F33 1 Tf
0.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Why Use Display Lists?")-34( explains when to use display lists.)]TJ
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("An Example of Using a Display List")28( gives a brief example, showing the basic commands for using)]TJ
0 -1.6 TD
(display lists.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Display-List Design Philosophy")183( explains why certain design choices were made \(such as making)]TJ
0 -1.6 TD
(display lists uneditable\) and what performance optimizations you might expect to see when using)Tj
0 -1.5 TD
(display lists.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Creating and Executing a Display List")22( discusses in detail the commands for creating, executing,)]TJ
0 -1.6 TD
(and deleting display lists.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Executing Multiple Display Lists")24( shows how to execute several display lists in succession, using a)]TJ
0 -1.6 TD
(small character set as an example.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Managing State Variables with Display Lists")-11( illustrates how to use display lists to save and restore)]TJ
0 -1.6 TD
(OpenGL commands that set state variables.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 222.000 Tm
(Why Use Display Lists?)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 200.000 Tm
(Display lists may improve performance since you can use them to store OpenGL commands for later)Tj
0 -1.5 TD
(execution. It is often a good idea to cache commands in a display list if you plan to redraw the same)Tj
T*
(geometry multiple times, or if you have a set of state changes that need to be applied multiple times.)Tj
T*
(Using display lists, you can define the geometry and/or state changes once and execute them multiple)Tj
T*
(times.)Tj
0 -2.1 TD
(To see how you can use display lists to store geometry just once, consider drawing a tricycle. The two)Tj
0 -1.5 TD
(wheels on the back are the same size but are offset from each other. The front wheel is larger than the)Tj
T*
(back wheels and also in a different location. An efficient way to render the wheels on the tricycle would)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 1)Tj
ET
endstream
endobj
730 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
732 0 obj
<<
/Length 2881
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(be to store the geometry for one wheel in a display list then execute the list three times. You would need)Tj
0 -1.5 TD
(to set the modelview matrix appropriately each time before executing the list to calculate the correct size)Tj
T*
(and location for the wheels.)Tj
0 -2.1 TD
(When running OpenGL programs remotely to another machine on the network, it is especially important)Tj
0 -1.5 TD
(to cache commands in a display list. In this case, the server is a different machine than the host. \(See)Tj
T*
[("What Is OpenGL?" in Chapter 1)43( for a discussion of the OpenGL client-server model.\) Since display lists)]TJ
T*
(are part of the server state and therefore reside on the server machine, you can reduce the cost of)Tj
T*
(repeatedly transmitting that data over a network if you store repeatedly used commands in a display list.)Tj
0 -2.1 TD
(When running locally, you can often improve performance by storing frequently used commands in a)Tj
0 -1.5 TD
(display list. Some graphics hardware may store display lists in dedicated memory or may store the data in)Tj
T*
[(an optimized form that is more compatible with the graphics hardware or software. \(See )-31("Display-List)]TJ
T*
[(Design Philosophy")-7( for a detailed discussion of these optimizations.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 500.000 Tm
(An Example of Using a Display List)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 478.000 Tm
(A display list is a convenient and efficient way to name and organize a set of OpenGL commands. For)Tj
T*
(example, suppose you want to draw a torus and view it from different angles. The most efficient way to)Tj
T*
(do this would be to store the torus in a display list. Then whenever you want to change the view, you)Tj
T*
[(would change the modelview matrix and execute the display list to draw the torus. )-6(Example 7-1)]TJ
T*
(illustrates this.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 7-1 )Tj
/F11 1 Tf
6.1 0 TD
( Creating a Display List: torus.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <stdio.h>)Tj
T*
(#include <math.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(GLuint theTorus;)Tj
T*
(/* Draw a torus */)Tj
0 -1.5 TD
(static void torus\(int numc, int numt\))Tj
T*
({)Tj
T*
(   int i, j, k;)Tj
T*
(   double s, t, x, y, z, twopi;)Tj
0 -3 TD
(   twopi = 2 * \(double\)M_PI;)Tj
0 -1.5 TD
(   for \(i = 0; i < numc; i++\) {)Tj
T*
(      glBegin\(GL_QUAD_STRIP\);)Tj
T*
(      for \(j = 0; j <= numt; j++\) {)Tj
T*
(         for \(k = 1; k >= 0; k--\) {)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 2)Tj
ET
endstream
endobj
733 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
737 0 obj
<<
/Length 1681
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(            s = \(i + k\) % numc + 0.5;)Tj
0 -1.5 TD
(            t = j % numt;)Tj
0 -3 TD
(            x = \(1+.1*cos\(s*twopi/numc\)\)*cos\(t*twopi/numt\);)Tj
0 -1.5 TD
(            y = \(1+.1*cos\(s*twopi/numc\)\)*sin\(t*twopi/numt\);)Tj
T*
(            z = .1 * sin\(s * twopi / numc\);)Tj
T*
(            glVertex3f\(x, y, z\);)Tj
T*
(         })Tj
T*
(      })Tj
T*
(      glEnd\(\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(/* Create display list with Torus and initialize state*/)Tj
0 -1.5 TD
(static void init\(void\))Tj
T*
({)Tj
T*
(   theTorus = glGenLists \(1\);)Tj
T*
(   glNewList\(theTorus, GL_COMPILE\);)Tj
T*
(   torus\(8, 25\);)Tj
T*
(   glEndList\(\);)Tj
0 -3 TD
(   glShadeModel\(GL_FLAT\);)Tj
0 -1.5 TD
(   glClearColor\(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
T*
(   glCallList\(theTorus\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluPerspective\(30, \(GLfloat\) w/\(GLfloat\) h, 1.0, 100.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluLookAt\(0, 0, 10, 0, 0, 0, 0, 1, 0\);)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 3)Tj
ET
endstream
endobj
738 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
740 0 obj
<<
/Length 1911
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 697.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(/* Rotate about x-axis when "x" typed; rotate about y-axis)Tj
0 -1.5 TD
(   when "y" typed; "i" returns torus to original view */)Tj
T*
(void keyboard\(unsigned char key, int x, int y\))Tj
T*
({)Tj
T*
(   switch \(key\) {)Tj
T*
(   case `x':)Tj
T*
(   case `X':)Tj
T*
(      glRotatef\(30.,1.0,0.0,0.0\);)Tj
T*
(      glutPostRedisplay\(\);)Tj
T*
(      break;)Tj
T*
(   case `y':)Tj
T*
(   case `Y':)Tj
T*
(      glRotatef\(30.,0.0,1.0,0.0\);)Tj
T*
(      glutPostRedisplay\(\);)Tj
T*
(      break;)Tj
T*
(   case `i':)Tj
T*
(   case `I':)Tj
T*
(      glLoadIdentity\(\);)Tj
T*
(      gluLookAt\(0, 0, 10, 0, 0, 0, 0, 1, 0\);)Tj
T*
(      glutPostRedisplay\(\);)Tj
T*
(      break;)Tj
T*
(   case 27:)Tj
T*
(      exit\(0\);)Tj
T*
(      break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char **argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInitWindowSize\(200, 200\);)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Let's start by looking at )Tj
/F15 1 Tf
9.8 0 TD
(init\(\))Tj
/F11 1 Tf
2 0 TD
(. It creates a display list for the torus and initializes the viewing matrices)Tj
-11.8 -1.5 TD
(and other rendering state. Note that the routine for drawing a torus \()Tj
/F15 1 Tf
27.1 0 TD
(torus\(\))Tj
/F11 1 Tf
2.8 0 TD
(\) is bracketed by )Tj
/F15 1 Tf
6.8 0 TD
(glNewList\(\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 4)Tj
ET
endstream
endobj
741 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
743 0 obj
<<
/Length 5391
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(and )Tj
/F15 1 Tf
1.7 0 TD
(glEndList\(\))Tj
/F11 1 Tf
4.6 0 TD
0.000 Tw
(, which defines a display list. The argument )Tj
/F15 1 Tf
17.7 0 TD
(listName)Tj
/F11 1 Tf
3.5 0 TD
( for )Tj
/F15 1 Tf
1.7 0 TD
(glNewList\(\))Tj
/F11 1 Tf
4.7 0 TD
( is an integer index,)Tj
-33.9 -1.5 TD
(generated by )Tj
/F15 1 Tf
5.4 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
(, that uniquely identifies this display list.)Tj
-10.4 -2.1 TD
(The user can rotate the torus about the x- or y-axis by pressing the `x' or `y' key when the window has)Tj
0 -1.5 TD
(focus. Whenever this happens, the callback function )Tj
/F15 1 Tf
21.1 0 TD
(keyboard\(\))Tj
/F11 1 Tf
4.4 0 TD
( is called, which concatenates a)Tj
-25.5 -1.5 TD
(30-degree rotation matrix \(about the x- or y-axis\) with the current modelview matrix. Then)Tj
/F15 1 Tf
T*
(glutPostRedisplay\(\) )Tj
/F11 1 Tf
8.2 0 TD
(is called, which will cause )Tj
/F15 1 Tf
10.8 0 TD
(glutMainLoop\(\))Tj
/F11 1 Tf
6.4 0 TD
( to call )Tj
/F15 1 Tf
2.9 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
( and render the torus after)Tj
-31.9 -1.5 TD
(other events have been processed. When the `i' key is pressed, )Tj
/F15 1 Tf
25.2 0 TD
(keyboard\(\))Tj
/F11 1 Tf
4.4 0 TD
( restores the initial modelview)Tj
-29.6 -1.5 TD
(matrix and returns the torus to its original location.)Tj
0 -2.1 TD
(The )Tj
/F15 1 Tf
1.8 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
( function is very simple: It clears the window and then calls )Tj
/F15 1 Tf
24.1 0 TD
(glCallList\(\) )Tj
/F11 1 Tf
4.9 0 TD
(to execute the)Tj
-34.4 -1.5 TD
(commands in the display list. If we hadn't used display lists, )Tj
/F15 1 Tf
24.4 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
( would have to reissue the)Tj
-28 -1.5 TD
(commands to draw the torus each time it was called.)Tj
0 -2.1 TD
[(A display list contains only OpenGL commands. In )-37(Example 7-1)]TJ
26 0 TD
(, only the )Tj
/F15 1 Tf
4 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glVertex\(\))Tj
/F11 1 Tf
4 0 TD
(, and)Tj
/F15 1 Tf
-38.3 -1.5 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( calls are stored in the display list. The parameters for the calls are )Tj
/F15 1 Tf
26.7 0 TD
(evaluated)Tj
/F11 1 Tf
3.9 0 TD
(, and their values are)Tj
-33.7 -1.5 TD
(copied into the display list when it is created. All the trigonometry to create the torus is done only once,)Tj
T*
(which should increase rendering performance. However, the values in the display list can't be changed)Tj
T*
(later. And once a command has been stored in a list it is not possible to remove it. Neither can you add)Tj
T*
(any new commands to the list after it has been defined. You can delete the entire display list and create a)Tj
T*
(new one, but you can't edit it.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Display lists also work well with GLU commands, since those operations are ultimately broken)Tj
-2.8 -1.5 TD
(down into low-level OpenGL commands, which can easily be stored in display lists. Use of display lists)Tj
0 -1.4 TD
(with GLU is particularly important for optimizing performance of GLU tessellators and NURBS.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 352.000 Tm
(Display-List Design Philosophy)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 330.000 Tm
(To optimize performance, an OpenGL display list is a cache of commands rather than a dynamic)Tj
0 -1.5 TD
(database. In other words, once a display list is created, it can't be modified. If a display list were)Tj
T*
(modifiable, performance could be reduced by the overhead required to search through the display list and)Tj
T*
(perform memory management. As portions of a modifiable display list were changed, memory allocation)Tj
T*
(and deallocation might lead to memory fragmentation. Any modifications that the OpenGL)Tj
T*
(implementation made to the display-list commands in order to make them more efficient to render would)Tj
T*
(need to be redone. Also, the display list may be difficult to access, cached somewhere over a network or)Tj
T*
(a system bus.)Tj
0 -2.1 TD
(The way in which the commands in a display list are optimized may vary from implementation to)Tj
0 -1.5 TD
(implementation. For example, a command as simple as )Tj
/F15 1 Tf
22.3 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.5 0 TD
( might show a significant)Tj
-26.8 -1.5 TD
(improvement if it's in a display list, since the calculations to produce the rotation matrix aren't trivial)Tj
T*
(\(they can involve square roots and trigonometric functions\). In the display list, however, only the final)Tj
T*
(rotation matrix needs to be stored, so a display-list rotation command can be executed as fast as the)Tj
T*
(hardware can execute )Tj
/F15 1 Tf
8.9 0 TD
(glMultMatrix*\(\))Tj
/F11 1 Tf
6.6 0 TD
(. A sophisticated OpenGL implementation might even concatenate)Tj
-15.5 -1.5 TD
(adjacent transformation commands into a single matrix multiplication.)Tj
0 -2.1 TD
(Although you're not guaranteed that your OpenGL implementation optimizes display lists for any)Tj
0 -1.5 TD
(particular uses, the execution of display lists isn't slower than executing the commands contained within)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 5)Tj
ET
endstream
endobj
744 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
746 0 obj
<<
/Length 4146
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(them individually. There is some overhead, however, involved in jumping to a display list. If a particular)Tj
0 -1.5 TD
(list is small, this overhead could exceed any execution advantage. The most likely possibilities for)Tj
T*
(optimization are listed next, with references to the chapters where the topics are discussed.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[(Matrix operations \()22(Chapter 3)16(\). Most matrix operations require OpenGL to compute inverses. Both)]TJ
0 -1.6 TD
(the computed matrix and its inverse might be stored by a particular OpenGL implementation in a)Tj
0 -1.5 TD
(display list.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[(Raster bitmaps and images \()33(Chapter 8)16(\). The format in which you specify raster data isn't likely to be)]TJ
0 -1.6 TD
(one that's ideal for the hardware. When a display list is compiled, OpenGL might transform the data)Tj
0 -1.5 TD
(into the representation preferred by the hardware. This can have a significant effect on the speed of)Tj
T*
(raster character drawing, since character strings usually consist of a series of small bitmaps.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[(Lights, material properties, and lighting models \()12(Chapter 5)16(\). When you draw a scene with complex)]TJ
0 -1.6 TD
(lighting conditions, you might change the materials for each item in the scene. Setting the materials)Tj
0 -1.5 TD
(can be slow, since it might involve significant calculations. If you put the material definitions in)Tj
T*
(display lists, these calculations don't have to be done each time you switch materials, since only the)Tj
T*
(results of the calculations need to be stored; as a result, rendering lit scenes might be faster. \(See)Tj
T*
[("Encapsulating Mode Changes")-39( for more details on using display lists to change such values as)]TJ
T*
(lighting conditions.\))Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[(Textures \()-18(Chapter 9)16(\). You might be able to maximize efficiency when defining textures by)]TJ
0 -1.5 TD
(compiling them into a display list, since the display list may allow the texture image to be cached in)Tj
T*
(dedicated texture memory. Then the texture image would not have to be recopied each time it was)Tj
T*
(needed. Also, the hardware texture format might differ from the OpenGL format, and the conversion)Tj
T*
(can be done at display-list compile time rather than during display.)Tj
0 -2.1 TD
(In OpenGL version 1.0, the display list is the primary method to manage textures. However, if the)Tj
0 -1.5 TD
(OpenGL implementation that you are using is version 1.1 or greater, then you should store the)Tj
T*
(texture in a texture object instead. \(Some version 1.0 implementations have a vendor-specific)Tj
T*
(extension to support texture objects. If your implementation supports texture objects, you are)Tj
T*
(encouraged to use them.\))Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[(Polygon stipple patterns \()-49(Chapter 2)16(\))0(.)]TJ
-1.9 -2.7 TD
(Some of the commands to specify the properties listed here are context-sensitive, so you need to take this)Tj
0 -1.5 TD
(into account to ensure optimum performance. For example, when GL_COLOR_MATERIAL is enabled,)Tj
T*
[(some of the material properties will track the current color. \(See )-14(Chapter 5)16(.\) Any )]TJ
/F15 1 Tf
32.6 0 TD
(glMaterial*\(\))Tj
/F11 1 Tf
5.4 0 TD
( calls that)Tj
-38 -1.5 TD
(set the same material properties are ignored.)Tj
0 -2.1 TD
(It may improve performance to store state settings with geometry. For example, suppose you want to)Tj
0 -1.5 TD
(apply a transformation to some geometric objects and then draw the result. Your code may look like this:)Tj
/F7 1 Tf
0 -2.1 TD
(glNewList\(1, GL_COMPILE\); )Tj
0 -1.5 TD
(draw_some_geometric_objects\(\); )Tj
T*
(glEndList\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 6)Tj
ET
endstream
endobj
747 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
749 0 obj
<<
/Length 3334
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glLoadMatrix\(M\);)Tj
0 -1.5 TD
(glCallList\(1\);)Tj
/F11 1 Tf
0 -2.1 TD
0.000 Tw
(However, if the geometric objects are to be transformed in the same way each time, it is better to store)Tj
0 -1.5 TD
(the matrix in the display list. For example, if you were to write your code as follows, some)Tj
T*
(implementations may be able to improve performance by transforming the objects when they are defined)Tj
T*
(instead of each time they are drawn:)Tj
/F7 1 Tf
0 -2.1 TD
(glNewList\(1, GL_COMPILE\);)Tj
0 -1.5 TD
(glLoadMatrix\(M\);)Tj
T*
(draw_some_geometric_objects\(\); )Tj
T*
(glEndList\(\);)Tj
0 -3 TD
(glCallList\(1\);)Tj
/F11 1 Tf
0 -2.1 TD
[(A more likely situation occurs when rendering images. As you will see in )-33(Chapter 8)16(,)0( you can modify)]TJ
0 -1.5 TD
(pixel transfer state variables and control the way images and bitmaps are rasterized. If the commands that)Tj
T*
(set these state variables precede the definition of the image or bitmap in the display list, the)Tj
T*
(implementation may be able to perform some of the operations ahead of time and cache the result.)Tj
0 -2.1 TD
(Remember that display lists have some disadvantages. Very small lists may not perform well since there)Tj
0 -1.5 TD
(is some overhead when executing a list. Another disadvantage is the immutability of the contents of a)Tj
T*
(display list. To optimize performance, an OpenGL display list can't be changed and its contents can't be)Tj
T*
(read. If the application needs to maintain data separately from the display list \(for example, for continued)Tj
T*
(data processing\), then a lot of additional memory may be required.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 354.000 Tm
(Creating and Executing a Display List)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 332.000 Tm
(As you've already seen, )Tj
/F15 1 Tf
9.9 0 TD
(glNewList\(\))Tj
/F11 1 Tf
4.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEndList\(\))Tj
/F11 1 Tf
4.6 0 TD
( are used to begin and end the definition of a display)Tj
-21.1 -1.5 TD
(list, which is then invoked by supplying its identifying index with )Tj
/F15 1 Tf
26.6 0 TD
(glCallList\(\))Tj
/F11 1 Tf
4.6 0 TD
[(. In )-17(Example 7-2)]TJ
6.7 0 TD
(, a display)Tj
-37.9 -1.5 TD
(list is created in the )Tj
/F15 1 Tf
8 0 TD
(init\(\))Tj
/F11 1 Tf
2 0 TD
( routine. This display list contains OpenGL commands to draw a red triangle.)Tj
-10 -1.5 TD
(Then in the )Tj
/F15 1 Tf
4.8 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
( routine, the display list is executed ten times. In addition, a line is drawn in)Tj
-8.4 -1.5 TD
(immediate mode. Note that the display list allocates memory to store the commands and the values of)Tj
T*
(any necessary variables.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 7-2 )Tj
/F11 1 Tf
6.1 0 TD
(Using a Display List: list.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(GLuint listName;)Tj
T*
(static void init \(void\))Tj
0 -1.5 TD
({)Tj
T*
(   listName = glGenLists \(1\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 7)Tj
ET
endstream
endobj
750 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
752 0 obj
<<
/Length 1808
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glNewList \(listName, GL_COMPILE\);)Tj
0 -1.5 TD
(      glColor3f \(1.0, 0.0, 0.0\);  /*  current color red  */)Tj
T*
(      glBegin \(GL_TRIANGLES\);)Tj
T*
(      glVertex2f \(0.0, 0.0\);)Tj
T*
(      glVertex2f \(1.0, 0.0\);)Tj
T*
(      glVertex2f \(0.0, 1.0\);)Tj
T*
(      glEnd \(\);)Tj
T*
(      glTranslatef \(1.5, 0.0, 0.0\); /*  move position  */)Tj
T*
(   glEndList \(\);)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
T*
(})Tj
0 -3 TD
(static void drawLine \(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glBegin \(GL_LINES\);)Tj
T*
(   glVertex2f \(0.0, 0.5\);)Tj
T*
(   glVertex2f \(15.0, 0.5\);)Tj
T*
(   glEnd \(\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLuint i;)Tj
0 -3 TD
(   glClear \(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glColor3f \(0.0, 1.0, 0.0\);  /*  current color green  */)Tj
T*
(   for \(i = 0; i < 10; i++\)    /*  draw 10 triangles    */)Tj
T*
(      glCallList \(listName\);)Tj
T*
(   drawLine \(\);  /*  is this line green?  NO!  */)Tj
T*
(                 /*  where is the line drawn?  */)Tj
T*
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, w, h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\) )Tj
T*
(      gluOrtho2D \(0.0, 2.0, -0.5 * \(GLfloat\) h/\(GLfloat\) w, )Tj
T*
(         1.5 * \(GLfloat\) h/\(GLfloat\) w\);)Tj
T*
(   else )Tj
T*
(      gluOrtho2D \(0.0, 2.0*\(GLfloat\) w/\(GLfloat\) h, -0.5, 1.5\); )Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 8)Tj
ET
endstream
endobj
753 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
755 0 obj
<<
/Length 2935
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glMatrixMode\(GL_MODELVIEW\);)Tj
0 -1.5 TD
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize\(650, 50\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutReshapeFunc \(reshape\);)Tj
T*
(   glutKeyboardFunc \(keyboard\);)Tj
T*
(   glutDisplayFunc \(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(The )Tj
/F15 1 Tf
1.8 0 TD
(glTranslatef\(\))Tj
/F11 1 Tf
5.6 0 TD
( routine in the display list alters the position of the next object to be drawn. Without it,)Tj
-7.4 -1.5 TD
(calling the display list twice would just draw the triangle on top of itself. The )Tj
/F15 1 Tf
31.1 0 TD
(drawLine\(\))Tj
/F11 1 Tf
4.5 0 TD
( routine, which)Tj
-35.6 -1.5 TD
(is called in immediate mode, is also affected by the ten )Tj
/F15 1 Tf
22.2 0 TD
(glTranslatef\(\))Tj
/F11 1 Tf
5.6 0 TD
( calls that precede it. So if you call)Tj
-27.8 -1.5 TD
(transformation commands within a display list, don't forget to take into account the effect those)Tj
T*
(commands will have later in your program.)Tj
0 -2.1 TD
(Only one display list can be created at a time. In other words, you must eventually follow )Tj
/F15 1 Tf
36 0 TD
(glNewList\(\))Tj
/F11 1 Tf
-36 -1.5 TD
(with )Tj
/F15 1 Tf
2 0 TD
(glEndList\(\))Tj
/F11 1 Tf
4.6 0 TD
( to end the creation of a display list before starting another one. As you might expect,)Tj
-6.6 -1.5 TD
(calling )Tj
/F15 1 Tf
3 0 TD
(glEndList\(\))Tj
/F11 1 Tf
4.5 0 TD
( without having started a display list generates the error)Tj
-7.5 -1.5 TD
[(GL_INVALID_OPERATION. \(See )-7("Error Handling" in Chapter 14)-7( for more information about)]TJ
T*
(processing errors.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 161.000 Tm
(Naming and Creating a Display List)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 139.000 Tm
(Each display list is identified by an integer index. When creating a display list, you want to be careful)Tj
T*
(that you don't accidentally choose an index that's already in use, thereby overwriting an existing display)Tj
T*
(list. To avoid accidental deletions, use )Tj
/F15 1 Tf
15.6 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
( to generate one or more unused indices.)Tj
/F15 1 Tf
-20.6 -2.1 TD
0.016 Tw
[(GLuint glGenLists)34(\(GLsizei )-45(range)33(\);)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 9)Tj
ET
endstream
endobj
756 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
758 0 obj
<<
/Length 3598
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(Allocates )-28(range)33( number of contiguous, previously unallocated display-list indices. The integer)]TJ
0 -1.5 TD
(returned is the index that marks the beginning of a contiguous block of empty display-list indices.)Tj
T*
[(The returned indices are all marked as empty and used, so subsequent calls to )29(glGenLists\(\) don't)]TJ
T*
(return these indices until they're deleted. Zero is returned if the requested number of indices isn't)Tj
T*
[(available, or if )-32(range)33( is zero.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(In the following example, a single index is requested, and if it proves to be available, it's used to create a)Tj
0 -1.5 TD
(new display list:)Tj
/F7 1 Tf
0 -2 TD
(listIndex = glGenLists\(1\);)Tj
0 -1.5 TD
(if \(listIndex != 0\) {)Tj
T*
(   glNewList\(listIndex,GL_COMPILE\);)Tj
T*
(      ...)Tj
T*
(   glEndList\(\);)Tj
T*
(})Tj
/F27 1 Tf
0 -2.2 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Zero is not a valid display-list index.)Tj
/F15 1 Tf
-2.8 -2.1 TD
[(void )-28(glNewList)57( \(GLuint )-33(list)23(, GLenum )-6(mode)-34(\);)]TJ
1.8 -1.5 TD
[(Specifies the start of a display list. OpenGL routines that are called subsequently \(until )43(glEndList\(\))]TJ
T*
(is called to end the display list\) are stored in a display list, except for a few restricted OpenGL)Tj
T*
(routines that can't be stored. \(Those restricted routines are executed immediately, during the)Tj
T*
[(creation of the display list.\) )-21(list)23( is a nonzero positive integer that uniquely identifies the display list.)]TJ
T*
[(The possible values for mode)-34( are GL_COMPILE and GL_COMPILE_AND_EXECUTE. Use)]TJ
T*
(GL_COMPILE if you don't want the OpenGL commands executed as they're placed in the display)Tj
T*
(list; to cause the commands to be executed immediately as well as placed in the display list for later)Tj
T*
(use, specify GL_COMPILE_AND_EXECUTE.)Tj
-1.8 -2.1 TD
0.028 Tw
[(void glEndList)-10( )28(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Marks the end of a display list.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(When a display list is created it is stored with the current OpenGL context. Thus, when the context is)Tj
0 -1.5 TD
(destroyed, the display list is also destroyed. Some windowing systems allow multiple contexts to share)Tj
T*
(display lists. In this case, the display list is destroyed when the last context in the share group is)Tj
T*
(destroyed.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 226.000 Tm
(What's Stored in a Display List)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 205.000 Tm
(When you're building a display list, only the values for expressions are stored in the list. If values in an)Tj
T*
(array are subsequently changed, the display-list values don't change. In the following code fragment, the)Tj
T*
(display list contains a command to set the current RGBA color to black \(0.0, 0.0, 0.0\). The subsequent)Tj
T*
(change of the value of the )Tj
/F15 1 Tf
10.6 0 TD
(color_vector)Tj
/F11 1 Tf
5.1 0 TD
( array to red \(1.0, 0.0, 0.0\) has no effect on the display list)Tj
-15.7 -1.5 TD
(because the display list contains the values that were in effect when it was created.)Tj
/F7 1 Tf
0 -2.1 TD
(GLfloat color_vector[3] = {0.0, 0.0, 0.0};)Tj
0 -1.5 TD
(glNewList\(1, GL_COMPILE\);)Tj
T*
(   glColor3fv\(color_vector\);)Tj
T*
(glEndList\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 10)Tj
ET
endstream
endobj
759 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
761 0 obj
<<
/Length 5093
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(color_vector[0] = 1.0;)Tj
/F11 1 Tf
0 -2.1 TD
(Not all OpenGL commands can be stored and executed from within a display list. For example,)Tj
0 -1.5 TD
(commands that set client state and commands that retrieve state values aren't stored in a display list.)Tj
T*
(\(Many of these commands are easily identifiable because they return values in parameters passed by)Tj
T*
(reference or return a value directly.\) If these commands are called when making a display list, they're)Tj
T*
(executed immediately.)Tj
0 -2.1 TD
(Here are the OpenGL commands that aren't stored in a display list \(also, note that )Tj
/F15 1 Tf
33 0 TD
(glNewList\(\))Tj
/F11 1 Tf
4.7 0 TD
( generates)Tj
-37.7 -1.5 TD
(an error if it's called while you're creating a display list\). Some of these commands haven't been)Tj
T*
(described yet; you can look in the index to see where they're discussed.)Tj
0 -1.2 TD
[(glColorPointer\(\))-7188(glFlush\(\))-10133(glNormalPointer\(\))]TJ
0 -1.4 TD
[(glDeleteLists\(\))-7800(glGenLists\(\))-8744(glPixelStore\(\))]TJ
T*
[(glDisableClientState\(\))-4855(glGet*\(\))-10412(glReadPixels\(\))]TJ
T*
[(glEdgeFlagPointer\(\))-5633(glIndexPointer\(\))-7189(glRenderMode\(\))]TJ
T*
[(glEnableClientState\(\))-5133(glInterleavedArrays\(\))-5136(glSelectBuffer\(\))]TJ
T*
[(glFeedbackBuffer\(\))-5913(glIsEnabled\(\))-8356(glTexCoordPointer\(\))]TJ
0 -1.5 TD
[(glFinish\(\))-9855(glIsList\(\))-10078(glVertexPointer\(\))]TJ
0 -2.1 TD
(To understand more clearly why these commands can't be stored in a display list, remember that when)Tj
0 -1.5 TD
(you're using OpenGL across a network, the client may be on one machine and the server on another.)Tj
T*
(After a display list is created, it resides with the server, so the server can't rely on the client for any)Tj
T*
(information related to the display list. If querying commands, such as )Tj
/F15 1 Tf
28 0 TD
(glGet*\(\) )Tj
/F11 1 Tf
3.7 0 TD
(or )Tj
/F15 1 Tf
1 0 TD
(glIs*\(\))Tj
/F11 1 Tf
2.7 0 TD
(, were allowed in)Tj
-35.4 -1.5 TD
(a display list, the calling program would be surprised at random times by data returned over the network.)Tj
T*
(Without parsing the display list as it was sent, the calling program wouldn't know where to put the data.)Tj
T*
(Thus, any command that returns a value can't be stored in a display list. In addition, commands that)Tj
T*
(change client state, such as )Tj
/F15 1 Tf
11.1 0 TD
(glPixelStore\(\))Tj
/F11 1 Tf
5.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glSelectBuffer\(\))Tj
/F11 1 Tf
6.3 0 TD
(, and the commands to define vertex arrays,)Tj
-23.5 -1.5 TD
(can't be stored in a display list.)Tj
0 -2.1 TD
(The operation of some OpenGL commands depends upon client state. For example, the vertex array)Tj
0 -1.5 TD
(specification routines \(such as )Tj
/F15 1 Tf
12.3 0 TD
[(glVertexPointer\(\))-45(glColorPointer\(\))]TJ
/F11 1 Tf
13.9 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glInterleavedArrays\(\))Tj
/F11 1 Tf
8.7 0 TD
(\) set client)Tj
-37.1 -1.5 TD
(state pointers and cannot be stored in a display list. )Tj
/F15 1 Tf
20.6 0 TD
(glArrayElement\(\))Tj
/F11 1 Tf
7.1 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glDrawArrays\(\))Tj
/F11 1 Tf
6.4 0 TD
(, and)Tj
/F15 1 Tf
-34.6 -1.5 TD
(glDrawElements\(\))Tj
/F11 1 Tf
7.4 0 TD
( send data to the server state to construct primitives from elements in the enabled)Tj
-7.4 -1.5 TD
[(arrays, so these operations can be stored in a display list. \(See )43("Vertex Arrays" in Chapter 2.\) The vertex)]TJ
T*
(array data stored in this display list is obtained by dereferencing data from the pointers, not by storing the)Tj
T*
(pointers themselves. Therefore, subsequent changes to the data in the vertex arrays will not affect the)Tj
T*
(definition of the primitive in the display list.)Tj
0 -2.1 TD
(In addition, any commands that use the pixel storage modes use the modes that are in effect when they)Tj
0 -1.5 TD
[(are placed in the display list. \(See )22("Controlling Pixel-Storage Modes" in Chapter 8)221(.\) Other routines that)]TJ
0 -1.6 TD
(rely upon client state)Tj
/F33 1 Tf
8.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(such as )Tj
/F15 1 Tf
3.1 0 TD
(glFlush\(\) )Tj
/F11 1 Tf
4 0 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(glFinish\(\))Tj
/F33 1 Tf
4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(can't be stored in a display list because they)Tj
-23.2 -1.5 TD
(depend upon the client state that is in effect when they are executed.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 120.000 Tm
(Executing a Display List)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 98.000 Tm
(After you've created a display list, you can execute it by calling )Tj
/F15 1 Tf
25.8 0 TD
(glCallList\(\))Tj
/F11 1 Tf
4.7 0 TD
(. Naturally, you can execute)Tj
-30.5 -1.5 TD
(the same display list many times, and you can mix calls to execute display lists with calls to perform)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 11)Tj
ET
endstream
endobj
762 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
764 0 obj
<<
/Length 3645
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(immediate-mode graphics, as you've already seen.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glCallList )28(\(GLuint )95(list)-77(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(This routine executes the display list specified by )34(list)-77(. The commands in the display list are executed)]TJ
T*
[(in the order they were saved, just as if they were issued without using a display list. If list)23( hasn't)]TJ
T*
(been defined, nothing happens.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(You can call )Tj
/F15 1 Tf
5.3 0 TD
(glCallList\(\))Tj
/F11 1 Tf
4.7 0 TD
( from anywhere within a program, as long as an OpenGL context that can access)Tj
-10 -1.5 TD
(the display list is active \(that is, the context that was active when the display list was created or a context)Tj
T*
(in the same share group\). A display list can be created in one routine and executed in a different one,)Tj
T*
(since its index uniquely identifies it. Also, there is no facility to save the contents of a display list into a)Tj
T*
(data file, nor a facility to create a display list from a file. In this sense, a display list is designed for)Tj
T*
(temporary use.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 520.000 Tm
(Hierarchical Display Lists)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 499.000 Tm
(You can create a )Tj
/F15 1 Tf
6.9 0 TD
(hierarchical display list)Tj
/F11 1 Tf
9.6 0 TD
(, which is a display list that executes another display list by)Tj
-16.5 -1.5 TD
(calling )Tj
/F15 1 Tf
3 0 TD
(glCallList\(\))Tj
/F11 1 Tf
4.6 0 TD
( between a )Tj
/F15 1 Tf
4.6 0 TD
(glNewList\(\))Tj
/F11 1 Tf
4.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEndList\(\))Tj
/F11 1 Tf
4.6 0 TD
( pair. A hierarchical display list is useful for an)Tj
-23.4 -1.5 TD
(object made of components, especially if some of those components are used more than once. For)Tj
T*
(example, this is a display list that renders a bicycle by calling other display lists to render parts of the)Tj
T*
(bicycle:)Tj
/F7 1 Tf
0 -2.1 TD
(glNewList\(listIndex,GL_COMPILE\);)Tj
0 -1.5 TD
(   glCallList\(handlebars\);)Tj
T*
(   glCallList\(frame\);)Tj
T*
(   glTranslatef\(1.0,0.0,0.0\);)Tj
T*
(   glCallList\(wheel\);)Tj
T*
(   glTranslatef\(3.0,0.0,0.0\);)Tj
T*
(   glCallList\(wheel\);)Tj
T*
(glEndList\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(To avoid infinite recursion, there's a limit on the nesting level of display lists; the limit is at least 64, but)Tj
0 -1.5 TD
(it might be higher, depending on the implementation. To determine the nesting limit for your)Tj
T*
(implementation of OpenGL, call)Tj
/F7 1 Tf
0 -2.1 TD
(glGetIntegerv\(GL_MAX_LIST_NESTING, GLint *data\);)Tj
/F11 1 Tf
T*
(OpenGL allows you to create a display list that calls another list that hasn't been created yet. Nothing)Tj
0 -1.5 TD
(happens when the first list calls the second, undefined one.)Tj
0 -2.1 TD
(You can use a hierarchical display list to approximate an editable display list by wrapping a list around)Tj
0 -1.5 TD
(several lower-level lists. For example, to put a polygon in a display list while allowing yourself to be able)Tj
T*
[(to easily edit its vertices, you could use the code in )11(Example 7-3)]TJ
25.7 0 TD
(.)Tj
/F27 1 Tf
-25.7 -2.1 TD
(Example 7-3 )Tj
/F11 1 Tf
6.1 0 TD
(Hierarchical Display List)Tj
/F7 1 Tf
-6.1 -2.4 TD
(glNewList\(1,GL_COMPILE\); )Tj
0 -1.5 TD
(   glVertex3f\(v1\); )Tj
T*
(glEndList\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 12)Tj
ET
endstream
endobj
765 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
768 0 obj
<<
/Length 3717
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glNewList\(2,GL_COMPILE\); )Tj
0 -1.5 TD
0.000 Tw
(   glVertex3f\(v2\); )Tj
T*
(glEndList\(\);)Tj
T*
(glNewList\(3,GL_COMPILE\); )Tj
T*
(   glVertex3f\(v3\); )Tj
T*
(glEndList\(\);)Tj
0 -3 TD
(glNewList\(4,GL_COMPILE\);)Tj
0 -1.5 TD
(   glBegin\(GL_POLYGON\);)Tj
T*
(      glCallList\(1\); )Tj
T*
(      glCallList\(2\); )Tj
T*
(      glCallList\(3\);)Tj
T*
(   glEnd\(\);)Tj
T*
(glEndList\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(To render the polygon, call display list number 4. To edit a vertex, you need only recreate the single)Tj
0 -1.5 TD
(display list corresponding to that vertex. Since an index number uniquely identifies a display list,)Tj
T*
(creating one with the same index as an existing one automatically deletes the old one. Keep in mind that)Tj
T*
(this technique doesn't necessarily provide optimal memory usage or peak performance, but it's)Tj
T*
(acceptable and useful in some cases.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 407.000 Tm
(Managing Display List Indices)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 385.000 Tm
(So far, we've recommended the use of )Tj
/F15 1 Tf
15.7 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
( to obtain unused display-list indices. If you insist)Tj
-20.7 -1.5 TD
(upon avoiding )Tj
/F15 1 Tf
6 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
(, then be sure to use )Tj
/F15 1 Tf
8.2 0 TD
(glIsList\(\))Tj
/F11 1 Tf
3.7 0 TD
( to determine whether a specific index is in use.)Tj
/F15 1 Tf
-22.9 -2.1 TD
0.049 Tw
[(GLboolean glIsList\(GLuint )66(list)23(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Returns GL_TRUE if list)23( is already used for a display list and GL_FALSE otherwise.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(You can explicitly delete a specific display list or a contiguous range of lists with )Tj
/F15 1 Tf
32.8 0 TD
(glDeleteLists\(\))Tj
/F11 1 Tf
5.9 0 TD
(. Using)Tj
/F15 1 Tf
-38.7 -1.5 TD
(glDeleteLists\(\))Tj
/F11 1 Tf
5.9 0 TD
( makes those indices available again.)Tj
/F15 1 Tf
-5.9 -2.1 TD
0.028 Tw
[(void glDeleteLists)-21(\(GLuint )45(list)23(, )28(GLsizei )34(range)33(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Deletes )49(range)-67( display lists, starting at the index specified by )-20(list)23(. An attempt to delete a list that has)]TJ
T*
(never been created is ignored.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 214.000 Tm
(Executing Multiple Display Lists)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 192.000 Tm
(OpenGL provides an efficient mechanism to execute several display lists in succession. This mechanism)Tj
T*
(requires that you put the display-list indices in an array and call )Tj
/F15 1 Tf
25.7 0 TD
(glCallLists\(\))Tj
/F11 1 Tf
5 0 TD
(. An obvious use for such a)Tj
-30.7 -1.5 TD
(mechanism occurs when display-list indices correspond to meaningful values. For example, if you're)Tj
T*
(creating a font, each display-list index might correspond to the ASCII value of a character in that font. To)Tj
T*
(have several such fonts, you would need to establish a different initial display-list index for each font.)Tj
T*
(You can specify this initial index by using )Tj
/F15 1 Tf
17.2 0 TD
(glListBase\(\))Tj
/F11 1 Tf
4.9 0 TD
( before calling )Tj
/F15 1 Tf
6 0 TD
(glCallLists\(\))Tj
/F11 1 Tf
5 0 TD
(.)Tj
/F15 1 Tf
-33.1 -2.1 TD
0.028 Tw
[(void glListBase)23(\(GLuint )45(base)33(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Specifies the offset that's added to the display-list indices in )Tj
24.2 0 TD
[(glCallLists\(\))-42( to obtain the final)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 13)Tj
ET
endstream
endobj
769 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
771 0 obj
<<
/Length 3461
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(display-list indices. The default display-list base is 0. The list base has no effect on )Tj
33.4 0 TD
[(glCallList\(\))69(,)]TJ
-33.4 -1.5 TD
[(which executes only one display list or on )45(glNewList\(\))-76(.)]TJ
-1.8 -2.1 TD
[(void )-28(glCallLists)-9(\(GLsizei )39(n, GLenum )-6(type)-34(, const GLvoid *)12(lists)12(\);)]TJ
1.8 -1.5 TD
(Executes n display lists. The indices of the lists to be executed are computed by adding the offset)Tj
T*
(indicated by the current display-list base \(specified with )Tj
22.7 0 TD
[(glListBase\(\))-10(\) to the signed integer values in)]TJ
-22.7 -1.5 TD
[(the array pointed to by )17(lists)12(.)]TJ
T*
[(The )-50(type)66( parameter indicates the data type of the values in )-22(lists)12(. It can be set to GL_BYTE,)]TJ
T*
(GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, or)Tj
T*
[(GL_FLOAT, indicating that )47(lists)-88( should be treated as an array of bytes, unsigned bytes, shorts,)]TJ
T*
[(unsigned shorts, integers, unsigned integers, or floats, respectively. )52(Type)-56( can also be GL_2_BYTES,)]TJ
T*
[(GL_3_BYTES, or GL_4_BYTES, in which case sequences of 2, 3, or 4 bytes are read from )-8(lists)12( and)]TJ
T*
(then shifted and added together, byte by byte, to calculate the display-list offset. The following)Tj
T*
[(algorithm is used \(where )23(byte[0])-56( is the start of a byte sequence\).)]TJ
/F7 1 Tf
-1.8 -2 TD
( /* b = 2, 3, or 4; bytes are numbered 0, 1, 2, 3 in array */ )Tj
0 -1.1 TD
( offset = 0; )Tj
T*
( for \(i = 0; i < b; i++\) { )Tj
0 -1 TD
(    offset = offset << 8; )Tj
0 -1.1 TD
(    offset += byte[i]; )Tj
0 -1 TD
( })Tj
0 -1.1 TD
( index = offset + listbase; )Tj
/F15 1 Tf
1.8 -1.5 TD
(For multiple-byte data, the highest-order data comes first as bytes are taken from the array in order.)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(As an example of the use of multiple display lists, look at the program fragments in )40(Example 7-4)170( taken)]TJ
0 -1.5 TD
[(from the full program in )-28(Example 7-5)]TJ
15.1 0 TD
(. This program draws characters with a stroked font \(a set of letters)Tj
-15.1 -1.5 TD
(made from line segments\). The routine )Tj
/F15 1 Tf
15.8 0 TD
(initStrokedFont\(\))Tj
/F11 1 Tf
6.9 0 TD
( sets up the display-list indices for each letter so)Tj
-22.7 -1.5 TD
(that they correspond with their ASCII values.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 7-4 )Tj
/F11 1 Tf
6.1 0 TD
(Defining Multiple Display Lists)Tj
/F7 1 Tf
-6.1 -2.4 TD
(void initStrokedFont\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLuint base;)Tj
0 -3 TD
(   base = glGenLists\(128\);)Tj
0 -1.5 TD
(   glListBase\(base\);)Tj
T*
(   glNewList\(base+'A', GL_COMPILE\); )Tj
T*
(      drawLetter\(Adata\); glEndList\(\);)Tj
T*
(   glNewList\(base+'E', GL_COMPILE\); )Tj
T*
(      drawLetter\(Edata\); glEndList\(\);)Tj
T*
(   glNewList\(base+'P', GL_COMPILE\); )Tj
T*
(      drawLetter\(Pdata\); glEndList\(\);)Tj
T*
(   glNewList\(base+'R', GL_COMPILE\); )Tj
T*
(      drawLetter\(Rdata\); glEndList\(\);)Tj
T*
(   glNewList\(base+'S', GL_COMPILE\); )Tj
T*
(      drawLetter\(Sdata\); glEndList\(\);)Tj
T*
(   glNewList\(base+' ', GL_COMPILE\);    /* space character */)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 14)Tj
ET
endstream
endobj
772 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
773 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im70
/Width 408
/Height 78
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.69)
>>
stream
endstream
endobj
775 0 obj
<<
/Length 2436
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      glTranslatef\(8.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glEndList\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(The )Tj
/F15 1 Tf
1.8 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
( command allocates 128 contiguous display-list indices. The first of the contiguous)Tj
-6.8 -1.5 TD
(indices becomes the display-list base. A display list is made for each letter; each display-list index is the)Tj
T*
(sum of the base and the ASCII value of that letter. In this example, only a few letters and the space)Tj
T*
(character are created.)Tj
0 -2.1 TD
(After the display lists have been created, )Tj
/F15 1 Tf
16.5 0 TD
(glCallLists\(\))Tj
/F11 1 Tf
5.1 0 TD
( can be called to execute the display lists. For)Tj
-21.6 -1.5 TD
(example, you can pass a character string to the subroutine )Tj
/F15 1 Tf
23.4 0 TD
(printStrokedString\(\))Tj
/F11 1 Tf
8.1 0 TD
(:)Tj
/F7 1 Tf
-31.5 -2.1 TD
(void printStrokedString\(GLbyte *s\))Tj
0 -1.5 TD
({)Tj
T*
(   GLint len = strlen\(s\);)Tj
T*
(   glCallLists\(len, GL_BYTE, s\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(The ASCII value for each letter in the string is used as the offset into the display-list indices. The current)Tj
0 -1.5 TD
(list base is added to the ASCII value of each letter to determine the final display-list index to be)Tj
T*
[(executed. The output produced by )-12(Example 7-5)]TJ
19 0 TD
[( is shown in )-43(Figure 7-1)225(.)]TJ
ET
Q
/GS1 gs
q
408 0 0 78 124 351.7 cm
/Im70 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 339.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 7-1 )Tj
/F11 1 Tf
5.1 0 TD
(Stroked Font That Defines the Characters A, E, P, R, S)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 7-5 )Tj
/F11 1 Tf
6.1 0 TD
(Multiple Display Lists to Define a Stroked Font: stroke.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <string.h>)Tj
0 -3 TD
(#define PT 1)Tj
0 -1.5 TD
(#define STROKE 2)Tj
T*
(#define END 3)Tj
0 -3 TD
(typedef struct charpoint {)Tj
0 -1.5 TD
(   GLfloat   x, y;)Tj
T*
(   int    type;)Tj
T*
(} CP;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 15)Tj
ET
endstream
endobj
776 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im70 773 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
778 0 obj
<<
/Length 1773
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(CP Adata[] = {)Tj
0 -1.5 TD
(   { 0, 0, PT}, {0, 9, PT}, {1, 10, PT}, {4, 10, PT}, )Tj
T*
(   {5, 9, PT}, {5, 0, STROKE}, {0, 5, PT}, {5, 5, END})Tj
T*
(};)Tj
0 -3 TD
(CP Edata[] = {)Tj
0 -1.5 TD
(   {5, 0, PT}, {0, 0, PT}, {0, 10, PT}, {5, 10, STROKE},)Tj
T*
(   {0, 5, PT}, {4, 5, END})Tj
T*
(};)Tj
0 -3 TD
(CP Pdata[] = {)Tj
0 -1.5 TD
(   {0, 0, PT}, {0, 10, PT}, {4, 10, PT}, {5, 9, PT}, {5, 6, PT}, )Tj
T*
(   {4, 5, PT}, {0, 5, END})Tj
T*
(};)Tj
0 -3 TD
(CP Rdata[] = {)Tj
0 -1.5 TD
(   {0, 0, PT}, {0, 10, PT}, {4, 10, PT}, {5, 9, PT}, {5, 6, PT}, )Tj
T*
(   {4, 5, PT}, {0, 5, STROKE}, {3, 5, PT}, {5, 0, END})Tj
T*
(};)Tj
0 -3 TD
(CP Sdata[] = {)Tj
0 -1.5 TD
(   {0, 1, PT}, {1, 0, PT}, {4, 0, PT}, {5, 1, PT}, {5, 4, PT}, )Tj
T*
(   {4, 5, PT}, {1, 5, PT}, {0, 6, PT}, {0, 9, PT}, {1, 10, PT}, )Tj
T*
(   {4, 10, PT}, {5, 9, END})Tj
T*
(};)Tj
0 -3 TD
(/*  drawLetter\(\) interprets the instructions from the array)Tj
0 -1.5 TD
( *  for that letter and renders the letter with line segments.)Tj
T*
( */)Tj
T*
(static void drawLetter\(CP *l\))Tj
T*
({)Tj
T*
(   glBegin\(GL_LINE_STRIP\);)Tj
T*
(   while \(1\) {)Tj
T*
(      switch \(l->type\) {)Tj
T*
(         case PT:)Tj
T*
(            glVertex2fv\(&l->x\);)Tj
T*
(            break;)Tj
T*
(         case STROKE:)Tj
T*
(            glVertex2fv\(&l->x\);)Tj
T*
(            glEnd\(\);)Tj
T*
(            glBegin\(GL_LINE_STRIP\);)Tj
T*
(            break;)Tj
T*
(         case END:)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 16)Tj
ET
endstream
endobj
779 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
781 0 obj
<<
/Length 1687
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(            glVertex2fv\(&l->x\);)Tj
0 -1.5 TD
(            glEnd\(\);)Tj
T*
(            glTranslatef\(8.0, 0.0, 0.0\);)Tj
T*
(            return;)Tj
T*
(      })Tj
T*
(      l++;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(/*  Create a display list for each of 6 characters      */)Tj
0 -1.5 TD
(static void init \(void\))Tj
T*
({)Tj
T*
(   GLuint base;)Tj
0 -3 TD
(   glShadeModel \(GL_FLAT\);)Tj
T*
(   base = glGenLists \(128\);)Tj
0 -1.5 TD
(   glListBase\(base\);)Tj
T*
(   glNewList\(base+'A', GL_COMPILE\); drawLetter\(Adata\);)Tj
T*
(   glEndList\(\);)Tj
T*
(   glNewList\(base+'E', GL_COMPILE\); drawLetter\(Edata\);)Tj
T*
(   glEndList\(\);)Tj
T*
(   glNewList\(base+'P', GL_COMPILE\); drawLetter\(Pdata\);)Tj
T*
(   glEndList\(\);)Tj
T*
(   glNewList\(base+'R', GL_COMPILE\); drawLetter\(Rdata\);)Tj
T*
(   glEndList\(\);)Tj
T*
(   glNewList\(base+'S', GL_COMPILE\); drawLetter\(Sdata\);)Tj
T*
(   glEndList\(\);)Tj
T*
(   glNewList\(base+' `, GL_COMPILE\); )Tj
T*
(   glTranslatef\(8.0, 0.0, 0.0\); glEndList\(\);)Tj
T*
(})Tj
0 -3 TD
(char *test1 = "A SPARE SERAPE APPEARS AS";)Tj
0 -1.5 TD
(char *test2 = "APES PREPARE RARE PEPPERS";)Tj
0 -3 TD
(static void printStrokedString\(char *s\))Tj
0 -1.5 TD
({)Tj
T*
(   GLsizei len = strlen\(s\);)Tj
T*
(   glCallLists\(len, GL_BYTE, \(GLbyte *\)s\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 17)Tj
ET
endstream
endobj
782 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
784 0 obj
<<
/Length 1652
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glColor3f\(1.0, 1.0, 1.0\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glScalef\(2.0, 2.0, 2.0\);)Tj
T*
(   glTranslatef\(10.0, 30.0, 0.0\);)Tj
T*
(   printStrokedString\(test1\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glScalef\(2.0, 2.0, 2.0\);)Tj
T*
(   glTranslatef\(10.0, 13.0, 0.0\);)Tj
T*
(   printStrokedString\(test2\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   gluOrtho2D \(0.0, \(GLdouble\) w, 0.0, \(GLdouble\) h\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case ` `:)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(440, 120\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 18)Tj
ET
endstream
endobj
785 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
787 0 obj
<<
/Length 3329
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glutDisplayFunc\(display\);)Tj
0 -1.5 TD
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 633.000 Tm
(Managing State Variables with Display Lists)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 611.000 Tm
(A display list can contain calls that change the value of OpenGL state variables. These values change as)Tj
T*
(the display list is executed, just as if the commands were called in immediate mode and the changes)Tj
T*
[(persist after execution of the display list is completed. As previously seen in )23(Example 7-2)170( and in)]TJ
T*
(Example 7-6)Tj
5.1 0 TD
(, which follows, the changes to the current color and current matrix made during the)Tj
-5.1 -1.5 TD
(execution of the display list remain in effect after it has been called.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 7-6 )Tj
/F11 1 Tf
6.1 0 TD
(Persistence of State Changes after Execution of a Display List)Tj
/F7 1 Tf
-6.1 -2.4 TD
(glNewList\(listIndex,GL_COMPILE\);)Tj
0 -1.5 TD
(   glColor3f\(1.0, 0.0, 0.0\);)Tj
T*
(   glBegin\(GL_POLYGON\);)Tj
T*
(      glVertex2f\(0.0,0.0\);)Tj
T*
(      glVertex2f\(1.0,0.0\);)Tj
T*
(      glVertex2f\(0.0,1.0\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   glTranslatef\(1.5,0.0,0.0\);)Tj
T*
(glEndList\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(So if you now call the following sequence, the line drawn after the display list is drawn with red as the)Tj
0 -1.5 TD
(current color and translated by an additional \(1.5, 0.0, 0.0\):)Tj
/F7 1 Tf
0 -2.1 TD
(glCallList\(listIndex\);)Tj
0 -1.5 TD
(glBegin\(GL_LINES\);)Tj
T*
(   glVertex2f\(2.0,-1.0\);)Tj
T*
(   glVertex2f\(1.0,0.0\);)Tj
T*
(glEnd\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(Sometimes you want state changes to persist, but other times you want to save the values of state)Tj
0 -1.5 TD
(variables before executing a display list and then restore these values after the list has executed.)Tj
T*
(Remember that you cannot use )Tj
/F15 1 Tf
12.6 0 TD
(glGet*\(\))Tj
/F11 1 Tf
3.4 0 TD
( in a display list, so you must use another way to query and store)Tj
-16 -1.5 TD
(the values of state variables.)Tj
0 -2.1 TD
(You can use )Tj
/F15 1 Tf
5.2 0 TD
(glPushAttrib\(\))Tj
/F11 1 Tf
5.8 0 TD
( to save a group of state variables and )Tj
/F15 1 Tf
15.3 0 TD
(glPopAttrib\(\))Tj
/F11 1 Tf
5.4 0 TD
( to restore the values)Tj
-31.7 -1.5 TD
(when you're ready for them. To save and restore the current matrix, use )Tj
/F15 1 Tf
29 0 TD
(glPushMatrix\(\))Tj
/F11 1 Tf
6.1 0 TD
( and)Tj
/F15 1 Tf
-35.1 -1.5 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
[( as described in )44("Manipulating the Matrix Stacks" in Chapter 3)6(.)0( These push and pop)]TJ
-5.8 -1.5 TD
[(routines can be legally cached in a display list. To restore the state variables in )-35(Example 7-6)]TJ
36.8 0 TD
(, you might)Tj
-36.8 -1.5 TD
[(use the code shown in )-17(Example 7-7)]TJ
14.2 0 TD
(.)Tj
/F27 1 Tf
-14.2 -2.1 TD
(Example 7-7 )Tj
/F11 1 Tf
6.1 0 TD
(Restoring State Variables within a Display List)Tj
/F7 1 Tf
-6.1 -2.4 TD
(glNewList\(listIndex,GL_COMPILE\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 19)Tj
ET
endstream
endobj
788 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
790 0 obj
<<
/Length 2915
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glPushMatrix\(\);)Tj
0 -1.5 TD
(   glPushAttrib\(GL_CURRENT_BIT\);)Tj
T*
(   glColor3f\(1.0, 0.0, 0.0\);)Tj
T*
(   glBegin\(GL_POLYGON\);)Tj
T*
(      glVertex2f\(0.0,0.0\);)Tj
T*
(      glVertex2f\(1.0,0.0\);)Tj
T*
(      glVertex2f\(0.0,1.0\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   glTranslatef\(1.5,0.0,0.0\);)Tj
T*
(   glPopAttrib\(\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(glEndList\(\);)Tj
/F11 1 Tf
0 -2.1 TD
[(If you use the display list from )28(Example 7-7)170(, which restores values, the code in )49(Example 7-8)170( draws a)]TJ
0 -1.5 TD
[(green, untranslated line. With the display list in )23(Example 7-6)170(, which doesn't save and restore values, the)]TJ
T*
(line is drawn red, and its position is translated ten times \(1.5, 0.0, 0.0\).)Tj
/F27 1 Tf
0 -2.1 TD
(Example 7-8 )Tj
/F11 1 Tf
6.1 0 TD
(The Display List May or May Not Affect drawLine\(\))Tj
/F7 1 Tf
-6.1 -2.4 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLint i;)Tj
0 -3 TD
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glColor3f\(0.0, 1.0, 0.0\);  /* set current color to green   */)Tj
T*
(   for \(i = 0; i < 10; i++\))Tj
T*
(      glCallList\(listIndex\);  /* display list called 10 times */)Tj
T*
(   drawLine\(\);        /* how and where does this line appear? */)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 270.000 Tm
(Encapsulating Mode Changes)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 249.000 Tm
(You can use display lists to organize and store groups of commands to change various modes or set)Tj
T*
(various parameters. When you want to switch from one group of settings to another, using display lists)Tj
T*
(might be more efficient than making the calls directly, since the settings might be cached in a format that)Tj
T*
(matches the requirements of your graphics system.)Tj
0 -2.1 TD
(Display lists may be more efficient than immediate mode for switching among various lighting,)Tj
0 -1.5 TD
(lighting-model, and material-parameter settings. You might also use display lists for stipple patterns, fog)Tj
T*
(parameters, and clipping-plane equations. In general, you'll find that executing display lists is at least as)Tj
T*
(fast as making the relevant calls directly, but remember that some overhead is involved in jumping to a)Tj
T*
(display list.)Tj
0 -2.1 TD
(Example 7-9)Tj
5.1 0 TD
( shows how to use display lists to switch among three different line stipples. First, you call)Tj
/F15 1 Tf
-5.1 -1.5 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
( to allocate a display list for each stipple pattern and create a display list for each pattern.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 7,  Display Lists  - 20)Tj
ET
endstream
endobj
791 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
793 0 obj
<<
/Length 1623
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Then, you use )Tj
/F15 1 Tf
5.9 0 TD
(glCallList\(\))Tj
/F11 1 Tf
4.7 0 TD
( to switch from one stipple pattern to another.)Tj
/F27 1 Tf
-10.6 -2.1 TD
(Example 7-9 )Tj
/F11 1 Tf
6.1 0 TD
(Display Lists for Mode Changes)Tj
/F7 1 Tf
-6.1 -2.4 TD
(GLuint offset;)Tj
0 -1.5 TD
(offset = glGenLists\(3\);)Tj
0 -3 TD
(glNewList \(offset, GL_COMPILE\);)Tj
0 -1.5 TD
(    glDisable \(GL_LINE_STIPPLE\);)Tj
T*
(glEndList \(\);)Tj
0 -3 TD
(glNewList \(offset+1, GL_COMPILE\);)Tj
0 -1.5 TD
(    glEnable \(GL_LINE_STIPPLE\);)Tj
T*
(    glLineStipple \(1, 0x0F0F\);)Tj
T*
(glEndList \(\);)Tj
0 -3 TD
(glNewList \(offset+2, GL_COMPILE\);)Tj
0 -1.5 TD
(    glEnable \(GL_LINE_STIPPLE\);)Tj
T*
(    glLineStipple \(1, 0x1111\);)Tj
T*
(glEndList \(\);)Tj
0 -4.5 TD
(#define drawOneLine\(x1,y1,x2,y2\) glBegin\(GL_LINES\); \\ )Tj
0 -1.5 TD
(    glVertex2f \(\(x1\),\(y1\)\); glVertex2f \(\(x2\),\(y2\)\); glEnd\(\);)Tj
0 -3 TD
(glCallList \(offset\);)Tj
0 -1.5 TD
(drawOneLine \(50.0, 125.0, 350.0, 125.0\);)Tj
0 -3 TD
(glCallList \(offset+1\);)Tj
0 -1.5 TD
(drawOneLine \(50.0, 100.0, 350.0, 100.0\);)Tj
0 -3 TD
(glCallList \(offset+2\);)Tj
0 -1.5 TD
(drawOneLine \(50.0, 75.0, 350.0, 75.0\);)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 213.350 m
547.000 213.350 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 21)Tj
ET
endstream
endobj
794 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
796 0 obj
<<
/Length 3822
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 8)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Drawing Pixels, Bitmaps, Fonts, and Images)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Position and draw bitmapped data)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Read pixel data \(bitmaps and images\) from the framebuffer into processor memory and from)Tj
0 -1.5 TD
(memory into the framebuffer)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Copy pixel data from one color buffer to another, or to another location in the same buffer)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Magnify or reduce an image as it's written to the framebuffer)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Control pixel-data formatting and perform other transformations as the data is moved to and from)Tj
0 -1.6 TD
(the framebuffer)Tj
-1.9 -2.8 TD
(So far, most of the discussion in this guide has concerned the rendering of geometric data)Tj
/F33 1 Tf
35.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(points, lines,)Tj
-36.8 -1.6 TD
(and polygons. Two other important classes of data that can be rendered by OpenGL are)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Bitmaps, typically used for characters in fonts)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Image data, which might have been scanned in or calculated)Tj
-1.9 -2.8 TD
(Both bitmaps and image data take the form of rectangular arrays of pixels. One difference between them)Tj
0 -1.5 TD
(is that a )Tj
/F13 1 Tf
3.4 0 TD
(bitmap)Tj
/F11 1 Tf
3 0 TD
( consists of a single bit of information about each pixel, and image data typically)Tj
-6.4 -1.5 TD
(includes several pieces of data per pixel \(the complete red, green, blue, and alpha color components, for)Tj
T*
(example\). Also, bitmaps are like masks in that they're used to overlay another image, but image data)Tj
T*
(simply overwrites or is blended with whatever data is in the framebuffer.)Tj
0 -2.1 TD
(This chapter describes how to draw pixel data \(bitmaps and images\) from processor memory to the)Tj
0 -1.5 TD
(framebuffer and how to read pixel data from the framebuffer into processor memory. It also describes)Tj
T*
(how to copy pixel data from one position to another, either from one buffer to another or within a single)Tj
T*
(buffer. This chapter contains the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Bitmaps and Fonts")18( describes the commands for positioning and drawing bitmapped data. Such)]TJ
0 -1.6 TD
(data may describe a font.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Images" presents the basic information about drawing, reading and copying pixel data.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Imaging Pipeline")-22( describes the operations that are performed on images and bitmaps when they)]TJ
0 -1.6 TD
(are read from the framebuffer and when they are written to the framebuffer.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Reading and Drawing Pixel Rectangles")38( covers all the details of how pixel data is stored in)]TJ
0 -1.6 TD
(memory and how to transform it as it's moved into or out of memory.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Tips for Improving Pixel Drawing Rates")11( lists tips for getting better performance when drawing)]TJ
0 -1.5 TD
(pixel rectangles.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 1)Tj
ET
endstream
endobj
797 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
799 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im71
/Width 354
/Height 212
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.70)
>>
stream
endstream
endobj
801 0 obj
<<
/Length 3205
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(In most cases, the necessary pixel operations are simple, so the first three sections might be all you need)Tj
0 -1.7 TD
(to read for your application. However, pixel manipulation can be complex)Tj
/F33 1 Tf
29.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(there are many ways to store)Tj
-30.7 -1.5 TD
(pixel data in memory, and you can apply any of several transformations to pixels as they're moved to and)Tj
T*
(from the framebuffer. These details are the subject of the fourth section of this chapter. Most likely,)Tj
T*
(you'll want to read this section only when you actually need to make use of the information. The last)Tj
T*
(section provides useful tips to get the best performance when rendering bitmaps and images.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 600.000 Tm
(Bitmaps and Fonts)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 578.000 Tm
(A bitmap is a rectangular array of 0s and 1s that serves as a drawing mask for a corresponding)Tj
T*
(rectangular portion of the window. Suppose you're drawing a bitmap and that the current raster color is)Tj
T*
(red. Wherever there's a 1 in the bitmap, the corresponding pixel is replaced by a red pixel \(or combined)Tj
T*
[(with a red pixel, depending on which per-fragment operations are in effect. \(See )232("Testing and Operating)]TJ
T*
[(on Fragments" in Chapter 10)-25(.\) If there's a 0 in the bitmap, the contents of the pixel are unaffected. The)]TJ
T*
(most common use of bitmaps is for drawing characters on the screen.)Tj
0 -2.1 TD
(OpenGL provides only the lowest level of support for drawing strings of characters and manipulating)Tj
0 -1.5 TD
(fonts. The commands )Tj
/F15 1 Tf
8.9 0 TD
(glRasterPos*\(\))Tj
/F11 1 Tf
6 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
( position and draw a single bitmap on the screen. In)Tj
-21.2 -1.5 TD
(addition, through the display-list mechanism, you can use a sequence of character codes to index into a)Tj
T*
[(corresponding series of bitmaps representing those characters. \(See )35(Chapter 7)16( for more information about)]TJ
T*
(display lists.\) You'll have to write your own routines to provide any other support you need for)Tj
T*
(manipulating bitmaps, fonts, and strings of characters.)Tj
0 -2.1 TD
0.039 Tw
[(Consider Example )39(8-1)]TJ
9 0 TD
0.000 Tw
[(, which draws the character F three times on the screen. )-31(Figure 8-1)225( shows the F as)]TJ
-9 -1.5 TD
(a bitmap and its corresponding bitmap data.)Tj
ET
Q
/GS1 gs
q
354 0 0 212 124 144.88 cm
/Im71 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 132.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-1 )Tj
/F11 1 Tf
5.1 0 TD
(Bitmapped F and Its Data)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 8-1 )Tj
/F11 1 Tf
6.1 0 TD
(Drawing a Bitmapped Character: drawf.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 2)Tj
ET
endstream
endobj
802 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im71 799 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
804 0 obj
<<
/Length 1648
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(#include <GL/glu.h>)Tj
0 -1.5 TD
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(GLubyte rasters[24] = {)Tj
0 -1.5 TD
(   0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00,)Tj
T*
(   0xff, 0x00, 0xff, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00,)Tj
T*
(   0xff, 0xc0, 0xff, 0xc0};)Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glPixelStorei \(GL_UNPACK_ALIGNMENT, 1\);)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
T*
(   glRasterPos2i \(20, 20\);)Tj
T*
(   glBitmap \(10, 12, 0.0, 0.0, 11.0, 0.0, rasters\);)Tj
T*
(   glBitmap \(10, 12, 0.0, 0.0, 11.0, 0.0, rasters\);)Tj
T*
(   glBitmap \(10, 12, 0.0, 0.0, 11.0, 0.0, rasters\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   glOrtho \(0, w, 0, h, -1.0, 1.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(   })Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 3)Tj
ET
endstream
endobj
805 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
807 0 obj
<<
/Length 3895
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize\(100, 100\);)Tj
T*
(   glutInitWindowPosition\(100, 100\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
[(In )-17(Figure 8-1)225(, note that the visible part of the F character is at most 10 bits wide. Bitmap data is always)]TJ
0 -1.5 TD
(stored in chunks that are multiples of 8 bits, but the width of the actual bitmap doesn't have to be a)Tj
T*
(multiple of 8. The bits making up a bitmap are drawn starting from the lower-left corner: First, the)Tj
T*
(bottom row is drawn, then the next row above it, and so on. As you can tell from the code, the bitmap is)Tj
0 -1.6 TD
(stored in memory in this order)Tj
/F33 1 Tf
12.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the array of rasters begins with 0xc0, 0x00, 0xc0, 0x00 for the bottom)Tj
-13.1 -1.6 TD
(two rows of the F and continues to 0xff, 0xc0, 0xff, 0xc0 for the top two rows.)Tj
0 -2.1 TD
(The commands of interest in this example are )Tj
/F15 1 Tf
18.5 0 TD
(glRasterPos2i\(\))Tj
/F11 1 Tf
6.3 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
(; they're discussed in detail)Tj
-31.1 -1.5 TD
(in the next section. For now, ignore the call to )Tj
/F15 1 Tf
18.7 0 TD
(glPixelStorei\(\))Tj
/F11 1 Tf
5.9 0 TD
(; it describes how the bitmap data is stored)Tj
-24.6 -1.5 TD
[(in computer memory. \(See )16("Controlling Pixel-Storage Modes")227( for more information.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 339.000 Tm
(The Current Raster Position)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 317.000 Tm
(The )Tj
/F13 1 Tf
1.8 0 TD
(current raster position)Tj
/F11 1 Tf
9.7 0 TD
( is the origin where the next bitmap \(or image\) is to be drawn. In the F)Tj
-11.5 -1.5 TD
(example, the raster position was set by calling )Tj
/F15 1 Tf
18.7 0 TD
(glRasterPos*\(\))Tj
/F11 1 Tf
6 0 TD
( with coordinates \(20, 20\), which is where)Tj
-24.7 -1.5 TD
(the lower-left corner of the F was drawn:)Tj
/F7 1 Tf
0 -2.1 TD
(glRasterPos2i\(20, 20\); )Tj
/F15 1 Tf
T*
[(void )-28(glRasterPos)-10({234}{sifd}\()79(TYPE x, TYPE y, TYPE z, TYPE w)-18(\))0(;)]TJ
0 -1.1 TD
0.028 Tw
[(void glRasterPos)-10({234}{sifd})46(v)-56(\()33(TYPE )28(*coords)7(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Sets the current raster position. The )41(x, y, z)-23(,)0( and )-50(w)67( arguments specify the coordinates of the raster)]TJ
T*
[(position. If the vector form of the function is used, the coords)22( array contains the coordinates of the)]TJ
T*
[(raster position. If )24(glRasterPos2*\(\))-44( is used, z)-11( is implicitly set to zero and )7(w)67( is implicitly set to one;)]TJ
T*
[(similarly, with )30(glRasterPos3*\(\))-44(, w)-33( is set to one.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(The coordinates of the raster position are transformed to screen coordinates in exactly the same way as)Tj
0 -1.5 TD
(coordinates supplied with a )Tj
/F15 1 Tf
11.2 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.6 0 TD
( command \(that is, with the modelview and perspective matrices\).)Tj
-15.8 -1.5 TD
(After transformation, they either define a valid spot in the viewport, or they're clipped out because the)Tj
T*
(coordinates were outside the viewing volume. If the transformed point is clipped out, the current raster)Tj
T*
(position is invalid.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 4)Tj
ET
endstream
endobj
808 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
809 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im72
/Width 376
/Height 174
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.71)
>>
stream
endstream
endobj
811 0 obj
<<
/Length 3641
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
0.000 Tw
(If you want to specify the raster position in screen coordinates, you'll want to make sure you've)Tj
-2.8 -1.4 TD
(specified the modelview and projection matrices for simple 2D rendering, with something like this)Tj
T*
(sequence of commands, where )Tj
/F15 1 Tf
12.5 0 TD
(width)Tj
/F11 1 Tf
2.2 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(height)Tj
/F11 1 Tf
2.5 0 TD
( are also the size \(in pixels\) of the viewport:)Tj
/F7 1 Tf
-19.2 -2.1 TD
(glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(glLoadIdentity\(\);)Tj
T*
(gluOrtho2D\(0.0, \(GLfloat\) width, 0.0, \(GLfloat\) height\);)Tj
T*
(glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(glLoadIdentity\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(To obtain the current raster position, you can use the query command )Tj
/F15 1 Tf
28 0 TD
(glGetFloatv\(\))Tj
/F11 1 Tf
5.5 0 TD
( with)Tj
-33.5 -1.5 TD
(GL_CURRENT_RASTER_POSITION as the first argument. The second argument should be a pointer)Tj
T*
(to an array that can hold the \()Tj
/F15 1 Tf
11.7 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.5 0 TD
(\) values as floating-point numbers. Call)Tj
/F15 1 Tf
15.8 0 TD
( glGetBooleanv\(\))Tj
/F11 1 Tf
6.9 0 TD
( with)Tj
-37.9 -1.5 TD
(GL_CURRENT_RASTER_POSITION_VALID as the first argument to determine whether the current)Tj
T*
(raster position is valid.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 491.000 Tm
(Drawing the Bitmap)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 469.000 Tm
(Once you've set the desired raster position, you can use the )Tj
/F15 1 Tf
24 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
( command to draw the data.)Tj
/F15 1 Tf
-28.3 -2.1 TD
[(void )-28(glBitmap)67(\(GLsizei )-61(width)23(, GLsizei )6(height, GLfloat )-38(x)]TJ
22.1 -0.2 TD
(bo)Tj
1 0.2 TD
(,)Tj
-23.1 -1.3 TD
0.038 Tw
(GLfloat y)Tj
3.8 -0.2 TD
(bo)Tj
1 0.2 TD
0.000 Tw
[(, GLfloat )-38(x)]TJ
4.3 -0.2 TD
(bi)Tj
0.8 0.2 TD
(,)Tj
-9.9 -1.3 TD
0.038 Tw
(GLfloat y)Tj
3.8 -0.2 TD
(bi)Tj
0.8 0.2 TD
0.000 Tw
[(, const GLubyte )56(*bitmap)-22(\);)]TJ
-2.8 -1.7 TD
[(Draws the bitmap specified by )17(bitmap)-22(, which is a pointer to the bitmap image. The origin of the)]TJ
0 -1.5 TD
(bitmap is placed at the current raster position. If the current raster position is invalid, nothing is)Tj
T*
[(drawn, and the raster position remains invalid. The )-7(width)23( and height arguments indicate the width)]TJ
T*
(and height, in pixels, of the bitmap. The width need not be a multiple of 8, although the data is)Tj
T*
(stored in unsigned characters of 8 bits each. \(In the F example, it wouldn't matter if there were)Tj
T*
[(garbage bits in the data beyond the tenth bit; since )12(glBitmap\(\))33( was called with a width of 10, only 10)]TJ
T*
[(bits of the row are rendered.\) Use )34(x)]TJ
14.3 -0.2 TD
(bo)Tj
1 0.2 TD
( and y)Tj
2.4 -0.2 TD
(bo)Tj
1 0.2 TD
( to define the origin of the bitmap \(positive values)Tj
-18.7 -1.7 TD
(move the origin up and to the right of the raster position; negative values move it down and to the)Tj
0 -1.5 TD
0.006 Tw
(left\); x)Tj
2.6 -0.2 TD
(bi)Tj
0.8 0.2 TD
0.000 Tw
( and y)Tj
2.5 -0.2 TD
(bi)Tj
0.7 0.2 TD
[( indicate the x)-56( and y)44( increments that are added to the raster position after the)]TJ
-6.6 -1.7 TD
[(bitmap is rasterized \(see )-44(Figure 8-2)]TJ
14.4 0 TD
(\).)Tj
ET
Q
/GS1 gs
q
376 0 0 174 124 78.31 cm
/Im72 Do
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 5)Tj
ET
endstream
endobj
812 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im72 809 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
814 0 obj
<<
/Length 5436
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 8-2 )Tj
/F11 1 Tf
5.1 0 TD
(Bitmap and Its Associated Parameters)Tj
-5.1 -2.1 TD
(Allowing the origin of the bitmap to be placed arbitrarily makes it easy for characters to extend below the)Tj
0 -1.5 TD
(origin \(typically used for characters with descenders, such as g, j, and y\), or to extend beyond the left of)Tj
T*
(the origin \(used for various swash characters, which have extended flourishes, or for characters in fonts)Tj
T*
(that lean to the left\).)Tj
0 -2.1 TD
(After the bitmap is drawn, the current raster position is advanced by )Tj
/F15 1 Tf
27.5 0 TD
(x)Tj
/F11 1 Tf
0.4 -0.2 TD
(bi)Tj
0.8 0.2 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(y)Tj
/F11 1 Tf
0.5 -0.2 TD
(bi)Tj
0.8 0.2 TD
( in the)Tj
/F15 1 Tf
2.5 0 TD
( x)Tj
/F11 1 Tf
0.6 0 TD
(- and )Tj
/F15 1 Tf
2.3 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(-directions,)Tj
-37.8 -1.7 TD
(respectively. \(If you just want to advance the current raster position without drawing anything, call)Tj
/F15 1 Tf
0 -1.5 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
( with the )Tj
/F15 1 Tf
3.8 0 TD
(bitmap)Tj
/F11 1 Tf
2.8 0 TD
( parameter set to NULL and with the )Tj
/F15 1 Tf
15 0 TD
(width)Tj
/F11 1 Tf
2.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(height)Tj
/F11 1 Tf
2.5 0 TD
( set to zero.\) For)Tj
-32.5 -1.5 TD
(standard Latin fonts, )Tj
/F15 1 Tf
8.5 0 TD
(y)Tj
/F11 1 Tf
0.4 -0.2 TD
(bi)Tj
0.8 0.2 TD
( is typically 0.0 and )Tj
/F15 1 Tf
8.1 0 TD
(x)Tj
/F11 1 Tf
0.5 -0.2 TD
(bi)Tj
0.8 0.2 TD
( is positive \(since successive characters are drawn from)Tj
-19.1 -1.7 TD
(left to right\). For Hebrew, where characters go from right to left, the )Tj
/F15 1 Tf
27.5 0 TD
(x)Tj
/F11 1 Tf
0.5 -0.2 TD
(bi)Tj
0.8 0.2 TD
( values would typically be)Tj
-28.8 -1.7 TD
(negative. Fonts that draw successive characters vertically in columns would use zero for )Tj
/F15 1 Tf
35.5 0 TD
(x)Tj
/F11 1 Tf
0.5 -0.2 TD
(bi)Tj
0.8 0.2 TD
( and nonzero)Tj
-36.8 -1.7 TD
(values for )Tj
/F15 1 Tf
4.2 0 TD
(y)Tj
/F11 1 Tf
0.5 -0.2 TD
(bi)Tj
0.7 0.2 TD
[(. In )-17(Figure 8-2)225(, each time the F is drawn, the current raster position advances by 11 pixels,)]TJ
-5.4 -1.7 TD
(allowing a 1-pixel space between successive characters.)Tj
0 -2.1 TD
(Since )Tj
/F15 1 Tf
2.5 0 TD
(x)Tj
/F11 1 Tf
0.4 -0.2 TD
(bo)Tj
1 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.5 -0.2 TD
(bo)Tj
1 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(x)Tj
/F11 1 Tf
0.4 -0.2 TD
(bi)Tj
0.8 0.2 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(y)Tj
/F11 1 Tf
0.4 -0.2 TD
(bi)Tj
0.8 0.2 TD
( are floating-point values, characters need not be an integral number of pixels)Tj
-11 -1.7 TD
(apart. Actual characters are drawn on exact pixel boundaries, but the current raster position is kept in)Tj
0 -1.5 TD
(floating point so that each character is drawn as close as possible to where it belongs. For example, if the)Tj
T*
(code in the F example was modified so that )Tj
/F15 1 Tf
17.6 0 TD
(x)Tj
/F11 1 Tf
0.5 -0.2 TD
(bi)Tj
0.8 0.2 TD
( is 11.5 instead of 12, and if more characters were drawn,)Tj
-18.9 -1.7 TD
(the space between letters would alternate between 1 and 2 pixels, giving the best approximation to the)Tj
0 -1.5 TD
(requested 1.5-pixel space.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(You can't rotate bitmap fonts because the bitmap is always drawn aligned to the )Tj
/F15 1 Tf
32.4 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(y)Tj
/F11 1 Tf
-37.5 -1.4 TD
(framebuffer axes.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 344.000 Tm
(Choosing a Color for the Bitmap)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 323.000 Tm
(You are familiar with using )Tj
/F15 1 Tf
11.3 0 TD
(glColor*\(\))Tj
/F11 1 Tf
4.3 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glIndex*\(\))Tj
/F11 1 Tf
4.2 0 TD
( to set the current color or index to draw geometric)Tj
-21.7 -1.5 TD
(primitives. The same commands are used to set different state variables,)Tj
T*
(GL_CURRENT_RASTER_COLOR and GL_CURRENT_RASTER_INDEX, for rendering bitmaps.)Tj
T*
(The raster color state variables are set when )Tj
/F15 1 Tf
17.8 0 TD
(glRasterPos*\(\))Tj
/F11 1 Tf
6 0 TD
( is called, which can lead to a trap. In the)Tj
-23.8 -1.5 TD
(following sequence of code, what is the color of the bitmap?)Tj
/F7 1 Tf
0 -2.1 TD
(glColor3f\(1.0, 1.0, 1.0\);  /* white */)Tj
0 -1.5 TD
(glRasterPos3fv\(position\);)Tj
T*
(glColor3f\(1.0, 0.0, 0.0\);  /* red  */)Tj
T*
(glBitmap\(....\);)Tj
/F11 1 Tf
0 -2.1 TD
(The bitmap is white! The GL_CURRENT_RASTER_COLOR is set to white when )Tj
/F15 1 Tf
33.5 0 TD
(glRasterPos3fv\(\))Tj
/F11 1 Tf
6.8 0 TD
( is)Tj
-40.3 -1.5 TD
(called. The second call to )Tj
/F15 1 Tf
10.4 0 TD
(glColor3f\(\))Tj
/F11 1 Tf
4.6 0 TD
( changes the value of GL_CURRENT_COLOR for future)Tj
-15 -1.5 TD
(geometric rendering, but the color used to render the bitmap is unchanged.)Tj
0 -2.1 TD
(To obtain the current raster color or index, you can use the query commands )Tj
/F15 1 Tf
30.8 0 TD
(glGetFloatv\(\))Tj
/F11 1 Tf
5.5 0 TD
( or)Tj
/F15 1 Tf
-36.3 -1.5 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
( with GL_CURRENT_RASTER_COLOR or GL_CURRENT_RASTER_INDEX as the)Tj
-6.2 -1.5 TD
(first argument.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 6)Tj
ET
endstream
endobj
815 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
817 0 obj
<<
/Length 4886
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Fonts and Display Lists)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 687.000 Tm
[(Display lists are discussed in general terms in Chapter 7)16(.)0( However, a few of the display-list management)]TJ
0 -1.5 TD
(commands have special relevance for drawing strings of characters. As you read this section, keep in)Tj
T*
(mind that the ideas presented here apply equally well to characters that are drawn using bitmap data and)Tj
T*
[(those drawn using geometric primitives \(points, lines, and polygons\). \(See )-26("Executing Multiple Display)]TJ
T*
[(Lists" in Chapter 7)48( for an example of a geometric font.\))]TJ
0 -2.1 TD
(A font typically consists of a set of characters, where each character has an identifying number \(usually)Tj
0 -1.5 TD
(the ASCII code\) and a drawing method. For a standard ASCII character set, the capital letter A is number)Tj
T*
(65, B is 66, and so on. The string "DAB" would be represented by the three indices 68, 65, 66. In the)Tj
T*
(simplest approach, display-list number 65 draws an A, number 66 draws a B, and so on. Then to draw the)Tj
T*
(string 68, 65, 66, just execute the corresponding display lists.)Tj
0 -2.1 TD
(You can use the command )Tj
/F15 1 Tf
10.9 0 TD
(glCallLists\(\))Tj
/F11 1 Tf
5 0 TD
( in just this way:)Tj
/F7 1 Tf
-15.9 -2.1 TD
(void glCallLists\(GLsizei n, GLenum type, const GLvoid *lists\);)Tj
/F11 1 Tf
T*
(The first argument, )Tj
/F15 1 Tf
7.9 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(, indicates the number of characters to be drawn, )Tj
/F15 1 Tf
19.7 0 TD
(type)Tj
/F11 1 Tf
1.7 0 TD
( is usually GL_BYTE, and)Tj
/F15 1 Tf
-29.8 -1.5 TD
(lists)Tj
/F11 1 Tf
1.6 0 TD
( is an array of character codes.)Tj
-1.6 -2.1 TD
(Since many applications need to draw character strings in multiple fonts and sizes, this simplest approach)Tj
0 -1.5 TD
(isn't convenient. Instead, you'd like to use 65 as A no matter what font is currently active. You could)Tj
T*
(force font 1 to encode A, B, and C as 1065, 1066, 1067, and font 2 as 2065, 2066, 2067, but then any)Tj
T*
(numbers larger than 256 would no longer fit in an 8-bit byte. A better solution is to add an offset to every)Tj
T*
(entry in the string and to choose the display list. In this case, font 1 has A, B, and C represented by 1065,)Tj
T*
(1066, and 1067, and in font 2, they might be 2065, 2066, and 2067. Then to draw characters in font 1, set)Tj
T*
(the offset to 1000 and draw display lists 65, 66, and 67. To draw that same string in font 2, set the offset)Tj
T*
(to 2000 and draw the same lists.)Tj
0 -2.1 TD
(To set the offset, use the command )Tj
/F15 1 Tf
14.2 0 TD
(glListBase\(\))Tj
/F11 1 Tf
4.9 0 TD
(. For the preceding examples, it should be called with)Tj
-19.1 -1.5 TD
(1000 or 2000 as the \(only\) argument. Now what you need is a contiguous list of unused display-list)Tj
T*
(numbers, which you can obtain from )Tj
/F15 1 Tf
15 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
(:)Tj
/F7 1 Tf
-20 -2.1 TD
(GLuint glGenLists\(GLsizei range\); )Tj
/F11 1 Tf
T*
(This function returns a block of )Tj
/F15 1 Tf
12.9 0 TD
(range)Tj
/F11 1 Tf
2.3 0 TD
( display-list identifiers. The returned lists are all marked as "used")Tj
-15.2 -1.5 TD
(even though they're empty, so that subsequent calls to )Tj
/F15 1 Tf
21.9 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
( never return the same lists \(unless)Tj
-26.9 -1.5 TD
(you've explicitly deleted them previously\). Therefore, if you use 4 as the argument and if )Tj
/F15 1 Tf
36 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
-36 -1.5 TD
(returns 81, you can use display-list identifiers 81, 82, 83, and 84 for your characters. If )Tj
/F15 1 Tf
34.9 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
( can't)Tj
-39.9 -1.5 TD
(find a block of unused identifiers of the requested length, it returns 0. \(Note that the command)Tj
/F15 1 Tf
T*
(glDeleteLists\(\))Tj
/F11 1 Tf
5.9 0 TD
( makes it easy to delete all the lists associated with a font in a single operation.\))Tj
-5.9 -2.1 TD
(Most American and European fonts have a small number of characters \(fewer than 256\), so it's easy to)Tj
0 -1.5 TD
(represent each character with a different code that can be stored in a single byte. Asian fonts, among)Tj
T*
(others, may require much larger character sets, so a byte-per-character encoding is impossible. OpenGL)Tj
T*
(allows strings to be composed of 1-, 2-, 3-, or 4-byte characters through the )Tj
/F15 1 Tf
30.4 0 TD
(type)Tj
/F11 1 Tf
1.7 0 TD
( parameter in)Tj
/F15 1 Tf
-32.1 -1.5 TD
(glCallLists\(\))Tj
/F11 1 Tf
5.1 0 TD
(. This parameter can have any of the following values:)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 7)Tj
ET
endstream
endobj
818 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
820 0 obj
<<
/Length 2736
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(GL_BYTE  GL_UNSIGNED_BYTE)Tj
0 -2.1 TD
(GL_SHORT  GL_UNSIGNED_SHORT)Tj
T*
(GL_INT  GL_UNSIGNED_INT)Tj
T*
(GL_FLOAT  GL_2_BYTES)Tj
T*
(GL_3_BYTES  GL_4_BYTES)Tj
T*
[(\(See )27("Executing Multiple Display Lists" in Chapter 7)18( for more information about these values.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 577.000 Tm
(Defining and Using a Complete Font)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 556.000 Tm
(The )Tj
/F15 1 Tf
1.8 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
( command and the display-list mechanism described in the previous section make it easy)Tj
-6.1 -1.5 TD
[(to define a raster font. In )37(Example 8-2)170(, the upper-case characters of an ASCII font are defined. In this)]TJ
T*
(example, each character has the same width, but this is not always the case. Once the characters are)Tj
T*
(defined, the program prints the message "THE QUICK BROWN FOX JUMPS OVER A LAZY DOG".)Tj
0 -2.1 TD
[(The code in )-28(Example 8-2)]TJ
10.1 0 TD
( is similar to the F example, except that each character's bitmap is stored in its)Tj
-10.1 -1.5 TD
(own display list. The display list identifier, when combined with the offset returned by )Tj
/F15 1 Tf
34.9 0 TD
(glGenLists\(\))Tj
/F11 1 Tf
5 0 TD
(, is)Tj
-39.9 -1.5 TD
(equal to the ASCII code for the character.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 8-2 )Tj
/F11 1 Tf
6.1 0 TD
(Drawing a Complete Font: font.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <string.h>)Tj
0 -3 TD
(GLubyte space[] =)Tj
0 -1.5 TD
(    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,)Tj
T*
( 0x00, 0x00};)Tj
T*
(GLubyte letters[][13] = {)Tj
T*
(    {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66,)Tj
T*
( 0x3c, 0x18},)Tj
T*
(    {0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3,)Tj
T*
( 0xc7, 0xfe},)Tj
T*
(    {0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,)Tj
T*
( 0xe7, 0x7e},)Tj
T*
(    {0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7,)Tj
T*
( 0xce, 0xfc},)Tj
T*
(    {0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0,)Tj
T*
( 0xc0, 0xff},)Tj
T*
(    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0,)Tj
T*
( 0xc0, 0xff},)Tj
T*
(    {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0,)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 8)Tj
ET
endstream
endobj
821 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
823 0 obj
<<
/Length 2299
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
( 0xe7, 0x7e},)Tj
0 -1.5 TD
(    {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3,)Tj
T*
( 0xc3, 0xc3},)Tj
T*
(    {0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,)Tj
T*
( 0x18, 0x7e},)Tj
T*
(    {0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,)Tj
T*
( 0x06, 0x06},)Tj
T*
(    {0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc,)Tj
T*
( 0xc6, 0xc3},)Tj
T*
(    {0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,)Tj
T*
( 0xc0, 0xc0},)Tj
T*
(    {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff,)Tj
T*
( 0xe7, 0xc3},)Tj
T*
(    {0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3,)Tj
T*
( 0xe3, 0xe3},)Tj
T*
(    {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,)Tj
T*
( 0xe7, 0x7e},)Tj
T*
(    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3,)Tj
T*
( 0xc7, 0xfe},)Tj
T*
(    {0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,)Tj
T*
( 0x66, 0x3c},)Tj
T*
(    {0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3,)Tj
T*
( 0xc7, 0xfe},)Tj
T*
(    {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0,)Tj
T*
( 0xe7, 0x7e},)Tj
T*
(    {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,)Tj
T*
( 0x18, 0xff},)Tj
T*
(    {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,)Tj
T*
( 0xc3, 0xc3},)Tj
T*
(    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3,)Tj
T*
( 0xc3, 0xc3},)Tj
T*
(    {0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3,)Tj
T*
( 0xc3, 0xc3},)Tj
T*
(    {0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66,)Tj
T*
( 0x66, 0xc3},)Tj
T*
(    {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66,)Tj
T*
( 0x66, 0xc3},)Tj
T*
(    {0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03,)Tj
T*
( 0x03, 0xff})Tj
T*
(};)Tj
0 -3 TD
(GLuint fontOffset;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 9)Tj
ET
endstream
endobj
824 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
826 0 obj
<<
/Length 1700
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void makeRasterFont\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLuint i, j;)Tj
T*
(   glPixelStorei\(GL_UNPACK_ALIGNMENT, 1\);)Tj
0 -3 TD
(   fontOffset = glGenLists \(128\);)Tj
0 -1.5 TD
(   for \(i = 0,j = `A'; i < 26; i++,j++\) {)Tj
T*
(      glNewList\(fontOffset + j, GL_COMPILE\);)Tj
T*
(      glBitmap\(8, 13, 0.0, 2.0, 10.0, 0.0, letters[i]\);)Tj
T*
(      glEndList\(\);)Tj
T*
(   })Tj
T*
(   glNewList\(fontOffset + ` `, GL_COMPILE\);)Tj
T*
(   glBitmap\(8, 13, 0.0, 2.0, 10.0, 0.0, space\);)Tj
T*
(   glEndList\(\);)Tj
T*
(})Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
T*
(   makeRasterFont\(\);)Tj
T*
(})Tj
0 -3 TD
(void printString\(char *s\))Tj
0 -1.5 TD
({)Tj
T*
(   glPushAttrib \(GL_LIST_BIT\);)Tj
T*
(   glListBase\(fontOffset\);)Tj
T*
(   glCallLists\(strlen\(s\), GL_UNSIGNED_BYTE, \(GLubyte *\) s\);)Tj
T*
(   glPopAttrib \(\);)Tj
T*
(})Tj
0 -3 TD
(/* Everything above this line could be in a library )Tj
0 -1.5 TD
( * that defines a font.  To make it work, you've got )Tj
T*
( * to call makeRasterFont\(\) before you start making )Tj
T*
( * calls to printString\(\).)Tj
T*
( */)Tj
T*
(void display\(void\))Tj
T*
({)Tj
T*
(   GLfloat white[3] = { 1.0, 1.0, 1.0 };)Tj
0 -3 TD
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glColor3fv\(white\);)Tj
0 -3 TD
(   glRasterPos2i\(20, 60\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 10)Tj
ET
endstream
endobj
827 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
829 0 obj
<<
/Length 1907
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   printString\("THE QUICK BROWN FOX JUMPS"\);)Tj
0 -1.5 TD
(   glRasterPos2i\(20, 40\);)Tj
T*
(   printString\("OVER A LAZY DOG"\);)Tj
T*
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   glOrtho \(0.0, w, 0.0, h, -1.0, 1.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize\(300, 100\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 138.000 Tm
(Images)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 116.000 Tm
(An image is similar to a bitmap, but instead of containing only a single bit for each pixel in a rectangular)Tj
T*
(region of the screen, an image can contain much more information. For example, an image can contain a)Tj
T*
(complete \(R, G, B, A\) color stored at each pixel. Images can come from several sources, such as)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 11)Tj
ET
endstream
endobj
830 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
832 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im73
/Width 370
/Height 153
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.72)
>>
stream
endstream
endobj
834 0 obj
<<
/Length 3749
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
(A photograph that's digitized with a scanner)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(An image that was first generated on the screen by a graphics program using the graphics hardware)Tj
0 -1.6 TD
(and then read back, pixel by pixel)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A software program that generated the image in memory pixel by pixel)Tj
-1.9 -2.8 TD
(The images you normally think of as pictures come from the color buffers. However, you can read or)Tj
0 -1.5 TD
[(write rectangular regions of pixel data from or to the depth buffer or the stencil buffer. \(See )28(Chapter 10)]TJ
T*
(for an explanation of these other buffers.\))Tj
0 -2.1 TD
(In addition to simply being displayed on the screen, images can be used for texture maps, in which case)Tj
0 -1.5 TD
[(they're essentially pasted onto polygons that are rendered on the screen in the normal way. \(See )-20(Chapter)]TJ
T*
(9 for more information about this technique.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 512.000 Tm
(Reading, Writing, and Copying Pixel Data)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 490.000 Tm
(OpenGL provides three basic commands that manipulate image data:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glReadPixels\(\))Tj
/F33 1 Tf
5.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Reads a rectangular array of pixels from the framebuffer and stores the data in)Tj
-6.9 -1.6 TD
(processor memory.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glDrawPixels\(\))Tj
/F33 1 Tf
6.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Writes a rectangular array of pixels from data kept in processor memory into the)Tj
-7.2 -1.6 TD
(framebuffer at the current raster position specified by )Tj
/F15 1 Tf
21.6 0 TD
(glRasterPos*\(\))Tj
/F11 1 Tf
6.1 0 TD
(.)Tj
/F33 1 Tf
-29.5 -2.2 TD
(  )Tj
/F15 1 Tf
1.8 0 TD
(glCopyPixels\(\))Tj
/F33 1 Tf
6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Copies a rectangular array of pixels from one part of the framebuffer to another.)Tj
-7 -1.5 TD
(This command behaves similarly to a call to )Tj
/F15 1 Tf
17.9 0 TD
(glReadPixels\(\))Tj
/F11 1 Tf
6 0 TD
( followed by a call to )Tj
/F15 1 Tf
8.7 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
(,)Tj
-38.8 -1.5 TD
(but the data is never written into processor memory.)Tj
-1.9 -2.7 TD
[(For the aforementioned commands, the order of pixel data processing operations is shown in Figure 8-3)225(:)]TJ
ET
Q
/GS1 gs
q
370 0 0 153 124 167.35 cm
/Im73 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 155.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-3 )Tj
/F11 1 Tf
5.1 0 TD
(Simplistic Diagram of Pixel Data Flow)Tj
-5.1 -2.1 TD
[(The basic ideas in )44(Figure 8-3)225( are correct. The coordinates of )]TJ
/F15 1 Tf
24.4 0 TD
(glRasterPos*\(\))Tj
/F11 1 Tf
6 0 TD
(, which specify the current)Tj
-30.4 -1.5 TD
(raster position used by )Tj
/F15 1 Tf
9.3 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.1 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
(, are transformed by the geometric processing)Tj
-23.4 -1.5 TD
(pipeline. Both )Tj
/F15 1 Tf
5.9 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
( are affected by rasterization and per-fragment)Tj
-20 -1.5 TD
(operations. \(But when drawing or copying a pixel rectangle, there's almost never a reason to have fog or)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 12)Tj
ET
endstream
endobj
835 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im73 832 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
837 0 obj
<<
/Length 4836
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(texture enabled.\))Tj
0 -2.1 TD
(However, additional steps arise because there are many kinds of framebuffer data, many ways to store)Tj
0 -1.5 TD
(pixel information in computer memory, and various data conversions that can be performed during the)Tj
T*
(reading, writing, and copying operations. These possibilities translate to many different modes of)Tj
T*
(operation. If all your program does is copy images on the screen or read them into memory temporarily)Tj
T*
(so that they can be copied out later, you can ignore most of these modes. However, if you want your)Tj
0 -1.6 TD
(program to modify the data while it's in memory)Tj
/F33 1 Tf
19.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, if you have an image stored in one)Tj
-20.6 -1.7 TD
(format but the window requires a different format)Tj
/F33 1 Tf
19.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(or if you want to save image data to a file for future)Tj
-20.9 -1.6 TD
(restoration in another session or on another kind of machine with significantly different graphical)Tj
0 -1.5 TD
(capabilities, you have to understand the various modes.)Tj
0 -2.1 TD
(The rest of this section describes the basic commands in detail. The following sections discuss the details)Tj
0 -1.5 TD
(of the series of imaging operations that comprise the Imaging Pipeline: pixel-storage modes,)Tj
T*
(pixel-transfer operations, and pixel-mapping operations.)Tj
/F27 1 Tf
0 -3 TD
(Reading Pixel Data from Frame Buffer to Processor Memory)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glReadPixels)78(\(GLint )-83(x)44(,)0( GLint )-16(y)44(,)0( GLsizei )6(width)-77(, GLsizei )6(height,)]TJ
0 -1.1 TD
[(GLenum )-6(format)-33(, GLenum )-6(type)66(, GLvoid *)-50(pixels)33(\);)]TJ
1.8 -1.5 TD
(Reads pixel data from the framebuffer rectangle whose lower-left corner is at \()Tj
31.6 0 TD
[(x, y)-12(\))0( and whose)]TJ
-31.6 -1.5 TD
[(dimensions are )34(width)-77( and height and stores it in the array pointed to by )91(pixels)-67(. format)67( indicates the)]TJ
T*
(kind of pixel data elements that are read \(an index value or an R, G, B, or A component value, as)Tj
T*
[(listed in )45(Table 8-1)]TJ
7.3 0 TD
[(\), and )-17(type)-34( indicates the data type of each element \(see )15(Table 8-2)]TJ
26 0 TD
(\).)Tj
/F11 1 Tf
-35.1 -2.1 TD
(If you are using )Tj
/F15 1 Tf
6.6 0 TD
(glReadPixels\(\))Tj
/F11 1 Tf
5.9 0 TD
( to obtain RGBA or color-index information, you may need to clarify)Tj
-12.5 -1.5 TD
(which buffer you are trying to access. For example, if you have a double-buffered window, you need to)Tj
T*
(specify whether you are reading data from the front buffer or back buffer. To control the current read)Tj
T*
(source buffer, call )Tj
/F15 1 Tf
7.5 0 TD
(glReadBuffer\(\))Tj
/F11 1 Tf
6 0 TD
[(. \(See )27("Selecting Color Buffers for Writing and Reading" in Chapter)]TJ
-13.5 -1.5 TD
(10.\))Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 301.100 m
463.000 301.100 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 293.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(format Constant)-8276(Pixel Format)]TJ
ET
Q
124.000 287.580 m
463.000 287.580 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 279.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_COLOR_INDEX)-5389(A single color index)]TJ
0 -1.4444 TD
[(GL_RGB)-10333(A red color component, followed by a green color)]TJ
14.2222 -1.3333 TD
(component, followed by a blue color component)Tj
-14.2222 -1.4444 TD
[(GL_RGBA)-9611(A red color component, followed by a green color)]TJ
14.2222 -1.3333 TD
(component, followed by a blue color component,)Tj
T*
(followed  by an alpha color component)Tj
-14.2222 -1.4444 TD
[(GL_RED)-10389(A single red color component)]TJ
T*
[(GL_GREEN)-9056(A single green color component)]TJ
T*
[(GL_BLUE)-9778(A single blue color component)]TJ
T*
[(GL_ALPHA)-9056(A single alpha color component)]TJ
T*
[(GL_LUMINANCE)-6389(A single luminance component)]TJ
T*
[(GL_LUMINANCE_ALPHA)-2555(A luminance component followed by an alpha color)]TJ
14.2222 -1.3333 TD
(component)Tj
-14.2222 -1.4444 TD
[(GL_STENCIL_INDEX)-4667(A single stencil index)]TJ
T*
[(GL_DEPTH_COMPONENT)-2443(A single depth component)]TJ
ET
Q
124.000 93.520 m
463.010 93.520 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 77.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 8-1 )Tj
/F11 1 Tf
4.6 0 TD
(Pixel Formats for glReadPixels\(\) or glDrawPixels\(\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 13)Tj
ET
endstream
endobj
838 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
840 0 obj
<<
/Length 5006
>>
stream
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 714.010 m
468.000 714.010 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 706.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(type Constant)-14707(Data Type)]TJ
ET
Q
124.000 700.490 m
468.000 700.490 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 692.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_UNSIGNED_BYTE)-8944(unsigned 8-bit integer)]TJ
0 -1.4445 TD
[(GL_BYTE)-14555(signed 8-bit integer)]TJ
T*
[(GL_BITMAP)-13388(single bits in unsigned 8-bit integers using the)]TJ
19 -1.3333 TD
(same format as )Tj
/F15 1 Tf
6.3333 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
-25.3333 -1.4444 TD
[(GL_UNSIGNED_SHORT)-8277(unsigned 16-bit integer)]TJ
T*
[(GL_SHORT)-13888(signed 16-bit integer)]TJ
T*
[(GL_UNSIGNED_INT)-9890(unsigned 32-bit integer)]TJ
T*
[(GL_INT)-15501(signed 32-bit integer)]TJ
T*
[(GL_FLOAT)-13944(single-precision floating point)]TJ
ET
Q
124.000 581.580 m
468.010 581.580 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 565.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 8-2 )Tj
/F11 1 Tf
4.6 0 TD
(Data Types for glReadPixels\(\) or glDrawPixels\(\))Tj
-4.6 -2.1 TD
(Remember that, depending on the format, anywhere from one to four elements are read \(or written\). For)Tj
0 -1.5 TD
(example, if the format is GL_RGBA and you're reading into 32-bit integers \(that is, if )Tj
/F15 1 Tf
34.7 0 TD
(type)Tj
/F11 1 Tf
1.7 0 TD
( is equal to)Tj
-36.4 -1.5 TD
(GL_UNSIGNED_INT or GL_INT\), then every pixel read requires 16 bytes of storage \(four components)Tj
/F33 1 Tf
0 -1.6 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
( four bytes/component\).)Tj
-0.5 -2.2 TD
[(Each element of the image is stored in memory as indicated by )-12(Table 8-2)]TJ
29.2 0 TD
(. If the element represents a)Tj
-29.2 -1.5 TD
(continuous value, such as a red, green, blue, or )Tj
/F13 1 Tf
19 0 TD
(luminance)Tj
/F11 1 Tf
4.4 0 TD
( component, each value is scaled to fit into the)Tj
-23.4 -1.5 TD
(available number of bits. For example, assume the red component is initially specified as a floating-point)Tj
T*
(value between 0.0 and 1.0. If it needs to be packed into an unsigned byte, only 8 bits of precision are)Tj
T*
(kept, even if more bits are allocated to the red component in the framebuffer. GL_UNSIGNED_SHORT)Tj
T*
(and GL_UNSIGNED_INT give 16 and 32 bits of precision, respectively. The normal \(signed\) versions)Tj
T*
(of GL_BYTE, GL_SHORT, and GL_INT have 7, 15, and 31 bits of precision, since the negative values)Tj
T*
(are typically not used.)Tj
0 -2.1 TD
(If the element is an index \(a color index or a stencil index, for example\), and the type is not GL_FLOAT,)Tj
0 -1.6 TD
(the value is simply masked against the available bits in the type. The signed versions)Tj
/F33 1 Tf
33.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(GL_BYTE,)Tj
-34.9 -1.7 TD
(GL_SHORT, and GL_INT)Tj
/F33 1 Tf
10.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(have masks with one fewer bit. For example, if a color index is to be stored)Tj
-11.8 -1.6 TD
(in a signed 8-bit integer, it's first masked against 0x7f. If the type is GL_FLOAT, the index is simply)Tj
0 -1.5 TD
(converted into a single-precision floating-point number \(for example, the index 17 is converted to the)Tj
T*
(float 17.0\).)Tj
/F27 1 Tf
0 -3 TD
(Writing Pixel Data from Processor Memory to Frame Buffer)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glDrawPixels\(GLsizei )39(width)23(, GLsizei )6(height, GLenum )-6(format)-33(,)]TJ
0 -1.1 TD
[(GLenum )-6(type)-34(, const GLvoid *)12(pixels)33(\);)]TJ
1.8 -1.5 TD
[(Draws a rectangle of pixel data with dimensions )-31(width)23( and height. The pixel rectangle is drawn with)]TJ
T*
(its lower-left corner at the current raster position. )Tj
20.3 0 TD
[(format)-33( and type)66( have the same meaning as with)]TJ
-20.3 -1.5 TD
[(glReadPixels\(\))44(. \(For legal values for )-44(format)-33( and type)66(, see )-73(Table 8-1)]TJ
27.2 0 TD
( and Table 8-2)Tj
5.9 0 TD
(.\) The array)Tj
-33.1 -1.5 TD
[(pointed to by )-27(pixels)33( contains the pixel data to be drawn. If the current raster position is invalid,)]TJ
T*
(nothing is drawn, and the raster position remains invalid.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(Example 8-3)Tj
5.1 0 TD
( is a portion of a program, which uses )Tj
/F15 1 Tf
15.4 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.1 0 TD
( to draw an pixel rectangle in the)Tj
-26.6 -1.5 TD
(lower-left corner of a window. )Tj
/F15 1 Tf
12.5 0 TD
(makeCheckImage\(\))Tj
/F11 1 Tf
7.8 0 TD
( creates a 64-by-64 RGB array of a black-and-white)Tj
-20.3 -1.5 TD
(checkerboard image. )Tj
/F15 1 Tf
8.6 0 TD
(glRasterPos2i\()Tj
/F11 1 Tf
6 0 TD
(0,0)Tj
/F15 1 Tf
1.2 0 TD
(\))Tj
/F11 1 Tf
0.4 0 TD
( positions the lower-left corner of the image. For now, ignore)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 14)Tj
ET
endstream
endobj
841 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
843 0 obj
<<
/Length 2281
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glPixelStorei\(\))Tj
/F11 1 Tf
5.9 0 TD
0.000 Tw
(.)Tj
/F27 1 Tf
-5.9 -2.1 TD
(Example 8-3 )Tj
/F11 1 Tf
6.1 0 TD
(Use of glDrawPixels\(\): image.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#define checkImageWidth 64)Tj
0 -1.5 TD
(#define checkImageHeight 64)Tj
T*
(GLubyte checkImage[checkImageHeight][checkImageWidth][3];)Tj
0 -3 TD
(void makeCheckImage\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i, j, c;)Tj
T*
(   )Tj
T*
(   for \(i = 0; i < checkImageHeight; i++\) {)Tj
T*
(      for \(j = 0; j < checkImageWidth; j++\) {)Tj
T*
(         c = \(\(\(\(i&0x8\)==0\)^\(\(j&0x8\)\)==0\)\)*255;)Tj
T*
(         checkImage[i][j][0] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][1] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][2] = \(GLubyte\) c;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({  )Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel\(GL_FLAT\);)Tj
T*
(   makeCheckImage\(\);)Tj
T*
(   glPixelStorei\(GL_UNPACK_ALIGNMENT, 1\);)Tj
T*
(})Tj
T*
(void display\(void\))Tj
T*
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glRasterPos2i\(0, 0\);)Tj
T*
(   glDrawPixels\(checkImageWidth, checkImageHeight, GL_RGB,)Tj
T*
(                GL_UNSIGNED_BYTE, checkImage\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(When using )Tj
/F15 1 Tf
5.1 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.1 0 TD
( to write RGBA or color-index information, you may need to control the)Tj
-11.2 -1.5 TD
(current drawing buffers with )Tj
/F15 1 Tf
11.7 0 TD
(glDrawBuffer\(\))Tj
/F11 1 Tf
6.2 0 TD
(, which, along with )Tj
/F15 1 Tf
8 0 TD
(glReadBuffer\(\))Tj
/F11 1 Tf
6 0 TD
(, is also described in)Tj
-31.9 -1.5 TD
[("Selecting Color Buffers for Writing and Reading" in Chapter 10)-34(.)]TJ
/F27 1 Tf
0 -3 TD
(Copying Pixel Data within the Frame Buffer)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glCopyPixels)34(\(GLint )17(x)-56(,)0( GLint )-16(y)44(,)0( GLsizei )6(width)23(, GLsizei )6(height,)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 15)Tj
ET
endstream
endobj
844 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
845 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im74
/Width 499
/Height 131
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.73)
>>
stream
endstream
endobj
847 0 obj
<<
/Length 4120
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.006 Tw
[(GLenum buffer)-11(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Copies pixel data from the framebuffer rectangle whose lower-left corner is at \()Tj
31.9 0 TD
[(x, y)-12(\))0( and whose)]TJ
-31.9 -1.5 TD
[(dimensions are )34(width)-77( and height. The data is copied to a new position whose lower-left corner is)]TJ
T*
[(given by the current raster position. )40(buffer)-11( is either GL_COLOR, GL_STENCIL, or GL_DEPTH,)]TJ
T*
[(specifying the framebuffer that is used. )7(glCopyPixels\(\) behaves similarly to a )6(glReadPixels\(\))]TJ
T*
[(followed by a )40(glDrawPixels\(\))-33(, with the following translation for the buffer)-11( to)28( format )-33(parameter:)]TJ
/F33 1 Tf
-1.7 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If )Tj
/F15 1 Tf
0.9 0 TD
(buffer)Tj
/F11 1 Tf
2.4 0 TD
( is GL_DEPTH or GL_STENCIL, then GL_DEPTH_COMPONENT or)Tj
-3.3 -1.6 TD
(GL_STENCIL_INDEX is used, respectively.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If GL_COLOR is specified, GL_RGBA or GL_COLOR_INDEX is used, depending on whether the)Tj
0 -1.6 TD
(system is in RGBA or color-index mode.)Tj
-1.9 -2.7 TD
(Note that there's no need for a )Tj
/F15 1 Tf
12.4 0 TD
(format)Tj
/F11 1 Tf
2.7 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(data)Tj
/F11 1 Tf
1.8 0 TD
( parameter for )Tj
/F15 1 Tf
5.9 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
(, since the data is never)Tj
-30.1 -1.5 TD
(copied into processor memory. The read source buffer and the destination buffer of )Tj
/F15 1 Tf
33.5 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
( are)Tj
-39.5 -1.5 TD
(specified by )Tj
/F15 1 Tf
5.1 0 TD
(glReadBuffer\(\))Tj
/F11 1 Tf
6 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glDrawBuffer\(\))Tj
/F11 1 Tf
6.2 0 TD
( respectively. Both )Tj
/F15 1 Tf
7.8 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.1 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
-35.2 -1.5 TD
[(are used in )-17(Example 8-4)]TJ
9.7 0 TD
(.)Tj
-9.7 -2.1 TD
(For all three functions, the exact conversions of the data going to or from the framebuffer depend on the)Tj
0 -1.5 TD
(modes in effect at the time. See the next section for details.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 419.000 Tm
(Imaging Pipeline)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 397.000 Tm
(This section discusses the complete Imaging Pipeline: the pixel-storage modes and pixel-transfer)Tj
T*
(operations, which include how to set up an arbitrary mapping to convert pixel data. You can also magnify)Tj
T*
(or reduce a pixel rectangle before it's drawn by calling )Tj
/F15 1 Tf
22.2 0 TD
(glPixelZoom\(\))Tj
/F11 1 Tf
5.7 0 TD
(. The order of these operations is)Tj
-27.9 -1.5 TD
[(shown in )-11(Figure 8-4)225(.)]TJ
ET
Q
/GS1 gs
q
423 0 0 111 124 226.61 cm
/Im74 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 214.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-4 )Tj
/F11 1 Tf
5.1 0 TD
(Imaging Pipeline)Tj
-5.1 -2.1 TD
(When )Tj
/F15 1 Tf
2.6 0 TD
(glDrawPixels\(\) )Tj
/F11 1 Tf
6.5 0 TD
(is called, the data is first unpacked from processor memory according to the)Tj
-9.1 -1.5 TD
(pixel-storage modes that are in effect and then the pixel-transfer operations are applied. The resulting)Tj
T*
(pixels are then rasterized. During rasterization, the pixel rectangle may be zoomed up or down,)Tj
T*
(depending on the current state. Finally, the fragment operations are applied and the pixels are written into)Tj
T*
[(the framebuffer. \(See )-25("Testing and Operating on Fragments" in Chapter 10)78( for a discussion of the)]TJ
T*
(fragment operations.\))Tj
0 -2.1 TD
(When )Tj
/F15 1 Tf
2.6 0 TD
(glReadPixels\(\))Tj
/F11 1 Tf
6 0 TD
( is called, data is read from the framebuffer, the pixel-transfer operations are)Tj
-8.6 -1.5 TD
(performed, and then the resulting data is packed into processor memory.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 16)Tj
ET
endstream
endobj
848 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im74 845 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
849 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im75
/Width 322
/Height 88
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.74)
>>
stream
endstream
endobj
850 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im76
/Width 526
/Height 76
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.75)
>>
stream
endstream
endobj
851 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im77
/Width 278
/Height 124
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.76)
>>
stream
endstream
endobj
853 0 obj
<<
/Length 2770
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
0.000 Tw
( applies all the pixel-transfer operations during what would be the )Tj
/F15 1 Tf
26.6 0 TD
(glReadPixels\(\))Tj
/F11 1 Tf
5.9 0 TD
( activity.)Tj
-38.5 -1.5 TD
(The resulting data is written as it would be by )Tj
/F15 1 Tf
18.6 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.1 0 TD
(, but the transformations aren't applied a)Tj
-24.7 -1.5 TD
[(second time. )6(Figure 8-5)225( shows how )]TJ
/F15 1 Tf
14.5 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
( moves pixel data, starting from the frame buffer.)Tj
ET
Q
/GS1 gs
q
322 0 0 88 124 576.5601 cm
/Im75 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 564.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-5 )Tj
/F11 1 Tf
5.1 0 TD
(glCopyPixels\(\) Pixel Path)Tj
-5.1 -2.1 TD
[(From )17("Drawing the Bitmap")-17( and )44(Figure 8-6)225(, you see that rendering bitmaps is simpler than rendering)]TJ
0 -1.5 TD
(images. Neither the pixel-transfer operations nor the pixel-zoom operation are applied.)Tj
ET
Q
q
423 0 0 61 124 452.56 cm
/Im76 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 440.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-6 )Tj
/F11 1 Tf
5.1 0 TD
(glBitmap\(\) Pixel Path)Tj
-5.1 -2.1 TD
(Note that the pixel-storage modes and pixel-transfer operations are applied to textures as they are read)Tj
0 -1.5 TD
[(from or written to texture memory. )50(Figure 8-7)225( shows the effect on )]TJ
/F15 1 Tf
26.7 0 TD
(glTexImage*\(\))Tj
/F11 1 Tf
5.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glTexSubImage*\(\))Tj
/F11 1 Tf
7.4 0 TD
(,)Tj
-40.5 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(glGetTexImage\(\))Tj
/F11 1 Tf
6.8 0 TD
(.)Tj
ET
Q
q
278 0 0 124 124 250.44 cm
/Im77 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 238.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-7 )Tj
/F11 1 Tf
5.1 0 TD
(glTexImage*\(\), glTexSubImage*\(\), and glGetTexImage\(\) Pixel Paths)Tj
-5.1 -2.1 TD
[(As seen in )17(Figure 8-8)225(, when pixel data is copied from the framebuffer into texture memory)]TJ
0 -1.5 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(glCopyTexImage*\(\))Tj
/F11 1 Tf
8 0 TD
( or )Tj
/F15 1 Tf
1.4 0 TD
(glCopyTexSubImage*\(\))Tj
/F11 1 Tf
9.5 0 TD
(\), only pixel-transfer operations are applied. \(See )Tj
19.8 0 TD
(Chapter)Tj
-39 -1.5 TD
(9 for more information on textures.\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 17)Tj
ET
endstream
endobj
854 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im75 849 0 R
/Im76 850 0 R
/Im77 851 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
855 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im78
/Width 468
/Height 135
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.77)
>>
stream
endstream
endobj
857 0 obj
<<
/Length 3793
>>
stream
/GS1 gs
q
423 0 0 122 124 598 cm
/Im78 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 585.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-8 )Tj
/F11 1 Tf
5.1 0 TD
(glCopyTexImage*\(\) and glCopyTexSubImage*\(\) Pixel Paths)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 556.000 Tm
(Pixel Packing and Unpacking)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 535.000 Tm
(Packing and unpacking refer to the way that pixel data is written to and read from processor memory.)Tj
0 -2.1 TD
(An image stored in memory has between one and four chunks of data, called )Tj
/F15 1 Tf
30.9 0 TD
(elements)Tj
/F11 1 Tf
3.5 0 TD
(. The data might)Tj
-34.4 -1.5 TD
(consist of just the color index or the luminance \(luminance is the weighted sum of the red, green, and)Tj
T*
(blue values\), or it might consist of the red, green, blue, and alpha components for each pixel. The)Tj
T*
(possible arrangements of pixel data, or )Tj
/F15 1 Tf
15.7 0 TD
(formats)Tj
/F11 1 Tf
3.1 0 TD
(, determine the number of elements stored for each pixel)Tj
-18.8 -1.5 TD
(and their order.)Tj
0 -2.1 TD
(Some elements \(such as a color index or a stencil index\) are integers, and others \(such as the red, green,)Tj
0 -1.5 TD
(blue, and alpha components, or the depth component\) are floating-point values, typically ranging)Tj
T*
(between 0.0 and 1.0. Floating-point components are usually stored in the framebuffer with lower)Tj
T*
(resolution than a full floating-point number would require \(for example, color components may be stored)Tj
T*
(in 8 bits\). The exact number of bits used to represent the components depends on the particular hardware)Tj
T*
(being used. Thus, it's often wasteful to store each component as a full 32-bit floating-point number,)Tj
T*
(especially since images can easily contain a million pixels.)Tj
0 -2.1 TD
(Elements can be stored in memory as various data types, ranging from 8-bit bytes to 32-bit integers or)Tj
0 -1.5 TD
(floating-point numbers. OpenGL explicitly defines the conversion of each component in each format to)Tj
T*
(each of the possible data types. Keep in mind that you may lose data if you try to store a high-resolution)Tj
T*
(component in a type represented by a small number of bits.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 248.000 Tm
(Controlling Pixel-Storage Modes)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 227.000 Tm
(Image data is typically stored in processor memory in rectangular two- or three-dimensional arrays.)Tj
T*
(Often, you want to display or store a subimage that corresponds to a subrectangle of the array. In)Tj
T*
(addition, you might need to take into account that different machines have different byte-ordering)Tj
T*
(conventions. Finally, some machines have hardware that is far more efficient at moving data to and from)Tj
T*
(the framebuffer if the data is aligned on 2-byte, 4-byte, or 8-byte boundaries in processor memory. For)Tj
T*
(such machines, you probably want to control the byte alignment. All the issues raised in this paragraph)Tj
T*
(are controlled as pixel-storage modes, which are discussed in the next subsection. You specify these)Tj
T*
(modes by using )Tj
/F15 1 Tf
6.5 0 TD
(glPixelStore*\(\))Tj
/F11 1 Tf
6.1 0 TD
(, which you've already seen used in a couple of example programs.)Tj
-12.6 -2.1 TD
(All the possible pixel-storage modes are controlled with the )Tj
/F15 1 Tf
24.1 0 TD
(glPixelStore*\(\))Tj
/F11 1 Tf
6.1 0 TD
( command. Typically, several)Tj
-30.2 -1.5 TD
(successive calls are made with this command to set several parameter values.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 18)Tj
ET
endstream
endobj
858 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im78 855 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
860 0 obj
<<
/Length 4924
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.028 Tw
[(void glPixelStore)45({if}\(GLenum )12(pname)-34(, )28(TYPE)34(param)11(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Sets the pixel-storage modes, which affect the operation of )Tj
23.7 0 TD
[(glDrawPixels\(\))67(, glReadPixels\(\))-56(,)]TJ
-23.7 -1.5 TD
[(glBitmap\(\))33(, glPolygonStipple\(\))-44(, glTexImage1D\(\))10(, glTexImage2D\(\))10(, glTexSubImage1D\(\))10(,)]TJ
T*
[(glTexSubImage2D\(\))10(, and )-50(glGetTexImage\(\).)82( The possible parameter names for )-32(pname)-34( are shown in)]TJ
T*
(Table 8-3)Tj
3.9 0 TD
(, along with their data type, initial value, and valid range of values. The GL_UNPACK*)Tj
-3.9 -1.5 TD
[(parameters control how data is unpacked from memory by glDrawPixels\(\))-33(, glBitmap\(\))33(,)]TJ
T*
[(glPolygonStipple\(\))-44(, glTexImage1D\(\))10(, glTexImage2D\(\))10(,)50( glTexSubImage1D\(\))-40(, and)]TJ
T*
[(glTexSubImage2D\(\))10(. The GL_PACK* parameters control how data is packed into memory by)]TJ
T*
[(glReadPixels\(\))44( and glGetTexImage\(\))-68(.)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 580.000 m
460.000 580.000 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 572.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Parameter Name)-9856(Type)-4791(Initial Value)-1566(Valid Range)]TJ
ET
Q
124.000 566.480 m
460.000 566.480 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 558.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(GL_UNPACK_SWAP_BYTES,)Tj
0 -1.3333 TD
(GL_PACK_SWAP_BYTES)Tj
15.7778 1.3333 TD
[(GLboolean)-1834(FALSE)-3277(TRUE/FALSE)]TJ
-15.7778 -2.7778 TD
(GL_UNPACK_LSB_FIRST,)Tj
0 -1.3333 TD
(GL_PACK_LSB_FIRST)Tj
15.7778 1.3333 TD
[(GLboolean)-1834(FALSE)-3277(TRUE/FALSE)]TJ
-15.7778 -2.7778 TD
(GL_UNPACK_ROW_LENGTH,)Tj
0 -1.3333 TD
(GL_PACK_ROW_LENGTH)Tj
15.7778 1.3333 TD
0.000 Tw
[(GLint)-3944(0)-5833(any nonnegative)]TJ
12.6667 -1.3333 TD
(integer)Tj
-28.4444 -1.4444 TD
(GL_UNPACK_SKIP_ROWS,)Tj
0 -1.3333 TD
(GL_PACK_SKIP_ROWS)Tj
15.7778 1.3333 TD
[(GLint)-3944(0)-5833(any nonnegative)]TJ
12.6667 -1.3333 TD
(integer)Tj
-28.4444 -1.4444 TD
(GL_UNPACK_SKIP_PIXELS,)Tj
0 -1.3333 TD
(GL_PACK_SKIP_PIXELS)Tj
15.7778 1.3333 TD
[(GLint)-3944(0)-5833(any nonnegative)]TJ
12.6667 -1.3333 TD
(integer)Tj
-28.4444 -1.4444 TD
(GL_UNPACK_ALIGNMENT,)Tj
0 -1.3333 TD
(GL_PACK_ALIGNMENT)Tj
15.7778 1.3333 TD
[(GLint)-3944(4)-5833(1, 2, 4, 8)]TJ
ET
Q
124.000 413.670 m
460.010 413.670 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 397.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 8-3 )Tj
/F11 1 Tf
4.6 0 TD
(glPixelStore\(\) Parameters)Tj
-4.6 -2.1 TD
(Since the corresponding parameters for packing and unpacking have the same meanings, they're)Tj
0 -1.5 TD
(discussed together in the rest of this section and referred to without the GL_PACK or GL_UNPACK)Tj
T*
(prefix. For example, *SWAP_BYTES refers to GL_PACK_SWAP_BYTES and)Tj
T*
(GL_UNPACK_SWAP_BYTES.)Tj
0 -2.1 TD
(If the *SWAP_BYTES parameter is FALSE \(the default\), the ordering of the bytes in memory is)Tj
0 -1.5 TD
(whatever is native for the OpenGL client; otherwise, the bytes are reversed. The byte reversal applies to)Tj
T*
(any size element, but really only has a meaningful effect for multibyte elements.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(As long as your OpenGL application doesn't share images with other machines, you can ignore)Tj
-2.8 -1.4 TD
(the issue of byte ordering. If your application must render an OpenGL image that was created on a)Tj
T*
(different machine and the "endianness" of the two machines differs, byte ordering can be swapped using)Tj
T*
(*SWAP_BYTES. However, *SWAP_BYTES does not allow you to reorder elements \(for example, to)Tj
0 -1.5 TD
(swap red and green\).)Tj
0 -2.1 TD
(The *LSB_FIRST parameter applies when drawing or reading 1-bit images or bitmaps, for which a)Tj
0 -1.5 TD
(single bit of data is saved or restored for each pixel. If *LSB_FIRST is FALSE \(the default\), the bits are)Tj
T*
(taken from the bytes starting with the most significant bit; otherwise, they're taken in the opposite order.)Tj
T*
(For example, if *LSB_FIRST is FALSE, and the byte in question is 0x31, the bits, in order, are {0, 0, 1,)Tj
T*
(1, 0, 0, 0, 1}. If *LSB_FIRST is TRUE, the order is {1, 0, 0, 0, 1, 1, 0, 0}.)Tj
0 -2.1 TD
(Sometimes you want to draw or read only a subrectangle of the entire rectangle of image data stored in)Tj
0 -1.5 TD
(memory. If the rectangle in memory is larger than the subrectangle that's being drawn or read, you need)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 19)Tj
ET
endstream
endobj
861 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
862 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im79
/Width 376
/Height 229
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.78)
>>
stream
endstream
endobj
864 0 obj
<<
/Length 3556
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(to specify the actual length \(measured in pixels\) of the larger rectangle with *ROW_LENGTH. If)Tj
0 -1.5 TD
(*ROW_LENGTH is zero \(which it is by default\), the row length is understood to be the same as the)Tj
T*
(width that's specified with )Tj
/F15 1 Tf
10.9 0 TD
(glReadPixels\(\))Tj
/F11 1 Tf
5.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
(. You also need to specify)Tj
-31.1 -1.5 TD
(the number of rows and pixels to skip before starting to copy the data for the subrectangle. These)Tj
T*
[(numbers are set using the parameters *SKIP_ROWS and *SKIP_PIXELS, as shown in )-16(Figure 8-9)225(. By)]TJ
T*
(default, both parameters are 0, so you start at the lower-left corner.)Tj
ET
Q
/GS1 gs
q
376 0 0 229 124 392.84 cm
/Im79 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 380.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-9 )Tj
/F11 1 Tf
5.1 0 TD
(*SKIP_ROWS, *SKIP_PIXELS, and *ROW_LENGTH Parameters)Tj
-5.1 -2.1 TD
(Often a particular machine's hardware is optimized for moving pixel data to and from memory, if the)Tj
0 -1.5 TD
(data is saved in memory with a particular byte alignment. For example, in a machine with 32-bit words,)Tj
T*
(hardware can often retrieve data much faster if it's initially aligned on a 32-bit boundary, which typically)Tj
T*
(has an address that is a multiple of 4. Likewise, 64-bit architectures might work better when the data is)Tj
T*
(aligned to 8-byte boundaries. On some machines, however, byte alignment makes no difference.)Tj
0 -2.1 TD
(As an example, suppose your machine works better with pixel data aligned to a 4-byte boundary. Images)Tj
0 -1.5 TD
(are most efficiently saved by forcing the data for each row of the image to begin on a 4-byte boundary. If)Tj
T*
(the image is 5 pixels wide and each pixel consists of 1 byte each of red, green, and blue information, a)Tj
0 -1.6 TD
(row requires 5 )Tj
/F33 1 Tf
6 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
( 3 = 15 bytes of data. Maximum display efficiency can be achieved if the first row, and)Tj
-6.6 -1.6 TD
(each successive row, begins on a 4-byte boundary, so there is 1 byte of waste in the memory storage for)Tj
0 -1.5 TD
(each row. If your data is stored like this, set the *ALIGNMENT parameter appropriately \(to 4, in this)Tj
T*
(case\).)Tj
0 -2.1 TD
(If *ALIGNMENT is set to 1, the next available byte is used. If it's 2, a byte is skipped if necessary at the)Tj
0 -1.5 TD
(end of each row so that the first byte of the next row has an address that's a multiple of 2. In the case of)Tj
T*
(bitmaps \(or 1-bit images\) where a single bit is saved for each pixel, the same byte alignment works,)Tj
T*
(although you have to count individual bits. For example, if you're saving a single bit per pixel, the row)Tj
T*
(length is 75, and the alignment is 4, then each row requires 75/8, or 9 3/8 bytes. Since 12 is the smallest)Tj
T*
(multiple of 4 that is bigger than 9 3/8, 12 bytes of memory are used for each row. If the alignment is 1,)Tj
T*
(then 10 bytes are used for each row, as 9 3/8 is rounded up to the next byte. \(There is a simple use of)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 20)Tj
ET
endstream
endobj
865 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im79 862 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
867 0 obj
<<
/Length 6542
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glPixelStorei\(\))Tj
/F11 1 Tf
5.9 0 TD
0.000 Tw
[( in )-22(Example 8-4)]TJ
6.4 0 TD
(.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 679.000 Tm
(Pixel-Transfer Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 658.000 Tm
(As image data is transferred from memory into the framebuffer, or from the framebuffer into memory,)Tj
0 -1.5 TD
(OpenGL can perform several operations on it. For example, the ranges of components can be)Tj
0 -1.6 TD
(altered)Tj
/F33 1 Tf
2.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(normally, the red component is between 0.0 and 1.0, but you might prefer to keep it in some)Tj
-3.7 -1.6 TD
(other range; or perhaps the data you're using from a different graphics system stores the red component)Tj
0 -1.5 TD
(in a different range. You can even create maps to perform arbitrary conversion of color indices or color)Tj
T*
(components during pixel transfer. Conversions such as these performed during the transfer of pixels to)Tj
T*
(and from the framebuffer are called pixel-transfer operations. They're controlled with the)Tj
/F15 1 Tf
T*
(glPixelTransfer*\(\))Tj
/F11 1 Tf
7.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glPixelMap*\(\) )Tj
/F11 1 Tf
6.1 0 TD
(commands.)Tj
-15.5 -2.1 TD
(Be aware that although the color, depth, and stencil buffers have many similarities, they don't behave)Tj
0 -1.5 TD
(identically, and a few of the modes have special cases for special buffers. All the mode details are)Tj
T*
(covered in this section and the sections that follow, including all the special cases.)Tj
0 -2.1 TD
(Some of the pixel-transfer function characteristics are set with )Tj
/F15 1 Tf
25.1 0 TD
(glPixelTransfer*\(\))Tj
/F11 1 Tf
7.5 0 TD
(. The other)Tj
-32.6 -1.5 TD
(characteristics are specified with )Tj
/F15 1 Tf
13.3 0 TD
(glPixelMap*\(\))Tj
/F11 1 Tf
5.9 0 TD
(, which is described in the next section.)Tj
/F15 1 Tf
-19.2 -2.1 TD
0.028 Tw
[(void glPixelTransfer)-21({if}\(GLenum )112(pname)-34(, )28(TYPE)34(param)11(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Sets pixel-transfer modes that affect the operation of )Tj
21.3 0 TD
[(glDrawPixels\(\))67(, glReadPixels\(\))-56(,)]TJ
-21.3 -1.5 TD
[(glCopyPixels\(\),)50( glTexImage1D\(\))-40(, glTexImage2D\(\))10(, glCopyTexImage1D\(\))21(, glCopyTexImage2D\(\))-79(,)]TJ
T*
[(glTexSubImage1D\(\))10(, glTexSubImage2D\(\))10(, glCopyTexSubImage1D\(\))21(, glCopyTexSubImage2D\(\))-79(, and)]TJ
T*
[(glGetTexImage\(\))32(. The parameter )-33(pname)-34( must be one of those listed in the first column of )69(Table 8-4)]TJ
39.7 0 TD
(,)Tj
-39.7 -1.5 TD
[(and its value, )12(param)11(, must be in the valid range shown.)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 356.830 m
464.000 356.830 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 349.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Parameter Name)-6356(Type)-4791(Initial Value)-2691(Valid Range)]TJ
ET
Q
124.000 343.310 m
464.000 343.310 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 335.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(GL_MAP_COLOR)-4776(GLboolean)-1834(FALSE)-4277(TRUE/FALSE)]TJ
0 -1.4444 TD
[(GL_MAP_STENCIL)-4054(GLboolean)-1834(FALSE)-4277(TRUE/FALSE)]TJ
T*
[(GL_INDEX_SHIFT)-4444(GLint)-3944(0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
0.000 Tw
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.5555 TD
[(GL_INDEX_OFFSET)-3610(GLint)-3944(0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.4444 TD
[(GL_RED_SCALE)-5166(GLfloat)-3167(1.0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.5556 TD
[(GL_GREEN_SCALE)-3832(GLfloat)-3167(1.0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.5556 TD
[(GL_BLUE_SCALE)-4554(GLfloat)-3167(1.0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.5556 TD
[(GL_ALPHA_SCALE)-3832(GLfloat)-3167(1.0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.4444 TD
[(GL_DEPTH_SCALE)-3943(GLfloat)-3167(1.0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.5556 TD
[(GL_RED_BIAS)-6055(GLfloat)-3167(0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.5556 TD
[(GL_GREEN_BIAS)-4721(GLfloat)-3167(0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.4444 TD
[(GL_BLUE_BIAS)-5444(GLfloat)-3167(0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.5556 TD
[(GL_ALPHA_BIAS)-4721(GLfloat)-3167(0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
-28.8889 -1.5556 TD
[(GL_DEPTH_BIAS)-4832(GLfloat)-3167(0)]TJ
26.3333 -0.1111 TD
(\(-)Tj
/F33 1 Tf
0.6667 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(, )Tj
/F33 1 Tf
0.5556 0 TD
(\245)Tj
/F11 1 Tf
0.6667 0 TD
(\))Tj
ET
Q
124.000 137.940 m
464.010 137.940 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 122.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 8-4 )Tj
/F11 1 Tf
4.6 0 TD
(glPixelTransfer*\(\) Parameters \(continued\))Tj
-4.6 -2.1 TD
(If the GL_MAP_COLOR or GL_MAP_STENCIL parameter is TRUE, then mapping is enabled. See the)Tj
0 -1.5 TD
(next subsection to learn how the mapping is done and how to change the contents of the maps. All the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 21)Tj
ET
endstream
endobj
868 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
871 0 obj
<<
/Length 4643
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(other parameters directly affect the pixel component values.)Tj
0 -2.1 TD
(A scale and bias can be applied to the red, green, blue, alpha, and depth components. For example, you)Tj
0 -1.5 TD
(may wish to scale red, green, and blue components that were read from the framebuffer before)Tj
T*
(converting them to a luminance format in processor memory. Luminance is computed as the sum of the)Tj
T*
(red, green, and blue components, so if you use the default value for GL_RED_SCALE,)Tj
T*
(GL_GREEN_SCALE and GL_BLUE_SCALE, the components all contribute equally to the final)Tj
T*
(intensity or luminance value. If you want to convert RGB to luminance, according to the NTSC standard,)Tj
T*
(you set GL_RED_SCALE to .30, GL_GREEN_SCALE to .59, and GL_BLUE_SCALE to .11.)Tj
0 -2.1 TD
(Indices \(color and stencil\) can also be transformed. In the case of indices a shift and offset are applied.)Tj
0 -1.5 TD
(This is useful if you need to control which portion of the color table is used during rendering.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 535.000 Tm
(Pixel Mapping)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 514.000 Tm
(All the color components, color indices, and stencil indices can be modified by means of a table lookup)Tj
T*
(before they are placed in screen memory. The command for controlling this mapping is )Tj
/F15 1 Tf
35.2 0 TD
(glPixelMap*\(\))Tj
/F11 1 Tf
5.8 0 TD
(.)Tj
/F15 1 Tf
-41 -2.1 TD
[(void )-28(glPixelMap)67({ui us f})-55(v)44(\(GLenum )-73(map)22(, GLint )-16(mapsize)22(,)]TJ
0 -1.1 TD
0.039 Tw
[(const TYPE )39(*values)40(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Loads the pixel map indicated by map)22( with )23(mapsize)-78( entries, whose values are pointed to by )84(values)-45(.)]TJ
T*
(Table 8-5)Tj
3.9 0 TD
( lists the map names and values; the default sizes are all 1 and the default values are all 0.)Tj
-3.9 -1.5 TD
(Each map's size must be a power of 2.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 410.570 m
462.000 410.570 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 403.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Map Name)-13998(Address)-5498(Value)]TJ
ET
Q
124.000 397.050 m
462.000 397.050 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 389.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_PIXEL_MAP_I_TO_I)-6055(color index)-3917(color index)]TJ
0 -1.4444 TD
[(GL_PIXEL_MAP_S_TO_S)-5609(stencil index)-3361(stencil index)]TJ
T*
[(GL_PIXEL_MAP_I_TO_R)-5721(color index)-3917(R)]TJ
T*
[(GL_PIXEL_MAP_I_TO_G)-5666(color index)-3917(G)]TJ
T*
[(GL_PIXEL_MAP_I_TO_B)-5721(color index)-3917(B)]TJ
T*
[(GL_PIXEL_MAP_I_TO_A)-5666(color index)-3917(A)]TJ
T*
[(GL_PIXEL_MAP_R_TO_R)-5387(R)-7777(R)]TJ
T*
[(GL_PIXEL_MAP_G_TO_G)-5277(G)-7722(G)]TJ
T*
[(GL_PIXEL_MAP_B_TO_B)-5387(B)-7777(B)]TJ
T*
[(GL_PIXEL_MAP_A_TO_A)-5277(A)-7722(A)]TJ
ET
Q
124.000 264.040 m
462.010 264.040 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 248.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 8-5 )Tj
/F11 1 Tf
4.6 0 TD
(glPixelMap*\(\) Parameter Names and Values)Tj
-4.6 -2.1 TD
(The maximum size of the maps is machine-dependent. You can find the sizes of the pixel maps)Tj
0 -1.5 TD
(supported on your machine with )Tj
/F15 1 Tf
13.2 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
(. Use the query argument)Tj
-19.4 -1.5 TD
(GL_MAX_PIXEL_MAP_TABLE to obtain the maximum size for all the pixel map tables, and use)Tj
T*
(GL_PIXEL_MAP_*_TO_*_SIZE to obtain the current size of the specified map. The six maps whose)Tj
T*
(address is a color index or stencil index must always be sized to an integral power of 2. The four RGBA)Tj
T*
(maps can be any size from 1 through GL_MAX_PIXEL_MAP_TABLE.)Tj
0 -2.1 TD
(To understand how a table works, consider a simple example. Suppose that you want to create a)Tj
0 -1.5 TD
(256-entry table that maps color indices to color indices using GL_PIXEL_MAP_I_TO_I. You create a)Tj
T*
(table with an entry for each of the values between 0 and 255 and initialize the table with )Tj
/F15 1 Tf
35.5 0 TD
(glPixelMap*\(\))Tj
/F11 1 Tf
5.8 0 TD
(.)Tj
-41.3 -1.5 TD
(Assume you're using the table for thresholding and want to map indices below 101 \(indices 0 to 100\) to)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 22)Tj
ET
endstream
endobj
872 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
874 0 obj
<<
/Length 5996
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(0, and all indices 101 and above to 255. In this case, your table consists of 101 0s and 155 255s. The)Tj
0 -1.5 TD
(pixel map is enabled using the routine )Tj
/F15 1 Tf
15.5 0 TD
(glPixelTransfer*\(\))Tj
/F11 1 Tf
7.4 0 TD
( to set the parameter GL_MAP_COLOR to)Tj
-22.9 -1.5 TD
(TRUE. Once the pixel map is loaded and enabled, incoming color indices below 101 come out as 0, and)Tj
T*
(incoming pixels between 101 and 255 are mapped to 255. If the incoming pixel is larger than 255, it's)Tj
T*
(first masked by 255, throwing out all the bits above the eighth, and the resulting masked value is looked)Tj
T*
(up in the table. If the incoming index is a floating-point value \(say 88.14585\), it's rounded to the nearest)Tj
T*
(integer value \(giving 88\), and that number is looked up in the table \(giving 0\).)Tj
0 -2.1 TD
(Using pixel maps, you can also map stencil indices or convert color indices to RGB. \(See "Reading and)Tj
0 -1.5 TD
[(Drawing Pixel Rectangles")-48( for information about the conversion of indices.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 556.000 Tm
(Magnifying, Reducing, or Flipping an Image)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 535.000 Tm
(After the pixel-storage modes and pixel-transfer operations are applied, images and bitmaps are)Tj
T*
(rasterized. Normally, each pixel in an image is written to a single pixel on the screen. However, you can)Tj
T*
(arbitrarily magnify, reduce, or even flip \(reflect\) an image by using )Tj
/F15 1 Tf
27.1 0 TD
(glPixelZoom\(\))Tj
/F11 1 Tf
5.8 0 TD
(.)Tj
/F15 1 Tf
-32.9 -2.1 TD
0.028 Tw
[(void glPixelZoom)12(\(GLfloat )23(zoom)]TJ
12.9 -0.2 TD
0.000 Tw
(x)Tj
0.4 0.2 TD
[(, GLfloat )-38(zoom)]TJ
6 -0.2 TD
(y)Tj
0.5 0.2 TD
(\);)Tj
-18 -1.7 TD
(Sets the magnification or reduction factors for pixel-write operations \()Tj
28.3 0 TD
[(glDrawPixels\(\))67( or)]TJ
-28.3 -1.5 TD
[(glCopyPixels\(\)\), in the )33(x-)]TJ
10.1 0 TD
( and y-)Tj
2.8 0 TD
[(dimensions. By default, )-16(zoom)]TJ
11.7 -0.2 TD
(x)Tj
0.4 0.2 TD
( and zoom)Tj
4.1 -0.2 TD
(y)Tj
0.5 0.2 TD
( are 1.0. If they're both)Tj
-29.6 -1.7 TD
(2.0, each image pixel is drawn to 4 screen pixels. Note that fractional magnification or reduction)Tj
0 -1.5 TD
(factors are allowed, as are negative factors. Negative zoom factors reflect the resulting image about)Tj
T*
(the current raster position.)Tj
/F11 1 Tf
-1.8 -2.2 TD
(During rasterization, each image pixel is treated as a )Tj
/F15 1 Tf
21.2 0 TD
(zoom)Tj
/F11 1 Tf
2.1 -0.2 TD
(x)Tj
/F33 1 Tf
0.5 0.2 TD
(\264)Tj
/F15 1 Tf
0.6 0 TD
(zoom)Tj
/F11 1 Tf
2.1 -0.2 TD
(y)Tj
0.5 0.2 TD
( rectangle, and fragments are)Tj
-27 -1.7 TD
(generated for all the pixels whose centers lie within the rectangle. More specifically, let \()Tj
/F15 1 Tf
35.6 0 TD
(x)Tj
/F11 1 Tf
0.4 -0.2 TD
(rp)Tj
0.9 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.4 -0.2 TD
(rp)Tj
0.9 0.2 TD
(\) be the)Tj
-38.7 -1.7 TD
(current raster position. If a particular group of elements \(index or components\) is the )Tj
/F15 1 Tf
34.1 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(th in a row and)Tj
-34.6 -1.5 TD
(belongs to the )Tj
/F15 1 Tf
5.9 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
(th column, consider the region in window coordinates bounded by the rectangle with)Tj
-6.6 -1.5 TD
(corners at)Tj
0 -2.1 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(x)Tj
/F11 1 Tf
0.5 -0.2 TD
(rp)Tj
0.8 0.2 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(zoom)Tj
/F11 1 Tf
2.1 -0.2 TD
(x )Tj
/F15 1 Tf
0.7 0.2 TD
(* n)Tj
/F11 1 Tf
1.3 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.4 -0.2 TD
(rp)Tj
0.9 0.2 TD
( + )Tj
/F15 1 Tf
1 0 TD
(zoom)Tj
/F11 1 Tf
2.1 -0.2 TD
(y )Tj
/F15 1 Tf
0.8 0.2 TD
(* m)Tj
/F11 1 Tf
1.5 0 TD
(\) and \()Tj
/F15 1 Tf
2.6 0 TD
(x)Tj
/F11 1 Tf
0.4 -0.2 TD
(rp)Tj
0.8 0.2 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(zoom)Tj
/F11 1 Tf
2.1 -0.2 TD
(x)Tj
0.5 0.2 TD
(\()Tj
/F15 1 Tf
0.4 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(+1\), )Tj
/F15 1 Tf
1.9 0 TD
(y)Tj
/F11 1 Tf
0.4 -0.2 TD
(rp)Tj
0.8 0.2 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(zoom)Tj
/F11 1 Tf
2.1 -0.2 TD
(y)Tj
0.5 0.2 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(m)Tj
/F11 1 Tf
0.8 0 TD
(+1\)\))Tj
-30.3 -2.3 TD
(Any fragments whose centers lie inside this rectangle \(or on its bottom or left boundaries\) are produced)Tj
0 -1.5 TD
(in correspondence with this particular group of elements.)Tj
0 -2.1 TD
(A negative zoom can be useful for flipping an image. OpenGL describes images from the bottom row of)Tj
0 -1.5 TD
(pixels to the top \(and from left to right\). If you have a "top to bottom" image, such as a frame of video,)Tj
T*
(you may want to use )Tj
/F15 1 Tf
8.5 0 TD
(glPixelZoom)Tj
/F11 1 Tf
5.1 0 TD
(\(1.0, -1.0\) to make the image right side up for OpenGL. Be sure that)Tj
-13.6 -1.5 TD
(you reposition the current raster position appropriately, if needed.)Tj
0 -2.1 TD
(Example 8-4)Tj
5.1 0 TD
( shows the use of )Tj
/F15 1 Tf
7.2 0 TD
(glPixelZoom\(\))Tj
/F11 1 Tf
5.8 0 TD
(. A checkerboard image is initially drawn in the lower-left)Tj
-18.1 -1.5 TD
(corner of the window. Pressing a mouse button and moving the mouse uses )Tj
/F15 1 Tf
30.4 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
( to copy the)Tj
-36.4 -1.5 TD
(lower-left corner of the window to the current cursor location. \(If you copy the image onto itself, it looks)Tj
T*
(wacky!\) The copied image is zoomed, but initially it is zoomed by the default value of 1.0, so you won't)Tj
T*
(notice. The `z' and `Z' keys increase and decrease the zoom factors by 0.5. Any window damage causes)Tj
T*
(the contents of the window to be redrawn. Pressing the `r' key resets the image and the zoom factors.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 8-4 )Tj
/F11 1 Tf
6.1 0 TD
(Drawing, Copying, and Zooming Pixel Data: image.c)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 23)Tj
ET
endstream
endobj
875 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
877 0 obj
<<
/Length 1672
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 701.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(#define checkImageWidth 64)Tj
0 -1.5 TD
(#define checkImageHeight 64)Tj
T*
(GLubyte checkImage[checkImageHeight][checkImageWidth][3];)Tj
0 -3 TD
(static GLdouble zoomFactor = 1.0;)Tj
0 -1.5 TD
(static GLint height;)Tj
0 -3 TD
(void makeCheckImage\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i, j, c;)Tj
T*
(    )Tj
T*
(   for \(i = 0; i < checkImageHeight; i++\) {)Tj
T*
(      for \(j = 0; j < checkImageWidth; j++\) {)Tj
T*
(         c = \(\(\(\(i&0x8\)==0\)^\(\(j&0x8\)\)==0\)\)*255;)Tj
T*
(         checkImage[i][j][0] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][1] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][2] = \(GLubyte\) c;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({    )Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel\(GL_FLAT\);)Tj
T*
(   makeCheckImage\(\);)Tj
T*
(   glPixelStorei\(GL_UNPACK_ALIGNMENT, 1\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   glRasterPos2i\(0, 0\);)Tj
T*
(   glDrawPixels\(checkImageWidth, checkImageHeight, GL_RGB, )Tj
T*
(                GL_UNSIGNED_BYTE, checkImage\);)Tj
T*
(   glFlush\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 24)Tj
ET
endstream
endobj
878 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
880 0 obj
<<
/Length 1717
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   height = \(GLint\) h;)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluOrtho2D\(0.0, \(GLdouble\) w, 0.0, \(GLdouble\) h\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void motion\(int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   static GLint screeny;)Tj
T*
(   )Tj
T*
(   screeny = height - \(GLint\) y;)Tj
T*
(   glRasterPos2i \(x, screeny\);)Tj
T*
(   glPixelZoom \(zoomFactor, zoomFactor\);)Tj
T*
(   glCopyPixels \(0, 0, checkImageWidth, checkImageHeight,)Tj
T*
(                 GL_COLOR\);)Tj
T*
(   glPixelZoom \(1.0, 1.0\);)Tj
T*
(   glFlush \(\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `r':)Tj
T*
(      case `R':)Tj
T*
(         zoomFactor = 1.0;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         printf \("zoomFactor reset to 1.0\\n"\);)Tj
T*
(         break;)Tj
T*
(      case `z':)Tj
T*
(         zoomFactor += 0.5;)Tj
T*
(         if \(zoomFactor >= 3.0\) )Tj
T*
(            zoomFactor = 3.0;)Tj
T*
(         printf \("zoomFactor is now %4.1f\\n", zoomFactor\);)Tj
T*
(         break;)Tj
T*
(      case `Z':)Tj
T*
(         zoomFactor -= 0.5;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 25)Tj
ET
endstream
endobj
881 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
883 0 obj
<<
/Length 2056
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(         if \(zoomFactor <= 0.5\) )Tj
0 -1.5 TD
(            zoomFactor = 0.5;)Tj
T*
(         printf \("zoomFactor is now %4.1f\\n", zoomFactor\);)Tj
T*
(         break;)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize\(250, 250\);)Tj
T*
(   glutInitWindowPosition\(100, 100\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutMotionFunc\(motion\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0; )Tj
T*
(})Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 288.000 Tm
(Reading and Drawing Pixel Rectangles)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 266.000 Tm
(This section describes the reading and drawing processes in detail. The pixel conversions performed)Tj
T*
(when going from framebuffer to memory \(reading\) are similar but not identical to the conversions)Tj
T*
(performed when going in the opposite direction \(drawing\), as explained in the following sections. You)Tj
T*
(may wish to skip this section the first time through, especially if you do not plan to use the pixel-transfer)Tj
T*
(operations right away.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 177.000 Tm
(The Pixel Rectangle Drawing Process)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 156.000 Tm
[(Figure 8-10)226( and the following list describe the operation of drawing pixels into the framebuffer.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 26)Tj
ET
endstream
endobj
884 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
885 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im80
/Width 454
/Height 618
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.79)
>>
stream
endstream
endobj
887 0 obj
<<
/Length 818
>>
stream
q
1 i 
124.000 720.000 422.990 -575.800 re
W n
/GS1 gs
q
423 0 0 576 124 144 cm
/Im80 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 131.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 8-10 )Tj
/F11 1 Tf
5.6 0 TD
(Drawing Pixels with glDrawPixels\(\))Tj
-5.6 -2.1 TD
[(1.)-1050(If the pixels aren't indices \(that is, the format isn't GL_COLOR_INDEX or)]TJ
1.8 -1.5 TD
(GL_STENCIL_INDEX\), the first step is to convert the components to floating-point format if)Tj
T*
[(necessary. \(See )15(Table 4-1)191( for the details of the conversion.\))]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 27)Tj
ET
endstream
endobj
888 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im80 885 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
890 0 obj
<<
/Length 3617
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(2.)-1050(If the format is GL_LUMINANCE or GL_LUMINANCE_ALPHA, the luminance element is)]TJ
1.8 -1.5 TD
(converted into R, G, and B, by using the luminance value for each of the R, G, and B components. In)Tj
T*
(GL_LUMINANCE_ALPHA format, the alpha value becomes the A value. If GL_LUMINANCE is)Tj
T*
(specified, the A value is set to 1.0.)Tj
-1.8 -2.1 TD
[(3.)-1050(Each component \(R, G, B, A, or depth\) is multiplied by the appropriate scale, and the appropriate)]TJ
1.8 -1.5 TD
(bias is added. For example, the R component is multiplied by the value corresponding to)Tj
T*
(GL_RED_SCALE and added to the value corresponding to GL_RED_BIAS.)Tj
-1.8 -2.1 TD
[(4.)-1050(If GL_MAP_COLOR is true, each of the R, G, B, and A components is clamped to the range)]TJ
1.8 -1.5 TD
([0.0,1.0], multiplied by an integer one less than the table size, truncated, and looked up in the table.)Tj
T*
[(\(See )27("Tips for Improving Pixel Drawing Rates")11( for more details.\))]TJ
-1.8 -2.1 TD
[(5.)-1050(Next, the R, G, B, and A components are clamped to [0.0,1.0], if they weren't already, and converted)]TJ
1.8 -1.5 TD
(to fixed-point with as many bits to the left of the binary point as there are in the corresponding)Tj
T*
(framebuffer component.)Tj
-1.8 -2.1 TD
[(6.)-1050(If you're working with index values \(stencil or color indices\), then the values are first converted to)]TJ
1.8 -1.5 TD
(fixed-point \(if they were initially floating-point numbers\) with some unspecified bits to the right of)Tj
T*
(the binary point. Indices that were initially fixed-point remain so, and any bits to the right of the)Tj
T*
(binary point are set to zero.)Tj
0 -2.1 TD
(The resulting index value is then shifted right or left by the absolute value of GL_INDEX_SHIFT)Tj
0 -1.5 TD
(bits; the value is shifted left if GL_INDEX_SHIFT > 0 and right otherwise. Finally,)Tj
T*
(GL_INDEX_OFFSET is added to the index.)Tj
-1.8 -2.1 TD
[(7.)-1050(The next step with indices depends on whether you're using RGBA mode or color-index mode. In)]TJ
1.8 -1.5 TD
(RGBA mode, a color index is converted to RGBA using the color components specified by)Tj
T*
(GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and)Tj
T*
[(GL_PIXEL_MAP_I_TO_A. \(See )50("Pixel Mapping")-66( for details.\) Otherwise, if GL_MAP_COLOR is)]TJ
T*
(GL_TRUE, a color index is looked up through the table GL_PIXEL_MAP_I_TO_I. \(If)Tj
T*
(GL_MAP_COLOR is GL_FALSE, the index is unchanged.\) If the image is made up of stencil)Tj
T*
(indices rather than color indices, and if GL_MAP_STENCIL is GL_TRUE, the index is looked up in)Tj
T*
(the table corresponding to GL_PIXEL_MAP_S_TO_S. If GL_MAP_STENCIL is FALSE, the)Tj
T*
(stencil index is unchanged.)Tj
-1.8 -2.1 TD
[(8.)-1050(Finally, if the indices haven't been converted to RGBA, the indices are then masked to the number)]TJ
1.8 -1.5 TD
(of bits of either the color-index or stencil buffer, whichever is appropriate.)Tj
/F27 1 Tf
-1.8 -3.5 TD
(The Pixel Rectangle Reading Process)Tj
/F11 1 Tf
0 -2.1 TD
(Many of the conversions done during the pixel rectangle drawing process are also done during the pixel)Tj
0 -1.5 TD
[(rectangle reading process. The pixel reading process is shown in )25(Figure 8-11)226( and described in the)]TJ
T*
(following list.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 28)Tj
ET
endstream
endobj
891 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
892 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im81
/Width 461
/Height 552
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.80)
>>
stream
endstream
endobj
894 0 obj
<<
/Length 1188
>>
stream
/GS1 gs
q
423 0 0 506 124 214 cm
/Im81 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 201.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 8-11 )Tj
/F11 1 Tf
5.6 0 TD
(Reading Pixels with glReadPixels\(\))Tj
-5.6 -2.1 TD
[(1.)-1050(If the pixels to be read aren't indices \(that is, the format isn't GL_COLOR_INDEX or)]TJ
1.8 -1.6 TD
(GL_STENCIL_INDEX\), the components are mapped to [0.0,1.0])Tj
/F33 1 Tf
26.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, in exactly the opposite)Tj
-27.3 -1.6 TD
(way that they are when written.)Tj
-1.8 -2.1 TD
[(2.)-1050(Next, the scales and biases are applied to each component. If GL_MAP_COLOR is GL_TRUE,)]TJ
1.8 -1.5 TD
(they're mapped and again clamped to [0.0,1.0]. If luminance is desired instead of RGB, the R, G,)Tj
T*
(and B components are added \(L = R + G + B\).)Tj
-1.8 -2.1 TD
[(3.)-1050(If the pixels are indices \(color or stencil\), they're shifted, offset, and, if GL_MAP_COLOR is)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 29)Tj
ET
endstream
endobj
895 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im81 892 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
897 0 obj
<<
/Length 4178
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 142.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(GL_TRUE, also mapped.)Tj
-1.8 -2.1 TD
[(4.)-1050(If the storage format is either GL_COLOR_INDEX or GL_STENCIL_INDEX, the pixel indices are)]TJ
1.8 -1.5 TD
(masked to the number of bits of the storage type \(1, 8, 16, or 32\) and packed into memory as)Tj
T*
(previously described.)Tj
-1.8 -2.1 TD
[(5.)-1050(If the storage format is one of the component kind \(such as luminance or RGB\), the pixels are)]TJ
1.8 -1.5 TD
(always mapped by the index-to-RGBA maps. Then, they're treated as though they had been RGBA)Tj
T*
(pixels in the first place \(including potential conversion to luminance\).)Tj
-1.8 -2.1 TD
[(6.)-1050(Finally, for both index and component data, the results are packed into memory according to the)]TJ
1.8 -1.5 TD
(GL_PACK* modes set with )Tj
/F15 1 Tf
11.5 0 TD
(glPixelStore*\(\))Tj
/F11 1 Tf
6.1 0 TD
(.)Tj
-19.4 -2.6 TD
(The scaling, bias, shift, and offset values are the same as those used when drawing pixels, so if you're)Tj
0 -1.5 TD
(both reading and drawing pixels, be sure to reset these components to the appropriate values before doing)Tj
T*
(a read or a draw. Similarly, the various maps must be properly reset if you intend to use maps for both)Tj
T*
(reading and drawing.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(It might seem that luminance is handled incorrectly in both the reading and drawing operations.)Tj
-2.8 -1.4 TD
(For example, luminance is not usually equally dependent on the R, G, and B components as it may be)Tj
0 -1.5 TD
[(assumed from both )17(Figure 8-10)226( and )-56(Figure 8-11)]TJ
19.2 0 TD
(. If you wanted your luminance to be calculated such that)Tj
-19.2 -1.4 TD
(the R component contributed 30 percent, the G 59 percent, and the B 11 percent, you can set)Tj
T*
(GL_RED_SCALE to .30, GL_RED_BIAS to 0.0, and so on. The computed L is then .30R + .59G +)Tj
T*
(.11B.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 374.000 Tm
(Tips for Improving Pixel Drawing Rates)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 352.000 Tm
(As you can see, OpenGL has a rich set of features for reading, drawing and manipulating pixel data.)Tj
0 -1.5 TD
(Although these features are often very useful, they can also decrease performance. Here are some tips for)Tj
T*
(improving pixel draw rates.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(For best performance, set all pixel-transfer parameters to their default values, and set pixel zoom to)Tj
0 -1.6 TD
(\(1.0,1.0\).)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(A series of fragment operations is applied to pixels as they are drawn into the framebuffer. \(See)Tj
0 -1.6 TD
[("Testing and Operating on Fragments" in Chapter 10)-22(.\) For optimum performance disable all)]TJ
0 -1.5 TD
(fragment operations.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(While performing pixel operations, disable other costly states, such as texturing and lighting.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If you use an image format and type that matches the framebuffer, you can reduce the amount of)Tj
0 -1.6 TD
(work that the OpenGL implementation has to do. For example, if you are writing images to an RGB)Tj
0 -1.5 TD
(framebuffer with 8 bits per component, call )Tj
/F15 1 Tf
17.7 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.1 0 TD
( with )Tj
/F15 1 Tf
2.3 0 TD
(format)Tj
/F11 1 Tf
2.7 0 TD
( set to RGB and )Tj
/F15 1 Tf
6.6 0 TD
(type)Tj
/F11 1 Tf
1.7 0 TD
( set to)Tj
-37.1 -1.5 TD
(UNSIGNED_BYTE.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(For some implementations, unsigned image formats are faster to use than signed image formats.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(It is usually faster to draw a large pixel rectangle than to draw several small ones, since the cost of)Tj
0 -1.5 TD
(transferring the pixel data can be amortized over many pixels.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 8,  Drawing Pixels, Bitmaps, Fonts, and Images - 30)Tj
ET
endstream
endobj
898 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
900 0 obj
<<
/Length 884
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 706.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
(If possible, reduce the amount of data that needs to be copied by using small data types \(for)Tj
0 -1.6 TD
(example, use GL_UNSIGNED_BYTE\) and fewer components \(for example, use format)Tj
0 -1.5 TD
(GL_LUMINANCE_ALPHA\).)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Pixel-transfer operations, including pixel mapping and values for scale, bias, offset, and shift other)Tj
0 -1.6 TD
(than the defaults, may decrease performance.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 598.230 m
547.000 598.230 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 31)Tj
ET
endstream
endobj
901 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
904 0 obj
<<
/Length 4168
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 9)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Texture Mapping)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Understand what texture mapping can add to your scene)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Specify a texture image)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Control how a texture image is filtered as it's applied to a fragment)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Create and manage texture images in texture objects and, if available, control a high-performance)Tj
0 -1.6 TD
(working set of those texture objects)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Specify how the color values in the image combine with those of the fragment to which it's being)Tj
0 -1.6 TD
(applied)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Supply texture coordinates to indicate how the texture image should be aligned to the objects in your)Tj
0 -1.6 TD
(scene)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use automatic texture coordinate generation to produce effects like contour maps and environment)Tj
0 -1.6 TD
(maps)Tj
-1.9 -2.7 TD
(So far, every geometric primitive has been drawn as either a solid color or smoothly shaded between the)Tj
0 -1.6 TD
(colors at its vertices)Tj
/F33 1 Tf
8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, they've been drawn without texture mapping. If you want to draw a large)Tj
-9 -1.6 TD
(brick wall without texture mapping, for example, each brick must be drawn as a separate polygon.)Tj
T*
(Without texturing, a large flat wall)Tj
/F33 1 Tf
13.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(which is really a single rectangle)Tj
/F33 1 Tf
13.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(might require thousands of)Tj
-29 -1.6 TD
(individual bricks, and even then the bricks may appear too smooth and regular to be realistic.)Tj
0 -2.1 TD
(Texture mapping allows you to glue an image of a brick wall \(obtained, perhaps, by scanning in a)Tj
0 -1.5 TD
(photograph of a real wall\) to a polygon and to draw the entire wall as a single polygon. Texture mapping)Tj
T*
(ensures that all the right things happen as the polygon is transformed and rendered. For example, when)Tj
T*
(the wall is viewed in perspective, the bricks may appear smaller as the wall gets farther from the)Tj
T*
(viewpoint. Other uses for texture mapping include depicting vegetation on large polygons representing)Tj
T*
(the ground in flight simulation; wallpaper patterns; and textures that make polygons look like natural)Tj
T*
(substances such as marble, wood, or cloth. The possibilities are endless. Although it's most natural to)Tj
0 -1.6 TD
(think of applying textures to polygons, textures can be applied to all primitives)Tj
/F33 1 Tf
31.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(points, lines, polygons,)Tj
-32.5 -1.5 TD
(bitmaps, and images. Plates 6, 8, 18\25521, 24\25527, and 29\25531 all demonstrate the use of textures.)Tj
0 -2.1 TD
(Because there are so many possibilities, texture mapping is a fairly large, complex subject, and you must)Tj
0 -1.5 TD
(make several programming choices when using it. For instance, you can map textures to surfaces made)Tj
T*
(of a set of polygons or to curved surfaces, and you can repeat a texture in one or both directions to cover)Tj
T*
(the surface. A texture can even be one-dimensional. In addition, you can automatically map a texture)Tj
T*
(onto an object in such a way that the texture indicates contours or other properties of the item being)Tj
T*
(viewed. Shiny objects can be textured so that they appear to be in the center of a room or other)Tj
T*
(environment, reflecting the surroundings off their surfaces. Finally, a texture can be applied to a surface)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 1)Tj
ET
endstream
endobj
905 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
906 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im82
/Width 644
/Height 309
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.81)
>>
stream
endstream
endobj
908 0 obj
<<
/Length 3737
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(in different ways. It can be painted on directly \(like a decal placed on a surface\), used to modulate the)Tj
0 -1.5 TD
(color the surface would have been painted otherwise, or used to blend a texture color with the surface)Tj
T*
(color. If this is your first exposure to texture mapping, you might find that the discussion in this chapter)Tj
T*
(moves fairly quickly. As an additional reference, you might look at the chapter on texture mapping in)Tj
/F15 1 Tf
T*
(Fundamentals of Three-Dimensional Computer Graphics)Tj
/F11 1 Tf
23 0 TD
( by Alan Watt \(Reading, MA: Addison-Wesley)Tj
-23 -1.5 TD
(Publishing Company, 1990\).)Tj
0 -2.2 TD
(Textures are simply rectangular arrays of data)Tj
/F33 1 Tf
18.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, color data, luminance data, or color and)Tj
-19.4 -1.6 TD
(alpha data. The individual values in a texture array are often called)Tj
/F15 1 Tf
26.7 0 TD
( texels)Tj
/F11 1 Tf
2.5 0 TD
(. What makes texture mapping)Tj
-29.2 -1.5 TD
(tricky is that a rectangular texture can be mapped to nonrectangular regions, and this must be done in a)Tj
T*
(reasonable way.)Tj
0 -2.1 TD
[(Figure 9-1)225( illustrates the texture-mapping process. The left side of the figure represents the entire texture,)]TJ
0 -1.5 TD
(and the black outline represents a quadrilateral shape whose corners are mapped to those spots on the)Tj
T*
(texture. When the quadrilateral is displayed on the screen, it might be distorted by applying various)Tj
0 -1.6 TD
(transformations)Tj
/F33 1 Tf
6.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(rotations, translations, scaling, and projections. The right side of the figure shows how)Tj
-7.3 -1.6 TD
(the texture-mapped quadrilateral might appear on your screen after these transformations. \(Note that this)Tj
0 -1.5 TD
(quadrilateral is concave and might not be rendered correctly by OpenGL without prior tessellation. See)Tj
T*
[(Chapter 11)16( for more information about tessellating polygons.\))]TJ
ET
Q
/GS1 gs
q
423 0 0 203 124 238.1 cm
/Im82 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 225.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 9-1 )Tj
/F11 1 Tf
5.1 0 TD
(Texture-Mapping Process)Tj
-5.1 -2.1 TD
(Notice how the texture is distorted to match the distortion of the quadrilateral. In this case, it's stretched)Tj
0 -1.5 TD
(in the )Tj
/F15 1 Tf
2.5 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( direction and compressed in the )Tj
/F15 1 Tf
13.3 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( direction; there's a bit of rotation and shearing going on as)Tj
-16.6 -1.5 TD
(well. Depending on the texture size, the quadrilateral's distortion, and the size of the screen image, some)Tj
T*
(of the texels might be mapped to more than one fragment, and some fragments might be covered by)Tj
0 -1.6 TD
(multiple texels. Since the texture is made up of discrete texels \(in this case, 256)Tj
/F33 1 Tf
31.8 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(256 of them\), filtering)Tj
-32.3 -1.6 TD
(operations must be performed to map texels to fragments. For example, if many texels correspond to a)Tj
0 -1.5 TD
(fragment, they're averaged down to fit; if texel boundaries fall across fragment boundaries, a weighted)Tj
T*
(average of the applicable texels is performed. Because of these calculations, texturing is computationally)Tj
T*
(expensive, which is why many specialized graphics systems include hardware support for texture)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 2)Tj
ET
endstream
endobj
909 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im82 906 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
911 0 obj
<<
/Length 4051
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(mapping.)Tj
0 -2.1 TD
0.000 Tw
(An application may establish texture objects, with each texture object representing a single texture \(and)Tj
0 -1.5 TD
(possible associated mipmaps\). Some implementations of OpenGL can support a special )Tj
/F13 1 Tf
35.3 0 TD
(working set)Tj
/F11 1 Tf
4.9 0 TD
( of)Tj
-40.2 -1.5 TD
(texture objects that have better performance than texture objects outside the working set. These)Tj
T*
(high-performance texture objects are said to be )Tj
/F15 1 Tf
19.1 0 TD
(resident)Tj
/F11 1 Tf
3.2 0 TD
( and may have special hardware and/or software)Tj
-22.3 -1.5 TD
(acceleration available. You may use OpenGL to create and delete texture objects and to determine which)Tj
T*
(textures constitute your working set.)Tj
0 -2.1 TD
(This chapter covers the OpenGL's texture-mapping facility in the following major sections.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("An Overview and an Example")26( gives a brief, broad look at the steps required to perform texture)]TJ
0 -1.6 TD
(mapping. It also presents a relatively simple example of texture mapping.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Specifying the Texture")-18( explains how to specify one- or two-dimensional textures. It also discusses)]TJ
0 -1.6 TD
(how to use a texture's borders, how to supply a series of related textures of different sizes, and how)Tj
0 -1.5 TD
(to control the filtering methods used to determine how an applied texture is mapped to screen)Tj
T*
(coordinates.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Filtering")-39( details how textures are either magnified or minified as they are applied to the pixels of)]TJ
0 -1.6 TD
(polygons. Minification using special mipmap textures is also explained.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Texture Objects")32( describes how to put texture images into objects so that you can control several)]TJ
0 -1.6 TD
(textures at one time. With texture objects, you may be able to create a working set of)Tj
0 -1.5 TD
(high-performance textures, which are said to be resident. You may also prioritize texture objects to)Tj
T*
(increase or decrease the likelihood that a texture object is resident.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Texture Functions")22( discusses the methods used for painting a texture onto a surface. You can)]TJ
0 -1.6 TD
(choose to have the texture color values replace those that would be used if texturing wasn't in effect,)Tj
0 -1.5 TD
(or you can have the final color be a combination of the two.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Assigning Texture Coordinates")17( describes how to compute and assign appropriate texture)]TJ
0 -1.6 TD
(coordinates to the vertices of an object. It also explains how to control the behavior of coordinates)Tj
T*
(that lie outside the default range)Tj
/F33 1 Tf
12.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, how to repeat or clamp textures across a surface.)Tj
/F33 1 Tf
-15.7 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Automatic Texture-Coordinate Generation")201( shows how to have OpenGL automatically generate)]TJ
0 -1.5 TD
(texture coordinates so that you can achieve such effects as contour and environment maps.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Advanced Features")9( explains how to manipulate the texture matrix stack and how to use the )]TJ
/F15 1 Tf
37.4 0 TD
(q)Tj
/F11 1 Tf
-37.4 -1.6 TD
(texture coordinate.)Tj
-1.9 -2.7 TD
(Version 1.1 of OpenGL introduces several new texture-mapping operations:)Tj
0 -2.1 TD
(1.)Tj
3.6 -2.1 TD
(Thirty-eight additional internal texture image formats)Tj
T*
(Texture proxy, to query whether there are enough resources to accommodate a given texture)Tj
0 -1.5 TD
(image)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 3)Tj
ET
endstream
endobj
912 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
914 0 obj
<<
/Length 3674
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 160.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Texture subimage, to replace all or part of an existing texture image rather than completely)Tj
0 -1.5 TD
(deleting and creating a texture to achieve the same effect)Tj
0 -2.1 TD
(Specifying texture data from framebuffer memory \(as well as from processor memory\))Tj
T*
(Texture objects, including resident textures and prioritizing)Tj
-3.6 -2.6 TD
(If you try to use one of these texture-mapping operations and can't find it, check the version number of)Tj
0 -1.5 TD
[(your implementation of OpenGL to see if it actually supports it. \(See )6("Which Version Am I Using?" in)]TJ
T*
[(Chapter 14)16(.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 564.000 Tm
(An Overview and an Example)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 542.000 Tm
(This section gives an overview of the steps necessary to perform texture mapping. It also presents a)Tj
T*
(relatively simple texture-mapping program. Of course, you know that texture mapping can be a very)Tj
T*
(involved process.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 484.000 Tm
(Steps in Texture Mapping)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 462.000 Tm
(To use texture mapping, you perform these steps.)Tj
0 -2.1 TD
[(1.)-1050(Create a texture object and specify a texture for that object.)]TJ
T*
[(2.)-1050(Indicate how the texture is to be applied to each pixel.)]TJ
T*
[(3.)-1050(Enable texture mapping.)]TJ
T*
[(4.)-1050(Draw the scene, supplying both texture and geometric coordinates.)]TJ
0 -2.6 TD
(Keep in mind that texture mapping works only in RGBA mode. Texture mapping results in color-index)Tj
0 -1.5 TD
(mode are undefined.)Tj
/F27 1 Tf
0 -3 TD
(Create a Texture Object and Specify a Texture for That Object)Tj
/F11 1 Tf
0 -2.1 TD
(A texture is usually thought of as being two-dimensional, like most images, but it can also be)Tj
0 -1.5 TD
(one-dimensional. The data describing a texture may consist of one, two, three, or four elements per texel,)Tj
T*
(representing anything from a modulation constant to an \(R, G, B, A\) quadruple.)Tj
0 -2.1 TD
0.017 Tw
[(In Example )17(9-1)]TJ
6.2 0 TD
0.000 Tw
(, which is very simple, a single texture object is created to maintain a single)Tj
-6.2 -1.5 TD
(two-dimensional texture. This example does not find out how much memory is available. Since only one)Tj
T*
(texture is created, there is no attempt to prioritize or otherwise manage a working set of texture objects.)Tj
T*
(Other advanced techniques, such as texture borders or mipmaps, are not used in this simple example.)Tj
/F27 1 Tf
0 -3 TD
(Indicate How the Texture Is to Be Applied to Each Pixel)Tj
/F11 1 Tf
0 -2.1 TD
(You can choose any of four possible functions for computing the final RGBA value from the fragment)Tj
0 -1.5 TD
(color and the texture-image data. One possibility is simply to use the texture color as the final color; this)Tj
T*
(is the )Tj
/F15 1 Tf
2.4 0 TD
(decal)Tj
/F11 1 Tf
2.2 0 TD
( mode, in which the texture is painted on top of the fragment, just as a decal would be applied.)Tj
-4.6 -1.5 TD
[(\()33(Example 9-1)170( uses decal mode.\) The )]TJ
/F15 1 Tf
14.9 0 TD
(replace)Tj
/F11 1 Tf
3 0 TD
( mode, a variant of the decal mode, is a second method.)Tj
-17.9 -1.5 TD
(Another method is to use the texture to )Tj
/F15 1 Tf
15.8 0 TD
(modulate)Tj
/F11 1 Tf
3.8 0 TD
(, or scale, the fragment's color; this technique is useful)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 4)Tj
ET
endstream
endobj
915 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
917 0 obj
<<
/Length 3277
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(for combining the effects of lighting with texturing. Finally, a constant color can be blended with that of)Tj
0 -1.5 TD
(the fragment, based on the texture value.)Tj
/F27 1 Tf
0 -3 TD
(Enable Texture Mapping)Tj
/F11 1 Tf
0 -2.1 TD
(You need to enable texturing before drawing your scene. Texturing is enabled or disabled using)Tj
/F15 1 Tf
0 -1.5 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.6 0 TD
( with the symbolic constant GL_TEXTURE_1D or GL_TEXTURE_2D for)Tj
-10.2 -1.5 TD
(one- or two-dimensional texturing, respectively. \(If both are enabled, GL_TEXTURE_2D is the one that)Tj
T*
(is used.\))Tj
/F27 1 Tf
0 -3 TD
(Draw the Scene, Supplying Both Texture and Geometric Coordinates)Tj
/F11 1 Tf
0 -2.1 TD
(You need to indicate how the texture should be aligned relative to the fragments to which it's to be)Tj
0 -1.5 TD
(applied before it's "glued on." That is, you need to specify both texture coordinates and geometric)Tj
T*
(coordinates as you specify the objects in your scene. For a two-dimensional texture map, for example, the)Tj
T*
(texture coordinates range from 0.0 to 1.0 in both directions, but the coordinates of the items being)Tj
T*
(textured can be anything. For the brick-wall example, if the wall is square and meant to represent one)Tj
T*
(copy of the texture, the code would probably assign texture coordinates \(0, 0\), \(1, 0\), \(1, 1\), and \(0, 1\) to)Tj
T*
(the four corners of the wall. If the wall is large, you might want to paint several copies of the texture map)Tj
T*
(on it. If you do so, the texture map must be designed so that the bricks on the left edge match up nicely)Tj
T*
(with the bricks on the right edge, and similarly for the bricks on the top and those on the bottom.)Tj
0 -2.1 TD
(You must also indicate how texture coordinates outside the range [0.0,1.0] should be treated. Do the)Tj
0 -1.5 TD
(textures repeat to cover the object, or are they clamped to a boundary value?)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 364.000 Tm
(A Sample Program)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 343.000 Tm
(One of the problems with showing sample programs to illustrate texture mapping is that interesting)Tj
T*
(textures are large. Typically, textures are read from an image file, since specifying a texture)Tj
0 -1.6 TD
[(programmatically could take hundreds of lines of code. In )43(Example 9-1)170(, the texture)]TJ
/F33 1 Tf
33.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(which consists of)Tj
-34.3 -1.7 TD
(alternating white and black squares, like a checkerboard)Tj
/F33 1 Tf
22.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(is generated by the program. The program)Tj
-23.4 -1.6 TD
(applies this texture to two squares, which are then rendered in perspective, one of them facing the viewer)Tj
0 -1.5 TD
[(squarely and the other tilting back at 45 degrees, as shown in )38(Figure 9-2)225(. In object coordinates, both)]TJ
T*
(squares are the same size.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 5)Tj
ET
endstream
endobj
918 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
919 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im83
/Width 308
/Height 198
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.82)
>>
stream
endstream
endobj
921 0 obj
<<
/Length 1421
>>
stream
/GS1 gs
q
308 0 0 198 124 522 cm
/Im83 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 509.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 9-2 )Tj
/F11 1 Tf
5.1 0 TD
(Texture-Mapped Squares)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 9-1 )Tj
/F11 1 Tf
6.1 0 TD
(Texture-Mapped Checkerboard: checker.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(/*  Create checkerboard texture  */)Tj
0 -1.5 TD
(#define checkImageWidth 64)Tj
T*
(#define checkImageHeight 64)Tj
T*
(static GLubyte checkImage[checkImageHeight][checkImageWidth][4];)Tj
0 -3 TD
(static GLuint texName;)Tj
T*
(void makeCheckImage\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i, j, c;)Tj
T*
(    )Tj
T*
(   for \(i = 0; i < checkImageHeight; i++\) {)Tj
T*
(      for \(j = 0; j < checkImageWidth; j++\) {)Tj
T*
(         c = \(\(\(\(i&0x8\)==0\)^\(\(j&0x8\)\)==0\)\)*255;)Tj
T*
(         checkImage[i][j][0] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][1] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][2] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][3] = \(GLubyte\) 255;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 6)Tj
ET
endstream
endobj
922 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im83 919 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
924 0 obj
<<
/Length 2182
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 693.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void init\(void\))Tj
0 -1.5 TD
({    )Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel\(GL_FLAT\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
0 -3 TD
(   makeCheckImage\(\);)Tj
0 -1.5 TD
(   glPixelStorei\(GL_UNPACK_ALIGNMENT, 1\);)Tj
0 -3 TD
(   glGenTextures\(1, &texName\);)Tj
0 -1.5 TD
(   glBindTexture\(GL_TEXTURE_2D, texName\);)Tj
0 -3 TD
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT\);)Tj
0 -1.5 TD
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, )Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, )Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 0, GL_RGBA, checkImageWidth, )Tj
T*
(                checkImageHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, )Tj
T*
(                checkImage\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glEnable\(GL_TEXTURE_2D\);)Tj
T*
(   glTexEnvf\(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL\);)Tj
T*
(   glBindTexture\(GL_TEXTURE_2D, texName\);)Tj
T*
(   glBegin\(GL_QUADS\);)Tj
T*
(   glTexCoord2f\(0.0, 0.0\); glVertex3f\(-2.0, -1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(0.0, 1.0\); glVertex3f\(-2.0, 1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(1.0, 1.0\); glVertex3f\(0.0, 1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(1.0, 0.0\); glVertex3f\(0.0, -1.0, 0.0\);)Tj
0 -3 TD
(   glTexCoord2f\(0.0, 0.0\); glVertex3f\(1.0, -1.0, 0.0\);)Tj
0 -1.5 TD
(   glTexCoord2f\(0.0, 1.0\); glVertex3f\(1.0, 1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(1.0, 1.0\); glVertex3f\(2.41421, 1.0, -1.41421\);)Tj
T*
(   glTexCoord2f\(1.0, 0.0\); glVertex3f\(2.41421, -1.0, -1.41421\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(   glDisable\(GL_TEXTURE_2D\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 7)Tj
ET
endstream
endobj
925 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
927 0 obj
<<
/Length 2306
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluPerspective\(60.0, \(GLfloat\) w/\(GLfloat\) h, 1.0, 30.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   glTranslatef\(0.0, 0.0, -3.6\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard \(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize\(250, 250\);)Tj
T*
(   glutInitWindowPosition\(100, 100\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0; )Tj
T*
(})Tj
/F11 1 Tf
0 -2.2 TD
(The checkerboard texture is generated in the routine)Tj
/F15 1 Tf
20.9 0 TD
( makeCheckImage\(\))Tj
/F11 1 Tf
8 0 TD
(, and all the texture-mapping)Tj
-28.9 -1.5 TD
(initialization occurs in the routine )Tj
/F15 1 Tf
13.7 0 TD
(init\(\))Tj
/F11 1 Tf
2 0 TD
(. )Tj
/F15 1 Tf
0.5 0 TD
(glGenTextures\(\))Tj
/F11 1 Tf
6.6 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glBindTexture\(\))Tj
/F11 1 Tf
6.4 0 TD
( name and create a texture)Tj
-31.1 -1.5 TD
[(object for a texture image. \(See "Texture Objects.")-18(\) The single, full-resolution texture map is specified)]TJ
T*
(by )Tj
/F15 1 Tf
1.3 0 TD
(glTexImage2D\(\))Tj
/F11 1 Tf
6.6 0 TD
(, whose parameters indicate the size of the image, type of the image, location of the)Tj
-7.9 -1.5 TD
[(image, and other properties of it. \(See )-40("Specifying the Texture")82( for more information about)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 8)Tj
ET
endstream
endobj
928 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
930 0 obj
<<
/Length 4795
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glTexImage2D\(\))Tj
/F11 1 Tf
6.6 0 TD
(.\))Tj
-6.6 -2.1 TD
0.000 Tw
(The four calls to )Tj
/F15 1 Tf
6.8 0 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
( specify how the texture is to be wrapped and how the colors are to)Tj
-14.5 -1.5 TD
(be filtered if there isn't an exact match between pixels in the texture and pixels on the screen. \(See)Tj
T*
[("Repeating and Clamping Textures")11( and )-56("Filtering.")12(\))]TJ
0 -2.1 TD
(In )Tj
/F15 1 Tf
1.1 0 TD
(display\(\))Tj
/F11 1 Tf
3.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( turns on texturing. )Tj
/F15 1 Tf
7.9 0 TD
(glTexEnv*\(\))Tj
/F11 1 Tf
4.9 0 TD
( sets the drawing mode to GL_DECAL so that the)Tj
-22.2 -1.5 TD
(textured polygons are drawn using the colors from the texture map \(rather than taking into account what)Tj
T*
(color the polygons would have been drawn without the texture\).)Tj
0 -2.1 TD
(Then, two polygons are drawn. Note that texture coordinates are specified along with vertex coordinates.)Tj
0 -1.5 TD
(The )Tj
/F15 1 Tf
1.8 0 TD
(glTexCoord*\(\))Tj
/F11 1 Tf
5.9 0 TD
( command behaves similarly to the )Tj
/F15 1 Tf
14.3 0 TD
(glNormal\(\))Tj
/F11 1 Tf
4.5 0 TD
( command. )Tj
/F15 1 Tf
4.7 0 TD
(glTexCoord*\(\))Tj
/F11 1 Tf
5.9 0 TD
( sets the)Tj
-37.1 -1.5 TD
(current texture coordinates; any subsequent vertex command has those texture coordinates associated)Tj
T*
(with it until )Tj
/F15 1 Tf
4.9 0 TD
(glTexCoord*\(\))Tj
/F11 1 Tf
6 0 TD
( is called again.)Tj
/F27 1 Tf
-10.9 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(The checkerboard image on the tilted polygon might look wrong when you compile and run it on)Tj
-2.8 -1.5 TD
(your machine)Tj
/F33 1 Tf
5.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, it might look like two triangles with different projections of the)Tj
-6.5 -1.5 TD
(checkerboard image on them. If so, try setting the parameter)Tj
0 -1.4 TD
(GL_PERSPECTIVE_CORRECTION_HINT to GL_NICEST and running the example again. To do this,)Tj
0 -1.5 TD
(use )Tj
/F15 1 Tf
1.6 0 TD
(glHint\(\))Tj
/F11 1 Tf
3.2 0 TD
(.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 426.000 Tm
(Specifying the Texture)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 404.000 Tm
(The command )Tj
/F15 1 Tf
6 0 TD
(glTexImage2D\(\))Tj
/F11 1 Tf
6.6 0 TD
( defines a two-dimensional texture. It takes several arguments, which are)Tj
-12.6 -1.5 TD
(described briefly here and in more detail in the subsections that follow. The related command for)Tj
T*
(one-dimensional textures, )Tj
/F15 1 Tf
10.6 0 TD
(glTexImage1D\(\))Tj
/F11 1 Tf
6.6 0 TD
[(, is described in )28("One-Dimensional Textures.")]TJ
/F15 1 Tf
-17.2 -2.1 TD
[(void )-28(glTexImage2D)44(\(GLenum )27(target)-11(, GLint )-16(level)-12(, GLint )-16(internalFormat)-32(,)]TJ
0 -1.1 TD
-0.006 Tw
[(GLsizei width)23(, )-6(GLsizei height, )-6(GLint )-22(border)22(,)]TJ
T*
0.006 Tw
[(GLenum format)-33(, )6(GLenum type)66(,)]TJ
T*
0.000 Tw
[(const GLvoid )12(*pixels)33(\);)]TJ
1.8 -1.5 TD
(Defines a two-dimensional texture. The )Tj
16 0 TD
[(target)-11( parameter is set to either the constant)]TJ
-16 -1.5 TD
[(GL_TEXTURE_2D or GL_PROXY_TEXTURE_2D. You use the )20(level)-12( parameter if you're supplying)]TJ
T*
[(multiple resolutions of the texture map; with only one resolution, )-47(level)88( should be 0. \(See )-67("Multiple)]TJ
T*
[(Levels of Detail")-46( for more information about using multiple resolutions.\))]TJ
T*
[(The next parameter, )33(internalFormat)-32(, indicates which of the R, G, B, and A components or luminance)]TJ
T*
(or intensity values are selected for use in describing the texels of an image. The value of)Tj
T*
[(internalFormat )18(is an integer from 1 to 4, or one of thirty-eight symbolic constants. The thirty-eight)]TJ
T*
[(symbolic constants that are also legal values for )13(internalFormat)-32( are GL_ALPHA, GL_ALPHA4,)]TJ
T*
(GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4,)Tj
T*
(GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA,)Tj
T*
(GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8,)Tj
T*
(GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,)Tj
T*
(GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16,)Tj
T*
(GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12,)Tj
T*
(GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2,)Tj
T*
[(GL_RGBA12, and GL_RGBA16. \(See )-11("Texture Functions")46( for a discussion of how these selected)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 9)Tj
ET
endstream
endobj
931 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
933 0 obj
<<
/Length 4790
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(components are applied.\))Tj
0 -1.5 TD
[(If )-39(internalFormat)68( is one of the thirty-eight symbolic constants, then you are asking for specific)]TJ
T*
[(components and perhaps the resolution of those components. For example, if )-15(internalFormat)68( is)]TJ
T*
(GL_R3_G3_B2, you are asking that texels be 3 bits of red, 3 bits of green, and 2 bits of blue, but)Tj
T*
(OpenGL is not guaranteed to deliver this. OpenGL is only obligated to choose an internal)Tj
T*
(representation that closely approximates what is requested, but an exact match is usually not)Tj
T*
(required. By definition, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, and GL_RGBA)Tj
T*
(are lenient, because they do not ask for a specific resolution. \(For compatibility with the OpenGL)Tj
T*
[(release 1.0, the numeric values 1, 2, 3, and 4, for )-39(internalFormat)68(, are equivalent to the symbolic)]TJ
T*
(constants GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, and GL_RGBA, respectively.\))Tj
T*
[(The )-50(width)23( and height parameters give the dimensions of the texture image; )50(border)22( indicates the)]TJ
T*
[(width of the border, which is either zero \(no border\) or one. \(See )51("Using a Texture's Borders")-21(.\) Both)]TJ
0 -1.8 TD
[(width)23( and height must have the form 2)]TJ
15.4 0.3 TD
(m)Tj
0.7 -0.3 TD
(+2b, where m is a nonnegative integer \(which can have a)Tj
-16.1 -1.5 TD
[(different value for )-27(width)23( than for height\) and b is the value of )17(border)22(. The maximum size of a texture)]TJ
0 -1.6 TD
(map depends on the implementation of OpenGL, but it must be at least 64)Tj
/F33 1 Tf
29.5 0 TD
(\264)Tj
/F15 1 Tf
0.5 0 TD
(64 \(or 66)Tj
/F33 1 Tf
3.8 0 TD
(\264)Tj
/F15 1 Tf
0.5 0 TD
(66 with)Tj
-34.3 -1.6 TD
(borders\).)Tj
0 -1.5 TD
[(The )-50(format)67( and type)-34( parameters describe the format and data type of the texture image data. They)]TJ
T*
[(have the same meaning as they do for )33(glDrawPixels\(\))-33(. \(See )-29("Imaging Pipeline" in Chapter 8)64(.\) In)]TJ
T*
[(fact, texture data is in the same format as the data used by )13(glDrawPixels\(\))-33(, so the settings of)]TJ
T*
[(glPixelStore*\(\))11( and glPixelTransfer*\(\))-55( are applied. \(In )50(Example 9-1)]TJ
27.4 0 TD
(, the call)Tj
/F7 1 Tf
-29.2 -2.1 TD
(glPixelStorei\(GL_UNPACK_ALIGNMENT, 1\);)Tj
/F15 1 Tf
1.8 -1.1 TD
[(is made because the data in the example isn't padded at the end of each texel row.\) The )49(format)]TJ
T*
(parameter can be GL_COLOR_INDEX, GL_RGB, GL_RGBA, GL_RED, GL_GREEN, GL_BLUE,)Tj
0 -1.2 TD
(GL_ALPHA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA)Tj
/F33 1 Tf
25.5 0 TD
(\276)Tj
/F15 1 Tf
1 0 TD
(that is, the same formats available)Tj
-26.5 -1.2 TD
[(for )17(glDrawPixels\(\))-33( with the exceptions of GL_STENCIL_INDEX and GL_DEPTH_COMPONENT.)]TJ
0 -1.5 TD
[(Similarly, the )40(type)-34( parameter can be GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,)]TJ
T*
(GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_BITMAP.)Tj
T*
[(Finally, )-11(pixels)33( contains the texture-image data. This data describes the texture image itself as well)]TJ
T*
(as its border.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The internal format of a texture image may affect the performance of texture operations. For example,)Tj
0 -1.5 TD
(some implementations perform texturing with GL_RGBA faster than GL_RGB, because the color)Tj
T*
(components align the processor memory better. Since this varies, you should check specific information)Tj
T*
(about your implementation of OpenGL.)Tj
0 -2.1 TD
(The internal format of a texture image also may control how much memory a texture image consumes.)Tj
0 -1.5 TD
(For example, a texture of internal format GL_RGBA8 uses 32 bits per texel, while a texture of internal)Tj
T*
(format GL_R3_G3_B2 only uses 8 bits per texel. Of course, there is a corresponding trade-off between)Tj
T*
(memory consumption and color resolution.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Although texture-mapping results in color-index mode are undefined, you can still specify a)Tj
-2.8 -1.4 TD
(texture with a GL_COLOR_INDEX image. In that case, pixel-transfer operations are applied to convert)Tj
T*
(the indices to RGBA values by table lookup before they're used to form the texture image.)Tj
0 -2.1 TD
(The number of texels for both the width and height of a texture image, not including the optional border,)Tj
0 -1.5 TD
(must be a power of 2. If your original image does not have dimensions that fit that limitation, you can use)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 10)Tj
ET
endstream
endobj
934 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
937 0 obj
<<
/Length 5223
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(the OpenGL Utility Library routine )Tj
/F15 1 Tf
14.4 0 TD
(gluScaleImage\(\))Tj
/F11 1 Tf
6.6 0 TD
( to alter the size of your textures.)Tj
/F15 1 Tf
-21 -2.1 TD
[(int )6(gluScaleImage)44(\(GLenum )-73(format)67(, GLint )-16(widthin, GLint )-16(heightin)-22(,)]TJ
0 -1.1 TD
[(GLenum )-6(typein)44(, const void *)-66(datain)56(, GLint )-16(widthout,)]TJ
T*
[(GLint )-16(heightout)-22(, GLenum )-6(typeout)44(, void *)-28(dataout)56(\);)]TJ
1.8 -1.5 TD
(Scales an image using the appropriate pixel-storage modes to unpack the data from )Tj
33.8 0 TD
[(datain)-44(. The)]TJ
-33.8 -1.5 TD
[(format)-33(, typein)44(, and )-50(typeout)44( parameters can refer to any of the formats or data types supported by)]TJ
T*
[(glDrawPixels\(\))-33(. The image is scaled using linear interpolation and box filtering \(from the size)]TJ
T*
[(indicated by )-33(widthin and heightin)78( to )-22(widthout and heightout)-22(\), and the resulting image is written to)]TJ
T*
[(dataout)-44(, using the pixel GL_PACK* storage modes. The caller of )36(gluScaleImage\(\))10( must allocate)]TJ
T*
(sufficient space for the output buffer. A value of 0 is returned on success, and a GLU error code is)Tj
T*
(returned on failure.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The framebuffer itself can also be used as a source for texture data. )Tj
/F15 1 Tf
27.1 0 TD
(glCopyTexImage2D\(\))Tj
/F11 1 Tf
8.7 0 TD
( reads a)Tj
-35.8 -1.5 TD
(rectangle of pixels from the framebuffer and uses it for a new texture.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glCopyTexImage2D)55(\(GLenum )-45(target)89(, )28(GLint )12(level)-12(,)]TJ
0 -1.1 TD
0.016 Tw
[(GLint internalFormat)-32(,)]TJ
T*
0.000 Tw
[(GLint )-16(x)44(,)0( GLint )-16(y)-56(,)0( GLsizei )6(width)23(, GLsizei )6(height,)]TJ
T*
0.016 Tw
[(GLint border)22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Creates a two-dimensional texture, using framebuffer data to define the texels. The pixels are read)Tj
T*
[(from the current GL_READ_BUFFER and are processed exactly as if )-23(glCopyPixels\(\) had been)]TJ
T*
[(called but stopped before final conversion. The settings of )47(glPixelTransfer*\(\))-55( are applied.)]TJ
T*
[(The )-50(target)89( parameter must be set to the constant GL_TEXTURE_2D. The )-70(level)-12(,)50( internalFormat)18(, and)]TJ
T*
[(border)22( parameters have the same effects that they have for )-45(glTexImage2D\(\))10(. The texture array is)]TJ
T*
(taken from a screen-aligned pixel rectangle with the lower-left corner at coordinates specified by the)Tj
T*
[(\()33(x)-56(, y)44(\))0( parameters. The )-11(width)23( and height parameters specify the size of this pixel rectangle. Both)]TJ
0 -1.8 TD
[(width)23( and height must have the form 2)]TJ
15.4 0.3 TD
(m)Tj
0.7 -0.3 TD
(+2b, where m is a nonnegative integer \(which can have a)Tj
-16.1 -1.5 TD
[(different value for )-27(width)23( than for height\) and b is the value of )17(border)22(.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(The next sections give more detail about texturing, including the use of the )Tj
/F15 1 Tf
30.2 0 TD
(target)Tj
/F11 1 Tf
2.4 0 TD
(,)Tj
/F15 1 Tf
0.3 0 TD
( border)Tj
/F11 1 Tf
2.9 0 TD
(, and)Tj
/F15 1 Tf
2 0 TD
( level)Tj
/F11 1 Tf
-37.8 -1.5 TD
(parameters. The )Tj
/F15 1 Tf
6.7 0 TD
(target)Tj
/F11 1 Tf
2.4 0 TD
( parameter can be used to accurately query the size of a texture \(by creating a)Tj
-9.1 -1.5 TD
(texture proxy with )Tj
/F15 1 Tf
7.6 0 TD
(glTexImage*D\(\))Tj
/F11 1 Tf
6.6 0 TD
(\) and whether a texture possibly can be used within the texture)Tj
-14.2 -1.5 TD
[(resources of an OpenGL implementation. Redefining a portion of a texture is described in )-8("Replacing All)]TJ
T*
[(or Part of a Texture Image.")39( One-dimensional textures are discussed in )219("One-Dimensional Textures.")]TJ
T*
(The texture border, which has its size controlled by the )Tj
/F15 1 Tf
22.2 0 TD
(border)Tj
/F11 1 Tf
2.8 0 TD
[( parameter, is detailed in )10("Using a)]TJ
-25 -1.5 TD
[(Texture's Borders.")7( The )]TJ
/F15 1 Tf
10 0 TD
(level)Tj
/F11 1 Tf
1.8 0 TD
( parameter is used to specify textures of different resolutions and is)Tj
-11.8 -1.5 TD
(incorporated into the special technique of )Tj
/F15 1 Tf
16.8 0 TD
(mipmapping)Tj
/F11 1 Tf
5 0 TD
[(, which is explained in )-22("Multiple Levels of)]TJ
-21.8 -1.5 TD
(Detail." Mipmapping requires understanding how to filter textures as they're applied; filtering is the)Tj
T*
[(subject of )-34("Filtering.")]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 149.000 Tm
(Texture Proxy)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 127.000 Tm
(To an OpenGL programmer who uses textures, size is important. Texture resources are typically limited)Tj
T*
(and vary among OpenGL implementations. There is a special texture proxy target to evaluate whether)Tj
T*
(sufficient resources are available.)Tj
/F15 1 Tf
0 -2.1 TD
(glGetIntegerv)Tj
/F11 1 Tf
5.6 0 TD
(\(GL_MAX_TEXTURE_SIZE,...\) tells you the largest dimension \(width or height, without)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 11)Tj
ET
endstream
endobj
938 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
940 0 obj
<<
/Length 4462
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(borders\) of a texture image, typically the size of the largest square texture supported. However,)Tj
0 -1.5 TD
(GL_MAX_TEXTURE_SIZE does not consider the effect of the internal format of a texture. A texture)Tj
T*
(image that stores texels using the GL_RGBA16 internal format may be using 64 bits per texel, so its)Tj
T*
(image may have to be 16 times smaller than an image with the GL_LUMINANCE4 internal format.)Tj
T*
(\(Also, images requiring borders or mipmaps may further reduce the amount of available memory.\))Tj
0 -2.1 TD
(A special place holder, or )Tj
/F15 1 Tf
10.5 0 TD
(proxy)Tj
/F11 1 Tf
2.3 0 TD
(, for a texture image allows the program to query more accurately)Tj
-12.8 -1.5 TD
(whether OpenGL can accommodate a texture of a desired internal format. To use the proxy to query)Tj
T*
(OpenGL, call )Tj
/F15 1 Tf
5.7 0 TD
(glTexImage2D\(\))Tj
/F11 1 Tf
6.6 0 TD
( with a )Tj
/F15 1 Tf
3 0 TD
(target)Tj
/F11 1 Tf
2.4 0 TD
( parameter of GL_PROXY_TEXTURE_2D and the given)Tj
/F15 1 Tf
-17.7 -1.5 TD
(level, internalFormat, width, height, border, format, )Tj
/F11 1 Tf
21.2 0 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(type)Tj
/F11 1 Tf
1.6 0 TD
(. \(For one-dimensional textures, use)Tj
-24.5 -1.5 TD
(corresponding 1D routines and symbolic constants.\) For a proxy, you should pass NULL as the pointer)Tj
T*
(for the )Tj
/F15 1 Tf
2.9 0 TD
(pixels)Tj
/F11 1 Tf
2.3 0 TD
( array.)Tj
-5.2 -2.1 TD
(To find out whether there are enough resources available for your texture, after the texture proxy has)Tj
0 -1.5 TD
(been created, query the texture state variables with )Tj
/F15 1 Tf
20.5 0 TD
(glGetTexLevelParameter*\(\))Tj
/F11 1 Tf
11.3 0 TD
(. If there aren't enough)Tj
-31.8 -1.5 TD
(resources to accommodate the texture proxy, the texture state variables for width, height, border width,)Tj
T*
(and component resolutions are set to 0.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glGetTexLevelParameter)10({if})56(v)-56(\(GLenum )55(target)-11(, )28(GLint )12(level)-12(,)]TJ
0 -1.1 TD
0.000 Tw
[(GLenum )-6(pname)-34(, TYPE)34( *)50(params\);)]TJ
1.8 -1.5 TD
[(Returns in )-10(params texture parameter values for a specific level of detail, specified as )61(level)-12(. target)]TJ
T*
(defines the target texture and is one of GL_TEXTURE_1D, GL_TEXTURE_2D,)Tj
T*
[(GL_PROXY_TEXTURE_1D, or GL_PROXY_TEXTURE_2D. Accepted values for )-42(pname)66( are)]TJ
T*
(GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_BORDER,)Tj
T*
(GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,)Tj
T*
(GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_LUMINANCE_SIZE,)Tj
T*
(or GL_TEXTURE_INTENSITY_SIZE.)Tj
T*
[(GL_TEXTURE_COMPONENTS is also accepted for )20(pname)-34(, but only for backward compatibility)]TJ
0 -1.6 TD
(with OpenGL Release 1.0)Tj
/F33 1 Tf
10.3 0 TD
(\276)Tj
/F15 1 Tf
1 0 TD
(GL_TEXTURE_INTERNAL_FORMAT is the recommended symbolic)Tj
-11.3 -1.6 TD
(constant for Release 1.1.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(Example 9-2)Tj
5.1 0 TD
( demonstrates how to use the texture proxy to find out if there are enough resources to create)Tj
-5.1 -1.6 TD
(a 64)Tj
/F33 1 Tf
1.7 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(64 texel texture with RGBA components with 8 bits of resolution. If this succeeds, then)Tj
/F15 1 Tf
-2.2 -1.6 TD
(glGetTexLevelParameteriv\(\))Tj
/F11 1 Tf
11.5 0 TD
( stores the internal format \(in this case, GL_RGBA8\) into the variable)Tj
/F15 1 Tf
-11.5 -1.5 TD
(format)Tj
/F11 1 Tf
2.7 0 TD
(.)Tj
/F27 1 Tf
-2.7 -2 TD
(Example 9-2 )Tj
/F11 1 Tf
6.1 0 TD
(Querying Texture Resources with a Texture Proxy)Tj
/F7 1 Tf
-6.1 -2.4 TD
(  GLint format;)Tj
0 -3 TD
(  glTexImage2D\(GL_PROXY_TEXTURE_2D, 0, GL_RGBA8,)Tj
0 -1.5 TD
(               64, 64, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL\);)Tj
T*
(  glGetTexLevelParameteriv\(GL_PROXY_TEXTURE_2D, 0,)Tj
T*
(                           GL_TEXTURE_INTERNAL_FORMAT, &format\);)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(There is one major limitation about texture proxies: The texture proxy tells you if there is space)Tj
-2.8 -1.5 TD
(for your texture, but only if all texture resources are available \(in other words, if it's the only texture in)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 12)Tj
ET
endstream
endobj
941 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
943 0 obj
<<
/Length 4061
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(town\). If other textures are using resources, then the texture proxy query may respond affirmatively, but)Tj
0 -1.4 TD
(there may not be enough space to make your texture resident \(that is, part of a possibly high-performance)Tj
T*
[(working set of textures\). \(See )-46("Texture Objects")32( for more information about managing resident textures.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 654.000 Tm
(Replacing All or Part of a Texture Image)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 632.000 Tm
(Creating a texture may be more computationally expensive than modifying an existing one. In OpenGL)Tj
0 -1.5 TD
(Release 1.1, there are new routines to replace all or part of a texture image with new information. This)Tj
T*
(can be helpful for certain applications, such as using real-time, captured video images as texture images.)Tj
T*
(For that application, it makes sense to create a single texture and use )Tj
/F15 1 Tf
27.7 0 TD
(glTexSubImage2D\(\))Tj
/F11 1 Tf
8.1 0 TD
( to repeatedly)Tj
-35.8 -1.5 TD
(replace the texture data with new video images. Also, there are no size restrictions for)Tj
/F15 1 Tf
T*
(glTexSubImage2D\(\))Tj
/F11 1 Tf
8.1 0 TD
( that force the height or width to be a power of two. This is helpful for processing)Tj
-8.1 -1.5 TD
(video images, which generally do not have sizes that are powers of two.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glTexSubImage2D)44(\(GLenum )27(target)-11(, GLint )-16(level)-12(, GLint )-16(xoffset)11(,)]TJ
0 -1.1 TD
[(GLint )-16(yoffset)11(, GLsizei )6(width)23(, GLsizei )6(height,)]TJ
T*
[(GLenum )-6(format)-33(, GLenum )-6(type)66(, const GLvoid )12(*pixels)-67(\);)]TJ
1.8 -1.5 TD
(Defines a two-dimensional texture image that replaces all or part of a contiguous subregion \(in 2D,)Tj
T*
(it's simply a rectangle\) of the current, existing two-dimensional texture image. The )Tj
33.4 0 TD
[(target)-11( parameter)]TJ
-33.4 -1.5 TD
(must be set to GL_TEXTURE_2D.)Tj
T*
[(The level)38(, format,)-83( and type)66( parameters are similar to the ones used for )7(glTexImage2D\(\))10(. level)-12( is the)]TJ
T*
(mipmap level-of-detail number. It is not an error to specify a width or height of zero, but the)Tj
T*
[(subimage will have no effect. )-11(format)-33( and type)66( describe the format and data type of the texture image)]TJ
T*
[(data. The subimage is also affected by modes set by )18(glPixelStore*\(\))11( and glPixelTransfer*\(\))-55(.)]TJ
T*
[(pixels )-17(contains the texture data for the subimage. )-10(width)23( and height are the dimensions of the)]TJ
T*
[(subregion that is replacing all or part of the current texture image. )-14(xoffset)11( and yoffset)11( specify the)]TJ
T*
[(texel offset in the )-44(x)44( and y)44( directions \(with \(0, 0\) at the lower-left corner of the texture\) and specify)]TJ
T*
(where to put the subimage within the existing texture array. This region may not include any texels)Tj
T*
(outside the range of the originally defined texture array.)Tj
/F11 1 Tf
-1.8 -2.1 TD
0.017 Tw
[(In Example )17(9-3)]TJ
6.2 0 TD
0.000 Tw
[(, some of the code from )-51(Example 9-1)]TJ
14.9 0 TD
( has been modified so that pressing the `s' key drops)Tj
-21.1 -1.5 TD
[(a smaller checkered subimage into the existing image. \(The resulting texture is shown in )38(Figure 9-3)225(.\))]TJ
T*
[(Pressing the `r' key restores the original image. )-7(Example 9-3)]TJ
24.3 0 TD
( shows the two routines,)Tj
/F15 1 Tf
-24.3 -1.5 TD
(makeCheckImages\(\))Tj
/F11 1 Tf
8.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(keyboard\(\))Tj
/F11 1 Tf
4.4 0 TD
[(, that have been substantially changed. \(See )-7("Texture Objects")32( for)]TJ
-14.5 -1.5 TD
(more information about )Tj
/F15 1 Tf
9.7 0 TD
(glBindTexture\(\))Tj
/F11 1 Tf
6.4 0 TD
(.\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 13)Tj
ET
endstream
endobj
944 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
945 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im84
/Width 262
/Height 160
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.83)
>>
stream
endstream
endobj
947 0 obj
<<
/Length 1767
>>
stream
/GS1 gs
q
262 0 0 160 124 560 cm
/Im84 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 547.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 9-3 )Tj
/F11 1 Tf
5.1 0 TD
(Texture with Subimage Added)Tj
/F27 1 Tf
-5.1 -2.1 TD
(Example 9-3 )Tj
/F11 1 Tf
6.1 0 TD
(Replacing a Texture Subimage: texsub.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(/*  Create checkerboard textures  */)Tj
0 -1.5 TD
(#define checkImageWidth 64)Tj
T*
(#define checkImageHeight 64)Tj
T*
(#define subImageWidth 16)Tj
T*
(#define subImageHeight 16)Tj
T*
(static GLubyte checkImage[checkImageHeight][checkImageWidth][4];)Tj
T*
(static GLubyte subImage[subImageHeight][subImageWidth][4];)Tj
0 -3 TD
(void makeCheckImages\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i, j, c;)Tj
0 -3 TD
(   for \(i = 0; i < checkImageHeight; i++\) {)Tj
0 -1.5 TD
(      for \(j = 0; j < checkImageWidth; j++\) {)Tj
T*
(         c = \(\(\(\(i&0x8\)==0\)^\(\(j&0x8\)\)==0\)\)*255;)Tj
T*
(         checkImage[i][j][0] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][1] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][2] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][3] = \(GLubyte\) 255;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(   for \(i = 0; i < subImageHeight; i++\) {)Tj
T*
(      for \(j = 0; j < subImageWidth; j++\) {)Tj
T*
(         c = \(\(\(\(i&0x4\)==0\)^\(\(j&0x4\)\)==0\)\)*255;)Tj
T*
(         subImage[i][j][0] = \(GLubyte\) c;)Tj
T*
(         subImage[i][j][1] = \(GLubyte\) 0;)Tj
T*
(         subImage[i][j][2] = \(GLubyte\) 0;)Tj
T*
(         subImage[i][j][3] = \(GLubyte\) 255;)Tj
T*
(      })Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 14)Tj
ET
endstream
endobj
948 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im84 945 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
950 0 obj
<<
/Length 2857
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   })Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void keyboard \(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `s':)Tj
T*
(      case `S':)Tj
T*
(         glBindTexture\(GL_TEXTURE_2D, texName\);)Tj
T*
(         glTexSubImage2D\(GL_TEXTURE_2D, 0, 12, 44, )Tj
T*
(                         subImageWidth, subImageHeight, GL_RGBA,)Tj
T*
(                         GL_UNSIGNED_BYTE, subImage\);)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `r':)Tj
T*
(      case `R':)Tj
T*
(         glBindTexture\(GL_TEXTURE_2D, texName\);)Tj
T*
(         glTexImage2D\(GL_TEXTURE_2D, 0, GL_RGBA, )Tj
T*
(                      checkImageWidth, checkImageHeight, 0,)Tj
T*
(                      GL_RGBA, GL_UNSIGNED_BYTE, checkImage\);)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Once again, the framebuffer itself can be used as a source for texture data; this time, a texture subimage.)Tj
/F15 1 Tf
0 -1.5 TD
(glCopyTexSubImage2D\(\))Tj
/F11 1 Tf
10.2 0 TD
( reads a rectangle of pixels from the framebuffer and replaces a portion of an)Tj
-10.2 -1.5 TD
(existing texture array. \()Tj
/F15 1 Tf
9.3 0 TD
(glCopyTexSubImage2D\(\))Tj
/F11 1 Tf
10.3 0 TD
( is kind of a cross between )Tj
/F15 1 Tf
10.8 0 TD
(glCopyTexImage2D\(\))Tj
/F11 1 Tf
8.7 0 TD
( and)Tj
/F15 1 Tf
-39.1 -1.5 TD
(glTexSubImage2D\(\))Tj
/F11 1 Tf
8.1 0 TD
(.\))Tj
/F15 1 Tf
-8.1 -2.7 TD
0.028 Tw
[(void glCopyTexSubImage2D)55(\(GLenum )-45(target)89(, )28(GLint )12(level)-12(,)]TJ
0 -1.1 TD
0.016 Tw
[(GLint xoffset)11(, )16(GLint yoffset)11(, )16(GLint x)44(,)0( )16(GLint y)44(,)]TJ
T*
-0.006 Tw
[(GLsizei width)23(, )-6(GLsizei height\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Uses image data from the framebuffer to replace all or part of a contiguous subregion of the current,)Tj
T*
(existing two-dimensional texture image. The pixels are read from the current GL_READ_BUFFER)Tj
T*
[(and are processed exactly as if )11(glCopyPixels\(\) had been called, stopping before final conversion.)]TJ
T*
[(The settings of )-15(glPixelStore*\(\))11( and glPixelTransfer*\(\))45( are applied.)]TJ
T*
[(The )-50(target)89( parameter must be set to GL_TEXTURE_2D. )-32(level)-12( is the mipmap level-of-detail number.)]TJ
T*
[(xoffset)11( and yoffset)11( specify the texel offset in the x and y directions \(with \(0, 0\) at the lower-left corner)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 15)Tj
ET
endstream
endobj
951 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
953 0 obj
<<
/Length 4875
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(of the texture\) and specify where to put the subimage within the existing texture array. The subimage)Tj
0 -1.5 TD
(texture array is taken from a screen-aligned pixel rectangle with the lower-left corner at coordinates)Tj
T*
[(specified by the \(x)44(, y)-56(\))0( parameters. The )-11(width)23( and height parameters specify the size of this subimage)]TJ
T*
(rectangle.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 637.000 Tm
(One-Dimensional Textures)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 615.000 Tm
(Sometimes a one-dimensional texture is sufficient)Tj
/F33 1 Tf
20 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, if you're drawing textured bands where)Tj
-21 -1.6 TD
(all the variation is in one direction. A one-dimensional texture behaves like a two-dimensional one with)Tj
/F15 1 Tf
0 -1.5 TD
(height)Tj
/F11 1 Tf
2.5 0 TD
( = 1, and without borders along the top and bottom. All the two-dimensional texture and subtexture)Tj
-2.5 -1.5 TD
(definition routines have corresponding one-dimensional routines. To create a simple one-dimensional)Tj
T*
(texture, use )Tj
/F15 1 Tf
4.9 0 TD
(glTexImage1D\(\))Tj
/F11 1 Tf
6.6 0 TD
(.)Tj
/F15 1 Tf
-11.5 -2.1 TD
[(void )-28(glTexImage1D)44(\(GLenum )27(target)-11(, GLint )-16(level)-12(, GLint )-16(internalFormat)-32(,)]TJ
0 -1.1 TD
[(GLsizei )6(width)23(, GLint )-16(border)22(, GLenum )-6(format)-33(,)]TJ
T*
[(GLenum )-6(type)-34(, const GLvoid )12(*pixels)33(\);)]TJ
1.8 -1.5 TD
(Defines a one-dimensional texture. All the parameters have the same meanings as for)Tj
T*
[(glTexImage2D\(\))10(, except that the image is now a one-dimensional array of texels. As before, the)]TJ
0 -1.8 TD
[(value of )44(width)-77( is 2)]TJ
7.3 0.3 TD
(m)Tj
0.8 -0.3 TD
( \(or 2)Tj
2.2 0.3 TD
(m)Tj
0.7 -0.3 TD
(+2, if there's a border\), where m is a nonnegative integer. You can)Tj
-11 -1.5 TD
[(supply mipmaps, proxies \(set )-39(target)89( to GL_PROXY_TEXTURE_1D\), and the same filtering options)]TJ
T*
(are available as well.)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(For a sample program that uses a one-dimensional texture map, see )196(Example 9-6)]TJ
32.3 0 TD
(.)Tj
-32.3 -2.1 TD
(To replace all or some of the texels of a one-dimensional texture, use )Tj
/F15 1 Tf
27.9 0 TD
(glTexSubImage1D\(\))Tj
/F11 1 Tf
8.1 0 TD
(.)Tj
/F15 1 Tf
-36 -2.1 TD
[(void )-28(glTexSubImage1D)44(\(GLenum )27(target)-11(, GLint )-16(level)-12(, GLint )-16(xoffset)11(,)]TJ
0 -1.1 TD
-0.006 Tw
[(GLsizei width)23(, )-6(GLenum )-12(format)-33(,)]TJ
T*
0.000 Tw
[(GLenum )-6(type)-34(, const GLvoid )12(*pixels)33(\);)]TJ
1.8 -1.5 TD
(Defines a one-dimensional texture array that replaces all or part of a contiguous subregion \(in 1D,)Tj
T*
(a row\) of the current, existing one-dimensional texture image. The )Tj
26.8 0 TD
[(target)-11( parameter must be set to)]TJ
-26.8 -1.5 TD
(GL_TEXTURE_1D.)Tj
T*
[(The level)38(, format,)-83( and type)66( parameters are similar to the ones used for )7(glTexImage1D\(\))10(. level)-12( is the)]TJ
T*
(mipmap level-of-detail number. )Tj
12.9 0 TD
[(format)-33( and type)66( describe the format and data type of the texture)]TJ
-12.9 -1.5 TD
[(image data. The subimage is also affected by modes set by )12(glPixelStore*\(\))11( or )-11(glPixelTransfer*\(\))-55(.)]TJ
-1.8 -2.1 TD
(pixels )Tj
/F11 1 Tf
2.6 0 TD
(contains the texture data for the subimage. )Tj
/F15 1 Tf
17.2 0 TD
(width)Tj
/F11 1 Tf
2.2 0 TD
( is the number of texels that replace part or all of)Tj
-22 -1.5 TD
(the current texture image. )Tj
/F15 1 Tf
10.5 0 TD
(xoffset)Tj
/F11 1 Tf
2.6 0 TD
( specifies the texel offset for where to put the subimage within the)Tj
-13.1 -1.5 TD
(existing texture array.)Tj
0 -2.1 TD
(To use the framebuffer as the source of a new or replacement for an old one-dimensional texture, use)Tj
0 -1.5 TD
(either )Tj
/F15 1 Tf
2.5 0 TD
(glCopyTexImage1D\(\))Tj
/F11 1 Tf
8.7 0 TD
( or )Tj
/F15 1 Tf
1.4 0 TD
(glCopyTexSubImage1D\(\))Tj
/F11 1 Tf
10.2 0 TD
(.)Tj
/F15 1 Tf
-22.8 -2.1 TD
0.028 Tw
[(void glCopyTexImage1D)55(\(GLenum )-45(target)89(, )28(GLint )12(level)-12(,)]TJ
0 -1.1 TD
0.000 Tw
[(GLint )-16(internalFormat)-32(, GLint )84(x)-56(,)0( GLint )-16(y)44(,)]TJ
T*
-0.006 Tw
[(GLsizei width)23(, )-6(GLint )-22(border)22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Creates a one-dimensional texture, using framebuffer data to define the texels. The pixels are read)Tj
T*
[(from the current GL_READ_BUFFER and are processed exactly as if )-23(glCopyPixels\(\) had been)]TJ
T*
[(called but stopped before final conversion. The settings of )47(glPixelStore*\(\))-89( and glPixelTransfer*\(\))]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 16)Tj
ET
endstream
endobj
954 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
956 0 obj
<<
/Length 4440
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(are applied.)Tj
0 -1.5 TD
[(The )-50(target)89( parameter must be set to the constant GL_TEXTURE_1D. The )-70(level)-12(,)50( internalFormat)18(, and)]TJ
T*
[(border)22( parameters have the same effects that they have for )-45(glCopyTexImage2D\(\))21(. The texture array)]TJ
T*
(is taken from a row of pixels with the lower-left corner at coordinates specified by the \()Tj
34.9 0 TD
0.056 Tc
-0.056 Tw
[(x,)56( y)100(\))]TJ
-34.9 -1.8 TD
0.000 Tc
0.000 Tw
[(parameters. The )6(width)23( parameter specifies the number of pixels in this row. The value of )24(width)-77( is 2)]TJ
39.6 0.3 TD
(m)Tj
-39.6 -2.1 TD
(\(or 2)Tj
2 0.3 TD
(m)Tj
0.7 -0.3 TD
(+2 if there's a border\), where m is a nonnegative integer.)Tj
-4.5 -2.1 TD
[(void )-28(glCopyTexSubImage1D)55(\(GLenum )-73(target)89(, GLint )-16(level)-12(, GLint )-16(xoffset)11(,)]TJ
0 -1.1 TD
0.016 Tw
[(GLint x)44(,)0( )16(GLint y)-56(,)0( )16(GLsizei )22(width)23(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Uses image data from the framebuffer to replace all or part of a contiguous subregion of the current,)Tj
T*
(existing one-dimensional texture image. The pixels are read from the current GL_READ_BUFFER)Tj
T*
[(and are processed exactly as if )11(glCopyPixels\(\) had been called but stopped before final conversion.)]TJ
T*
[(The settings of )-15(glPixelStore*\(\))11( and glPixelTransfer*\(\))45( are applied.)]TJ
T*
[(The )-50(target)89( parameter must be set to GL_TEXTURE_1D. )-32(level)-12( is the mipmap level-of-detail number.)]TJ
T*
[(xoffset)11( specifies the texel offset and specifies where to put the subimage within the existing texture)]TJ
T*
(array. The subimage texture array is taken from a row of pixels with the lower-left corner at)Tj
T*
[(coordinates specified by the \()-23(x)44(, y)-56(\))0( parameters. The )-11(width)23( parameter specifies the number of pixels in)]TJ
T*
(this row.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 434.000 Tm
(Using a Texture's Borders)Tj
10.000 0.000 0.000 10.000 204.000 412.000 Tm
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(If you need to apply a larger texture map than your implementation of OpenGL allows, you can, with a)Tj
0 -1.5 TD
(little care, effectively make larger textures by tiling with several different textures. For example, if you)Tj
T*
(need a texture twice as large as the maximum allowed size mapped to a square, draw the square as four)Tj
T*
(subsquares, and load a different texture before drawing each piece.)Tj
0 -2.1 TD
(Since only a single texture map is available at one time, this approach might lead to problems at the)Tj
0 -1.5 TD
(edges of the textures, especially if some form of linear filtering is enabled. The texture value to be used)Tj
T*
(for pixels at the edges must be averaged with something beyond the edge, which, ideally, should come)Tj
T*
(from the adjacent texture map. If you define a border for each texture whose texel values are equal to the)Tj
T*
(values of the texels on the edge of the adjacent texture map, then the correct behavior results when linear)Tj
T*
(filtering takes place.)Tj
0 -2.2 TD
(To do this correctly, notice that each map can have eight neighbors)Tj
/F33 1 Tf
26.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(one adjacent to each edge, and one)Tj
-27.8 -1.6 TD
(touching each corner. The values of the texels in the corner of the border need to correspond with the)Tj
0 -1.5 TD
(texels in the texture maps that touch the corners. If your texture is an edge or corner of the whole tiling,)Tj
T*
(you need to decide what values would be reasonable to put in the borders. The easiest reasonable thing to)Tj
T*
(do is to copy the value of the adjacent texel in the texture map. Remember that the border values need to)Tj
T*
(be supplied at the same time as the texture-image data, so you need to figure this out ahead of time.)Tj
0 -2.1 TD
(A texture's border color is also used if the texture is applied in such a way that it only partially covers a)Tj
0 -1.5 TD
[(primitive. \(See "Repeating and Clamping Textures")11( for more information about this situation.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 88.000 Tm
(Multiple Levels of Detail)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 17)Tj
ET
endstream
endobj
957 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
958 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im85
/Width 552
/Height 279
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.84)
>>
stream
endstream
endobj
960 0 obj
<<
/Length 3969
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 204.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
0.000 Tw
(Textured objects can be viewed, like any other objects in a scene, at different distances from the)Tj
0 -1.5 TD
(viewpoint. In a dynamic scene, as a textured object moves farther from the viewpoint, the texture map)Tj
T*
(must decrease in size along with the size of the projected image. To accomplish this, OpenGL has to)Tj
T*
(filter the texture map down to an appropriate size for mapping onto the object, without introducing)Tj
0 -1.6 TD
(visually disturbing artifacts. For example, to render a brick wall, you may use a large \(say 128)Tj
/F33 1 Tf
37.7 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(128 texel\))Tj
-38.2 -1.6 TD
(texture image when it is close to the viewer. But if the wall is moved farther away from the viewer until)Tj
0 -1.5 TD
(it appears on the screen as a single pixel, then the filtered textures may appear to change abruptly at)Tj
T*
(certain transition points.)Tj
0 -2.1 TD
(To avoid such artifacts, you can specify a series of prefiltered texture maps of decreasing resolutions,)Tj
0 -1.5 TD
(called )Tj
/F15 1 Tf
2.6 0 TD
(mipmaps)Tj
/F11 1 Tf
3.6 0 TD
[(, as shown in )-27(Figure 9-4)225(. The term )]TJ
/F15 1 Tf
14.1 0 TD
(mipmap)Tj
/F11 1 Tf
3.2 0 TD
( was coined by Lance Williams, when he)Tj
-23.5 -1.5 TD
(introduced the idea in his paper, ")Tj
/F15 1 Tf
13.5 0 TD
(Pyramidal Parametrics)Tj
/F11 1 Tf
9.4 0 TD
(" \(SIGGRAPH 1983 Proceedings\). )Tj
/F15 1 Tf
14.2 0 TD
(Mip)Tj
/F11 1 Tf
1.6 0 TD
( stands)Tj
-38.7 -1.5 TD
(for the Latin )Tj
/F15 1 Tf
5.2 0 TD
(multim im parvo)Tj
/F11 1 Tf
6.7 0 TD
(, meaning "many things in a small place." Mipmapping uses some clever)Tj
-11.9 -1.5 TD
(methods to pack image data into memory.)Tj
ET
Q
q
1 i 
124.000 487.230 423.000 -213.790 re
W n
/GS1 gs
q
423 0 0 214 124 273.23 cm
/Im85 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 261.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 9-4 )Tj
/F11 1 Tf
5.1 0 TD
(Mipmaps)Tj
-5.1 -2.1 TD
(When using mipmapping, OpenGL automatically determines which texture map to use based on the size)Tj
0 -1.5 TD
(\(in pixels\) of the object being mapped. With this approach, the level of detail in the texture map is)Tj
0 -1.7 TD
(appropriate for the image that's drawn on the screen)Tj
/F33 1 Tf
20.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(as the image of the object gets smaller, the size of)Tj
-21.9 -1.5 TD
(the texture map decreases. Mipmapping requires some extra computation and texture storage area;)Tj
T*
(however, when it's not used, textures that are mapped onto smaller objects might shimmer and flash as)Tj
T*
(the objects move.)Tj
0 -2.1 TD
(To use mipmapping, you must provide all sizes of your texture in powers of 2 between the largest size)Tj
0 -1.6 TD
(and a 1)Tj
/F33 1 Tf
2.9 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(1 map. For example, if your highest-resolution map is 64)Tj
/F33 1 Tf
22.8 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(16, you must also provide maps of)Tj
-26.8 -1.7 TD
(size 32)Tj
/F33 1 Tf
2.8 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(8, 16)Tj
/F33 1 Tf
2 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4, 8)Tj
/F33 1 Tf
1.5 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(2, 4)Tj
/F33 1 Tf
1.5 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(1, 2)Tj
/F33 1 Tf
1.5 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(1, and 1)Tj
/F33 1 Tf
3.1 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(1. The smaller maps are typically filtered and averaged-down)Tj
-15.8 -1.6 TD
(versions of the largest map in which each texel in a smaller texture is an average of the corresponding)Tj
0 -1.5 TD
(four texels in the larger texture. \(Since OpenGL doesn't require any particular method for calculating the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 18)Tj
ET
endstream
endobj
961 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im85 958 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
963 0 obj
<<
/Length 3235
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(smaller maps, the differently sized textures could be totally unrelated. In practice, unrelated textures)Tj
0 -1.5 TD
(would make the transitions between mipmaps extremely noticeable.\))Tj
0 -2.1 TD
(To specify these textures, call )Tj
/F15 1 Tf
12.2 0 TD
(glTexImage2D\(\) )Tj
/F11 1 Tf
6.8 0 TD
(once for each resolution of the texture map, with different)Tj
-19 -1.5 TD
(values for the )Tj
/F15 1 Tf
5.7 0 TD
(level)Tj
/F11 1 Tf
1.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(width)Tj
/F11 1 Tf
2.2 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(height)Tj
/F11 1 Tf
2.5 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(image)Tj
/F11 1 Tf
2.4 0 TD
( parameters. Starting with zero, )Tj
/F15 1 Tf
12.8 0 TD
(level)Tj
/F11 1 Tf
1.9 0 TD
( identifies which)Tj
-32.6 -1.6 TD
(texture in the series is specified; with the previous example, the largest texture of size 64)Tj
/F33 1 Tf
35.5 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(16 would be)Tj
-36 -1.7 TD
(declared with )Tj
/F15 1 Tf
5.7 0 TD
(level)Tj
/F11 1 Tf
1.9 0 TD
( = 0, the 32)Tj
/F33 1 Tf
4.5 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(8 texture with )Tj
/F15 1 Tf
5.8 0 TD
(level)Tj
/F11 1 Tf
1.9 0 TD
( = 1, and so on. In addition, for the mipmapped)Tj
-20.3 -1.6 TD
(textures to take effect, you need to choose one of the appropriate filtering methods described in the next)Tj
0 -1.5 TD
(section.)Tj
0 -2.2 TD
(Example 9-4)Tj
5.1 0 TD
( illustrates the use of a series of six texture maps decreasing in size from 32)Tj
/F33 1 Tf
30.2 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(32 to 1)Tj
/F33 1 Tf
2.8 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(1. This)Tj
-39.2 -1.6 TD
(program draws a rectangle that extends from the foreground far back in the distance, eventually)Tj
0 -1.5 TD
[(disappearing at a point, as shown in )-44("Plate 20" in Appendix I)72(.)0( Note that the texture coordinates range)]TJ
T*
(from 0.0 to 8.0 so 64 copies of the texture map are required to tile the rectangle, eight in each direction.)Tj
T*
(To illustrate how one texture map succeeds another, each map has a different color.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 9-4 )Tj
/F11 1 Tf
6.1 0 TD
(Mipmap Textures: mipmap.c)Tj
/F7 1 Tf
-6.1 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(GLubyte mipmapImage32[32][32][4];)Tj
0 -1.5 TD
(GLubyte mipmapImage16[16][16][4];)Tj
T*
(GLubyte mipmapImage8[8][8][4];)Tj
T*
(GLubyte mipmapImage4[4][4][4];)Tj
T*
(GLubyte mipmapImage2[2][2][4];)Tj
T*
(GLubyte mipmapImage1[1][1][4];)Tj
0 -3 TD
(static GLuint texName;)Tj
T*
(void makeImages\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i, j;)Tj
T*
(    )Tj
T*
(   for \(i = 0; i < 32; i++\) {)Tj
T*
(      for \(j = 0; j < 32; j++\) {)Tj
T*
(         mipmapImage32[i][j][0] = 255;)Tj
T*
(         mipmapImage32[i][j][1] = 255;)Tj
T*
(         mipmapImage32[i][j][2] = 0;)Tj
T*
(         mipmapImage32[i][j][3] = 255;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(   for \(i = 0; i < 16; i++\) {)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 19)Tj
ET
endstream
endobj
964 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
966 0 obj
<<
/Length 1762
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      for \(j = 0; j < 16; j++\) {)Tj
0 -1.5 TD
(         mipmapImage16[i][j][0] = 255;)Tj
T*
(         mipmapImage16[i][j][1] = 0;)Tj
T*
(         mipmapImage16[i][j][2] = 255;)Tj
T*
(         mipmapImage16[i][j][3] = 255;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(   for \(i = 0; i < 8; i++\) {)Tj
T*
(      for \(j = 0; j < 8; j++\) {)Tj
T*
(         mipmapImage8[i][j][0] = 255;)Tj
T*
(         mipmapImage8[i][j][1] = 0;)Tj
T*
(         mipmapImage8[i][j][2] = 0;)Tj
T*
(         mipmapImage8[i][j][3] = 255;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(   for \(i = 0; i < 4; i++\) {)Tj
T*
(      for \(j = 0; j < 4; j++\) {)Tj
T*
(         mipmapImage4[i][j][0] = 0;)Tj
T*
(         mipmapImage4[i][j][1] = 255;)Tj
T*
(         mipmapImage4[i][j][2] = 0;)Tj
T*
(         mipmapImage4[i][j][3] = 255;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(   for \(i = 0; i < 2; i++\) {)Tj
T*
(      for \(j = 0; j < 2; j++\) {)Tj
T*
(         mipmapImage2[i][j][0] = 0;)Tj
T*
(         mipmapImage2[i][j][1] = 0;)Tj
T*
(         mipmapImage2[i][j][2] = 255;)Tj
T*
(         mipmapImage2[i][j][3] = 255;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(   mipmapImage1[0][0][0] = 255;)Tj
T*
(   mipmapImage1[0][0][1] = 255;)Tj
T*
(   mipmapImage1[0][0][2] = 255;)Tj
T*
(   mipmapImage1[0][0][3] = 255;)Tj
T*
(})Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({    )Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glShadeModel\(GL_FLAT\);)Tj
0 -3 TD
(   glTranslatef\(0.0, 0.0, -3.6\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 20)Tj
ET
endstream
endobj
967 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
970 0 obj
<<
/Length 2358
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   makeImages\(\);)Tj
0 -1.5 TD
(   glPixelStorei\(GL_UNPACK_ALIGNMENT, 1\);)Tj
0 -3 TD
(   glGenTextures\(1, &texName\);)Tj
0 -1.5 TD
(   glBindTexture\(GL_TEXTURE_2D, texName\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,)Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, )Tj
T*
(                   GL_NEAREST_MIPMAP_NEAREST\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 0, GL_RGBA, 32, 32, 0,)Tj
T*
(                GL_RGBA, GL_UNSIGNED_BYTE, mipmapImage32\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 1, GL_RGBA, 16, 16, 0,)Tj
T*
(                GL_RGBA, GL_UNSIGNED_BYTE, mipmapImage16\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 2, GL_RGBA, 8, 8, 0,)Tj
T*
(                GL_RGBA, GL_UNSIGNED_BYTE, mipmapImage8\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 3, GL_RGBA, 4, 4, 0,)Tj
T*
(                GL_RGBA, GL_UNSIGNED_BYTE, mipmapImage4\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 4, GL_RGBA, 2, 2, 0,)Tj
T*
(                GL_RGBA, GL_UNSIGNED_BYTE, mipmapImage2\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 5, GL_RGBA, 1, 1, 0,)Tj
T*
(                GL_RGBA, GL_UNSIGNED_BYTE, mipmapImage1\);)Tj
0 -3 TD
(   glTexEnvf\(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL\);)Tj
0 -1.5 TD
(   glEnable\(GL_TEXTURE_2D\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glBindTexture\(GL_TEXTURE_2D, texName\);)Tj
T*
(   glBegin\(GL_QUADS\);)Tj
T*
(   glTexCoord2f\(0.0, 0.0\); glVertex3f\(-2.0, -1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(0.0, 8.0\); glVertex3f\(-2.0, 1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(8.0, 8.0\); glVertex3f\(2000.0, 1.0, -6000.0\);)Tj
T*
(   glTexCoord2f\(8.0, 0.0\); glVertex3f\(2000.0, -1.0, -6000.0\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 21)Tj
ET
endstream
endobj
971 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
973 0 obj
<<
/Length 2385
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
0 -1.5 TD
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluPerspective\(60.0, \(GLfloat\)w/\(GLfloat\)h, 1.0, 30000.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard \(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize\(500, 500\);)Tj
T*
(   glutInitWindowPosition\(50, 50\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Example 9-4)Tj
5.1 0 TD
( illustrates mipmapping by making each mipmap a different color so that it's obvious when)Tj
-5.1 -1.5 TD
(one map is replaced by another. In a real situation, you define mipmaps so that the transition is as smooth)Tj
T*
(as possible. Thus, the maps of lower resolution are usually filtered versions of an original,)Tj
T*
(high-resolution map. The construction of a series of such mipmaps is a software process, and thus isn't)Tj
T*
(part of OpenGL, which is simply a rendering library. However, since mipmap construction is such an)Tj
T*
(important operation, however, the OpenGL Utility Library contains two routines that aid in the)Tj
T*
(manipulation of images to be used as mipmapped textures.)Tj
0 -2.1 TD
(Assuming you have constructed the level 0, or highest-resolution map, the routines)Tj
/F15 1 Tf
0 -1.5 TD
(gluBuild1DMipmaps\(\))Tj
/F11 1 Tf
9.1 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluBuild2DMipmaps\(\))Tj
/F11 1 Tf
9.1 0 TD
( construct and define the pyramid of mipmaps down to)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 22)Tj
ET
endstream
endobj
974 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
975 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im86
/Width 486
/Height 147
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.85)
>>
stream
endstream
endobj
977 0 obj
<<
/Length 3904
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(a resolution of 1 )Tj
/F33 1 Tf
6.8 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
( 1 \(or 1, for one-dimensional texture maps\). If your original image has dimensions that)Tj
-7.3 -1.6 TD
(are not exact powers of 2, )Tj
/F15 1 Tf
10.6 0 TD
(gluBuild*DMipmaps\(\) )Tj
/F11 1 Tf
9.3 0 TD
(helpfully scales the image to the nearest power of 2.)Tj
/F15 1 Tf
-19.9 -2.1 TD
[(int )6(gluBuild1DMipmaps)-10(\(GLenum )27(target)-11(, GLint )-16(components)-22(, GLint)34( width)-27(,)]TJ
0 -1.1 TD
[(GLenum )-6(format)-33(, GLenum )-6(type)66(, void *)-28(data)-22(\);)]TJ
T*
[(int )6(gluBuild2DMipmaps)-10(\(GLenum )27(target)-11(, GLint )-16(components)-22(, GLint)34( width)-27(,)]TJ
T*
[(GLint )-16(height, GLenum )-6(format)67(, GLenum )-6(type)-34(,)]TJ
T*
[(void *)-28(data)-22(\);)]TJ
1.8 -1.5 TD
[(Constructs a series of mipmaps and calls glTexImage*D)44(\(\) to load the images. The parameters for)]TJ
T*
[(target)-11(, components)-22(, width)23(, height, format)-33(, type)66(, and )-50(data)-22( are exactly the same as those for)]TJ
T*
[(glTexImage1D\(\))10( and glTexImage2D\(\))10(. A value of 0 is returned if all the mipmaps are constructed)]TJ
T*
(successfully; otherwise, a GLU error code is returned.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 536.000 Tm
(Filtering)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 514.000 Tm
(Texture maps are square or rectangular, but after being mapped to a polygon or surface and transformed)Tj
T*
(into screen coordinates, the individual texels of a texture rarely correspond to individual pixels of the)Tj
T*
(final screen image. Depending on the transformations used and the texture mapping applied, a single)Tj
T*
(pixel on the screen can correspond to anything from a tiny portion of a texel \(magnification\) to a large)Tj
T*
[(collection of texels \(minification\), as shown in )-11(Figure 9-5)225(. In either case, it's unclear exactly which texel)]TJ
T*
(values should be used and how they should be averaged or interpolated. Consequently, OpenGL allows)Tj
T*
(you to specify any of several filtering options to determine these calculations. The options provide)Tj
T*
(different trade-offs between speed and image quality. Also, you can specify  independently the filtering)Tj
T*
(methods for magnification and minification.)Tj
ET
Q
/GS1 gs
q
423 0 0 128 124 251.32 cm
/Im86 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 239.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 9-5 )Tj
/F11 1 Tf
5.1 0 TD
(Texture Magnification and Minification)Tj
-5.1 -2.1 TD
(In some cases, it isn't obvious whether magnification or minification is called for. If the mipmap needs to)Tj
0 -1.5 TD
(be stretched \(or shrunk\) in both the )Tj
/F15 1 Tf
14.3 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( directions, then magnification \(or minification\) is needed. If)Tj
-17.1 -1.5 TD
(the mipmap needs to be stretched in one direction and shrunk in the other, OpenGL makes a choice)Tj
T*
(between magnification and minification that in most cases gives the best result possible. It's best to try to)Tj
T*
[(avoid these situations by using texture coordinates that map without such distortion. \(See )-9("Computing)]TJ
T*
[(Appropriate Texture Coordinates.")35(\))]TJ
0 -2.1 TD
(The following lines are examples of how to use )Tj
/F15 1 Tf
19.2 0 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
( to specify the magnification and)Tj
-26.9 -1.5 TD
(minification filtering methods:)Tj
/F7 1 Tf
0 -2.1 TD
(glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 23)Tj
ET
endstream
endobj
978 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im86 975 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
980 0 obj
<<
/Length 4713
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(                GL_NEAREST\); )Tj
0 -1.5 TD
(glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, )Tj
T*
(                GL_NEAREST\);)Tj
/F11 1 Tf
0 -2.1 TD
(The first argument to )Tj
/F15 1 Tf
8.7 0 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
( is either GL_TEXTURE_2D or GL_TEXTURE_1D, depending)Tj
-16.4 -1.5 TD
(on whether you're working with two- or one-dimensional textures. For the purposes of this discussion,)Tj
T*
(the second argument is either GL_TEXTURE_MAG_FILTER or GL_TEXTURE_MIN_FILTER to)Tj
T*
(indicate whether you're specifying the filtering method for magnification or minification. The third)Tj
T*
[(argument specifies the filtering method; )50(Table 9-1)191( lists the possible values.)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 589.450 m
467.000 589.450 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 582.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Parameter)-16483(Values)]TJ
ET
Q
124.000 575.930 m
467.000 575.930 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 568.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_TEXTURE_MAG_FILTER)-5888(GL_NEAREST or GL_LINEAR)]TJ
0 -1.4444 TD
[(GL_TEXTURE_MIN_FILTER)-6277(GL_NEAREST, GL_LINEAR,)]TJ
19 -1.3333 TD
(GL_NEAREST_MIPMAP_NEAREST,)Tj
T*
(GL_NEAREST_MIPMAP_LINEAR,)Tj
T*
(GL_LINEAR_MIPMAP_NEAREST, or)Tj
T*
(GL_LINEAR_MIPMAP_LINEAR)Tj
ET
Q
124.000 499.320 m
467.010 499.320 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 483.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 9-1 )Tj
/F11 1 Tf
4.6 0 TD
(Filtering Methods for Magnification and Minification)Tj
-4.6 -2.1 TD
(If you choose GL_NEAREST, the texel with coordinates nearest the center of the pixel is used for both)Tj
0 -1.5 TD
(magnification and minification. This can result in aliasing artifacts \(sometimes severe\). If you choose)Tj
0 -1.6 TD
(GL_LINEAR, a weighted linear average of the 2)Tj
/F33 1 Tf
19.6 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(2 array of texels that lie nearest to the center of the)Tj
-20.1 -1.6 TD
(pixel is used, again for both magnification and minification. When the texture coordinates are near the)Tj
T*
(edge of the texture map, the nearest 2)Tj
/F33 1 Tf
15 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(2 array of texels might include some that are outside the texture)Tj
-15.5 -1.6 TD
(map. In these cases, the texel values used depend on whether GL_REPEAT or GL_CLAMP is in effect)Tj
0 -1.5 TD
[(and whether you've assigned a border for the texture. \(See )35("Using a Texture's Borders.")-52(\) GL_NEAREST)]TJ
T*
(requires less computation than GL_LINEAR and therefore might execute more quickly, but)Tj
T*
(GL_LINEAR provides smoother results.)Tj
0 -2.1 TD
(With magnification, even if you've supplied mipmaps, the largest texture map \()Tj
/F15 1 Tf
31.9 0 TD
(level)Tj
/F11 1 Tf
1.8 0 TD
( = 0\) is always used.)Tj
-33.7 -1.5 TD
(With minification, you can choose a filtering method that uses the most appropriate one or two mipmaps,)Tj
T*
(as described in the next paragraph. \(If GL_NEAREST or GL_LINEAR is specified with minification, the)Tj
T*
(largest texture map is used.\))Tj
0 -2.1 TD
[(As shown in )-49(Table 9-1)]TJ
9.1 0 TD
(, four additional filtering choices are available when minifying with mipmaps.)Tj
-9.1 -1.5 TD
(Within an individual mipmap, you can choose the nearest texel value with)Tj
T*
(GL_NEAREST_MIPMAP_NEAREST, or you can interpolate linearly by specifying)Tj
T*
(GL_LINEAR_MIPMAP_NEAREST. Using the nearest texels is faster but yields less desirable results.)Tj
T*
(The particular mipmap chosen is a function of the amount of minification required, and there's a cutoff)Tj
T*
(point from the use of one particular mipmap to the next. To avoid a sudden transition, use)Tj
T*
(GL_NEAREST_MIPMAP_LINEAR or GL_LINEAR_MIPMAP_LINEAR to linearly interpolate texel)Tj
T*
(values from the two nearest best choices of mipmaps. GL_NEAREST_MIPMAP_LINEAR selects the)Tj
T*
(nearest texel in each of the two maps and then interpolates linearly between these two values.)Tj
T*
(GL_LINEAR_MIPMAP_LINEAR uses linear interpolation to compute the value in each of two maps)Tj
T*
(and then interpolates linearly between these two values. As you might expect,)Tj
T*
(GL_LINEAR_MIPMAP_LINEAR generally produces the smoothest results, but it requires the most)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 24)Tj
ET
endstream
endobj
981 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
983 0 obj
<<
/Length 4195
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(computation and therefore might be the slowest.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 677.000 Tm
(Texture Objects)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 655.000 Tm
(Texture objects are an important new feature in release 1.1 of OpenGL. A texture object stores texture)Tj
0 -1.5 TD
(data and makes it readily available. You can now control many textures and go back to textures that have)Tj
T*
(been previously loaded into your texture resources. Using texture objects is usually the fastest way to)Tj
T*
(apply textures, resulting in big performance gains, because it is almost always much faster to bind \(reuse\))Tj
T*
(an existing texture object than it is to reload a texture image using )Tj
/F15 1 Tf
26.6 0 TD
(glTexImage*D\(\))Tj
/F11 1 Tf
6.6 0 TD
(.)Tj
-33.2 -2.1 TD
(Also, some implementations support a limited )Tj
/F13 1 Tf
18.7 0 TD
(working set)Tj
/F11 1 Tf
5 0 TD
( of high-performance textures. You can use)Tj
-23.7 -1.5 TD
(texture objects to load your most often used textures into this limited area.)Tj
0 -2.1 TD
(To use texture objects for your texture data, take these steps.)Tj
T*
[(1.)-1050(Generate texture names.)]TJ
T*
[(2.)-1050(Initially bind \(create\) texture objects to texture data, including the image arrays and texture)]TJ
1.8 -1.5 TD
(properties.)Tj
-1.8 -2.1 TD
[(3.)-1050(If your implementation supports a working set of high-performance textures, see if you have enough)]TJ
1.8 -1.5 TD
(space for all your texture objects. If there isn't enough space, you may wish to establish priorities for)Tj
T*
(each texture object so that more often used textures stay in the working set.)Tj
-1.8 -2.1 TD
[(4.)-1050(Bind and rebind texture objects, making their data currently available for rendering textured models.)]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 375.000 Tm
(Naming A Texture Object)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 354.000 Tm
(Any nonzero unsigned integer may be used as a texture name. To avoid accidentally reusing names,)Tj
0 -1.5 TD
(consistently use )Tj
/F15 1 Tf
6.6 0 TD
(glGenTextures\(\))Tj
/F11 1 Tf
6.6 0 TD
( to provide unused texture names.)Tj
/F15 1 Tf
-13.2 -2.1 TD
0.028 Tw
[(void glGenTextures)-11(\(GLsizei )67(n, )28(GLuint )12(*textureNames\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Returns )-39(n currently unused names for texture objects in the array )56(textureNames. The names returned)]TJ
T*
[(in )28(textureNames do not have to be a contiguous set of integers.)]TJ
T*
[(The names in )-16(textureNames are marked as used, but they acquire texture state and dimensionality)]TJ
T*
(\(1D or 2D\) only when they are first bound.)Tj
T*
[(Zero is a reserved texture name and is never returned as a texture name by glGenTextures\(\))-45(.)]TJ
-1.8 -2.1 TD
(glIsTexture\(\))Tj
/F11 1 Tf
5.2 0 TD
( determines if a texture name is actually in use. If a texture name was returned by)Tj
/F15 1 Tf
-5.2 -1.5 TD
(glGenTextures\(\))Tj
/F11 1 Tf
6.6 0 TD
( but has not yet been bound \(calling )Tj
/F15 1 Tf
14.5 0 TD
(glBindTexture\(\))Tj
/F11 1 Tf
6.4 0 TD
( with the name at least once\), then)Tj
/F15 1 Tf
-27.5 -1.5 TD
(glIsTexture\(\))Tj
/F11 1 Tf
5.2 0 TD
( returns GL_FALSE.)Tj
/F15 1 Tf
-5.2 -2.1 TD
0.049 Tw
[(GLboolean glIsTexture)56(\(GLuint )66(textureName)11(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Returns GL_TRUE if textureName)11( is the name of a texture that has been bound and has not been)]TJ
T*
[(subsequently deleted. Returns GL_FALSE if )-10(textureName)11( is zero or )-22(textureName)11( is a nonzero value)]TJ
T*
(that is not the name of an existing texture.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 97.000 Tm
(Creating and Using Texture Objects)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 75.000 Tm
(The same routine, )Tj
/F15 1 Tf
7.4 0 TD
(glBindTexture\(\))Tj
/F11 1 Tf
6.4 0 TD
(, both creates and uses texture objects. When a texture name is initially)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 25)Tj
ET
endstream
endobj
984 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
986 0 obj
<<
/Length 3908
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(bound \(used with )Tj
/F15 1 Tf
7.2 0 TD
(glBindTexture\(\))Tj
/F11 1 Tf
6.4 0 TD
(\), a new texture object is created with default values for the texture)Tj
-13.6 -1.5 TD
(image and texture properties. Subsequent calls to )Tj
/F15 1 Tf
19.9 0 TD
(glTexImage*\(\))Tj
/F11 1 Tf
5.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glTexSubImage*\(\))Tj
/F11 1 Tf
7.4 0 TD
(,)Tj
/F15 1 Tf
-33.7 -1.5 TD
(glCopyTexImage*\(\))Tj
/F11 1 Tf
8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glCopyTexSubImage*\(\))Tj
/F11 1 Tf
9.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glPrioritizeTextures\(\))Tj
/F11 1 Tf
8.7 0 TD
( store data in)Tj
-37.1 -1.5 TD
(the texture object. The texture object may contain a texture image and associated mipmap images \(if)Tj
T*
(any\), including associated data such as width, height, border width, internal format, resolution of)Tj
T*
(components, and texture properties. Saved texture properties include minification and magnification)Tj
T*
(filters, wrapping modes, border color, and texture priority.)Tj
0 -2.1 TD
(When a texture object is subsequently bound once again, its data becomes the current texture state. \(The)Tj
0 -1.5 TD
(state of the previously bound texture is replaced.\))Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glBindTexture)23(\(GLenum )55(target)-11(, )28(GLuint )12(textureName)11(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(glBindTexture\(\))-11( does three things. When using )28(textureName)11( of an unsigned integer other than zero)]TJ
T*
(for the first time, a new texture object is created and assigned that name. When binding to a)Tj
T*
[(previously created texture object, that texture object becomes active. When binding to a )-41(textureName)]TJ
T*
(value of zero, OpenGL stops using texture objects and returns to the unnamed default texture.)Tj
T*
[(When a texture object is initially bound \(that is, created\), it assumes the dimensionality of target)-11(,)]TJ
T*
(which is either GL_TEXTURE_1D or GL_TEXTURE_2D. Immediately upon its initial binding, the)Tj
T*
(state of texture object is equivalent to the state of the default GL_TEXTURE_1D or)Tj
T*
(GL_TEXTURE_2D \(depending upon its dimensionality\) at the initialization of OpenGL. In this)Tj
T*
(initial state, texture properties such as minification and magnification filters, wrapping modes,)Tj
T*
(border color, and texture priority are set to their default values.)Tj
/F11 1 Tf
-1.8 -2.1 TD
0.017 Tw
[(In Example )17(9-5)]TJ
6.2 0 TD
0.000 Tw
(, two texture objects are created in )Tj
/F15 1 Tf
14 0 TD
(init\(\))Tj
/F11 1 Tf
2 0 TD
(. In )Tj
/F15 1 Tf
1.6 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
(, each texture object is used to render)Tj
-27.4 -1.5 TD
(a different four-sided polygon.)Tj
/F27 1 Tf
0 -2 TD
(Example 9-5 )Tj
/F11 1 Tf
6.1 0 TD
(Binding Texture Objects: texbind.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#define checkImageWidth 64)Tj
0 -1.5 TD
(#define checkImageHeight 64)Tj
T*
(static GLubyte checkImage[checkImageHeight][checkImageWidth][4];)Tj
T*
(static GLubyte otherImage[checkImageHeight][checkImageWidth][4];)Tj
0 -3 TD
(static GLuint texName[2];)Tj
T*
(void makeCheckImages\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i, j, c;)Tj
T*
(    )Tj
T*
(   for \(i = 0; i < checkImageHeight; i++\) {)Tj
T*
(      for \(j = 0; j < checkImageWidth; j++\) {)Tj
T*
(         c = \(\(\(\(i&0x8\)==0\)^\(\(j&0x8\)\)==0\)\)*255;)Tj
T*
(         checkImage[i][j][0] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][1] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][2] = \(GLubyte\) c;)Tj
T*
(         checkImage[i][j][3] = \(GLubyte\) 255;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 26)Tj
ET
endstream
endobj
987 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
989 0 obj
<<
/Length 2269
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(         c = \(\(\(\(i&0x10\)==0\)^\(\(j&0x10\)\)==0\)\)*255;)Tj
0 -1.5 TD
(         otherImage[i][j][0] = \(GLubyte\) c;)Tj
T*
(         otherImage[i][j][1] = \(GLubyte\) 0;)Tj
T*
(         otherImage[i][j][2] = \(GLubyte\) 0;)Tj
T*
(         otherImage[i][j][3] = \(GLubyte\) 255;)Tj
T*
(      })Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({    )Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel\(GL_FLAT\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
0 -3 TD
(   makeCheckImages\(\);)Tj
0 -1.5 TD
(   glPixelStorei\(GL_UNPACK_ALIGNMENT, 1\);)Tj
0 -3 TD
(   glGenTextures\(2, texName\);)Tj
0 -1.5 TD
(   glBindTexture\(GL_TEXTURE_2D, texName[0]\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,)Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,)Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 0, GL_RGBA, checkImageWidth,)Tj
T*
(                checkImageHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE,)Tj
T*
(                checkImage\);)Tj
0 -3 TD
(   glBindTexture\(GL_TEXTURE_2D, texName[1]\);)Tj
0 -1.5 TD
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,)Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,)Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexEnvf\(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL\);   )Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 0, GL_RGBA, checkImageWidth, )Tj
T*
(                checkImageHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, )Tj
T*
(                otherImage\);)Tj
T*
(   glEnable\(GL_TEXTURE_2D\);)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 27)Tj
ET
endstream
endobj
990 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
992 0 obj
<<
/Length 3318
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 697.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glBindTexture\(GL_TEXTURE_2D, texName[0]\);)Tj
T*
(   glBegin\(GL_QUADS\);)Tj
T*
(   glTexCoord2f\(0.0, 0.0\); glVertex3f\(-2.0, -1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(0.0, 1.0\); glVertex3f\(-2.0, 1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(1.0, 1.0\); glVertex3f\(0.0, 1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(1.0, 0.0\); glVertex3f\(0.0, -1.0, 0.0\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   glBindTexture\(GL_TEXTURE_2D, texName[1]\);)Tj
T*
(   glBegin\(GL_QUADS\);)Tj
T*
(   glTexCoord2f\(0.0, 0.0\); glVertex3f\(1.0, -1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(0.0, 1.0\); glVertex3f\(1.0, 1.0, 0.0\);)Tj
T*
(   glTexCoord2f\(1.0, 1.0\); glVertex3f\(2.41421, 1.0, -1.41421\);)Tj
T*
(   glTexCoord2f\(1.0, 0.0\); glVertex3f\(2.41421, -1.0, -1.41421\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.2 TD
(Whenever a texture object is bound once again, you may edit the contents of the bound texture object.)Tj
0 -1.5 TD
(Any commands you call that change the texture image or other properties change the contents of the)Tj
T*
(currently bound texture object as well as the current texture state.)Tj
0 -2.1 TD
0.017 Tw
[(In Example )17(9-5)]TJ
6.2 0 TD
0.000 Tw
(, after completion of )Tj
/F15 1 Tf
8.4 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
(, you are still bound to the texture named by the contents of)Tj
/F15 1 Tf
-18.2 -1.5 TD
(texName[1])Tj
/F11 1 Tf
4.8 0 TD
(. Be careful that you don't call a spurious texture routine that changes the data in that texture)Tj
-4.8 -1.5 TD
(object.)Tj
0 -2.1 TD
(When using mipmaps, all related mipmaps of a single texture image must be put into a single texture)Tj
0 -1.5 TD
[(object. In )27(Example 9-4)170(, levels 0\2555 of a mipmapped texture image are put into a single texture object)]TJ
T*
(named )Tj
/F15 1 Tf
2.9 0 TD
(texName)Tj
/F11 1 Tf
3.5 0 TD
(.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 245.000 Tm
(Cleaning Up Texture Objects)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 223.000 Tm
(As you bind and unbind texture objects, their data still sits around somewhere among your texture)Tj
0 -1.5 TD
(resources. If texture resources are limited, deleting textures may be one way to free up resources.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glDeleteTextures)33(\(GLsizei )39(n, const GLuint )-54(*textureNames\);)]TJ
1.8 -1.5 TD
[(Deletes )49(n texture objects, named by elements in the array )-57(textureNames. The freed texture names)]TJ
T*
[(may now be reused \(for example, by )21(glGenTextures\(\))-45(\).)]TJ
T*
(If a texture that is currently bound is deleted, the binding reverts to the default texture, as if)Tj
T*
[(glBindTexture\(\))-11( were called with zero for the value of )18(textureName)11(. Attempts to delete nonexistent)]TJ
T*
(texture names or the texture name of zero are ignored without generating an error.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 83.000 Tm
(A Working Set of Resident Textures)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 28)Tj
ET
endstream
endobj
993 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
995 0 obj
<<
/Length 4839
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Some OpenGL implementations support a working set of high-performance textures, which are said to be)Tj
0 -1.5 TD
(resident. Typically, these implementations have specialized hardware to perform texture operations and a)Tj
T*
(limited hardware cache to store texture images. In this case, using texture objects is recommended,)Tj
T*
(because you are able to load many textures into the working set and then control them.)Tj
0 -2.1 TD
(If all the textures required by the application exceed the size of the cache, some textures cannot be)Tj
0 -1.5 TD
(resident. If you want to find out if a single texture is currently resident, bind its object, and then use)Tj
/F15 1 Tf
T*
(glGetTexParameter*v\(\))Tj
/F11 1 Tf
9.6 0 TD
( to find out the value associated with the GL_TEXTURE_RESIDENT state. If)Tj
-9.6 -1.5 TD
(you want to know about the texture residence status of many textures, use )Tj
/F15 1 Tf
29.8 0 TD
(glAreTexturesResident\(\))Tj
/F11 1 Tf
9.7 0 TD
(.)Tj
/F15 1 Tf
-39.5 -2.1 TD
0.049 Tw
[(GLboolean glAreTexturesResident)11(\(GLsizei )88(n, )49(const)]TJ
0 -1.1 TD
0.000 Tw
[(GLuint)34(*textureNames, GLboolean )-49(*residences)22(\);)]TJ
1.8 -1.5 TD
[(Queries the texture residence status of the )-17(n texture objects, named in the array textureNames.)]TJ
T*
[(residences)21( is an array in which texture residence status is returned for the corresponding texture)]TJ
T*
[(objects in the array )-44(textureNames. If all the named textures in textureNames are resident, the)]TJ
T*
[(glAreTexturesResident\(\))-23( function returns GL_TRUE, and the contents of the array )75(residences)-79( are)]TJ
T*
[(undisturbed. If any texture in )-11(textureNames is not resident, then )-10(glAreTexturesResident\(\))-23( returns)]TJ
T*
[(GL_FALSE and the elements in )18(residences)21(, which correspond to nonresident texture objects in)]TJ
T*
(textureNames, are also set to GL_FALSE.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(Note that )Tj
/F15 1 Tf
3.9 0 TD
(glAreTexturesResident\(\))Tj
/F11 1 Tf
9.8 0 TD
( returns the current residence status. Texture resources are very)Tj
-13.7 -1.5 TD
(dynamic, and texture residence status may change at any time. Some implementations cache textures)Tj
T*
(when they are first used. It may be necessary to draw with the texture before checking residency.)Tj
0 -2.1 TD
(If your OpenGL implementation does not establish a working set of high-performance textures, then the)Tj
0 -1.5 TD
(texture objects are always considered resident. In that case, )Tj
/F15 1 Tf
23.9 0 TD
(glAreTexturesResident\(\))Tj
/F11 1 Tf
9.8 0 TD
( always returns)Tj
-33.7 -1.5 TD
(GL_TRUE and basically provides no information.)Tj
/F27 1 Tf
0 -3 TD
(Texture Residence Strategies)Tj
/F11 1 Tf
0 -2.1 TD
(If you can create a working set of textures and want to get the best texture performance possible, you)Tj
0 -1.5 TD
(really have to know the specifics of your implementation and application. For example, with a visual)Tj
T*
(simulation or video game, you have to maintain performance in all situations. In that case, you should)Tj
T*
(never access a nonresident texture. For these applications, you want to load up all your textures upon)Tj
T*
(initialization and make them all resident. If you don't have enough texture memory available, you may)Tj
T*
(need to reduce the size, resolution, and levels of mipmaps for your texture images, or you may use)Tj
/F15 1 Tf
T*
(glTexSubImage*\(\))Tj
/F11 1 Tf
7.4 0 TD
( to repeatedly reuse the same texture memory.)Tj
-7.4 -2.1 TD
(For applications that create textures "on the fly," nonresident textures may be unavoidable. If some)Tj
0 -1.5 TD
(textures are used more frequently than others, you may assign a higher priority to those texture objects to)Tj
T*
(increase their likelihood of being resident. Deleting texture objects also frees up space. Short of that,)Tj
T*
(assigning a lower priority to a texture object may make it first in line for being moved out of the working)Tj
T*
(set, as resources dwindle. )Tj
/F15 1 Tf
10.4 0 TD
(glPrioritizeTextures\(\))Tj
/F11 1 Tf
8.8 0 TD
( is used to assign priorities to texture objects.)Tj
/F15 1 Tf
-19.2 -2.1 TD
[(void )-28(glPrioritizeTextures)57(\(GLsizei )-61(n, const GLuint )46(*textureNames,)]TJ
0 -1.1 TD
[(const GLclampf )12(*priorities)23(\);)]TJ
1.8 -1.5 TD
[(Assigns the )-21(n texture objects, named in the array textureNames, the texture residence priorities in)]TJ
T*
[(the corresponding elements of the array )-22(priorities)23(. The priority values in the array )35(priorities)-77( are)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 29)Tj
ET
endstream
endobj
996 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
998 0 obj
<<
/Length 4706
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(clamped to the range [0.0, 1.0] before being assigned. Zero indicates the lowest priority; these)Tj
0 -1.5 TD
(textures are least likely to be resident. One indicates the highest priority.)Tj
T*
[(glPrioritizeTextures\(\))23( does not require that any of the textures in textureNames be bound. However,)]TJ
T*
(the priority might not have any effect on a texture object until it is initially bound.)Tj
-1.8 -2.1 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
( also may be used to set a single texture's priority, but only if the texture is currently)Tj
-7.7 -1.5 TD
(bound. In fact, use of )Tj
/F15 1 Tf
8.7 0 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
( is the only way to set the priority of a default texture.)Tj
-16.4 -2.1 TD
(If texture objects have equal priority, typical implementations of OpenGL apply a least recently used)Tj
0 -1.5 TD
(\(LRU\) strategy to decide which texture objects to move out of the working set. If you know that your)Tj
T*
(OpenGL implementation has this behavior, then having equal priorities for all texture objects creates a)Tj
T*
(reasonable LRU system for reallocating texture resources.)Tj
0 -2.1 TD
(If your implementation of OpenGL doesn't use an LRU strategy for texture objects of equal priority \(or if)Tj
0 -1.5 TD
(you don't know how it decides\), you can implement your own LRU strategy by carefully maintaining the)Tj
T*
(texture object priorities. When a texture is used \(bound\), you can maximize its priority, which reflects its)Tj
T*
(recent use. Then, at regular \(time\) intervals, you can degrade the priorities of all texture objects.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Fragmentation of texture memory can be a problem, especially if you're deleting and creating lots)Tj
-2.8 -1.4 TD
(of new textures. Although it is even possible that you can load all the texture objects into a working set)Tj
0 -1.5 TD
(by binding them in one sequence, binding them in a different sequence may leave some textures)Tj
0 -1.4 TD
(nonresident.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 399.000 Tm
(Texture Functions)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 376.000 Tm
(In all the examples so far in this chapter, the values in the texture map have been used directly as colors)Tj
0 -1.5 TD
(to be painted on the surface being rendered. You can also use the values in the texture map to modulate)Tj
T*
(the color that the surface would be rendered without texturing, or to blend the color in the texture map)Tj
T*
(with the original color of the surface. You choose one of four texturing functions by supplying the)Tj
T*
(appropriate arguments to )Tj
/F15 1 Tf
10.2 0 TD
(glTexEnv*\(\))Tj
/F11 1 Tf
5 0 TD
(.)Tj
/F15 1 Tf
-15.2 -2.1 TD
[(void )-28(glTexEnv)77({if}\(GLenum )-16(target)-11(, GLenum )-6(pname)-34(, TYPE)34(param)11(\);)]TJ
0 -1.1 TD
[(void )-28(glTexEnv)77({if})-44(v)44(\(GLenum )-73(target)-11(, GLenum )-6(pname)66(, TYPE)-66( *)50(param)11(\);)]TJ
1.8 -1.5 TD
[(Sets the current texturing function. )-32(target)-11( must be GL_TEXTURE_ENV. If )91(pname)-34( is)]TJ
T*
[(GL_TEXTURE_ENV_MODE, )34(param )-39(can be GL_DECAL, GL_REPLACE, GL_MODULATE, or)]TJ
T*
(GL_BLEND, to specify how texture values are to be combined with the color values of the fragment)Tj
T*
[(being processed. If )33(pname)-34( is GL_TEXTURE_ENV_COLOR, )-8(param)11( is an array of four floating-point)]TJ
T*
(values representing R, G, B, and A components. These values are used only if the GL_BLEND)Tj
T*
(texture function has been specified as well.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The combination of the texturing function and the base internal format determine how the textures are)Tj
0 -1.5 TD
(applied for each component of the texture. The texturing function operates on selected components of the)Tj
T*
(texture and the color values that would be used with no texturing. \(Note that the selection is performed)Tj
T*
(after the pixel-transfer function has been applied.\) Recall that when you specify your texture map with)Tj
/F15 1 Tf
T*
(glTexImage*D\(\))Tj
/F11 1 Tf
6.6 0 TD
(, the third argument is the internal format to be selected for each texel.)Tj
-6.6 -2.1 TD
[(Table 9-2)191( and )44(Table 9-3)191( show how the texturing function and base internal format determine the)]TJ
0 -1.5 TD
(texturing application formula used for each component of the texture. There are six base internal formats)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 30)Tj
ET
endstream
endobj
999 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1002 0 obj
<<
/Length 7716
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(\(the letters in parentheses represent their values in the tables\): GL_ALPHA \(A\), GL_LUMINANCE \(L\),)Tj
0 -1.5 TD
(GL_LUMINANCE_ALPHA \(L and A\), GL_INTENSITY \(I\), GL_RGB \(C\), and GL_RGBA \(C and A\).)Tj
T*
(Other internal formats specify desired resolutions of the texture components and can be matched to one)Tj
T*
(of these six base internal formats.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 654.310 m
472.000 654.310 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 647.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Base Internal Format)-6051(Replace Texture Function)-1398(Modulate Texture Function)]TJ
ET
Q
124.000 640.790 m
472.000 640.790 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 633.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_ALPHA)-9056(C = C)]TJ
16.6667 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(,)Tj
-2.7778 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(t)Tj
9.5556 1.5556 TD
(C = C)Tj
2.4444 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(,)Tj
-2.7778 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(A)Tj
0.6667 -0.2222 TD
(t)Tj
-29.8889 -1.4444 TD
[(GL_LUMINANCE)-6389(C = L)]TJ
16.5556 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-2.6667 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
9.5556 1.5556 TD
(C = C)Tj
2.4444 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(L)Tj
0.5556 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-3.6667 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
-28.8889 -1.4444 TD
[(GL_LUMINANCE_ALPHA)-2555(C = L)]TJ
16.5556 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-2.6667 -1.4444 TD
(A = A)Tj
2.5556 -0.2222 TD
(t)Tj
9.5556 1.6667 TD
(C = C)Tj
2.4444 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(L)Tj
0.5556 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-3.6667 -1.4444 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(A)Tj
0.6667 -0.2222 TD
(t)Tj
-29.8889 -1.4444 TD
[(GL_INTENSITY)-7167(C = I)]TJ
16.3333 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-2.3333 -1.3333 TD
(A = I)Tj
2.1111 -0.2222 TD
(t)Tj
10 1.5556 TD
(C = C)Tj
2.4444 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(I)Tj
0.3333 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-3.3333 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(I)Tj
0.3333 -0.2222 TD
(t)Tj
-29.5556 -1.4444 TD
[(GL_RGB)-10333(C = C)]TJ
16.6667 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-2.6667 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
9.5556 1.5555 TD
(C = C)Tj
2.4444 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(C)Tj
0.6667 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-3.6667 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
-28.8889 -1.4445 TD
[(GL_RGBA)-9611(C = C)]TJ
16.6667 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-2.6667 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(t)Tj
9.5556 1.5556 TD
(C = C)Tj
2.4444 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(C)Tj
0.6667 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-3.6667 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(A)Tj
0.6667 -0.2222 TD
(t)Tj
ET
Q
124.000 475.740 m
472.010 475.740 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 460.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 9-2 )Tj
/F11 1 Tf
4.6 0 TD
(Replace and Modulate Texture Function)Tj
ET
Q
124.000 442.230 m
472.000 442.230 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 435.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Base Internal Format)-6051(Decal Texture Function)-2565(Blend Texture Function)]TJ
ET
Q
124.000 428.710 m
472.000 428.710 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 421.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_ALPHA)-9056(undefined)-8112(C = C)]TJ
28.7778 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(,)Tj
-2.7778 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(A)Tj
0.6667 -0.2222 TD
(t)Tj
-29.8889 -1.4444 TD
[(GL_LUMINANCE)-6389(undefined)-8112(C = C)]TJ
28.7778 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(\(1-L)Tj
1.7778 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(\) + C)Tj
2.1111 -0.2222 TD
(c)Tj
0.4445 0.2222 TD
(L)Tj
0.5555 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-8.2222 -1.4444 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
-28.8889 -1.4444 TD
[(GL_LUMINANCE_ALPHA)-2555(undefined)-8112(C = C)]TJ
28.7778 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(\(1-L)Tj
1.7778 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(\) + C)Tj
2.1111 -0.2222 TD
(c)Tj
0.4445 0.2222 TD
(L)Tj
0.5555 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-8.2222 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(A)Tj
0.6667 -0.2222 TD
(t)Tj
-29.8889 -1.4444 TD
[(GL_INTENSITY)-7167(undefined)-8112(C = C)]TJ
28.7778 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(\(1-I)Tj
1.4444 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(\) + C)Tj
2 -0.2222 TD
(c)Tj
0.4444 0.2222 TD
(I)Tj
0.3333 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-7.6667 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(\(1-I)Tj
1.4445 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(\) + A)Tj
2.1111 -0.2222 TD
(c)Tj
0.4444 0.2222 TD
(I)Tj
0.3333 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-34.1111 -1.6667 TD
[(GL_RGB)-10333(C = C)]TJ
16.6667 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-2.6667 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
9.5556 1.5556 TD
(C = C)Tj
2.4444 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(\(1-C)Tj
1.7778 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(\) + C)Tj
2 -0.2222 TD
(c)Tj
0.4445 0.2222 TD
(C)Tj
0.6667 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-8.3333 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
-28.8889 -1.4444 TD
[(GL_RGBA)-9611(C = C)]TJ
16.6667 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(\(1-A)Tj
1.8889 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(\) + C)Tj
2.1111 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(A)Tj
0.7778 -0.2222 TD
(t)Tj
0.2222 0.2222 TD
(,)Tj
-8.2222 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
9.5556 1.5556 TD
(C = C)Tj
2.4444 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(\(1-C)Tj
1.7778 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(\) + C)Tj
2 -0.2222 TD
(c)Tj
0.4445 0.2222 TD
(C)Tj
0.6667 -0.2222 TD
(t)Tj
0.3333 0.2222 TD
(,)Tj
-8.3333 -1.3333 TD
(A = A)Tj
2.5556 -0.2222 TD
(f)Tj
0.3333 0.2222 TD
(A)Tj
0.6667 -0.2222 TD
(t)Tj
ET
Q
124.000 263.660 m
472.010 263.660 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 247.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 9-3 )Tj
/F11 1 Tf
4.6 0 TD
(Decal and Blend Texture Function)Tj
/F27 1 Tf
-4.6 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
[(In )-17(Table 9-2)191( and )44(Table 9-3)191(, a subscript of t indicates a texture value, f indicates the incoming)]TJ
-2.8 -1.4 TD
(fragment value, c indicates the values assigned with GL_TEXTURE_ENV_COLOR, and no subscript)Tj
T*
(indicates the final, computed value. Also in the tables, multiplication of a color triple by a scalar means)Tj
T*
(multiplying each of the R, G, and B components by the scalar; multiplying \(or adding\) two color triples)Tj
0 -1.5 TD
(means multiplying \(or adding\) each component of the second by the corresponding component of the)Tj
0 -1.4 TD
(first.)Tj
0 -2.1 TD
(The decal texture function makes sense only for the RGB and RGBA internal formats \(remember that)Tj
0 -1.5 TD
(texture mapping doesn't work in color-index mode\). With the RGB internal format, the color that would)Tj
T*
(have been painted in the absence of any texture mapping \(the fragment's color\) is replaced by the texture)Tj
T*
(color, and its alpha is unchanged. With the RGBA internal format, the fragment's color is blended with)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 31)Tj
ET
endstream
endobj
1003 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1005 0 obj
<<
/Length 5550
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(the texture color in a ratio determined by the texture alpha, and the fragment's alpha is unchanged. You)Tj
0 -1.6 TD
(use the decal texture function in situations where you want to apply an opaque texture to an object)Tj
/F33 1 Tf
39.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(if)Tj
-40.3 -1.6 TD
(you were drawing a soup can with an opaque label, for example. The decal texture function also can be)Tj
0 -1.5 TD
(used to apply an alpha blended texture, such as an insignia onto an airplane wing.)Tj
0 -2.1 TD
(The replacement texture function is similar to decal; in fact, for the RGB internal format, they are exactly)Tj
0 -1.5 TD
(the same. With all the internal formats, the component values are either replaced or left alone.)Tj
0 -2.1 TD
(For modulation, the fragment's color is modulated by the contents of the texture map. If the base internal)Tj
0 -1.5 TD
(format is GL_LUMINANCE, GL_LUMINANCE_ALPHA, or GL_INTENSITY, the color values are)Tj
T*
(multiplied by the same value, so the texture map modulates between the fragment's color \(if the)Tj
T*
(luminance or intensity is 1\) to black \(if it's 0\). For the GL_RGB and GL_RGBA internal formats, each of)Tj
T*
(the incoming color components is multiplied by a corresponding \(possibly different\) value in the texture.)Tj
T*
(If there's an alpha value, it's multiplied by the fragment's alpha. Modulation is a good texture function)Tj
T*
(for use with lighting, since the lit polygon color can be used to attenuate the texture color. Most of the)Tj
T*
(texture-mapping examples in the color plates use modulation for this reason. White, specular polygons)Tj
T*
(are often used to render lit, textured objects, and the texture image provides the diffuse color.)Tj
0 -2.1 TD
(The blending texture function is the only function that uses the color specified by)Tj
0 -1.5 TD
(GL_TEXTURE_ENV_COLOR. The luminance, intensity, or color value is used somewhat like an alpha)Tj
T*
[(value to blend the fragment's color with the GL_TEXTURE_ENV_COLOR. \(See )38("Sample Uses of)]TJ
T*
[(Blending" in Chapter 6)-30( for the billboarding example, which uses a blended texture.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 388.000 Tm
(Assigning Texture Coordinates)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 366.000 Tm
(As you draw your texture-mapped scene, you must provide both object coordinates and texture)Tj
T*
(coordinates for each vertex. After transformation, the object coordinates determine where on the screen)Tj
T*
(that particular vertex is rendered. The texture coordinates determine which texel in the texture map is)Tj
T*
(assigned to that vertex. In exactly the same way that colors are interpolated between two vertices of)Tj
T*
(shaded polygons and lines, texture coordinates are also interpolated between vertices. \(Remember that)Tj
T*
(textures are rectangular arrays of data.\))Tj
0 -2.1 TD
(Texture coordinates can comprise one, two, three, or four coordinates. They're usually referred to as the)Tj
/F15 1 Tf
0 -1.5 TD
(s, t, r,)Tj
/F11 1 Tf
2.3 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( coordinates to distinguish them from object coordinates \()Tj
/F15 1 Tf
23.1 0 TD
(x, y, z,)Tj
/F11 1 Tf
2.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(\) and from evaluator)Tj
-33 -1.5 TD
(coordinates \()Tj
/F15 1 Tf
5.2 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
[(; see )55(Chapter 12)-84(\). For one-dimensional textures, you use the )]TJ
/F15 1 Tf
24.3 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( coordinate; for)Tj
-32.8 -1.5 TD
(two-dimensional textures, you use )Tj
/F15 1 Tf
14 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(t)Tj
/F11 1 Tf
0.3 0 TD
(. In Release 1.1, the )Tj
/F15 1 Tf
8.1 0 TD
(r)Tj
/F11 1 Tf
0.4 0 TD
( coordinate is ignored. \(Some)Tj
-25.1 -1.5 TD
(implementations have 3D texture mapping as an extension, and that extension uses the )Tj
/F15 1 Tf
34.9 0 TD
(r)Tj
/F11 1 Tf
0.4 0 TD
( coordinate.\) The)Tj
/F15 1 Tf
-35.3 -1.5 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( coordinate, like )Tj
/F15 1 Tf
6.7 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(, is typically given the value 1 and can be used to create homogeneous coordinates;)Tj
-7.9 -1.5 TD
[(it's described as an advanced feature in )-31("The q Coordinate.")66( The command to specify texture)]TJ
0 -1.7 TD
(coordinates, )Tj
/F15 1 Tf
5.1 0 TD
(glTexCoord*\(\))Tj
/F11 1 Tf
6 0 TD
(, is similar to )Tj
/F15 1 Tf
5.4 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glColor*\(\))Tj
/F11 1 Tf
4.3 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glNormal*\(\))Tj
/F33 1 Tf
5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(it comes in similar)Tj
-34.1 -1.5 TD
(variations and is used the same way between )Tj
/F15 1 Tf
18.2 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
( pairs. Usually, texture-coordinate)Tj
-26.9 -1.5 TD
(values range from 0 to 1; values can be assigned outside this range, however, with the results described)Tj
T*
[(in )28("Repeating and Clamping Textures.")]TJ
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glTexCoord)-21({1234}{sifd}\()79(TYPE)-66(coords)22(\);)]TJ
0 -1.1 TD
[(void glTexCoord)-21({1234}{sifd})46(v)44(\()-67(TYPE)34( )28(*)-50(coords)22(\);)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 32)Tj
ET
endstream
endobj
1006 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1008 0 obj
<<
/Length 4747
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(Sets the current texture coordinates \()-39(s, t, r, q)56(\). Subsequent calls to )6(glVertex*\(\))-45( result in those)]TJ
0 -1.5 TD
[(vertices being assigned the current texture coordinates. With )39(glTexCoord1*\(\))-55(, the )-28(s)89( coordinate is set)]TJ
T*
[(to the specified value, )-28(t)78( and r)-11( are set to 0, and )-27(q is set to 1. Using glTexCoord2*\(\))45( allows you to)]TJ
T*
[(specify )27(s)-11( and t)-22(;)0( )-17(r)-11( and q are set to 0 and 1, respectively. With )39(glTexCoord3*\(\))45(, q is set to 1 and the)]TJ
T*
[(other coordinates are set as specified. You can specify all coordinates with )53(glTexCoord4*\(\))-55(. Use the)]TJ
T*
[(appropriate suffix \(s, i, f, or d\) and the corresponding value for )-14(TYPE)34( \(GLshort, GLint, GLfloat, or)]TJ
T*
(GLdouble\) to specify the coordinates' data type. You can supply the coordinates individually, or you)Tj
T*
(can use the vector version of the command to supply them in a single array. Texture coordinates are)Tj
0 -1.6 TD
(multiplied by the 4)Tj
/F33 1 Tf
7.5 0 TD
(\264)Tj
/F15 1 Tf
0.5 0 TD
[(4 texture matrix before any texture mapping occurs. \(See )-46("The Texture Matrix)]TJ
-8 -1.6 TD
[(Stack.")36(\) Note that integer texture coordinates are interpreted directly rather than being mapped to)]TJ
0 -1.5 TD
(the range [-1,1] as normal coordinates are.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The next section discusses how to calculate appropriate texture coordinates. Instead of explicitly)Tj
0 -1.5 TD
(assigning them yourself, you can choose to have texture coordinates calculated automatically by OpenGL)Tj
T*
(as a function of the vertex coordinates. \(See "Automatic Texture-Coordinate Generation.")Tj
35.9 0 TD
(\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 479.000 Tm
(Computing Appropriate Texture Coordinates)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 458.000 Tm
(Two-dimensional textures are square or rectangular images that are typically mapped to the polygons that)Tj
0 -1.5 TD
(make up a polygonal model. In the simplest case, you're mapping a rectangular texture onto a model)Tj
0 -1.6 TD
(that's also rectangular)Tj
/F33 1 Tf
8.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, your texture is a scanned image of a brick wall, and your rectangle)Tj
-9.8 -1.6 TD
(is to represent a brick wall of a building. Suppose the brick wall is square and the texture is square, and)Tj
0 -1.5 TD
(you want to map the whole texture to the whole wall. The texture coordinates of the texture square are \(0,)Tj
T*
(0\), \(1, 0\), \(1, 1\), and \(0, 1\) in counterclockwise order. When you're drawing the wall, just give those four)Tj
T*
(coordinate sets as the texture coordinates as you specify the wall's vertices in counterclockwise order.)Tj
0 -2.1 TD
(Now suppose that the wall is two-thirds as high as it is wide, and that the texture is again square. To)Tj
0 -1.5 TD
(avoid distorting the texture, you need to map the wall to a portion of the texture map so that the aspect)Tj
T*
(ratio of the texture is preserved. Suppose that you decide to use the lower two-thirds of the texture map to)Tj
T*
(texture the wall. In this case, use texture coordinates of \(0,0\), \(1,0\), \(1,2/3\), and \(0,2/3\) for the texture)Tj
T*
(coordinates as the wall vertices are traversed in a counterclockwise order.)Tj
0 -2.1 TD
(As a slightly more complicated example, suppose you'd like to display a tin can with a label wrapped)Tj
0 -1.5 TD
(around it on the screen. To obtain the texture, you purchase a can, remove the label, and scan it in.)Tj
T*
(Suppose the label is 4 units tall and 12 units around, which yields an aspect ratio of 3 to 1. Since textures)Tj
0 -1.8 TD
(must have aspect ratios of 2)Tj
11.1 0.3 TD
(n)Tj
0.5 -0.3 TD
( to 1, you can either simply not use the top third of the texture, or you can)Tj
-11.6 -1.5 TD
(cut and paste the texture until it has the necessary aspect ratio. Suppose you decide not to use the top)Tj
T*
(third. Now suppose the tin can is a cylinder approximated by thirty polygons of length 4 units \(the height)Tj
T*
(of the can\) and width 12/30 \(1/30 of the circumference of the can\). You can use the following texture)Tj
T*
(coordinates for each of the thirty approximating rectangles:)Tj
0 -2.1 TD
(1: \(0, 0\), \(1/30, 0\), \(1/30, 2/3\), \(0, 2/3\))Tj
T*
(2: \(1/30, 0\), \(2/30, 0\), \(2/30, 2/3\), \(1/30, 2/3\))Tj
T*
(3: \(2/30, 0\), \(3/30, 0\), \(3/30, 2/3\), \(2/30, 2/3\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 33)Tj
ET
endstream
endobj
1009 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1010 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im87
/Width 678
/Height 309
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.86)
>>
stream
endstream
endobj
1012 0 obj
<<
/Length 3912
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(. . .)Tj
0 -2.1 TD
(30: \(29/30, 0\), \(1, 0\), \(1, 2/3\), \(29/30, 2/3\))Tj
T*
(Only a few curved surfaces such as cones and cylinders can be mapped to a flat surface without geodesic)Tj
0 -1.5 TD
(distortion. Any other shape requires some distortion. In general, the higher the curvature of the surface,)Tj
T*
(the more distortion of the texture is required.)Tj
0 -2.1 TD
(If you don't care about texture distortion, it's often quite easy to find a reasonable mapping. For example,)Tj
0 -1.6 TD
(consider a sphere whose surface coordinates are given by \(cos )Tj
/F33 1 Tf
25.1 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( cos )Tj
/F33 1 Tf
1.9 0 TD
(f)Tj
/F11 1 Tf
0.5 0 TD
(, cos )Tj
/F33 1 Tf
2.1 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( sin )Tj
/F33 1 Tf
1.6 0 TD
(f)Tj
/F11 1 Tf
0.6 0 TD
(, sin )Tj
/F33 1 Tf
1.9 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
(\), where 0)Tj
/F33 1 Tf
4 0 TD
0.051 Tc
[(\243q)72(\243)]TJ
/F11 1 Tf
1.7 0 TD
0.000 Tc
(2)Tj
/F33 1 Tf
0.5 0 TD
(p)Tj
/F11 1 Tf
0.5 0 TD
(,)Tj
-41.9 -1.7 TD
(and 0)Tj
/F33 1 Tf
2.2 0 TD
-0.049 Tc
[(\243f)-128(\243p)]TJ
/F11 1 Tf
2.2 0 TD
0.000 Tc
(. The )Tj
/F33 1 Tf
2.3 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
(-)Tj
/F33 1 Tf
0.3 0 TD
(f)Tj
/F11 1 Tf
0.5 0 TD
( rectangle can be mapped directly to a rectangular texture map, but the closer you get)Tj
-8 -1.6 TD
(to the poles, the more distorted the texture is. The entire top edge of the texture map is mapped to the)Tj
0 -1.5 TD
(north pole, and the entire bottom edge to the south pole. For other surfaces, such as that of a torus)Tj
T*
(\(doughnut\) with a large hole, the natural surface coordinates map to the texture coordinates in a way that)Tj
T*
[(produces only a little distortion, so it might be suitable for many applications. )9(Figure 9-6)225( shows two tori,)]TJ
T*
(one with a small hole \(and therefore a lot of distortion near the center\) and one with a large hole \(and)Tj
T*
(only a little distortion\).)Tj
ET
Q
q
1 i 
124.000 480.100 422.990 -192.780 re
W n
/GS1 gs
q
423 0 0 193 124 287.1 cm
/Im87 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 275.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 9-6 )Tj
/F11 1 Tf
5.1 0 TD
(Texture-Map Distortion)Tj
-5.1 -2.1 TD
[(If you're texturing spline surfaces generated with evaluators \(see )-10(Chapter 12)16(\), the )]TJ
/F15 1 Tf
32.9 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( parameters for)Tj
-35.8 -1.5 TD
(the surface can sometimes be used as texture coordinates. In general, however, there's a large artistic)Tj
T*
(component to successfully mapping textures to polygonal approximations of curved surfaces.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 195.000 Tm
(Repeating and Clamping Textures)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 173.000 Tm
(You can assign texture coordinates outside the range [0,1] and have them either clamp or repeat in the)Tj
T*
(texture map. With repeating textures, if you have a large plane with texture coordinates running from 0.0)Tj
T*
(to 10.0 in both directions, for example, you'll get 100 copies of the texture tiled together on the screen.)Tj
T*
(During repeating, the integer part of texture coordinates is ignored, and copies of the texture map tile the)Tj
T*
(surface. For most applications where the texture is to be repeated, the texels at the top of the texture)Tj
T*
(should match those at the bottom, and similarly for the left and right edges.)Tj
0 -2.1 TD
(The other possibility is to clamp the texture coordinates: Any values greater than 1.0 are set to 1.0, and)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 34)Tj
ET
endstream
endobj
1013 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im87 1010 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1015 0 obj
<<
/Length 2982
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(any values less than 0.0 are set to 0.0. Clamping is useful for applications where you want a single copy)Tj
0 -1.5 TD
(of the texture to appear on a large surface. If the surface-texture coordinates range from 0.0 to 10.0 in)Tj
T*
(both directions, one copy of the texture appears in the lower corner of the surface. If you've chosen)Tj
T*
[(GL_LINEAR as the filtering method \(see )-12("Filtering")61(\), an equally weighted combination of the border)]TJ
T*
(color and the texture color is used, as follows.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(When repeating, the 2)Tj
/F33 1 Tf
8.8 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(2 array wraps to the opposite edge of the texture. Thus, texels on the right)Tj
-9.4 -1.6 TD
(edge are averaged with those on the left, and top and bottom texels are also averaged.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If there is a border, then the texel from the border is used in the weighting. Otherwise,)Tj
0 -1.6 TD
(GL_TEXTURE_BORDER_COLOR is used. \(If you've chosen GL_NEAREST as the filtering)Tj
0 -1.5 TD
(method, the border color is completely ignored.\))Tj
-1.9 -2.7 TD
(Note that if you are using clamping, you can avoid having the rest of the surface affected by the texture.)Tj
0 -1.5 TD
(To do this, use alpha values of 0 for the edges \(or borders, if they are specified\) of the texture. The decal)Tj
T*
(texture function directly uses the texture's alpha value in its calculations. If you are using one of the other)Tj
T*
(texture functions, you may also need to enable blending with good source and destination factors. \(See)Tj
T*
[("Blending" in Chapter 6)-22(.)0(\))]TJ
0 -2.1 TD
(To see the effects of wrapping, you must have texture coordinates that venture beyond [0.0, 1.0]. Start)Tj
0 -1.5 TD
[(with )28(Example 9-1)170(, and modify the texture coordinates for the squares by mapping the texture coordinates)]TJ
T*
(from 0.0 to 3.0 as follows:)Tj
/F7 1 Tf
0 -2 TD
(glBegin\(GL_QUADS\); )Tj
0 -1.5 TD
(  glTexCoord2f\(0.0, 0.0\); glVertex3f\(-2.0, -1.0, 0.0\);     )Tj
T*
(  glTexCoord2f\(0.0, 3.0\); glVertex3f\(-2.0, 1.0, 0.0\); )Tj
T*
(  glTexCoord2f\(3.0, 3.0\); glVertex3f\(0.0, 1.0, 0.0\); )Tj
T*
(  glTexCoord2f\(3.0, 0.0\); glVertex3f\(0.0, -1.0, 0.0\); )Tj
0 -3 TD
(  glTexCoord2f\(0.0, 0.0\); glVertex3f\(1.0, -1.0, 0.0\); )Tj
0 -1.5 TD
(  glTexCoord2f\(0.0, 3.0\); glVertex3f\(1.0, 1.0, 0.0\);  )Tj
T*
(  glTexCoord2f\(3.0, 3.0\); glVertex3f\(2.41421, 1.0, -1.41421\); )Tj
T*
(  glTexCoord2f\(3.0, 0.0\); glVertex3f\(2.41421, -1.0, -1.41421\); glEnd\(\))Tj
T*
(;)Tj
/F11 1 Tf
0 -2.2 TD
[(With GL_REPEAT wrapping, the result is as shown in )24(Figure 9-7)225(.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 35)Tj
ET
endstream
endobj
1016 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1017 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im88
/Width 319
/Height 191
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.87)
>>
stream
endstream
endobj
1018 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im89
/Width 309
/Height 187
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.88)
>>
stream
endstream
endobj
1020 0 obj
<<
/Length 1393
>>
stream
/GS1 gs
q
319 0 0 191 124 529 cm
/Im88 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 516.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 9-7 )Tj
/F11 1 Tf
5.1 0 TD
(Repeating a Texture)Tj
-5.1 -2.1 TD
(In this case, the texture is repeated in both the )Tj
/F15 1 Tf
18.6 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(t)Tj
/F11 1 Tf
0.3 0 TD
( directions, since the following calls are made to)Tj
/F15 1 Tf
-21.2 -1.5 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
(:)Tj
/F7 1 Tf
-7.7 -2 TD
(glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT\); )Tj
0 -1.5 TD
(glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT\);)Tj
/F11 1 Tf
0 -2.2 TD
[(If GL_CLAMP is used instead of GL_REPEAT for each direction, you see something similar to )-21(Figure)]TJ
0 -1.5 TD
(9-8)Tj
1.3 0 TD
(.)Tj
ET
Q
q
309 0 0 187 124 207 cm
/Im89 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 194.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 9-8 )Tj
/F11 1 Tf
5.1 0 TD
(Clamping a Texture)Tj
-5.1 -2.1 TD
[(You can also clamp in one direction and repeat in the other, as shown in )10(Figure 9-9)225(.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 36)Tj
ET
endstream
endobj
1021 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im88 1017 0 R
/Im89 1018 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1022 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im90
/Width 303
/Height 170
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.89)
>>
stream
endstream
endobj
1024 0 obj
<<
/Length 3343
>>
stream
/GS1 gs
q
303 0 0 170 124 550 cm
/Im90 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 537.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 9-9 )Tj
/F11 1 Tf
5.1 0 TD
(Repeating and Clamping a Texture)Tj
-5.1 -2.1 TD
(You've now seen all the possible arguments for )Tj
/F15 1 Tf
19.3 0 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
(, which is summarized here.)Tj
/F15 1 Tf
-27 -2.1 TD
[(void )-28(glTexParameter{if}\(GLenum )-16(target)89(, GLenum )-6(pname)-34(, TYPE param\);)]TJ
0 -1.1 TD
0.028 Tw
[(void glTexParameter{if})56(v)-56(\(GLenum )55(target)-11(, )28(GLenum )22(pname)66(,)]TJ
T*
0.000 Tw
(TYPE *param\);)Tj
1.8 -1.5 TD
(Sets various parameters that control how a texture is treated as it's applied to a fragment or stored)Tj
T*
[(in a texture object. The target)-11( parameter is either GL_TEXTURE_2D or GL_TEXTURE_1D to)]TJ
T*
(indicate a two- or one-dimensional texture. The possible values for )Tj
27.1 0 TD
[(pname)66( and param)-89( are shown in)]TJ
-27.1 -1.5 TD
(Table 9-4)Tj
3.9 0 TD
(. You can use the vector version of the command to supply an array of values for)Tj
-3.9 -1.5 TD
(GL_TEXTURE_BORDER_COLOR, or you can supply individual values for other parameters using)Tj
T*
(the nonvector version. If these values are supplied as integers, they're converted to floating-point)Tj
T*
[(according to )34(Table 4-1)]TJ
9.2 0 TD
(; they're also clamped to the range [0,1].)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
1 i 
124.000 357.000 m
456.000 357.000 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 349.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Parameter)-16483(Values)]TJ
ET
Q
124.000 343.480 m
456.000 343.480 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 335.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_TEXTURE_WRAP_S)-8165(GL_CLAMP, GL_REPEAT)]TJ
0 -1.4444 TD
[(GL_TEXTURE_WRAP_T)-8110(GL_CLAMP, GL_REPEAT)]TJ
T*
[(GL_TEXTURE_MAG_FILTER)-5888(GL_NEAREST, GL_LINEAR)]TJ
T*
[(GL_TEXTURE_MIN_FILTER)-6277(GL_NEAREST, GL_LINEAR,)]TJ
19 -1.3333 TD
(GL_NEAREST_MIPMAP_NEAREST,)Tj
T*
(GL_NEAREST_MIPMAP_LINEAR,)Tj
T*
(GL_LINEAR_MIPMAP_NEAREST,)Tj
T*
(GL_LINEAR_MIPMAP_LINEAR)Tj
-19 -1.4444 TD
[(GL_TEXTURE_BORDER_COLOR)-4165(any four values in [0.0, 1.0])]TJ
T*
[(GL_TEXTURE_PRIORITY)-7499([0.0, 1.0] for the current texture object)]TJ
ET
Q
124.000 214.670 m
456.010 214.670 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 198.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 9-4 )Tj
/F11 1 Tf
4.6 0 TD
(glTexParameter*\(\) Parameters)Tj
/F27 1 Tf
3.4 -2.1 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
[(Figure 9-8)225( and )44(Figure 9-9)225( are drawn using GL_NEAREST for the minification and magnification filter.)]TJ
0 -1.5 TD
(What happens if you change the filter values to GL_LINEAR? Why?)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 107.000 Tm
(Automatic Texture-Coordinate Generation)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 85.000 Tm
(You can use texture mapping to make contours on your models or to simulate the reflections from an)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 37)Tj
ET
endstream
endobj
1025 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im90 1022 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1027 0 obj
<<
/Length 6077
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(arbitrary environment on a shiny model. To achieve these effects, let OpenGL automatically generate the)Tj
0 -1.5 TD
(texture coordinates for you, rather than explicitly assigning them with )Tj
/F15 1 Tf
28.2 0 TD
(glTexCoord*\(\))Tj
/F11 1 Tf
5.9 0 TD
(. To generate)Tj
-34.1 -1.5 TD
(texture coordinates automatically, use the command )Tj
/F15 1 Tf
21.1 0 TD
(glTexGen\(\))Tj
/F11 1 Tf
4.5 0 TD
(.)Tj
/F15 1 Tf
-25.6 -2.1 TD
[(void )-28(glTexGen)-12({ifd}\(GLenum )84(coord)-67(, GLenum )-6(pname)66(, TYPE)-66(param)11(\);)]TJ
0 -1.1 TD
[(void )-28(glTexGen)-12({ifd})56(v)-56(\(GLenum )27(coord)33(, GLenum )-6(pname)-34(, TYPE)34( *)-50(param)11(\);)]TJ
1.8 -1.5 TD
[(Specifies the functions for automatically generating texture coordinates. The first parameter, )-24(coord)33(,)]TJ
T*
[(must be GL_S, GL_T, GL_R, or GL_Q to indicate whether texture coordinate )9(s, t, r)-44(,)0( or )39(q is to be)]TJ
T*
[(generated. The )50(pname)-34( parameter is GL_TEXTURE_GEN_MODE, GL_OBJECT_PLANE, or)]TJ
T*
[(GL_EYE_PLANE. If it's GL_TEXTURE_GEN_MODE, )48(param)-89( is an integer \(or, in the vector version)]TJ
T*
(of the command, points to an integer\) that's either GL_OBJECT_LINEAR, GL_EYE_LINEAR, or)Tj
T*
(GL_SPHERE_MAP. These symbolic constants determine which function is used to generate the)Tj
T*
[(texture coordinate. With either of the other possible values for pname)-34(, param)11( is a pointer to an)]TJ
T*
(array of values \(for the vector version\) specifying parameters for the texture-generation function.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The different methods of texture-coordinate generation have different uses. Specifying the reference)Tj
0 -1.5 TD
(plane in object coordinates is best for when a texture image remains fixed to a moving object. Thus,)Tj
T*
(GL_OBJECT_LINEAR would be used for putting a wood grain on a table top. Specifying the reference)Tj
T*
(plane in eye coordinates \(GL_EYE_LINEAR\) is best for producing dynamic contour lines on moving)Tj
T*
(objects. GL_EYE_LINEAR may be used by specialists in geosciences, who are drilling for oil or gas. As)Tj
T*
(the drill goes deeper into the ground, the drill may be rendered with different colors to represent the)Tj
T*
(layers of rock at increasing depths. GL_SPHERE_MAP is predominantly used for environment mapping.)Tj
T*
-0.027 Tw
[(\(See "Environment )-27(Mapping.")-50(\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 374.000 Tm
0.000 Tw
(Creating Contours)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 353.000 Tm
(When GL_TEXTURE_GEN_MODE and GL_OBJECT_LINEAR are specified, the generation function)Tj
T*
(is a linear combination of the object coordinates of the vertex \()Tj
/F15 1 Tf
25.1 0 TD
(x)Tj
/F11 1 Tf
0.5 -0.2 TD
(o,)Tj
/F15 1 Tf
0.7 0.2 TD
(y)Tj
/F11 1 Tf
0.5 -0.2 TD
(o,)Tj
/F15 1 Tf
0.7 0.2 TD
(z)Tj
/F11 1 Tf
0.4 -0.2 TD
(o,)Tj
/F15 1 Tf
0.8 0.2 TD
(w)Tj
/F11 1 Tf
0.6 -0.2 TD
(o)Tj
0.5 0.2 TD
(\):)Tj
-29.8 -2.3 TD
(generated coordinate = )Tj
/F15 1 Tf
9.4 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
/F15 1 Tf
0.5 0.2 TD
(x)Tj
/F11 1 Tf
0.5 -0.2 TD
(0)Tj
0.5 0.2 TD
( + )Tj
/F15 1 Tf
1 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
/F15 1 Tf
0.5 0.2 TD
(y)Tj
/F11 1 Tf
0.5 -0.2 TD
(0)Tj
0.5 0.2 TD
( + )Tj
/F15 1 Tf
1 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
/F15 1 Tf
0.5 0.2 TD
(z)Tj
/F11 1 Tf
0.4 -0.2 TD
(0)Tj
0.5 0.2 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
/F15 1 Tf
0.5 0.2 TD
(w)Tj
/F11 1 Tf
0.7 -0.2 TD
(0)Tj
-20.1 -2.1 TD
(The )Tj
/F15 1 Tf
1.8 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
(, ..., )Tj
/F15 1 Tf
1.8 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
( values are supplied as the )Tj
/F15 1 Tf
10.7 0 TD
(param )Tj
/F11 1 Tf
2.8 0 TD
(argument to )Tj
/F15 1 Tf
5.1 0 TD
(glTexGen*v\(\))Tj
/F11 1 Tf
5.5 0 TD
(, with )Tj
/F15 1 Tf
2.5 0 TD
(pname)Tj
/F11 1 Tf
2.7 0 TD
( set to)Tj
-34.9 -1.7 TD
(GL_OBJECT_PLANE. With )Tj
/F15 1 Tf
12 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
(, ..., )Tj
/F15 1 Tf
1.7 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
( correctly normalized, this function gives the distance from the)Tj
-15.7 -1.7 TD
(vertex to a plane. For example, if )Tj
/F15 1 Tf
13.5 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
0.5 0.2 TD
( = )Tj
/F15 1 Tf
1.1 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
0.5 0.2 TD
( = )Tj
/F15 1 Tf
1.1 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
( = 0 and )Tj
/F15 1 Tf
3.5 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
( = 1, the function gives the distance between)Tj
-23.2 -1.7 TD
(the vertex and the plane )Tj
/F15 1 Tf
9.8 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( = 0. The distance is positive on one side of the plane, negative on the other,)Tj
-10.2 -1.5 TD
(and zero if the vertex lies on the plane.)Tj
0 -2.1 TD
[(Initially in )46(Example 9-6)170(, equally spaced contour lines are drawn on a teapot; the lines indicate the)]TJ
0 -1.5 TD
(distance from the plane )Tj
/F15 1 Tf
9.6 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
( = 0. The coefficients for the plane )Tj
/F15 1 Tf
14 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
( = 0 are in this array:)Tj
/F7 1 Tf
-24.6 -2.1 TD
(static GLfloat xequalzero[] = {1.0, 0.0, 0.0, 0.0};)Tj
/F11 1 Tf
T*
(Since only one property is being shown \(the distance from the plane\), a one-dimensional texture map)Tj
0 -1.5 TD
(suffices. The texture map is a constant green color, except that at equally spaced intervals it includes a)Tj
T*
(red mark. Since the teapot is sitting on the )Tj
/F15 1 Tf
17.1 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(-)Tj
/F15 1 Tf
0.3 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
[( plane, the contours are all perpendicular to its base. )-46("Plate)]TJ
-18.3 -1.5 TD
[(18" in Appendix I)14( shows the picture drawn by the program.)]TJ
0 -2.1 TD
(In the same example, pressing the `s' key changes the parameters of the reference plane to)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 38)Tj
ET
endstream
endobj
1028 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1030 0 obj
<<
/Length 2131
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(static GLfloat slanted[] = {1.0, 1.0, 1.0, 0.0};)Tj
/F11 1 Tf
0 -2.1 TD
(the contour stripes are parallel to the plane )Tj
/F15 1 Tf
17.3 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( = 0, slicing across the teapot at an angle, as shown in)Tj
-20.7 -1.5 TD
[("Plate 18" in Appendix I)-28(.)0( To restore the reference plane to its initial value, )]TJ
/F15 1 Tf
30 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
( = 0, press the `x' key.)Tj
/F27 1 Tf
-30.5 -2.1 TD
(Example 9-6 )Tj
/F11 1 Tf
6.1 0 TD
(Automatic Texture-Coordinate Generation: texgen.c)Tj
/F7 1 Tf
-6.1 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(#define stripeImageWidth 32)Tj
0 -1.5 TD
(GLubyte stripeImage[4*stripeImageWidth];)Tj
0 -3 TD
(static GLuint texName;)Tj
T*
(void makeStripeImage\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int j;)Tj
T*
(    )Tj
T*
(   for \(j = 0; j < stripeImageWidth; j++\) {)Tj
T*
(      stripeImage[4*j] = \(GLubyte\) \(\(j<=4\) ? 255 : 0\);)Tj
T*
(      stripeImage[4*j+1] = \(GLubyte\) \(\(j>4\) ? 255 : 0\);)Tj
T*
(      stripeImage[4*j+2] = \(GLubyte\) 0;)Tj
T*
(      stripeImage[4*j+3] = \(GLubyte\) 255;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(/*  planes for texture coordinate generation  */)Tj
0 -1.5 TD
(static GLfloat xequalzero[] = {1.0, 0.0, 0.0, 0.0};)Tj
T*
(static GLfloat slanted[] = {1.0, 1.0, 1.0, 0.0};)Tj
T*
(static GLfloat *currentCoeff;)Tj
T*
(static GLenum currentPlane;)Tj
T*
(static GLint currentGenMode;)Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glShadeModel\(GL_SMOOTH\);)Tj
0 -3 TD
(   makeStripeImage\(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 39)Tj
ET
endstream
endobj
1031 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1033 0 obj
<<
/Length 1970
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glPixelStorei\(GL_UNPACK_ALIGNMENT, 1\);)Tj
0 -3 TD
(   glGenTextures\(1, &texName\);)Tj
0 -1.5 TD
(   glBindTexture\(GL_TEXTURE_1D, texName\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER,)Tj
T*
(                   GL_LINEAR\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER,)Tj
T*
(                   GL_LINEAR\);)Tj
T*
(   glTexImage1D\(GL_TEXTURE_1D, 0, GL_RGBA, stripeImageWidth, 0,)Tj
T*
(                GL_RGBA, GL_UNSIGNED_BYTE, stripeImage\);)Tj
0 -3 TD
(   glTexEnvf\(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE\);)Tj
0 -1.5 TD
(   currentCoeff = xequalzero;)Tj
T*
(   currentGenMode = GL_OBJECT_LINEAR;)Tj
T*
(   currentPlane = GL_OBJECT_PLANE;)Tj
T*
(   glTexGeni\(GL_S, GL_TEXTURE_GEN_MODE, currentGenMode\);)Tj
T*
(   glTexGenfv\(GL_S, currentPlane, currentCoeff\);)Tj
0 -3 TD
(   glEnable\(GL_TEXTURE_GEN_S\);)Tj
0 -1.5 TD
(   glEnable\(GL_TEXTURE_1D\);)Tj
T*
(   glEnable\(GL_CULL_FACE\);)Tj
T*
(   glEnable\(GL_LIGHTING\);)Tj
T*
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_AUTO_NORMAL\);)Tj
T*
(   glEnable\(GL_NORMALIZE\);)Tj
T*
(   glFrontFace\(GL_CW\);)Tj
T*
(   glCullFace\(GL_BACK\);)Tj
T*
(   glMaterialf \(GL_FRONT, GL_SHININESS, 64.0\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(   glRotatef\(45.0, 0.0, 0.0, 1.0\);)Tj
T*
(   glBindTexture\(GL_TEXTURE_1D, texName\);)Tj
T*
(   glutSolidTeapot\(2.0\);)Tj
T*
(   glPopMatrix \(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 40)Tj
ET
endstream
endobj
1034 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1037 0 obj
<<
/Length 1977
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho \(-3.5, 3.5, -3.5*\(GLfloat\)h/\(GLfloat\)w, )Tj
T*
(               3.5*\(GLfloat\)h/\(GLfloat\)w, -3.5, 3.5\);)Tj
T*
(   else)Tj
T*
(      glOrtho \(-3.5*\(GLfloat\)w/\(GLfloat\)h, )Tj
T*
(               3.5*\(GLfloat\)w/\(GLfloat\)h, -3.5, 3.5, -3.5, 3.5\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard \(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `e':)Tj
T*
(      case `E':)Tj
T*
(         currentGenMode = GL_EYE_LINEAR;)Tj
T*
(         currentPlane = GL_EYE_PLANE;)Tj
T*
(         glTexGeni\(GL_S, GL_TEXTURE_GEN_MODE, currentGenMode\);)Tj
T*
(         glTexGenfv\(GL_S, currentPlane, currentCoeff\);)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `o':)Tj
T*
(      case `O':)Tj
T*
(         currentGenMode = GL_OBJECT_LINEAR;)Tj
T*
(         currentPlane = GL_OBJECT_PLANE;)Tj
T*
(         glTexGeni\(GL_S, GL_TEXTURE_GEN_MODE, currentGenMode\);)Tj
T*
(         glTexGenfv\(GL_S, currentPlane, currentCoeff\);)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `s':)Tj
T*
(      case `S':)Tj
T*
(         currentCoeff = slanted;)Tj
T*
(         glTexGenfv\(GL_S, currentPlane, currentCoeff\);)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case `x':)Tj
T*
(      case `X':)Tj
T*
(         currentCoeff = xequalzero;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 41)Tj
ET
endstream
endobj
1038 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1040 0 obj
<<
/Length 3756
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(         glTexGenfv\(GL_S, currentPlane, currentCoeff\);)Tj
0 -1.5 TD
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize\(256, 256\);)Tj
T*
(   glutInitWindowPosition\(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(You enable texture-coordinate generation for the )Tj
/F15 1 Tf
19.8 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( coordinate by passing GL_TEXTURE_GEN_S to)Tj
/F15 1 Tf
-20.2 -1.5 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
(. To generate other coordinates, enable them with GL_TEXTURE_GEN_T,)Tj
-4.3 -1.5 TD
(GL_TEXTURE_GEN_R, or GL_TEXTURE_GEN_Q. Use )Tj
/F15 1 Tf
24.2 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.5 0 TD
( with the appropriate constant to)Tj
-28.7 -1.5 TD
(disable coordinate generation. Also note the use of GL_REPEAT to cause the contour lines to be)Tj
T*
(repeated across the teapot.)Tj
0 -2.1 TD
(The GL_OBJECT_LINEAR function calculates the texture coordinates in the model's coordinate)Tj
0 -1.5 TD
[(system. Initially in )24(Example 9-6)170(, the GL_OBJECT_LINEAR function is used, so the contour lines)]TJ
T*
(remain perpendicular to the base of the teapot, no matter how the teapot is rotated or viewed. However, if)Tj
T*
(you press the `e' key, the texture generation mode is changed from GL_OBJECT_LINEAR to)Tj
T*
(GL_EYE_LINEAR, and the contour lines are calculated relative to the eye coordinate system. \(Pressing)Tj
T*
(the `o' key restores GL_OBJECT_LINEAR as the texture generation mode.\) If the reference plane is )Tj
/F15 1 Tf
40.7 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( =)Tj
-41.1 -1.5 TD
(0, the result is a teapot with red stripes parallel to the )Tj
/F15 1 Tf
21.4 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(-)Tj
/F15 1 Tf
0.3 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( plane from the eye's point of view, as shown in)Tj
-22.6 -1.5 TD
[("Plate 18" in Appendix I)-28(.)0( Mathematically, you are multiplying the vector \()]TJ
/F15 1 Tf
29.8 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
/F15 1 Tf
0.5 0.2 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
/F15 1 Tf
0.5 0.2 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
/F15 1 Tf
0.5 0.2 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
(\) by the inverse of)Tj
-33.8 -1.7 TD
(the modelview matrix to obtain the values used to calculate the distance to the plane. The texture)Tj
0 -1.5 TD
(coordinate is generated with the following function:)Tj
0 -2.1 TD
(generated coordinate = )Tj
/F15 1 Tf
9.4 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
/F15 1 Tf
0.5 0.2 TD
0.067 Tc
('x)Tj
/F11 1 Tf
0.8 -0.2 TD
0.000 Tc
(e)Tj
0.4 0.2 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
/F15 1 Tf
0.5 0.2 TD
-0.033 Tc
('y)Tj
/F11 1 Tf
0.8 -0.2 TD
0.000 Tc
(e)Tj
0.4 0.2 TD
( + )Tj
/F15 1 Tf
1.1 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
/F15 1 Tf
0.5 0.2 TD
-0.033 Tc
('z)Tj
/F11 1 Tf
0.7 -0.2 TD
0.000 Tc
(e)Tj
0.5 0.2 TD
( + )Tj
/F15 1 Tf
1 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
/F15 1 Tf
0.5 0.2 TD
0.067 Tc
('w)Tj
/F11 1 Tf
1 -0.2 TD
0.000 Tc
(e)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 42)Tj
ET
endstream
endobj
1041 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1043 0 obj
<<
/Length 5783
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(where \()Tj
/F15 1 Tf
3 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
(' )Tj
/F15 1 Tf
0.6 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
0.5 0.2 TD
(' )Tj
/F15 1 Tf
0.6 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
0.5 0.2 TD
(' )Tj
/F15 1 Tf
0.6 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
('\) = \()Tj
/F15 1 Tf
2 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
/F15 1 Tf
0.5 0.2 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
/F15 1 Tf
0.5 0.2 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
/F15 1 Tf
0.5 0.2 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
(\))Tj
/F15 1 Tf
0.4 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
(-1)Tj
-16 -2.3 TD
(In this case, \()Tj
/F15 1 Tf
5.3 0 TD
(x)Tj
/F11 1 Tf
0.5 -0.2 TD
(e)Tj
0.4 0.2 TD
(,)Tj
/F15 1 Tf
0.3 0 TD
( y)Tj
/F11 1 Tf
0.7 -0.2 TD
(e)Tj
0.4 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(z)Tj
/F11 1 Tf
0.4 -0.2 TD
(e)Tj
0.4 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(w)Tj
/F11 1 Tf
0.7 -0.2 TD
(e)Tj
0.5 0.2 TD
(\) are the eye coordinates of the vertex, and )Tj
/F15 1 Tf
17.2 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
(, ..., )Tj
/F15 1 Tf
1.8 0 TD
(p)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
( are supplied as the )Tj
/F15 1 Tf
7.9 0 TD
(param)Tj
/F11 1 Tf
-39.5 -1.7 TD
(argument to )Tj
/F15 1 Tf
5.1 0 TD
(glTexGen*\(\))Tj
/F11 1 Tf
5 0 TD
( with )Tj
/F15 1 Tf
2.3 0 TD
(pname)Tj
/F11 1 Tf
2.7 0 TD
( set to GL_EYE_PLANE. The primed values are calculated only at)Tj
-15.1 -1.5 TD
(the time they're specified so this operation isn't as computationally expensive as it looks.)Tj
0 -2.1 TD
(In all these examples, a single texture coordinate is used to generate contours. The )Tj
/F15 1 Tf
33.2 0 TD
(s)Tj
/F11 1 Tf
0.3 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(t)Tj
/F11 1 Tf
0.3 0 TD
( texture)Tj
-35.8 -1.5 TD
(coordinates can be generated independently, however, to indicate the distances to two different planes.)Tj
T*
(With a properly constructed two-dimensional texture map, the resulting two sets of contours can be)Tj
T*
(viewed simultaneously. For an added level of complexity, you can calculate the )Tj
/F15 1 Tf
32.1 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( coordinate using)Tj
-32.5 -1.5 TD
(GL_OBJECT_LINEAR and the )Tj
/F15 1 Tf
13.1 0 TD
(t)Tj
/F11 1 Tf
0.3 0 TD
( coordinate using GL_EYE_LINEAR.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 546.000 Tm
(Environment Mapping)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 525.000 Tm
(The goal of environment mapping is to render an object as if it were perfectly reflective, so that the)Tj
0 -1.5 TD
(colors on its surface are those reflected to the eye from its surroundings. In other words, if you look at a)Tj
T*
(perfectly polished, perfectly reflective silver object in a room, you see the walls, floor, and other objects)Tj
T*
(in the room reflected off the object. \(A classic example of using environment mapping is the evil,)Tj
T*
(morphing cyborg in the film )Tj
/F15 1 Tf
11.6 0 TD
(Terminator 2)Tj
/F11 1 Tf
5.3 0 TD
(.\) The objects whose reflections you see depend on the position)Tj
-16.9 -1.5 TD
(of your eye and on the position and surface angles of the silver object. To perform environment mapping,)Tj
T*
(all you have to do is create an appropriate texture map and then have OpenGL generate the texture)Tj
T*
(coordinates for you.)Tj
0 -2.1 TD
(Environment mapping is an approximation based on the assumption that the items in the environment are)Tj
0 -1.6 TD
(far away compared to the surfaces of the shiny object)Tj
/F33 1 Tf
21.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, it's a small object in a large room. With)Tj
-22.4 -1.6 TD
(this assumption, to find the color of a point on the surface, take the ray from the eye to the surface, and)Tj
0 -1.5 TD
(reflect the ray off the surface. The direction of the reflected ray completely determines the color to be)Tj
T*
(painted there. Encoding a color for each direction on a flat texture map is equivalent to putting a polished)Tj
T*
(perfect sphere in the middle of the environment and taking a picture of it with a camera that has a lens)Tj
T*
(with a very long focal length placed far away. Mathematically, the lens has an infinite focal length and)Tj
T*
(the camera is infinitely far away. The encoding therefore covers a circular region of the texture map,)Tj
T*
(tangent to the top, bottom, left, and right edges of the map. The texture values outside the circle make no)Tj
T*
(difference, as they are never accessed in environment mapping.)Tj
0 -2.1 TD
(To make a perfectly correct environment texture map, you need to obtain a large silvered sphere, take a)Tj
0 -1.5 TD
(photograph of it in some environment with a camera located an infinite distance away and with a lens)Tj
T*
(that has an infinite focal length, and scan in the photograph. To approximate this result, you can use a)Tj
T*
(scanned-in photograph of an environment taken with an extremely wide-angle \(or fish-eye\) lens. Plate 21)Tj
T*
(shows a photograph taken with such a lens and the results when that image is used as an environment)Tj
T*
(map.)Tj
0 -2.1 TD
(Once you've created a texture designed for environment mapping, you need to invoke OpenGL's)Tj
0 -1.5 TD
(environment-mapping algorithm. This algorithm finds the point on the surface of the sphere with the)Tj
T*
(same tangent surface as the point on the object being rendered, and it paints the object's point with the)Tj
T*
(color visible on the sphere at the corresponding point.)Tj
0 -2.1 TD
(To automatically generate the texture coordinates to support environment mapping, use this code in your)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 43)Tj
ET
endstream
endobj
1044 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1045 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im91
/Width 191
/Height 43
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.90)
>>
stream
endstream
endobj
1046 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im92
/Width 102
/Height 41
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.91)
>>
stream
endstream
endobj
1048 0 obj
<<
/Length 7512
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(program:)Tj
/F7 1 Tf
0 -2.1 TD
0.000 Tw
(glTexGeni\(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP\);)Tj
0 -1.5 TD
(glTexGeni\(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP\);)Tj
T*
(glEnable\(GL_TEXTURE_GEN_S\);)Tj
T*
(glEnable\(GL_TEXTURE_GEN_T\);)Tj
/F11 1 Tf
0 -2.1 TD
(The GL_SPHERE_MAP constant creates the proper texture coordinates for the environment mapping.)Tj
0 -1.5 TD
(As shown, you need to specify it for both the )Tj
/F15 1 Tf
18.2 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( and)Tj
/F15 1 Tf
1.7 0 TD
( t)Tj
/F11 1 Tf
0.6 0 TD
( directions. However, you don't have to specify any)Tj
-20.9 -1.5 TD
(parameters for the texture-coordinate generation function.)Tj
0 -2.1 TD
(The GL_SPHERE_MAP texture function generates texture coordinates using the following mathematical)Tj
0 -1.5 TD
(steps.)Tj
0 -2.1 TD
(1.)Tj
/F15 1 Tf
1.8 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( is the unit vector pointing from the origin to the vertex \(in eye coordinates\).)Tj
-2.3 -2.1 TD
(2.)Tj
/F15 1 Tf
1.8 0 TD
(n')Tj
/F11 1 Tf
0.8 0 TD
( is the current normal vector, after transformation to eye coordinates.)Tj
-2.6 -2.4 TD
(3.)Tj
/F15 1 Tf
1.8 0 TD
(r)Tj
/F11 1 Tf
0.4 0 TD
( is the reflection vector, \()Tj
/F15 1 Tf
10 0 TD
(r)Tj
/F11 1 Tf
0.4 -0.2 TD
(x)Tj
/F15 1 Tf
0.5 0.2 TD
(r)Tj
/F11 1 Tf
0.4 -0.2 TD
(y)Tj
/F15 1 Tf
0.5 0.2 TD
(r)Tj
/F11 1 Tf
0.4 -0.2 TD
(z)Tj
0.5 0.2 TD
(\))Tj
0.3 0.3 TD
(T)Tj
0.6 -0.3 TD
(, which is calculated by )Tj
/F15 1 Tf
9.7 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( \255 2)Tj
/F15 1 Tf
1.3 0 TD
(n'n')Tj
/F11 1 Tf
1.7 0.3 TD
(T)Tj
/F15 1 Tf
0.6 -0.3 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(.)Tj
-30.1 -2.3 TD
[(4.)-1050(Then an interim value, )]TJ
/F15 1 Tf
11.1 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
(, is calculated by)Tj
ET
Q
/GS1 gs
q
191 0 0 43 142 411.84 cm
/Im91 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 388.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(.)Tj
0 -2.1 TD
[(1.)-1050(Finally, the )]TJ
/F15 1 Tf
6.6 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(t)Tj
/F11 1 Tf
0.3 0 TD
( texture coordinates are calculated by)Tj
ET
Q
q
102 0 0 41 142 311.84 cm
/Im92 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 288.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(and)Tj
0 -5.5 TD
0.000 Tw
(.)Tj
ET
Q
q
99 0 0 41 126.5 232.84 cm
BI
/W 99
/H 41
/BPC 8
/CS /DeviceGray
ID ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ   ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ    ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ  ˇ  ˇˇˇˇˇˇˇˇˇˇˇˇ ˇ  ˇˇ  ˇˇ ˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇ        ˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇ ˇ ˇ ˇ ˇ ˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇ  ˇˇ  ˇˇ ˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇ         ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇ ˇˇˇ ˇˇˇ ˇˇˇˇˇˇˇ       ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇ        ˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇ ˇˇ ˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇ  ˇˇ ˇˇ ˇˇˇˇ ˇˇˇ ˇˇˇ  ˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ   ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇ ˇ  ˇ ˇˇˇˇˇ ˇˇˇ ˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇ ˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ  ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ ˇˇ ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ    ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ
EI
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 199.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Advanced Features)Tj
10.000 0.000 0.000 10.000 204.000 177.000 Tm
(Advanced)Tj
/F11 1 Tf
-8 -2.2 TD
(This section describes how to manipulate the texture matrix stack and how to use the )Tj
/F15 1 Tf
34.2 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( coordinate. Both)Tj
-34.7 -1.5 TD
(techniques are considered advanced, since you don't need them for many applications of texture)Tj
T*
(mapping.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 97.000 Tm
(The Texture Matrix Stack)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 75.000 Tm
(Just as your model coordinates are transformed by a matrix before being rendered, texture coordinates)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 9,  Texture Mapping - 44)Tj
ET
endstream
endobj
1049 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im91 1045 0 R
/Im92 1046 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1051 0 obj
<<
/Length 4672
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(are multiplied by a 4)Tj
/F33 1 Tf
8.3 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 matrix before any texture mapping occurs. By default, the texture matrix is the)Tj
-8.8 -1.6 TD
(identity, so the texture coordinates you explicitly assign or those that are automatically generated remain)Tj
0 -1.5 TD
(unchanged. By modifying the texture matrix while redrawing an object, however, you can make the)Tj
T*
(texture slide over the surface, rotate around it, stretch and shrink, or any combination of the three. In fact,)Tj
0 -1.6 TD
(since the texture matrix is a completely general 4)Tj
/F33 1 Tf
19.7 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 matrix, effects such as perspective can be achieved.)Tj
-20.2 -2.2 TD
(When the four texture coordinates \()Tj
/F15 1 Tf
14.2 0 TD
(s, t, r, q)Tj
/F11 1 Tf
3.1 0 TD
(\) are multiplied by the texture matrix, the resulting vector \()Tj
/F15 1 Tf
23.6 0 TD
(s')Tj
-40.9 -1.5 TD
(t' r' q')Tj
/F11 1 Tf
2.7 0 TD
(\) is interpreted as homogeneous texture coordinates. In other words, the texture map is indexed by)Tj
/F15 1 Tf
-2.7 -1.5 TD
(s'/q')Tj
/F11 1 Tf
1.8 0 TD
( and)Tj
/F15 1 Tf
1.7 0 TD
( t'/q')Tj
/F11 1 Tf
2 0 TD
( . \(Remember that )Tj
/F15 1 Tf
7.5 0 TD
(r'/q')Tj
/F11 1 Tf
1.8 0 TD
( is ignored in standard OpenGL, but may be used by)Tj
-14.8 -1.5 TD
(implementations that support a 3D texture extension.\) The texture matrix is actually the top matrix on a)Tj
T*
(stack, which must have a stack depth of at least two matrices. All the standard matrix-manipulation)Tj
T*
(commands such as )Tj
/F15 1 Tf
7.7 0 TD
(glPushMatrix\(\))Tj
/F11 1 Tf
6.2 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glMultMatrix\(\))Tj
/F11 1 Tf
6 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
( can be applied to the)Tj
-33.5 -1.5 TD
(texture matrix. To modify the current texture matrix, you need to set the matrix mode to GL_TEXTURE,)Tj
T*
(as follows:)Tj
/F7 1 Tf
0 -2 TD
(glMatrixMode\(GL_TEXTURE\); /* enter texture matrix mode */)Tj
0 -1.5 TD
(glRotated\(...\); )Tj
T*
(/* ... other matrix manipulations ... */)Tj
T*
(glMatrixMode\(GL_MODELVIEW\); /* back to modelview mode */)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 424.000 Tm
(The q Coordinate)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 402.000 Tm
(The mathematics of the )Tj
/F15 1 Tf
9.7 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( coordinate in a general four-dimensional texture coordinate is as described in)Tj
-10.2 -1.5 TD
(the previous section. You can make use of )Tj
/F15 1 Tf
17.2 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( in cases where more than one projection or perspective)Tj
-17.7 -1.5 TD
(transformation is needed. For example, suppose you want to model a spotlight that has some nonuniform)Tj
0 -1.6 TD
(pattern)Tj
/F33 1 Tf
2.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(brighter in the center, perhaps, or noncircular, because of flaps or lenses that modify the shape)Tj
-3.8 -1.6 TD
(of the beam. You can emulate shining such a light on a flat surface by making a texture map that)Tj
0 -1.5 TD
(corresponds to the shape and intensity of a light, and then projecting it on the surface in question using)Tj
T*
(projection transformations. Projecting the cone of light onto surfaces in the scene requires a perspective)Tj
0 -1.6 TD
(transformation \()Tj
/F15 1 Tf
6.5 0 TD
(q)Tj
/F33 1 Tf
0.5 0 TD
(\271)Tj
/F11 1 Tf
0.5 0 TD
( 1\), since the lights might shine on surfaces that aren't perpendicular to them. A)Tj
-7.5 -1.6 TD
(second perspective transformation occurs because the viewer sees the scene from a different \(but)Tj
0 -1.5 TD
[(perspective\) point of view. \(See "Plate 27" in Appendix I)-28( for an example, and see "Fast Shadows and)]TJ
T*
(Lighting Effects Using Texture Mapping" by Mark Segal, Carl Korobkin, Rolf van Widenfelt, Jim Foran,)Tj
T*
(and Paul Haeberli, SIGGRAPH 1992 Proceedings, \()Tj
/F15 1 Tf
20.9 0 TD
(Computer Graphics)Tj
/F11 1 Tf
8 0 TD
(, 26:2, July 1992, p. 249\255252\) for)Tj
-28.9 -1.5 TD
(more details.\))Tj
0 -2.1 TD
(Another example might arise if the texture map to be applied comes from a photograph that itself was)Tj
0 -1.5 TD
(taken in perspective. As with spotlights, the final view depends on the combination of two perspective)Tj
T*
(transformations.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 134.760 m
547.000 134.760 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 45)Tj
ET
endstream
endobj
1052 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1054 0 obj
<<
/Length 3265
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 10)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(The Framebuffer)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Understand what buffers make up the framebuffer and how they're used)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Clear selected buffers and enable them for writing)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Control the parameters of the scissoring, alpha, stencil, and depth-buffer tests that are applied to)Tj
0 -1.5 TD
(pixels)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Perform dithering and logical operations)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use the accumulation buffer for such purposes as scene antialiasing)Tj
-1.9 -2.8 TD
(An important goal of almost every graphics program is to draw pictures on the screen. The screen is)Tj
0 -1.5 TD
(composed of a rectangular array of pixels, each capable of displaying a tiny square of color at that point)Tj
T*
(in the image. After the rasterization stage \(including texturing and fog\), the data are not yet pixels, but)Tj
T*
(are fragments. Each fragment has coordinate data which corresponds to a pixel, as well as color and)Tj
T*
(depth values. Then each fragment undergoes a series of tests and operations, some of which have been)Tj
T*
[(previously described \(See )-18("Blending" in Chapter 6)-22(\))0( and others that are discussed in this chapter.)]TJ
0 -2.1 TD
(If the tests and operations are survived, the fragment values are ready to become pixels. To draw these)Tj
0 -1.5 TD
(pixels, you need to know what color they are, which is the information that's stored in the color buffer.)Tj
T*
(Whenever data is stored uniformly for each pixel, such storage for all the pixels is called a )Tj
/F15 1 Tf
36.4 0 TD
(buffer)Tj
/F11 1 Tf
2.4 0 TD
(.)Tj
-38.8 -1.5 TD
(Different buffers might contain different amounts of data per pixel, but within a given buffer, each pixel)Tj
T*
(is assigned the same amount of data. A buffer that stores a single bit of information about pixels is called)Tj
T*
(a )Tj
/F13 1 Tf
0.7 0 TD
(bitplane)Tj
/F11 1 Tf
3.5 0 TD
(.)Tj
-4.2 -2.1 TD
[(As shown in )-49(Figure 10-1)]TJ
9.9 0 TD
(, the lower-left pixel in an OpenGL window is pixel \(0, 0\), corresponding to the)Tj
-9.9 -1.7 TD
(window coordinates of the lower-left corner of the 1)Tj
/F33 1 Tf
20.9 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(1 region occupied by this pixel. In general, pixel \()Tj
/F15 1 Tf
20 0 TD
(x,)Tj
-41.5 -1.5 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(\) fills the region bounded by )Tj
/F15 1 Tf
11.7 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( on the left, )Tj
/F15 1 Tf
4.8 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(+1 on the right, )Tj
/F15 1 Tf
6.5 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( on the bottom, and )Tj
/F15 1 Tf
8 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(+1 on the top.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 1)Tj
ET
endstream
endobj
1055 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1056 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im93
/Width 296
/Height 240
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.92)
>>
stream
endstream
endobj
1058 0 obj
<<
/Length 3224
>>
stream
/GS1 gs
q
296 0 0 240 124 480 cm
/Im93 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 467.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 10-1 )Tj
/F11 1 Tf
5.6 0 TD
(Region Occupied by a Pixel)Tj
-5.6 -2.1 TD
(As an example of a buffer, let's look more closely at the color buffer, which holds the color information)Tj
0 -1.5 TD
(that's to be displayed on the screen. Assume that the screen is 1280 pixels wide and 1024 pixels high and)Tj
0 -1.8 TD
(that it's a full 24-bit color screen)Tj
/F33 1 Tf
13.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in other words, there are 2)Tj
10.5 0.3 TD
(24)Tj
1 -0.3 TD
( \(or 16,777,216\) different colors that can)Tj
-25.6 -1.6 TD
(be displayed. Since 24 bits translates to 3 bytes \(8 bits/byte\), the color buffer in this example has to store)Tj
0 -1.5 TD
(at least 3 bytes of data for each of the 1,310,720 \(1280*1024\) pixels on the screen. A particular hardware)Tj
T*
(system might have more or fewer pixels on the physical screen as well as more or less color data per)Tj
T*
(pixel. Any particular color buffer, however, has the same amount of data saved for each pixel on the)Tj
T*
(screen.)Tj
0 -2.1 TD
[(The color buffer is only one of several buffers that hold information about a pixel. For example, in )-35("A)]TJ
0 -1.5 TD
[(Hidden-Surface Removal Survival Kit" in Chapter 5)195(,)0( you learned that the depth buffer holds depth)]TJ
T*
(information for each pixel. The color buffer itself can consist of several subbuffers. The )Tj
/F13 1 Tf
35.4 0 TD
(framebuffer)Tj
/F11 1 Tf
5.2 0 TD
( on)Tj
-40.6 -1.5 TD
(a system comprises all of these buffers. With the exception of the color buffer\(s\), you don't view these)Tj
T*
(other buffers directly; instead, you use them to perform such tasks as hidden-surface elimination,)Tj
T*
(antialiasing of an entire scene, stenciling, drawing smooth motion, and other operations.)Tj
0 -2.1 TD
(This chapter describes all the buffers that can exist in an OpenGL implementation and how they're used.)Tj
0 -1.5 TD
(It also discusses the series of tests and pixel operations that are performed before any data is written to)Tj
T*
(the viewable color buffer. Finally, it explains how to use the accumulation buffer, which is used to)Tj
T*
(accumulate images that are drawn into the color buffer. This chapter has the following major sections.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Buffers and Their Uses")20( describes the possible buffers, what they're for, and how to clear them and)]TJ
0 -1.6 TD
(enable them for writing.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Testing and Operating on Fragments")-17( explains the scissoring, alpha, stencil, and depth-buffer tests)]TJ
0 -1.6 TD
(that occur after a pixel's position and color have been calculated but before this information is)Tj
T*
(drawn on the screen. Several operations)Tj
/F33 1 Tf
15.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(blending, dithering, and logical operations)Tj
/F33 1 Tf
17 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(can also be)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 2)Tj
ET
endstream
endobj
1059 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im93 1056 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1061 0 obj
<<
/Length 4415
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(performed before a fragment updates the screen.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("The Accumulation Buffer")48( describes how to perform several advanced techniques using the)]TJ
0 -1.6 TD
(accumulation buffer. These techniques include antialiasing an entire scene, using motion blur, and)Tj
0 -1.5 TD
(simulating photographic depth of field.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 619.000 Tm
(Buffers and Their Uses)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 597.000 Tm
(An OpenGL system can manipulate the following buffers:)Tj
/F33 1 Tf
0.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Color buffers: front-left, front-right, back-left, back-right, and any number of auxiliary color buffers)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Depth buffer)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Stencil buffer)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Accumulation buffer)Tj
-1.9 -2.8 TD
(Your particular OpenGL implementation determines which buffers are available and how many bits per)Tj
0 -1.5 TD
(pixel each holds. Additionally, you can have multiple visuals, or window types, that have different)Tj
T*
[(buffers available. )-7(Table 10-1)191( lists the parameters to use with )]TJ
/F15 1 Tf
24.4 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
( to query your OpenGL)Tj
-30.6 -1.5 TD
(system about per-pixel buffer storage for a particular visual.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(If you're using the X Window System, you're guaranteed, at a minimum, to have a visual with)Tj
-2.8 -1.4 TD
(one color buffer for use in RGBA mode with associated stencil, depth, and accumulation buffers that)Tj
T*
(have color components of nonzero size. Also, if your X Window System implementation supports a)Tj
0 -1.5 TD
(Pseudo-Color visual, you are also guaranteed to have one OpenGL visual that has a color buffer for use)Tj
0 -1.4 TD
(in color-index mode with associated depth and stencil buffers. You'll probably want to use)Tj
/F15 1 Tf
T*
(glXGetConfig\(\))Tj
/F11 1 Tf
6.2 0 TD
[( to query your visuals; see )22(Appendix C)-38( and the )]TJ
/F15 1 Tf
19 0 TD
(OpenGL Reference Manual)Tj
/F11 1 Tf
11.1 0 TD
( for more)Tj
-36.3 -1.5 TD
(information about this routine.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 315.280 m
465.000 315.280 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 308.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Parameter)-14108(Meaning)]TJ
ET
Q
124.000 301.760 m
465.000 301.760 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 294.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(GL_RED_BITS, GL_GREEN_BITS,)Tj
0 -1.1111 TD
(GL_BLUE_BITS,)Tj
T*
(GL_ALPHA_BITS)Tj
16.8889 2.2222 TD
(Number of bits per R, G, B, or A component in the)Tj
0 -1.3333 TD
(color buffers)Tj
-16.8889 -2.3333 TD
[(GL_INDEX_BITS)-9278(Number of bits per index in the color buffers)]TJ
0 -1.5556 TD
[(GL_DEPTH_BITS)-9166(Number of bits per pixel in the depth buffer)]TJ
0 -1.4444 TD
[(GL_STENCIL_BITS)-8277(Number of bits per pixel in the stencil buffer)]TJ
T*
(GL_ACCUM_RED_BITS,)Tj
0 -1.1111 TD
(GL_ACCUM_GREEN_BITS,)Tj
T*
(GL_ACCUM_BLUE_BITS,)Tj
T*
(GL_ACCUM_ALPHA_BITS)Tj
16.8889 3.3333 TD
(Number of bits per R, G, B, or A component in the)Tj
0 -1.3333 TD
(accumulation buffer)Tj
ET
Q
124.000 183.800 m
465.010 183.800 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 168.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 10-1 )Tj
/F11 1 Tf
5.2 0 TD
(Query Parameters for Per-Pixel Buffer Storage)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 139.000 Tm
(Color Buffers)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 117.000 Tm
(The color buffers are the ones to which you usually draw. They contain either color-index or RGB color)Tj
0 -1.5 TD
(data and may also contain alpha values. An OpenGL implementation that supports stereoscopic viewing)Tj
T*
(has left and right color buffers for the left and right stereo images. If stereo isn't supported, only the left)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 3)Tj
ET
endstream
endobj
1062 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1064 0 obj
<<
/Length 4383
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(buffers are used. Similarly, double-buffered systems have front and back buffers, and a single-buffered)Tj
0 -1.5 TD
(system has the front buffers only. Every OpenGL implementation must provide a front-left color buffer.)Tj
0 -2.1 TD
(Optional, nondisplayable auxiliary color buffers may also be supported. OpenGL doesn't specify any)Tj
0 -1.5 TD
(particular uses for these buffers, so you can define and use them however you please. For example, you)Tj
T*
(might use them for saving an image that you use repeatedly. Then rather than redrawing the image, you)Tj
T*
(can just copy it from an auxiliary buffer into the usual color buffers. \(See the description of)Tj
/F15 1 Tf
T*
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
[( in )-22("Reading, Writing, and Copying Pixel Data" in Chapter 8)40( for more information about)]TJ
-6 -1.5 TD
(how to do this.\))Tj
0 -2.1 TD
(You can use GL_STEREO or GL_DOUBLEBUFFER with )Tj
/F15 1 Tf
24.1 0 TD
(glGetBooleanv\(\))Tj
/F11 1 Tf
6.6 0 TD
( to find out if your system)Tj
-30.7 -1.5 TD
(supports stereo \(that is, has left and right buffers\) or double-buffering \(has front and back buffers\). To)Tj
T*
(find out how many, if any, auxiliary buffers are present, use )Tj
/F15 1 Tf
24.2 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
( with GL_AUX_BUFFERS.)Tj
/F27 1 Tf
-30.4 -3 TD
(Depth Buffer)Tj
/F11 1 Tf
0 -2.1 TD
[(The depth buffer stores a depth value for each pixel. As described in )7("A Hidden-Surface Removal)]TJ
0 -1.5 TD
[(Survival Kit" in Chapter 5)20(,)0( depth is usually measured in terms of distance to the eye, so pixels with larger)]TJ
T*
(depth-buffer values are overwritten by pixels with smaller values. This is just a useful convention,)Tj
T*
[(however, and the depth buffer's behavior can be modified as described in )35("Depth Test.")-17( The depth buffer)]TJ
T*
(is sometimes called the )Tj
/F15 1 Tf
9.6 0 TD
(z buffer)Tj
/F11 1 Tf
3 0 TD
( \(the z comes from the fact that )Tj
/F15 1 Tf
12.7 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( values measure horizontal and)Tj
-28.1 -1.5 TD
(vertical displacement on the screen, and the )Tj
/F15 1 Tf
17.7 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( value measures distance perpendicular to the screen\).)Tj
/F27 1 Tf
-18.1 -3 TD
(Stencil Buffer)Tj
/F11 1 Tf
0 -2.1 TD
(One use for the stencil buffer is to restrict drawing to certain portions of the screen, just as a cardboard)Tj
0 -1.5 TD
(stencil can be used with a can of spray paint to make fairly precise painted images. For example, if you)Tj
T*
(want to draw an image as it would appear through an odd-shaped windshield, you can store an image of)Tj
T*
(the windshield's shape in the stencil buffer, and then draw the entire scene. The stencil buffer prevents)Tj
T*
(anything that wouldn't be visible through the windshield from being drawn. Thus, if your application is a)Tj
T*
(driving simulation, you can draw all the instruments and other items inside the automobile once, and as)Tj
T*
(the car moves, only the outside scene need be updated.)Tj
/F27 1 Tf
0 -3 TD
(Accumulation Buffer)Tj
/F11 1 Tf
0 -2.1 TD
(The accumulation buffer holds RGBA color data just like the color buffers do in RGBA mode. \(The)Tj
0 -1.5 TD
(results of using the accumulation buffer in color-index mode are undefined.\) It's typically used for)Tj
T*
(accumulating a series of images into a final, composite image. With this method, you can perform)Tj
T*
(operations like scene antialiasing by supersampling an image and then averaging the samples to produce)Tj
T*
(the values that are finally painted into the pixels of the color buffers. You don't draw directly into the)Tj
T*
(accumulation buffer; accumulation operations are always performed in rectangular blocks, which are)Tj
T*
(usually transfers of data to or from a color buffer.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 112.000 Tm
(Clearing Buffers)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 91.000 Tm
(In graphics programs, clearing the screen \(or any of the buffers\) is typically one of the most expensive)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 4)Tj
ET
endstream
endobj
1065 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1067 0 obj
<<
/Length 4704
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(operations you can perform)Tj
/F33 1 Tf
11 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(on a 1280)Tj
/F33 1 Tf
4 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(1024 monitor, it requires touching well over a million pixels.)Tj
-16.5 -1.6 TD
(For simple graphics applications, the clear operation can take more time than the rest of the drawing. If)Tj
0 -1.5 TD
(you need to clear not only the color buffer but also the depth and stencil buffers, the clear operation can)Tj
T*
(be three times as expensive.)Tj
0 -2.1 TD
(To address this problem, some machines have hardware that can clear more than one buffer at once. The)Tj
0 -1.5 TD
(OpenGL clearing commands are structured to take advantage of architectures like this. First, you specify)Tj
T*
(the values to be written into each buffer to be cleared. Then you issue a single command to perform the)Tj
T*
(clear operation, passing in a list of all the buffers to be cleared. If the hardware is capable of)Tj
T*
(simultaneous clears, they all occur at once; otherwise, each buffer is cleared sequentially.)Tj
0 -2.1 TD
(The following commands set the clearing values for each buffer.)Tj
/F15 1 Tf
T*
[(void )-28(glClearColor)-9(\(GLclampf )84(red)-67(, GLclampf )51(green)-23(, GLclampf )-49(blue)22(,)]TJ
0 -1.1 TD
0.050 Tw
[(GLclampf alpha)78(\);)]TJ
T*
0.028 Tw
[(void glClearIndex)78(\(GLfloat )23(index)-34(\);)]TJ
T*
[(void glClearDepth\(GLclampd )34(depth)22(\);)]TJ
T*
[(void glClearStencil)-21(\(GLint )45(s)-11(\))0(;)]TJ
T*
0.001 Tw
[(void )-27(glClearAccum)78(\(GLfloat red)-67(, GLfloat )63(green)-23(, GLfloat )-37(blue)22(,)]TJ
T*
0.038 Tw
[(GLfloat alpha)78(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Specifies the current clearing values for the color buffer \(in RGBA mode\), the color buffer \(in)Tj
T*
(color-index mode\), the depth buffer, the stencil buffer, and the accumulation buffer. The GLclampf)Tj
T*
(and GLclampd types \(clamped GLfloat and clamped GLdouble\) are clamped to be between 0.0 and)Tj
T*
(1.0. The default depth-clearing value is 1.0; all the other default clearing values are 0. The values)Tj
T*
(set with the clear commands remain in effect until they're changed by another call to the same)Tj
T*
(command.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(After you've selected your clearing values and you're ready to clear the buffers, use )Tj
/F15 1 Tf
33.9 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.7 0 TD
(.)Tj
/F15 1 Tf
-37.6 -2.1 TD
0.028 Tw
[(void glClear)56(\(GLbitfield )24(mask)-45(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Clears the specified buffers. The value of )-32(mask)55( is the bitwise logical OR of some combination of)]TJ
T*
(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT, and)Tj
T*
(GL_ACCUM_BUFFER_BIT to identify which buffers are to be cleared. GL_COLOR_BUFFER_BIT)Tj
T*
(clears either the RGBA color or the color-index buffer, depending on the mode of the system at the)Tj
T*
(time. When you clear the color or color-index buffer, all the color buffers that are enabled for)Tj
T*
(writing \(see the next section\) are cleared. The pixel ownership test, scissor test, and dithering, if)Tj
T*
[(enabled, are applied to the clearing operation. Masking operations, such as )-31(glColorMask\(\))45( and)]TJ
T*
[(glIndexMask\(\))32(, are also effective. The alpha test, stencil test, and depth test do not affect the)]TJ
T*
[(operation of )-32(glClear\(\))22(.)]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 179.000 Tm
(Selecting Color Buffers for Writing and Reading)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 158.000 Tm
(The results of a drawing or reading operation can go into or come from any of the color buffers: front,)Tj
T*
(back, front-left, back-left, front-right, back-right, or any of the auxiliary buffers. You can choose an)Tj
T*
(individual buffer to be the drawing or reading target. For drawing, you can also set the target to draw into)Tj
T*
(more than one buffer at the same time. You use )Tj
/F15 1 Tf
19.2 0 TD
(glDrawBuffer\(\))Tj
/F11 1 Tf
6.3 0 TD
( to select the buffers to be written and)Tj
/F15 1 Tf
-25.5 -1.5 TD
(glReadBuffer\(\))Tj
/F11 1 Tf
6 0 TD
( to select the buffer as the source for )Tj
/F15 1 Tf
14.8 0 TD
(glReadPixels\(\))Tj
/F11 1 Tf
5.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glCopyTexImage*\(\))Tj
/F11 1 Tf
8 0 TD
(,)Tj
-41.7 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(glCopyTexSubImage*\(\))Tj
/F11 1 Tf
9.5 0 TD
(.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 5)Tj
ET
endstream
endobj
1068 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1072 0 obj
<<
/Length 4058
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(If you are using double-buffering, you usually want to draw only in the back buffer \(and swap the buffers)Tj
0 -1.5 TD
(when you're finished drawing\). In some situations, you might want to treat a double-buffered window as)Tj
T*
(though it were single-buffered by calling )Tj
/F15 1 Tf
16.6 0 TD
(glDrawBuffer\(\))Tj
/F11 1 Tf
6.2 0 TD
( to enable you to draw to both front and back)Tj
-22.8 -1.5 TD
(buffers at the same time.)Tj
/F15 1 Tf
0 -2.1 TD
(glDrawBuffer\(\))Tj
/F11 1 Tf
6.2 0 TD
( is also used to select buffers to render stereo images \(GL*LEFT and GL*RIGHT\) and to)Tj
-6.2 -1.5 TD
(render into auxiliary buffers \(GL_AUX)Tj
/F15 1 Tf
15.8 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
(\).)Tj
/F15 1 Tf
-16.1 -2.1 TD
0.028 Tw
[(void glDrawBuffer)57(\(GLenum )-45(mode)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Selects the color buffers enabled for writing or clearing. Disables buffers enabled by previous calls)Tj
T*
[(to )28(glDrawBuffer\(\))-77(. More than one buffer may be enabled at one time. The value of )44(mode)-34( can be one)]TJ
T*
(of the following:)Tj
/F11 1 Tf
-1.8 -1.1 TD
[(GL_FRONT)-6388(GL_FRONT_LEFT)-5799(GL_AUX)]TJ
/F15 1 Tf
29.3 0 TD
(i)Tj
/F11 1 Tf
-29.3 -1.4 TD
[(GL_BACK)-6889(GL_FRONT_RIGHT)-5133(GL_FRONT_AND_BACK)]TJ
0 -1.5 TD
[(GL_LEFT)-7278(GL_BACK_LEFT)-6299(GL_NONE)]TJ
0 -1.4 TD
[(GL_RIGHT)-6611(GL_BACK_RIGHT)]TJ
/F15 1 Tf
1.8 -1.5 TD
(Arguments that omit LEFT or RIGHT refer to both the left and right buffers; similarly, arguments)Tj
T*
[(that omit FRONT or BACK refer to both. The )48(i)-22( in GL_AUXi)-22( is a digit identifying a particular)]TJ
T*
(auxiliary buffer.)Tj
T*
[(By default, )-16(mode)66( is GL_FRONT for single-buffered contexts and GL_BACK for double-buffered)]TJ
T*
(contexts.)Tj
/F27 1 Tf
-1.8 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(You can enable drawing to nonexistent buffers as long as you enable drawing to at least one)Tj
-2.8 -1.4 TD
(buffer that does exist. If none of the specified buffers exist, an error results.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glReadBuffer)34(\(GLenum )55(mode)-34(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Selects the color buffer enabled as the source for reading pixels for subsequent calls to)Tj
T*
[(glReadPixels\(\))44(, glCopyPixels\(\), glCopyTexImage*\(\), and )-50(glCopyTexSubImage*\(\). Disables buffers)]TJ
T*
[(enabled by previous calls to )-28(glReadBuffer\(\). The value of mode)66( can be one of the following:)]TJ
/F11 1 Tf
-1.8 -1.1 TD
[(GL_FRONT)-8688(GL_FRONT_LEFT)-5799(GL_AUX)]TJ
/F15 1 Tf
31.6 0 TD
(i)Tj
/F11 1 Tf
-31.6 -1.4 TD
[(GL_BACK)-9189(GL_FRONT_RIGHT)]TJ
0 -1.5 TD
[(GL_LEFT)-9578(GL_BACK_LEFT)]TJ
0 -1.4 TD
[(GL_RIGHT)-8911(GL_BACK_RIGHT)]TJ
/F15 1 Tf
1.8 -1.5 TD
[(By default, )-16(mode)66( is GL_FRONT for single-buffered contexts and GL_BACK for double-buffered)]TJ
T*
(contexts.)Tj
/F27 1 Tf
-1.8 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(You must enable reading from a buffer that does exist or an error results.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 200.000 Tm
(Masking Buffers)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 178.000 Tm
(Before OpenGL writes data into the enabled color, depth, or stencil buffers, a masking operation is)Tj
0 -1.5 TD
(applied to the data, as specified with one of the following commands. A bitwise logical AND is)Tj
T*
(performed with each mask and the corresponding data to be written.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glIndexMask)66(\(GLuint )-55(mask)55(\);)]TJ
0 -1.1 TD
0.000 Tw
[(void )-28(glColorMask)-21(\(GLboolean )84(red)-67(, GLboolean )51(green)-23(, GLboolean )51(blue)-78(,)]TJ
T*
0.049 Tw
[(GLboolean alpha)78(\);)]TJ
T*
0.028 Tw
[(void glDepthMask)-11(\(GLboolean )112(flag)-44(\);)]TJ
T*
[(void glStencilMask)67(\(GLuint )-55(mask)55(\);)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 6)Tj
ET
endstream
endobj
1073 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1075 0 obj
<<
/Length 4961
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(Sets the masks used to control writing into the indicated buffers. The mask set by )-41(glIndexMask\(\))]TJ
0 -1.5 TD
(applies only in color-index mode. If a 1 appears in )Tj
20.5 0 TD
[(mask)-45(, the corresponding bit in the color-index)]TJ
-20.5 -1.5 TD
[(buffer is written; where a 0 appears, the bit isn't written. Similarly, glColorMask\(\))45( affects drawing)]TJ
T*
[(in RGBA mode only. The )22(red)-67(, green)77(, blue)-78(, and )50(alpha)-22( values control whether the corresponding)]TJ
T*
[(component is written. \(GL_TRUE means it is written.\) If )9(flag)-44( is GL_TRUE for )13(glDepthMask\(\))55(, the)]TJ
T*
[(depth buffer is enabled for writing; otherwise, it's disabled. The mask for )16(glStencilMask\(\))33( is used for)]TJ
T*
(stencil data in the same way as the mask is used for color-index data in )Tj
28.8 0 TD
[(glIndexMask\(\))32(. The default)]TJ
-28.8 -1.5 TD
(values of all the GLboolean masks are GL_TRUE, and the default values for the two GLuint masks)Tj
T*
(are all 1's.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(You can do plenty of tricks with color masking in color-index mode. For example, you can use each bit)Tj
0 -1.5 TD
(in the index as a different layer and set up interactions between arbitrary layers with appropriate settings)Tj
T*
(of the color map. You can create overlays and underlays, and do so-called color-map animations. \(See)Tj
T*
[(Chapter 14)16( for examples of using color masking.\) Masking in RGBA mode is useful less often, but you)]TJ
T*
(can use it for loading separate image files into the red, green, and blue bitplanes, for example.)Tj
0 -2.1 TD
[(You've seen one use for disabling the depth buffer in )-46("Three-Dimensional Blending with the Depth)]TJ
0 -1.5 TD
[(Buffer" in Chapter 6)13(.)0( Disabling the depth buffer for writing can also be useful if a common background)]TJ
T*
(is desired for a series of frames, and you want to add some features that may be obscured by parts of the)Tj
T*
(background. For example, suppose your background is a forest, and you would like to draw repeated)Tj
T*
(frames with the same trees, but with objects moving among them. After the trees are drawn with their)Tj
T*
(depths recorded in the depth buffer, then the image of the trees is saved, and the new items are drawn)Tj
T*
(with the depth buffer disabled for writing. As long as the new items don't overlap each other, the picture)Tj
T*
(is correct. To draw the next frame, restore the image of the trees and continue. You don't need to restore)Tj
0 -1.6 TD
(the values in the depth buffer. This trick is most useful if the background is extremely complex)Tj
/F33 1 Tf
38 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(so)Tj
-39 -1.6 TD
(complex that it's much faster just to recopy the image into the color buffer than to recompute it from the)Tj
0 -1.5 TD
(geometry.)Tj
0 -2.1 TD
(Masking the stencil buffer can allow you to use a multiple-bit stencil buffer to hold multiple stencils \(one)Tj
0 -1.5 TD
[(per bit\). You might use this technique to perform capping as explained in )-44("Stencil Test")67( or to implement)]TJ
T*
[(the Game of Life as described in "Life in the Stencil Buffer" in Chapter 14)-34(.)]TJ
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(The mask specified by )Tj
/F15 1 Tf
9.3 0 TD
(glStencilMask\(\))Tj
/F11 1 Tf
6.3 0 TD
( controls which stencil bitplanes are written. This mask)Tj
-18.4 -1.4 TD
(isn't related to the mask that's specified as the third parameter of )Tj
/F15 1 Tf
26.2 0 TD
(glStencilFunc\(\))Tj
/F11 1 Tf
6.2 0 TD
(, which specifies which)Tj
-32.4 -1.4 TD
(bitplanes are considered by the stencil function.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 203.000 Tm
(Testing and Operating on Fragments)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 181.000 Tm
(When you draw geometry, text, or images on the screen, OpenGL performs several calculations to rotate,)Tj
0 -1.5 TD
(translate, scale, determine the lighting, project the object\(s\) into perspective, figure out which pixels in)Tj
T*
(the window are affected, and determine what colors those pixels should be drawn. Many of the earlier)Tj
T*
(chapters in this book give some information about how to control these operations. After OpenGL)Tj
T*
(determines that an individual fragment should be generated and what its color should be, several)Tj
T*
(processing stages remain that control how and whether the fragment is drawn as a pixel into the)Tj
T*
(framebuffer. For example, if it's outside a rectangular region or if it's farther from the viewpoint than the)Tj
T*
(pixel that's already in the framebuffer, it isn't drawn. In another stage, the fragment's color is blended)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 7)Tj
ET
endstream
endobj
1076 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1078 0 obj
<<
/Length 3689
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(with the color of the pixel already in the framebuffer.)Tj
0 -2.1 TD
(This section describes both the complete set of tests that a fragment must pass before it goes into the)Tj
0 -1.5 TD
(framebuffer and the possible final operations that can be performed on the fragment as it's written. The)Tj
T*
(tests and operations occur in the following order; if a fragment is eliminated in an early test, none of the)Tj
T*
(later tests or operations take place.)Tj
0 -2.1 TD
[(1.)-1050(Scissor test)]TJ
T*
[(2.)-1050(Alpha test)]TJ
T*
[(3.)-1050(Stencil test)]TJ
T*
[(4.)-1050(Depth test)]TJ
T*
[(5.)-1050(Blending)]TJ
T*
[(6.)-1050(Dithering)]TJ
T*
[(7.)-1050(Logical operation)]TJ
0 -2.6 TD
(Each of these tests and operations is described in detail in the following sections.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 441.000 Tm
(Scissor Test)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 420.000 Tm
(You can define a rectangular portion of your window and restrict drawing to take place within it by using)Tj
0 -1.5 TD
(the )Tj
/F15 1 Tf
1.5 0 TD
(glScissor\(\))Tj
/F11 1 Tf
4.3 0 TD
( command. If a fragment lies inside the rectangle, it passes the scissor test.)Tj
/F15 1 Tf
-5.8 -2.1 TD
[(void )-28(glScissor)67(\(GLint )-83(x)44(,)0( GLint )-16(y)44(,)0( GLsizei )6(width)-77(, GLsizei )6(height\);)]TJ
1.8 -1.5 TD
(Sets the location and size of the scissor rectangle \(also known as the scissor box\). The parameters)Tj
T*
(define the lower-left corner \()Tj
11.6 0 TD
[(x)44(,)0( y)44(\), and the width and height of the rectangle. Pixels that lie inside the)]TJ
-11.6 -1.5 TD
(rectangle pass the scissor test. Scissoring is enabled and disabled by passing GL_SCISSOR_TEST to)Tj
T*
[(glEnable\(\))-23( and glDisable\(\))56(. By default, the rectangle matches the size of the window and scissoring)]TJ
T*
(is disabled.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(The scissor test is just a version of a stencil test using a rectangular region of the screen. It's fairly easy to)Tj
0 -1.5 TD
(create a blindingly fast hardware implementation of scissoring, while a given system might be much)Tj
0 -1.6 TD
(slower at stenciling)Tj
/F33 1 Tf
7.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(perhaps because the stenciling is performed in software.)Tj
/F27 1 Tf
-0.8 -2.3 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(An advanced use of scissoring is performing nonlinear projection. First divide the window into a regular)Tj
0 -1.5 TD
(grid of subregions, specifying viewport and scissor parameters that limit rendering to one region at a)Tj
T*
(time. Then project the entire scene to each region using a different projection matrix.)Tj
0 -2.1 TD
(To determine whether scissoring is enabled and to obtain the values that define the scissor rectangle, you)Tj
0 -1.5 TD
(can use GL_SCISSOR_TEST with )Tj
/F15 1 Tf
14.3 0 TD
(glIsEnabled\(\))Tj
/F11 1 Tf
5.5 0 TD
( and GL_SCISSOR_BOX with )Tj
/F15 1 Tf
12.7 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
(.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 119.000 Tm
(Alpha Test)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 97.000 Tm
(In RGBA mode, the alpha test allows you to accept or reject a fragment based on its alpha value. The)Tj
0 -1.5 TD
(alpha test is enabled and disabled by passing GL_ALPHA_TEST to )Tj
/F15 1 Tf
27.4 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.5 0 TD
(. To)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 8)Tj
ET
endstream
endobj
1079 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1081 0 obj
<<
/Length 5219
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(determine whether the alpha test is enabled, use GL_ALPHA_TEST with )Tj
/F15 1 Tf
29.7 0 TD
(glIsEnabled\(\))Tj
/F11 1 Tf
5.5 0 TD
(.)Tj
-35.2 -2.1 TD
(If enabled, the test compares the incoming alpha value with a reference value. The fragment is accepted)Tj
0 -1.5 TD
(or rejected depending on the result of the comparison. Both the reference value and the comparison)Tj
T*
(function are set with )Tj
/F15 1 Tf
8.4 0 TD
(glAlphaFunc\(\))Tj
/F11 1 Tf
5.9 0 TD
(. By default, the reference value is zero, the comparison function is)Tj
-14.3 -1.5 TD
(GL_ALWAYS, and the alpha test is disabled. To obtain the alpha comparison function or reference)Tj
T*
(value, use GL_ALPHA_TEST_FUNC or GL_ALPHA_TEST_REF with )Tj
/F15 1 Tf
29.5 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
(.)Tj
/F15 1 Tf
-35.7 -2.1 TD
0.028 Tw
[(void glAlphaFunc)23(\(GLenum )55(func)22(, )28(GLclampf )-21(ref)11(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Sets the reference value and comparison function for the alpha test. The reference value )27(ref)11( is)]TJ
T*
[(clamped to be between zero and one. The possible values for )-44(func)22( and their meaning are listed in)]TJ
T*
(Table 10-2)Tj
4.4 0 TD
(.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 552.840 m
463.000 552.840 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 545.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Parameter)-6983(Meaning)]TJ
ET
Q
124.000 539.320 m
463.000 539.320 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 531.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_NEVER)-5389(Never accept the fragment)]TJ
0 -1.4444 TD
[(GL_ALWAYS)-4445(Always accept the fragment)]TJ
T*
[(GL_LESS)-6388(Accept fragment if fragment alpha < reference alpha)]TJ
T*
(GL_LEQUAL)Tj
10.5556 -0.1111 TD
(Accept fragment if fragment alpha )Tj
/F33 1 Tf
14.1111 0 TD
(\243)Tj
/F11 1 Tf
0.5556 0 TD
( reference alpha)Tj
-25.2222 -1.5556 TD
[(GL_EQUAL)-5334(Accept fragment if fragment alpha = reference alpha)]TJ
0 -1.4444 TD
(GL_GEQUAL)Tj
10.5556 -0.1111 TD
(Accept fragment if fragment alpha  )Tj
/F33 1 Tf
14.3333 0 TD
(\263)Tj
/F11 1 Tf
0.5555 0 TD
( reference alpha)Tj
-25.4444 -1.4444 TD
[(GL_GREATER)-4111(Accept fragment if fragment alpha > reference alpha)]TJ
T*
(GL_NOTEQUAL)Tj
10.5556 -0.1111 TD
(Accept fragment if fragment alpha )Tj
/F33 1 Tf
14.1111 0 TD
(\271)Tj
/F11 1 Tf
0.5556 0 TD
( reference alpha)Tj
ET
Q
124.000 427.370 m
463.010 427.370 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 411.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 10-2 )Tj
/F11 1 Tf
5.2 0 TD
(glAlphaFunc\(\) Parameter Values \(continued\))Tj
-5.2 -2.1 TD
(One application for the alpha test is to implement a transparency algorithm. Render your entire scene)Tj
0 -1.5 TD
(twice, the first time accepting only fragments with alpha values of one, and the second time accepting)Tj
T*
(fragments with alpha values that aren't equal to one. Turn the depth buffer on during both passes, but)Tj
T*
(disable depth buffer writing during the second pass.)Tj
0 -2.1 TD
(Another use might be to make decals with texture maps where you can see through certain parts of the)Tj
0 -1.5 TD
(decals. Set the alphas in the decals to 0.0 where you want to see through, set them to 1.0 otherwise, set)Tj
T*
(the reference value to 0.5 \(or anything between 0.0 and 1.0\), and set the comparison function to)Tj
T*
(GL_GREATER. The decal has see-through parts, and the values in the depth buffer aren't affected. This)Tj
T*
[(technique, called billboarding, is described in )44("Sample Uses of Blending" in Chapter 6)6(.)]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 235.000 Tm
(Stencil Test)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 214.000 Tm
(The stencil test takes place only if there is a stencil buffer. \(If there is no stencil buffer, the stencil test)Tj
T*
(always passes.\) Stenciling applies a test that compares a reference value with the value stored at a pixel)Tj
T*
(in the stencil buffer. Depending on the result of the test, the value in the stencil buffer is modified. You)Tj
T*
(can choose the particular comparison function used, the reference value, and the modification performed)Tj
T*
(with the )Tj
/F15 1 Tf
3.5 0 TD
(glStencilFunc\(\))Tj
/F11 1 Tf
6.2 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glStencilOp\(\))Tj
/F11 1 Tf
5.4 0 TD
( commands.)Tj
/F15 1 Tf
-17.1 -2.1 TD
[(void )-28(glStencilFunc)56(\(GLenum )-73(func)22(, GLint )-16(ref)11(, GLuint )-16(mask)55(\);)]TJ
1.8 -1.5 TD
[(Sets the comparison function \()-33(func)22(\), reference value \()9(ref)11(\), and a mask \()-28(mask)55(\) for use with the stencil)]TJ
T*
(test. The reference value is compared to the value in the stencil buffer using the comparison)Tj
T*
(function, but the comparison applies only to those bits where the corresponding bits of the mask are)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 9)Tj
ET
endstream
endobj
1082 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1084 0 obj
<<
/Length 4951
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(1. The function can be GL_NEVER, GL_ALWAYS, GL_LESS, GL_LEQUAL, GL_EQUAL,)Tj
0 -1.5 TD
(GL_GEQUAL, GL_GREATER, or GL_NOTEQUAL. If it's GL_LESS, for example, then the)Tj
T*
[(fragment passes if )29(ref)11( is less than the value in the stencil buffer. If the stencil buffer contains )-42(s)]TJ
T*
(bitplanes, the low-order )Tj
9.9 0 TD
[(s)-11( bits of )-27(mask)55( are bitwise ANDed with the value in the stencil buffer and)]TJ
-9.9 -1.5 TD
(with the reference value before the comparison is performed. The masked values are all interpreted)Tj
T*
(as nonnegative values. The stencil test is enabled and disabled by passing GL_STENCIL_TEST to)Tj
T*
[(glEnable\(\))-23( and glDisable\(\))56(. By default, )-16(func)22( is GL_ALWAYS, )13(ref)-89( is 0, )67(mask)-45( is all 1's, and stenciling)]TJ
T*
(is disabled.)Tj
-1.8 -2.1 TD
[(void )-28(glStencilOp)23(\(GLenum )27(fail)-66(, GLenum )94(zfail)-77(, GLenum )-6(zpass)67(\);)]TJ
1.8 -1.5 TD
(Specifies how the data in the stencil buffer is modified when a fragment passes or fails the stencil)Tj
T*
[(test. The three functions )-38(fail)34(, zfail)23(, and )-50(zpass)67( can be GL_KEEP, GL_ZERO, GL_REPLACE)-48(,)]TJ
T*
(GL_INCR, GL_DECR, or GL_INVERT. They correspond to keeping the current value, replacing it)Tj
T*
(with zero, replacing it with the reference value, incrementing it, decrementing it, and)Tj
T*
(bitwise-inverting it. The result of the increment and decrement functions is clamped to lie between)Tj
0 -1.8 TD
(zero and the maximum unsigned integer value \(2)Tj
19.5 0.3 TD
(s)Tj
0.4 -0.3 TD
(-1 if the stencil buffer holds )Tj
11.3 0 TD
[(s)-11( bits\). The )-22(fail)]TJ
-31.2 -1.5 TD
[(function is applied if the fragment fails the stencil test; if it passes, then )10(zfail)23( is applied if the depth)]TJ
T*
[(test fails and )-37(zpass)67( if the depth test passes, or if no depth test is performed. \(See )13("Depth Test.")-48(\) By)]TJ
T*
(default, all three stencil operations are GL_KEEP.)Tj
/F27 1 Tf
-1.8 -3 TD
(Stencil Queries)Tj
/F11 1 Tf
0 -2.1 TD
(You can obtain the values for all six stencil-related parameters by using the query function)Tj
/F15 1 Tf
0 -1.5 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
[( and one of the values shown in )-11(Table 10-3)192(. You can also determine whether the stencil)]TJ
-6.2 -1.5 TD
(test is enabled by passing GL_STENCIL_TEST to )Tj
/F15 1 Tf
20.5 0 TD
(glIsEnabled\(\))Tj
/F11 1 Tf
5.5 0 TD
(.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 355.000 m
468.000 355.000 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 347.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Query Value)-15538(Meaning)]TJ
ET
Q
124.000 341.480 m
468.000 341.480 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 333.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_STENCIL_FUNC)-9888(Stencil function)]TJ
0 -1.4444 TD
[(GL_STENCIL_REF)-10721(Stencil reference value)]TJ
T*
[(GL_STENCIL_VALUE_MASK)-5777(Stencil mask)]TJ
T*
[(GL_STENCIL_FAIL)-10333(Stencil fail action)]TJ
T*
[(GL_STENCIL_PASS_DEPTH_FAIL)-3720(Stencil pass and depth buffer fail action)]TJ
T*
[(GL_STENCIL_PASS_DEPTH_PASS)-3552(Stencil pass and depth buffer pass action)]TJ
ET
Q
124.000 260.670 m
468.010 260.670 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 244.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 10-3 )Tj
/F11 1 Tf
5.2 0 TD
(Query Values for the Stencil Test \(continued\))Tj
/F27 1 Tf
-5.2 -3 TD
(Stencil Examples)Tj
/F11 1 Tf
0 -2.1 TD
(Probably the most typical use of the stencil test is to mask out an irregularly shaped region of the screen)Tj
0 -1.5 TD
[(to prevent drawing from occurring within it \(as in the windshield example in )17("Buffers and Their Uses")20(\).)]TJ
T*
(To do this, fill the stencil mask with zeros, and then draw the desired shape in the stencil buffer with 1's.)Tj
T*
(You can't draw geometry directly into the stencil buffer, but you can achieve the same result by drawing)Tj
T*
(into the color buffer and choosing a suitable value for the )Tj
/F15 1 Tf
23.2 0 TD
(zpass)Tj
/F11 1 Tf
2.2 0 TD
( function \(such as GL_REPLACE\). \(You)Tj
-25.4 -1.5 TD
(can use )Tj
/F15 1 Tf
3.2 0 TD
(glDrawPixels\()Tj
/F11 1 Tf
5.9 0 TD
(\) to draw pixel data directly into the stencil buffer.\) Whenever drawing occurs, a)Tj
-9.1 -1.5 TD
(value is also written into the stencil buffer \(in this case, the reference value\). To prevent the stencil-buffer)Tj
T*
(drawing from affecting the contents of the color buffer, set the color mask to zero \(or GL_FALSE\). You)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 10)Tj
ET
endstream
endobj
1085 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1087 0 obj
<<
/Length 2360
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(might also want to disable writing into the depth buffer.)Tj
0 -2.1 TD
(After you've defined the stencil area, set the reference value to one, and the comparison function such)Tj
0 -1.5 TD
(that the fragment passes if the reference value is equal to the stencil-plane value. During drawing, don't)Tj
T*
(modify the contents of the stencil planes.)Tj
0 -2.1 TD
(Example 10-1)Tj
5.6 0 TD
( demonstrates how to use the stencil test in this way. Two tori are drawn, with a)Tj
-5.6 -1.5 TD
(diamond-shaped cutout in the center of the scene. Within the diamond-shaped stencil mask, a sphere is)Tj
T*
(drawn. In this example, drawing into the stencil buffer takes place only when the window is redrawn, so)Tj
T*
(the color buffer is cleared after the stencil mask has been created.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 10-1 )Tj
/F11 1 Tf
6.7 0 TD
(Using the Stencil Test: stencil.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(#define YELLOWMAT   1)Tj
0 -1.5 TD
(#define BLUEMAT 2)Tj
0 -3 TD
(void init \(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat yellow_diffuse[] = { 0.7, 0.7, 0.0, 1.0 };)Tj
T*
(   GLfloat yellow_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
0 -3 TD
(   GLfloat blue_diffuse[] = { 0.1, 0.1, 0.7, 1.0 };)Tj
0 -1.5 TD
(   GLfloat blue_specular[] = { 0.1, 1.0, 1.0, 1.0 };)Tj
0 -3 TD
(   GLfloat position_one[] = { 1.0, 1.0, 1.0, 0.0 };)Tj
T*
(   glNewList\(YELLOWMAT, GL_COMPILE\);)Tj
0 -1.5 TD
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, yellow_diffuse\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, yellow_specular\);)Tj
T*
(   glMaterialf\(GL_FRONT, GL_SHININESS, 64.0\);)Tj
T*
(   glEndList\(\);)Tj
0 -3 TD
(   glNewList\(BLUEMAT, GL_COMPILE\);)Tj
0 -1.5 TD
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, blue_diffuse\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, blue_specular\);)Tj
T*
(   glMaterialf\(GL_FRONT, GL_SHININESS, 45.0\);)Tj
T*
(   glEndList\(\);)Tj
0 -3 TD
(   glLightfv\(GL_LIGHT0, GL_POSITION, position_one\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 11)Tj
ET
endstream
endobj
1088 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1090 0 obj
<<
/Length 1834
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glEnable\(GL_LIGHT0\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHTING\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
0 -3 TD
(   glClearStencil\(0x0\);)Tj
0 -1.5 TD
(   glEnable\(GL_STENCIL_TEST\);)Tj
T*
(})Tj
0 -3 TD
(/* Draw a sphere in a diamond-shaped section in the)Tj
0 -1.5 TD
( * middle of a window with 2 tori.)Tj
T*
( */)Tj
T*
(void display\(void\))Tj
T*
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
0 -3 TD
(/* draw blue sphere where the stencil is 1 */)Tj
0 -1.5 TD
(   glStencilFunc \(GL_EQUAL, 0x1, 0x1\);)Tj
T*
(   glStencilOp \(GL_KEEP, GL_KEEP, GL_KEEP\);)Tj
T*
(   glCallList \(BLUEMAT\);)Tj
T*
(   glutSolidSphere \(0.5, 15, 15\);)Tj
0 -3 TD
(/* draw the tori where the stencil is not 1 */)Tj
0 -1.5 TD
(   glStencilFunc \(GL_NOTEQUAL, 0x1, 0x1\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(      glRotatef \(45.0, 0.0, 0.0, 1.0\);)Tj
T*
(      glRotatef \(45.0, 0.0, 1.0, 0.0\);)Tj
T*
(      glCallList \(YELLOWMAT\);)Tj
T*
(      glutSolidTorus \(0.275, 0.85, 15, 15\);)Tj
T*
(      glPushMatrix\(\);)Tj
T*
(         glRotatef \(90.0, 1.0, 0.0, 0.0\);)Tj
T*
(         glutSolidTorus \(0.275, 0.85, 15, 15\);)Tj
T*
(      glPopMatrix\(\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(})Tj
0 -3 TD
(/*  Whenever the window is reshaped, redefine the )Tj
0 -1.5 TD
( *  coordinate system and redraw the stencil area.)Tj
T*
( */)Tj
T*
(void reshape\(int w, int h\))Tj
T*
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
0 -3 TD
(/* create a diamond shaped stencil area */)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 12)Tj
ET
endstream
endobj
1091 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1093 0 obj
<<
/Length 1931
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      gluOrtho2D\(-3.0, 3.0, -3.0*\(GLfloat\)h/\(GLfloat\)w,)Tj
T*
(                 3.0*\(GLfloat\)h/\(GLfloat\)w\);)Tj
T*
(   else)Tj
T*
(      gluOrtho2D\(-3.0*\(GLfloat\)w/\(GLfloat\)h,)Tj
T*
(                 3.0*\(GLfloat\)w/\(GLfloat\)h, -3.0, 3.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
0 -3 TD
(   glClear\(GL_STENCIL_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glStencilFunc \(GL_ALWAYS, 0x1, 0x1\);)Tj
T*
(   glStencilOp \(GL_REPLACE, GL_REPLACE, GL_REPLACE\);)Tj
T*
(   glBegin\(GL_QUADS\);)Tj
T*
(      glVertex2f \(-1.0, 0.0\);)Tj
T*
(      glVertex2f \(0.0, 1.0\);)Tj
T*
(      glVertex2f \(1.0, 0.0\);)Tj
T*
(      glVertex2f \(0.0, -1.0\);)Tj
T*
(   glEnd\(\);)Tj
0 -3 TD
(   glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(   glLoadIdentity\(\);)Tj
T*
(   gluPerspective\(45.0, \(GLfloat\) w/\(GLfloat\) h, 3.0, 7.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   glTranslatef\(0.0, 0.0, -5.0\);)Tj
T*
(})Tj
0 -3 TD
(/* Main Loop)Tj
0 -1.5 TD
( * Be certain to request stencil bits.)Tj
T*
( */)Tj
T*
(int main\(int argc, char** argv\))Tj
T*
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB )Tj
T*
(                        | GLUT_DEPTH | GLUT_STENCIL\);)Tj
T*
(   glutInitWindowSize \(400, 400\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 13)Tj
ET
endstream
endobj
1094 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1096 0 obj
<<
/Length 4423
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glutMainLoop\(\);)Tj
0 -1.5 TD
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
[(The following examples illustrate other uses of the stencil test. \(See )33(Chapter 14)16( for additional ideas.\))]TJ
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Capping)Tj
/F33 1 Tf
3.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Suppose you're drawing a closed convex object \(or several of them, as long as they don't)Tj
-4.4 -1.6 TD
(intersect or enclose each other\) made up of several polygons, and you have a clipping plane that may)Tj
0 -1.5 TD
(or may not slice off a piece of it. Suppose that if the plane does intersect the object, you want to cap)Tj
T*
(the object with some constant-colored surface, rather than seeing the inside of it. To do this, clear)Tj
T*
(the stencil buffer to zeros, and begin drawing with stenciling enabled and the stencil comparison)Tj
T*
(function set to always accept fragments. Invert the value in the stencil planes each time a fragment is)Tj
T*
(accepted. After all the objects are drawn, regions of the screen where no capping is required have)Tj
T*
(zeros in the stencil planes, and regions requiring capping are nonzero. Reset the stencil function so)Tj
T*
(that it draws only where the stencil value is nonzero, and draw a large polygon of the capping color)Tj
T*
(across the entire screen.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Overlapping translucent polygons)Tj
/F33 1 Tf
13.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Suppose you have a translucent surface that's made up of)Tj
-14.6 -1.6 TD
(polygons that overlap slightly. If you simply use alpha blending, portions of the underlying objects)Tj
0 -1.5 TD
(are covered by more than one transparent surface, which doesn't look right. Use the stencil planes to)Tj
T*
(make sure that each fragment is covered by at most one portion of the transparent surface. Do this)Tj
T*
(by clearing the stencil planes to zeros, drawing only when the stencil plane is zero, and incrementing)Tj
T*
(the value in the stencil plane when you draw.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Stippling)Tj
/F33 1 Tf
3.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
[(Suppose you want to draw an image with a stipple pattern. \(See )-6("Displaying Points,)]TJ
-4.7 -1.6 TD
[(Lines, and Polygons" in Chapter 2)43( for more information about stippling.\) You can do this by writing)]TJ
0 -1.5 TD
(the stipple pattern into the stencil buffer, and then drawing conditionally on the contents of the)Tj
T*
(stencil buffer. After the original stipple pattern is drawn, the stencil buffer isn't altered while)Tj
T*
(drawing the image, so the object gets stippled by the pattern in the stencil planes.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 287.000 Tm
(Depth Test)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 266.000 Tm
(For each pixel on the screen, the depth buffer keeps track of the distance between the viewpoint and the)Tj
T*
(object occupying that pixel. Then if the specified depth test passes, the incoming depth value replaces the)Tj
T*
(one already in the depth buffer.)Tj
0 -2.1 TD
(The depth buffer is generally used for hidden-surface elimination. If a new candidate color for that pixel)Tj
0 -1.5 TD
(appears, it's drawn only if the corresponding object is closer than the previous object. In this way, after)Tj
T*
(the entire scene has been rendered, only objects that aren't obscured by other items remain. Initially, the)Tj
T*
(clearing value for the depth buffer is a value that's as far from the viewpoint as possible, so the depth of)Tj
T*
(any object is nearer than that value. If this is how you want to use the depth buffer, you simply have to)Tj
T*
(enable it by passing GL_DEPTH_TEST to )Tj
/F15 1 Tf
17.4 0 TD
(glEnable\(\) )Tj
/F11 1 Tf
4.5 0 TD
(and remember to clear the depth buffer before you)Tj
-21.9 -1.5 TD
[(redraw each frame. \(See )-32("Clearing Buffers.")60(\) You can also choose a different comparison function for)]TJ
T*
(the depth test with )Tj
/F15 1 Tf
7.6 0 TD
(glDepthFunc\(\))Tj
/F11 1 Tf
6 0 TD
(.)Tj
/F15 1 Tf
-13.6 -2.1 TD
0.028 Tw
[(void glDepthFunc)78(\(GLenum )-45(func)22(\);)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 14)Tj
ET
endstream
endobj
1097 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1099 0 obj
<<
/Length 4442
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(Sets the comparison function for the depth test. The value for )-31(func)22( must be GL_NEVER,)]TJ
0 -1.5 TD
(GL_ALWAYS, GL_LESS, GL_LEQUAL, GL_EQUAL, GL_GEQUAL, GL_GREATER, or)Tj
T*
[(GL_NOTEQUAL. An incoming fragment passes the depth test if its )-13(z)-11( value has the specified relation)]TJ
T*
(to the value already stored in the depth buffer. The default is GL_LESS, which means that an)Tj
T*
[(incoming fragment passes the test if its )8(z)-11( value is less than that already stored in the depth buffer. In)]TJ
T*
[(this case, the )45(z)-11( value represents the distance from the object to the viewpoint, and smaller values)]TJ
T*
(mean the corresponding objects are closer to the viewpoint.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 592.000 Tm
(Blending, Dithering, and Logical Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 571.000 Tm
(Once an incoming fragment has passed all the tests described in the previous section, it can be combined)Tj
T*
(with the current contents of the color buffer in one of several ways. The simplest way, which is also the)Tj
T*
(default, is to overwrite the existing values. Alternatively, if you're using RGBA mode and you want the)Tj
T*
(fragment to be translucent or antialiased, you might average its value with the value already in the buffer)Tj
T*
(\(blending\). On systems with a small number of available colors, you might want to dither color values to)Tj
T*
(increase the number of colors available at the cost of a loss in resolution. In the final stage, you can use)Tj
T*
(arbitrary bitwise logical operations to combine the incoming fragment and the pixel that's already)Tj
T*
(written.)Tj
/F27 1 Tf
0 -3 TD
(Blending)Tj
/F11 1 Tf
0 -2.1 TD
(Blending combines the incoming fragment's R, G, B, and alpha values with those of the pixel already)Tj
0 -1.5 TD
(stored at the location. Different blending operations can be applied, and the blending that occurs depends)Tj
T*
(on the values of the incoming alpha value and the alpha value \(if any\) stored at the pixel. \(See)Tj
T*
[("Blending" in Chapter 6)-22( for an extensive discussion of this topic.\))]TJ
/F27 1 Tf
0 -3 TD
(Dithering)Tj
/F11 1 Tf
0 -2.1 TD
(On systems with a small number of color bitplanes, you can improve the color resolution at the expense)Tj
0 -1.5 TD
(of spatial resolution by dithering the color in the image. Dithering is like halftoning in newspapers.)Tj
0 -1.6 TD
(Although The New York Times has only two colors)Tj
/F33 1 Tf
20.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(black and white)Tj
/F33 1 Tf
6.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(it can show photographs by)Tj
-29.2 -1.6 TD
(representing the shades of gray with combinations of black and white dots. Comparing a newspaper)Tj
0 -1.5 TD
(image of a photo \(having no shades of gray\) with the original photo \(with grayscale\) makes the loss of)Tj
T*
(spatial resolution obvious. Similarly, systems with a small number of color bitplanes may dither values)Tj
T*
(of red, green, and blue on neighboring pixels for the perception of a wider range of colors.)Tj
0 -2.1 TD
(The dithering operation that takes place is hardware-dependent; all OpenGL allows you to do is to turn it)Tj
0 -1.5 TD
(on and off. In fact, on some machines, enabling dithering might do nothing at all, which makes sense if)Tj
T*
(the machine already has high color resolution. To enable and disable dithering, pass GL_DITHER to)Tj
/F15 1 Tf
T*
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.6 0 TD
(. Dithering is enabled by default.)Tj
-10.8 -2.1 TD
(Dithering applies in both RGBA and color-index mode. The colors or color indices alternate in some)Tj
0 -1.5 TD
(hardware-dependent way between the two nearest possibilities. For example, in color-index mode, if)Tj
T*
(dithering is enabled and the color index to be painted is 4.4, then 60% of the pixels may be painted with)Tj
T*
(index 4 and 40% of the pixels with index 5. \(Many dithering algorithms are possible, but a dithered value)Tj
T*
(produced by any algorithm must depend upon only the incoming value and the fragment's x and y)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 15)Tj
ET
endstream
endobj
1100 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1103 0 obj
<<
/Length 5766
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(coordinates.\) In RGBA mode, dithering is performed separately for each component \(including alpha\).)Tj
0 -1.5 TD
(To use dithering in color-index mode, you generally need to arrange the colors in the color map)Tj
T*
(appropriately in ramps, otherwise, bizarre images might result.)Tj
/F27 1 Tf
0 -3 TD
(Logical Operations)Tj
/F11 1 Tf
0 -2.1 TD
(The final operation on a fragment is the )Tj
/F13 1 Tf
16.1 0 TD
(logical operation)Tj
/F11 1 Tf
7.1 0 TD
(, such as an OR, XOR, or INVERT, which is)Tj
-23.2 -1.5 TD
(applied to the incoming fragment values \(source\) and/or those currently in the color buffer \(destination\).)Tj
T*
(Such fragment operations are especially useful on bit-blt-type machines, on which the primary graphics)Tj
T*
(operation is copying a rectangle of data from one place in the window to another, from the window to)Tj
T*
(processor memory, or from memory to the window. Typically, the copy doesn't write the data directly)Tj
T*
(into memory but instead allows you to perform an arbitrary logical operation on the incoming data and)Tj
T*
(the data already present; then it replaces the existing data with the results of the operation.)Tj
0 -2.1 TD
(Since this process can be implemented fairly cheaply in hardware, many such machines are available. As)Tj
0 -1.5 TD
(an example of using a logical operation, XOR can be used to draw on an image in an undoable way;)Tj
T*
(simply XOR the same drawing again, and the original image is restored. As another example, when using)Tj
T*
(color-index mode, the color indices can be interpreted as bit patterns. Then you can compose an image as)Tj
T*
(combinations of drawings on different layers, use writemasks to limit drawing to different sets of)Tj
T*
(bitplanes, and perform logical operations to modify different layers.)Tj
0 -2.1 TD
(You enable and disable logical operations by passing GL_INDEX_LOGIC_OP or)Tj
0 -1.5 TD
(GL_COLOR_LOGIC_OP to )Tj
/F15 1 Tf
11.8 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glDisable\(\))Tj
/F11 1 Tf
4.5 0 TD
( for color-index mode or RGBA mode,)Tj
-22.6 -1.5 TD
(respectively. You also must choose among the sixteen logical operations with )Tj
/F15 1 Tf
31.3 0 TD
(glLogicOp\(\))Tj
/F11 1 Tf
5 0 TD
(, or you'll just)Tj
-36.3 -1.5 TD
(get the effect of the default value, GL_COPY. \(For backward compatibility with OpenGL Version 1.0,)Tj
/F15 1 Tf
T*
(glEnable)Tj
/F11 1 Tf
3.6 0 TD
(\(GL_LOGIC_OP\) also enables logical operation in color-index mode.\))Tj
/F15 1 Tf
-3.6 -2.1 TD
0.028 Tw
[(void glLogicOp)-22(\(GLenum )55(opcode)-12(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Selects the logical operation to be performed, given an incoming \(source\) fragment and the pixel)Tj
T*
[(currently stored in the color buffer \(destination\). )-21(Table 10-4)]TJ
24.1 0 TD
[( shows the possible values for )-32(opcode)]TJ
-24.1 -1.5 TD
[(and their meaning \()17(s)-11( represents source and )33(d destination\). The default value is GL_COPY.)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 285.470 m
474.000 285.470 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 278.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Parameter)-8108(Operation)-6026(Parameter)-8108(Operation)]TJ
ET
Q
124.000 271.950 m
474.000 271.950 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 264.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(GL_CLEAR)-6444(0)-9056(GL_AND)]TJ
/F15 1 Tf
32.6667 -0.1111 TD
(s )Tj
/F33 1 Tf
0.6667 0 TD
0.000 Tw
(\331)Tj
/F15 1 Tf
0.5556 0 TD
( d)Tj
/F11 1 Tf
-33.8889 -1.5556 TD
(GL_COPY)Tj
/F15 1 Tf
11.5556 0 TD
(s)Tj
/F11 1 Tf
9.5556 0 TD
(GL_OR)Tj
/F15 1 Tf
11.5556 -0.1111 TD
(s )Tj
/F33 1 Tf
0.6667 0 TD
(\332)Tj
/F15 1 Tf
0.5556 0 TD
( d)Tj
/F11 1 Tf
-33.8889 -1.5556 TD
(GL_NOOP)Tj
/F15 1 Tf
11.5556 0.1111 TD
(d)Tj
/F11 1 Tf
9.5556 -0.1111 TD
(GL_NAND)Tj
/F15 1 Tf
11.5556 -0.1111 TD
(\254\(s )Tj
/F33 1 Tf
1.3333 0 TD
(\331)Tj
/F15 1 Tf
0.5556 0 TD
( d\))Tj
/F11 1 Tf
-34.5556 -1.4444 TD
[(GL_SET)-7944(1)-9056(GL_NOR)]TJ
/F15 1 Tf
32.6667 -0.1111 TD
(\254\(s )Tj
/F33 1 Tf
1.3333 0 TD
(\332)Tj
/F15 1 Tf
0.5556 0 TD
( d\))Tj
/F11 1 Tf
-34.5556 -1.5556 TD
[(GL_COPY_INVERTED)-1555(\254)]TJ
/F15 1 Tf
11.8889 0 TD
(s)Tj
/F11 1 Tf
9.2222 0 TD
(GL_XOR)Tj
/F15 1 Tf
11.5556 0 TD
(s XOR d)Tj
/F11 1 Tf
-32.6667 -1.4444 TD
[(GL_INVERT)-6056(\254)]TJ
/F15 1 Tf
11.8889 0 TD
(d)Tj
/F11 1 Tf
9.2222 0 TD
(GL_EQUIV)Tj
/F15 1 Tf
11.5556 0 TD
(\254\(s XOR d\))Tj
/F11 1 Tf
-32.6667 -1.4444 TD
(GL_AND_REVERSE)Tj
/F15 1 Tf
11.5556 -0.1111 TD
(s )Tj
/F33 1 Tf
0.6667 0 TD
(\331)Tj
/F15 1 Tf
0.5556 0 TD
( \254d)Tj
/F11 1 Tf
8.3333 0.1111 TD
(GL_AND_INVERTED)Tj
/F15 1 Tf
11.5556 -0.1111 TD
(\254s )Tj
/F33 1 Tf
1 0 TD
(\331)Tj
/F15 1 Tf
0.5555 0 TD
( d)Tj
/F11 1 Tf
-34.2222 -1.5556 TD
(GL_OR_REVERSE)Tj
/F15 1 Tf
11.5556 -0.1111 TD
(s )Tj
/F33 1 Tf
0.6667 0 TD
(\332)Tj
/F15 1 Tf
0.5556 0 TD
( \254d)Tj
/F11 1 Tf
8.3333 0.1111 TD
(GL_OR_INVERTED)Tj
/F15 1 Tf
11.5556 -0.1111 TD
(\254s )Tj
/F33 1 Tf
1 0 TD
(\332)Tj
/F15 1 Tf
0.5555 0 TD
( d)Tj
ET
Q
124.000 154.960 m
474.010 154.960 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 139.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 10-4 )Tj
/F11 1 Tf
5.2 0 TD
(Sixteen Logical Operations)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 105.000 Tm
(The Accumulation Buffer)Tj
10.000 0.000 0.000 10.000 204.000 82.000 Tm
(Advanced)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 16)Tj
ET
endstream
endobj
1104 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1106 0 obj
<<
/Length 4619
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The accumulation buffer can be used for such things as scene antialiasing, motion blur, simulating)Tj
0 -1.5 TD
(photographic depth of field, and calculating the soft shadows that result from multiple light sources.)Tj
T*
(Other techniques are possible, especially in combination with some of the other buffers. \(See)Tj
/F15 1 Tf
37.2 0 TD
( The)Tj
-37.2 -1.5 TD
(Accumulation Buffer: Hardware Support for High-Quality Rendering)Tj
/F11 1 Tf
27.8 0 TD
( by Paul Haeberli and Kurt Akeley)Tj
-27.8 -1.5 TD
(\(SIGGRAPH 1990 Proceedings, p. 309\255318\) for more information on the uses for the accumulation)Tj
T*
(buffer.\))Tj
0 -2.1 TD
(OpenGL graphics operations don't write directly into the accumulation buffer. Typically, a series of)Tj
0 -1.5 TD
(images is generated in one of the standard color buffers, and these are accumulated, one at a time, into)Tj
T*
(the accumulation buffer. When the accumulation is finished, the result is copied back into a color buffer)Tj
T*
(for viewing. To reduce rounding errors, the accumulation buffer may have higher precision \(more bits)Tj
T*
(per color\) than the standard color buffers. Rendering a scene several times obviously takes longer than)Tj
T*
(rendering it once, but the result is higher quality. You can decide what trade-off between quality and)Tj
T*
(rendering time is appropriate for your application.)Tj
0 -2.1 TD
(You can use the accumulation buffer the same way a photographer can use film for multiple exposures.)Tj
0 -1.5 TD
(A photographer typically creates a multiple exposure by taking several pictures of the same scene)Tj
T*
(without advancing the film. If anything in the scene moves, that object appears blurred. Not surprisingly,)Tj
T*
(a computer can do more with an image than a photographer can do with a camera. For example, a)Tj
T*
(computer has exquisite control over the viewpoint, but a photographer can't shake a camera a predictable)Tj
T*
[(and controlled amount. \(See )27("Clearing Buffers")10( for information about how to clear the accumulation)]TJ
T*
(buffer; use )Tj
/F15 1 Tf
4.6 0 TD
(glAccum\(\))Tj
/F11 1 Tf
4.1 0 TD
( to control it.\))Tj
/F15 1 Tf
-8.7 -2.1 TD
0.028 Tw
[(void glAccum\(GLenum )55(op, )28(GLfloat )-10(value)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Controls the accumulation buffer. The )-42(op parameter selects the operation, and )95(value)-34( is a number to)]TJ
T*
(be used in that operation. The possible operations are GL_ACCUM, GL_LOAD, GL_RETURN,)Tj
T*
(GL_ADD, and GL_MULT.)Tj
/F33 1 Tf
-1.7 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(GL_ACCUM reads each pixel from the buffer currently selected for reading with )Tj
/F15 1 Tf
32.8 0 TD
(glReadBuffer\(\))Tj
/F11 1 Tf
6 0 TD
(,)Tj
-38.8 -1.6 TD
(multiplies the R, G, B, and alpha values by )Tj
/F15 1 Tf
17.4 0 TD
(value)Tj
/F11 1 Tf
2.2 0 TD
(, and adds the result to the accumulation buffer.)Tj
/F33 1 Tf
-21.4 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(GL_LOAD does the same thing, except that the values replace those in the accumulation buffer)Tj
0 -1.5 TD
(rather than being added to them.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(GL_RETURN takes values from the accumulation buffer, multiplies them by )Tj
/F15 1 Tf
31.2 0 TD
(value)Tj
/F11 1 Tf
2.2 0 TD
(, and places the)Tj
-33.4 -1.5 TD
(result in the color buffer\(s\) enabled for writing.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(GL_ADD and GL_MULT simply add or multiply the value of each pixel in the accumulation buffer)Tj
0 -1.6 TD
(by )Tj
/F15 1 Tf
1.3 0 TD
(value)Tj
/F11 1 Tf
2.1 0 TD
( and then return it to the accumulation buffer. For GL_MULT, )Tj
/F15 1 Tf
25.3 0 TD
(value)Tj
/F11 1 Tf
2.1 0 TD
( is clamped to be in the)Tj
-30.8 -1.5 TD
(range [-1.0,1.0]. For GL_ADD, no clamping occurs.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 145.000 Tm
(Scene Antialiasing)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 123.000 Tm
(To perform scene antialiasing, first clear the accumulation buffer and enable the front buffer for reading)Tj
T*
(and writing. Then loop several times \(say, )Tj
/F15 1 Tf
17.1 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(\) through code that jitters and draws the image \()Tj
/F13 1 Tf
19.2 0 TD
(jittering)Tj
/F11 1 Tf
3.5 0 TD
( is)Tj
-40.3 -1.5 TD
(moving the image to a slightly different position\), accumulating the data with)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 17)Tj
ET
endstream
endobj
1107 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1109 0 obj
<<
/Length 4266
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(glAccum\(GL_ACCUM, 1.0/)Tj
/F15 1 Tf
13.2 0 TD
(n)Tj
/F7 1 Tf
0.5 0 TD
(\);)Tj
/F11 1 Tf
-13.7 -2.1 TD
(and finally calling)Tj
/F7 1 Tf
T*
(glAccum\(GL_RETURN, 1.0\);)Tj
/F11 1 Tf
T*
(Note that this method is a bit faster if, on the first pass through the loop, GL_LOAD is used and clearing)Tj
0 -1.5 TD
[(the accumulation buffer is omitted. See )-28(Table 10-5)]TJ
20.3 0 TD
( for possible jittering values. With this code, the image)Tj
-20.3 -1.5 TD
(is drawn )Tj
/F15 1 Tf
3.7 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( times before the final image is drawn. If you want to avoid showing the user the intermediate)Tj
-4.2 -1.5 TD
(images, draw into a color buffer that's not displayed, accumulate from that, and use the GL_RETURN)Tj
T*
(call to draw into a displayed buffer \(or into a back buffer that you subsequently swap to the front\).)Tj
0 -2.1 TD
(You could instead present a user interface that shows the viewed image improving as each additional)Tj
0 -1.5 TD
(piece is accumulated and that allows the user to halt the process when the image is good enough. To)Tj
T*
(accomplish this, in the loop that draws successive images, call )Tj
/F15 1 Tf
25.2 0 TD
(glAccum\(\))Tj
/F11 1 Tf
4.1 0 TD
( with GL_RETURN after each)Tj
-29.3 -1.5 TD
(accumulation, using 16.0/1.0, 16.0/2.0, 16.0/3.0, ... as the second argument. With this technique, after)Tj
T*
(one pass, 1/16 of the final image is shown, after two passes, 2/16 is shown, and so on. After the)Tj
T*
(GL_RETURN, the code should check to see if the user wants to interrupt the process. This interface is)Tj
T*
(slightly slower, since the resultant image must be copied in after each pass.)Tj
0 -2.1 TD
(To decide what )Tj
/F15 1 Tf
6.4 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( should be, you need to trade off speed \(the more times you draw the scene, the longer it)Tj
-6.9 -1.5 TD
(takes to obtain the final image\) and quality \(the more times you draw the scene, the smoother it gets,)Tj
T*
[(until you make maximum use of the accumulation buffer's resolution\). )-17("Plate 22")66( and )-56("Plate 23")-34( show)]TJ
T*
(improvements made using scene antialiasing.)Tj
0 -2.1 TD
(Example 10-2)Tj
5.6 0 TD
( defines two routines for jittering that you might find useful: )Tj
/F15 1 Tf
24.4 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.7 0 TD
( and)Tj
/F15 1 Tf
-36.7 -1.5 TD
(accFrustum\(\))Tj
/F11 1 Tf
5.4 0 TD
(. The routine )Tj
/F15 1 Tf
5.4 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.8 0 TD
( is used in place of )Tj
/F15 1 Tf
7.7 0 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
(, and the first four)Tj
-31.9 -1.5 TD
(parameters of both routines are the same. To jitter the viewing frustum for scene antialiasing, pass the )Tj
/F15 1 Tf
41 0 TD
(x)Tj
/F11 1 Tf
-41 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( jitter values \(of less than one pixel\) to the fifth and sixth parameters of )Tj
/F15 1 Tf
28.7 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.7 0 TD
(. Also pass)Tj
-37.5 -1.5 TD
(0.0 for the seventh and eighth parameters to )Tj
/F15 1 Tf
17.8 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.7 0 TD
( and a nonzero value for the ninth parameter)Tj
-24.5 -1.5 TD
(\(to prevent division by zero inside )Tj
/F15 1 Tf
13.9 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.8 0 TD
(\). These last three parameters are used for)Tj
-20.7 -1.5 TD
(depth-of-field effects, which are described later in this chapter.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 10-2 )Tj
/F11 1 Tf
6.7 0 TD
(Routines for Jittering the Viewing Volume: accpersp.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#define PI_ 3.14159265358979323846)Tj
0 -3 TD
(void accFrustum\(GLdouble left, GLdouble right, GLdouble bottom,)Tj
0 -1.5 TD
(    GLdouble top, GLdouble near, GLdouble far, GLdouble pixdx, )Tj
T*
(    GLdouble pixdy, GLdouble eyedx, GLdouble eyedy, )Tj
T*
(    GLdouble focus\))Tj
T*
({)Tj
T*
(    GLdouble xwsize, ywsize; )Tj
T*
(    GLdouble dx, dy;)Tj
T*
(    GLint viewport[4];)Tj
0 -3 TD
(    glGetIntegerv \(GL_VIEWPORT, viewport\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 18)Tj
ET
endstream
endobj
1110 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1112 0 obj
<<
/Length 1929
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(    xwsize = right - left;)Tj
0 -1.5 TD
(    ywsize = top - bottom;)Tj
T*
(    dx = -\(pixdx*xwsize/\(GLdouble\) viewport[2] + )Tj
T*
(            eyedx*near/focus\);)Tj
T*
(    dy = -\(pixdy*ywsize/\(GLdouble\) viewport[3] + )Tj
T*
(            eyedy*near/focus\);)Tj
0 -3 TD
(    glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(    glLoadIdentity\(\);)Tj
T*
(    glFrustum \(left + dx, right + dx, bottom + dy, top + dy, )Tj
T*
(        near, far\);)Tj
T*
(    glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(    glLoadIdentity\(\);)Tj
T*
(    glTranslatef \(-eyedx, -eyedy, 0.0\);)Tj
T*
(})Tj
0 -3 TD
(void accPerspective\(GLdouble fovy, GLdouble aspect, )Tj
0 -1.5 TD
(    GLdouble near, GLdouble far, GLdouble pixdx, GLdouble pixdy, )Tj
T*
(    GLdouble eyedx, GLdouble eyedy, GLdouble focus\))Tj
T*
({)Tj
T*
(    GLdouble fov2,left,right,bottom,top;)Tj
T*
(    fov2 = \(\(fovy*PI_\) / 180.0\) / 2.0;)Tj
0 -3 TD
(    top = near / \(fcos\(fov2\) / fsin\(fov2\)\);)Tj
0 -1.5 TD
(    bottom = -top;)Tj
T*
(    right = top * aspect;)Tj
T*
(    left = -right;)Tj
0 -3 TD
(    accFrustum \(left, right, bottom, top, near, far,)Tj
0 -1.5 TD
(        pixdx, pixdy, eyedx, eyedy, focus\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Example 10-3)Tj
5.6 0 TD
( uses these two routines to perform scene antialiasing.)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 10-3 )Tj
/F11 1 Tf
6.7 0 TD
(Scene Antialiasing: accpersp.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <math.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include "jitter.h")Tj
0 -3 TD
(void init\(void\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 19)Tj
ET
endstream
endobj
1113 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1115 0 obj
<<
/Length 2039
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
({)Tj
0 -1.5 TD
(   GLfloat mat_ambient[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(   GLfloat light_position[] = { 0.0, 0.0, 10.0, 1.0 };)Tj
T*
(   GLfloat lm_ambient[] = { 0.2, 0.2, 0.2, 1.0 };)Tj
0 -3 TD
(   glMaterialfv\(GL_FRONT, GL_AMBIENT, mat_ambient\);)Tj
0 -1.5 TD
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
T*
(   glMaterialf\(GL_FRONT, GL_SHININESS, 50.0\);)Tj
T*
(   glLightfv\(GL_LIGHT0, GL_POSITION, light_position\);)Tj
T*
(   glLightModelfv\(GL_LIGHT_MODEL_AMBIENT, lm_ambient\);)Tj
T*
(    )Tj
T*
(   glEnable\(GL_LIGHTING\);)Tj
T*
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
0 -3 TD
(   glClearColor\(0.0, 0.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glClearAccum\(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(})Tj
0 -3 TD
(void displayObjects\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat torus_diffuse[] = { 0.7, 0.7, 0.0, 1.0 };)Tj
T*
(   GLfloat cube_diffuse[] = { 0.0, 0.7, 0.7, 1.0 };)Tj
T*
(   GLfloat sphere_diffuse[] = { 0.7, 0.0, 0.7, 1.0 };)Tj
T*
(   GLfloat octa_diffuse[] = { 0.7, 0.4, 0.4, 1.0 };)Tj
T*
(    )Tj
T*
(   glPushMatrix \(\);)Tj
T*
(   glTranslatef \(0.0, 0.0, -5.0\); )Tj
T*
(   glRotatef \(30.0, 1.0, 0.0, 0.0\);)Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(   glTranslatef \(-0.80, 0.35, 0.0\); )Tj
T*
(   glRotatef \(100.0, 1.0, 0.0, 0.0\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, torus_diffuse\);)Tj
T*
(   glutSolidTorus \(0.275, 0.85, 16, 16\);)Tj
T*
(   glPopMatrix \(\);)Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(   glTranslatef \(-0.75, -0.50, 0.0\); )Tj
T*
(   glRotatef \(45.0, 0.0, 0.0, 1.0\);)Tj
T*
(   glRotatef \(45.0, 1.0, 0.0, 0.0\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 20)Tj
ET
endstream
endobj
1116 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1118 0 obj
<<
/Length 1719
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, cube_diffuse\);)Tj
0 -1.5 TD
(   glutSolidCube \(1.5\);)Tj
T*
(   glPopMatrix \(\);)Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(   glTranslatef \(0.75, 0.60, 0.0\); )Tj
T*
(   glRotatef \(30.0, 1.0, 0.0, 0.0\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, sphere_diffuse\);)Tj
T*
(   glutSolidSphere \(1.0, 16, 16\);)Tj
T*
(   glPopMatrix \(\);)Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(   glTranslatef \(0.70, -0.90, 0.25\); )Tj
T*
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, octa_diffuse\);)Tj
T*
(   glutSolidOctahedron \(\);)Tj
T*
(   glPopMatrix \(\);)Tj
0 -3 TD
(   glPopMatrix \(\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(#define ACSIZE  8)Tj
T*
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLint viewport[4];)Tj
T*
(   int jitter;)Tj
0 -3 TD
(   glGetIntegerv \(GL_VIEWPORT, viewport\);)Tj
T*
(   glClear\(GL_ACCUM_BUFFER_BIT\);)Tj
0 -1.5 TD
(   for \(jitter = 0; jitter < ACSIZE; jitter++\) {)Tj
T*
(      glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(      accPerspective \(50.0, )Tj
T*
(         \(GLdouble\) viewport[2]/\(GLdouble\) viewport[3], )Tj
T*
(         1.0, 15.0, j8[jitter].x, j8[jitter].y, 0.0, 0.0, 1.0\);)Tj
T*
(      displayObjects \(\);)Tj
T*
(      glAccum\(GL_ACCUM, 1.0/ACSIZE\);)Tj
T*
(   })Tj
T*
(   glAccum \(GL_RETURN, 1.0\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 21)Tj
ET
endstream
endobj
1119 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1121 0 obj
<<
/Length 2579
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
({)Tj
0 -1.5 TD
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(})Tj
0 -3 TD
(/*  Main Loop)Tj
0 -1.5 TD
( *  Be certain you request an accumulation buffer.)Tj
T*
( */)Tj
T*
(int main\(int argc, char** argv\))Tj
T*
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB)Tj
T*
(                        | GLUT_ACCUM | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize \(250, 250\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(You don't have to use a perspective projection to perform scene antialiasing. You can antialias a scene)Tj
0 -1.5 TD
(with orthographic projection simply by using )Tj
/F15 1 Tf
18.3 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
( to jitter the scene. Keep in mind that)Tj
/F15 1 Tf
-24.1 -1.5 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
( operates in world coordinates, but you want the apparent motion of the scene to be less)Tj
-5.8 -1.5 TD
(than one pixel, measured in screen coordinates. Thus, you must reverse the world-coordinate mapping by)Tj
T*
(calculating the jittering translation values, using its width or height in world coordinates divided by its)Tj
T*
(viewport size. Then multiply that world-coordinate value by the amount of jitter to determine how much)Tj
T*
[(the scene should be moved in world coordinates to get a predictable jitter of less than one pixel. )27(Example)]TJ
T*
(10-4)Tj
1.8 0 TD
( shows how the )Tj
/F15 1 Tf
6.5 0 TD
(display\(\))Tj
/F11 1 Tf
3.5 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(reshape\(\) )Tj
/F11 1 Tf
4.1 0 TD
(routines might look with a world-coordinate width and)Tj
-17.9 -1.5 TD
(height of 4.5.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 10-4 )Tj
/F11 1 Tf
6.7 0 TD
(Jittering with an Orthographic Projection: accanti.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#define ACSIZE  8)Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLint viewport[4];)Tj
T*
(   int jitter;)Tj
0 -3 TD
(   glGetIntegerv \(GL_VIEWPORT, viewport\);)Tj
T*
(   glClear\(GL_ACCUM_BUFFER_BIT\);)Tj
0 -1.5 TD
(   for \(jitter = 0; jitter < ACSIZE; jitter++\) {)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 22)Tj
ET
endstream
endobj
1122 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1124 0 obj
<<
/Length 2741
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
0 -1.5 TD
(      glPushMatrix \(\);)Tj
T*
(/*      Note that 4.5 is the distance in world space between)Tj
T*
( *      left and right and bottom and top.)Tj
T*
( *      This formula converts fractional pixel movement to )Tj
T*
( *      world coordinates.)Tj
T*
( */)Tj
T*
(      glTranslatef \(j8[jitter].x*4.5/viewport[2],)Tj
T*
(                    j8[jitter].y*4.5/viewport[3], 0.0\);)Tj
T*
(      displayObjects \(\);)Tj
T*
(      glPopMatrix \(\);)Tj
T*
(      glAccum\(GL_ACCUM, 1.0/ACSIZE\);)Tj
T*
(   })Tj
T*
(   glAccum \(GL_RETURN, 1.0\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\) )Tj
T*
(      glOrtho \(-2.25, 2.25, -2.25*h/w, 2.25*h/w, -10.0, 10.0\);)Tj
T*
(   else )Tj
T*
(      glOrtho \(-2.25*w/h, 2.25*w/h, -2.25, 2.25, -10.0, 10.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 260.000 Tm
(Motion Blur)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 238.000 Tm
[(Similar methods can be used to simulate motion blur, as shown in )-14("Plate 7" in Appendix I)-28( and )44(Figure)]TJ
T*
(10-2)Tj
1.8 0 TD
(. Suppose your scene has some stationary and some moving objects in it, and you want to make a)Tj
-1.8 -1.5 TD
(motion-blurred image extending over a small interval of time. Set up the accumulation buffer in the same)Tj
T*
(way, but instead of spatially jittering the images, jitter them temporally. The entire scene can be made)Tj
T*
(successively dimmer by calling)Tj
/F7 1 Tf
0 -2 TD
(glAccum \(GL_MULT, )Tj
10.000 0.000 2.126 10.000 232.000 158.000 Tm
(decayFactor)Tj
10.000 0.000 0.000 10.000 298.000 158.000 Tm
(\);)Tj
/F11 1 Tf
-17.4 -2.2 TD
(as the scene is drawn into the accumulation buffer, where )Tj
/F15 1 Tf
23.2 0 TD
(decayFactor)Tj
/F11 1 Tf
5.1 0 TD
( is a number from 0.0 to 1.0.)Tj
-28.3 -1.5 TD
(Smaller numbers for )Tj
/F15 1 Tf
8.5 0 TD
(decayFactor)Tj
/F11 1 Tf
5 0 TD
( cause the object to appear to be moving faster. You can transfer the)Tj
-13.5 -1.5 TD
(completed scene with the object's current position and "vapor trail" of previous positions from the)Tj
T*
(accumulation buffer to the standard color buffer with)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 23)Tj
ET
endstream
endobj
1125 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1126 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im94
/Width 252
/Height 104
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.93)
>>
stream
endstream
endobj
1128 0 obj
<<
/Length 2665
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(glAccum \(GL_RETURN, 1.0\);)Tj
/F11 1 Tf
0 -2.1 TD
(The image looks correct even if the items move at different speeds, or if some of them are accelerated.)Tj
0 -1.5 TD
(As before, the more jitter points \(temporal, in this case\) you use, the better the final image, at least up to)Tj
T*
(the point where you begin to lose resolution due to finite precision in the accumulation buffer. You can)Tj
T*
(combine motion blur with antialiasing by jittering in both the spatial and temporal domains, but you pay)Tj
T*
(for higher quality with longer rendering times.)Tj
ET
Q
/GS1 gs
q
252 0 0 104 124 512.45 cm
/Im94 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 500.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 10-2 )Tj
/F11 1 Tf
5.6 0 TD
(Motion-Blurred Object)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 471.000 Tm
(Depth of Field)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 449.000 Tm
(A photograph made with a camera is in perfect focus only for items lying on a single plane a certain)Tj
0 -1.5 TD
(distance from the film. The farther an item is from this plane, the more out of focus it is. The depth of)Tj
T*
(field for a camera is a region about the plane of perfect focus where items are out of focus by a small)Tj
T*
(enough amount.)Tj
0 -2.1 TD
(Under normal conditions, everything you draw with OpenGL is in focus \(unless your monitor's bad, in)Tj
0 -1.5 TD
(which case everything is out of focus\). The accumulation buffer can be used to approximate what you)Tj
T*
(would see in a photograph where items are more and more blurred as their distance from a plane of)Tj
T*
(perfect focus increases. It isn't an exact simulation of the effects produced in a camera, but the result)Tj
T*
(looks similar to what a camera would produce.)Tj
0 -2.1 TD
(To achieve this result, draw the scene repeatedly using calls with different argument values to)Tj
/F15 1 Tf
0 -1.5 TD
(glFrustum\(\))Tj
/F11 1 Tf
4.8 0 TD
(. Choose the arguments so that the position of the viewpoint varies slightly around its true)Tj
-4.8 -1.5 TD
(position and so that each frustum shares a common rectangle that lies in the plane of perfect focus, as)Tj
T*
[(shown in )-11(Figure 10-3)226(. The results of all the renderings should be averaged in the usual way using the)]TJ
T*
(accumulation buffer.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 24)Tj
ET
endstream
endobj
1129 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im94 1126 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1130 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im95
/Width 287
/Height 238
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.94)
>>
stream
endstream
endobj
1132 0 obj
<<
/Length 2837
>>
stream
/GS1 gs
q
287 0 0 238 124 482 cm
/Im95 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 469.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 10-3 )Tj
/F11 1 Tf
5.6 0 TD
(Jittered Viewing Volume for Depth-of-Field Effects)Tj
-5.6 -2.1 TD
[("Plate 10" in Appendix I)-28( shows an image of five teapots drawn using the depth-of-field effect. The gold)]TJ
0 -1.5 TD
(teapot \(second from the left\) is in focus, and the other teapots get progressively blurrier, depending upon)Tj
T*
(their distance from the focal plane \(gold teapot\). The code to draw this image is shown in Example 10-5)Tj
T*
(\(which assumes )Tj
/F15 1 Tf
6.6 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(accFrustum\(\))Tj
/F11 1 Tf
5.4 0 TD
[( are defined as described in )-36(Example 10-2)]TJ
16.8 0 TD
(\). The)Tj
-37.5 -1.5 TD
(scene is drawn eight times, each with a slightly jittered viewing volume, by calling )Tj
/F15 1 Tf
33.4 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.7 0 TD
(. As)Tj
-40.1 -1.5 TD
(you recall, with scene antialiasing, the fifth and sixth parameters jitter the viewing volumes in the )Tj
/F15 1 Tf
39.3 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(y)Tj
/F11 1 Tf
-41.7 -1.5 TD
(directions. For the depth-of-field effect, however, you want to jitter the volume while holding it)Tj
T*
(stationary at the focal plane. The focal plane is the depth value defined by the ninth \(last\) parameter to)Tj
/F15 1 Tf
T*
(accPerspective\(\))Tj
/F11 1 Tf
6.7 0 TD
(, which is )Tj
/F15 1 Tf
4.1 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( = 5.0 in this example. The amount of blur is determined by multiplying the )Tj
/F15 1 Tf
30.5 0 TD
(x)Tj
/F11 1 Tf
-41.7 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( jitter values \(seventh and eighth parameters of )Tj
/F15 1 Tf
19 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.8 0 TD
(\) by a constant. Determining the)Tj
-27.9 -1.5 TD
(constant is not a science; experiment with values until the depth of field is as pronounced as you want.)Tj
T*
[(\(Note that in )6(Example 10-5)]TJ
10.9 0 TD
(, the fifth and sixth parameters to )Tj
/F15 1 Tf
13.5 0 TD
(accPerspective\(\))Tj
/F11 1 Tf
6.8 0 TD
( are set to 0.0, so scene)Tj
-31.2 -1.5 TD
(antialiasing is turned off.\))Tj
/F27 1 Tf
0 -2.1 TD
(Example 10-5 )Tj
/F11 1 Tf
6.7 0 TD
(Depth-of-Field Effect: dof.c)Tj
/F7 1 Tf
-6.7 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <math.h>)Tj
T*
(#include "jitter.h")Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 25)Tj
ET
endstream
endobj
1133 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im95 1130 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1136 0 obj
<<
/Length 2062
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
0 -1.5 TD
(   GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(   GLfloat position[] = { 0.0, 3.0, 3.0, 0.0 };)Tj
T*
(    )Tj
T*
(   GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };)Tj
T*
(   GLfloat local_view[] = { 0.0 };)Tj
0 -3 TD
(   glLightfv\(GL_LIGHT0, GL_AMBIENT, ambient\);)Tj
0 -1.5 TD
(   glLightfv\(GL_LIGHT0, GL_DIFFUSE, diffuse\);)Tj
T*
(   glLightfv\(GL_LIGHT0, GL_POSITION, position\);)Tj
T*
(    )Tj
T*
(   glLightModelfv\(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient\);)Tj
T*
(   glLightModelfv\(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view\);)Tj
0 -3 TD
(   glFrontFace \(GL_CW\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHTING\);)Tj
T*
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_AUTO_NORMAL\);)Tj
T*
(   glEnable\(GL_NORMALIZE\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
0 -3 TD
(   glClearColor\(0.0, 0.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glClearAccum\(0.0, 0.0, 0.0, 0.0\); )Tj
T*
(/*  make teapot display list */)Tj
T*
(   teapotList = glGenLists\(1\);)Tj
T*
(   glNewList \(teapotList, GL_COMPILE\);)Tj
T*
(   glutSolidTeapot \(0.5\);)Tj
T*
(   glEndList \(\);)Tj
T*
(})Tj
0 -3 TD
(void renderTeapot \(GLfloat x, GLfloat y, GLfloat z, )Tj
0 -1.5 TD
(   GLfloat ambr, GLfloat ambg, GLfloat ambb, )Tj
T*
(   GLfloat difr, GLfloat difg, GLfloat difb, )Tj
T*
(   GLfloat specr, GLfloat specg, GLfloat specb, GLfloat shine\))Tj
T*
({)Tj
T*
(   GLfloat mat[4];)Tj
0 -3 TD
(   glPushMatrix\(\);)Tj
0 -1.5 TD
(   glTranslatef \(x, y, z\);)Tj
T*
(   mat[0] = ambr; mat[1] = ambg; mat[2] = ambb; mat[3] = 1.0;   )Tj
T*
(   glMaterialfv \(GL_FRONT, GL_AMBIENT, mat\);)Tj
T*
(   mat[0] = difr; mat[1] = difg; mat[2] = difb; )Tj
T*
(   glMaterialfv \(GL_FRONT, GL_DIFFUSE, mat\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 26)Tj
ET
endstream
endobj
1137 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1139 0 obj
<<
/Length 2269
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   mat[0] = specr; mat[1] = specg; mat[2] = specb;)Tj
0 -1.5 TD
(   glMaterialfv \(GL_FRONT, GL_SPECULAR, mat\);)Tj
T*
(   glMaterialf \(GL_FRONT, GL_SHININESS, shine*128.0\);)Tj
T*
(   glCallList\(teapotList\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int jitter;)Tj
T*
(   GLint viewport[4];)Tj
0 -3 TD
(   glGetIntegerv \(GL_VIEWPORT, viewport\);)Tj
0 -1.5 TD
(   glClear\(GL_ACCUM_BUFFER_BIT\);)Tj
0 -3 TD
(   for \(jitter = 0; jitter < 8; jitter++\) {)Tj
0 -1.5 TD
(      glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(      accPerspective \(45.0, )Tj
T*
(         \(GLdouble\) viewport[2]/\(GLdouble\) viewport[3], )Tj
T*
(         1.0, 15.0, 0.0, 0.0,)Tj
T*
(         0.33*j8[jitter].x, 0.33*j8[jitter].y, 5.0\);)Tj
0 -3 TD
(/*      ruby, gold, silver, emerald, and cyan teapots   */)Tj
0 -1.5 TD
(      renderTeapot \(-1.1, -0.5, -4.5, 0.1745, 0.01175, )Tj
T*
(                    0.01175, 0.61424, 0.04136, 0.04136, )Tj
T*
(                    0.727811, 0.626959, 0.626959, 0.6\);)Tj
T*
(      renderTeapot \(-0.5, -0.5, -5.0, 0.24725, 0.1995, )Tj
T*
(                    0.0745, 0.75164, 0.60648, 0.22648, )Tj
T*
(                    0.628281, 0.555802, 0.366065, 0.4\);)Tj
T*
(      renderTeapot \(0.2, -0.5, -5.5, 0.19225, 0.19225, )Tj
T*
(                    0.19225, 0.50754, 0.50754, 0.50754, )Tj
T*
(                    0.508273, 0.508273, 0.508273, 0.4\);)Tj
T*
(      renderTeapot \(1.0, -0.5, -6.0, 0.0215, 0.1745, 0.0215, )Tj
T*
(                    0.07568, 0.61424, 0.07568, 0.633, )Tj
T*
(                    0.727811, 0.633, 0.6\);)Tj
T*
(      renderTeapot \(1.8, -0.5, -6.5, 0.0, 0.1, 0.06, 0.0, )Tj
T*
(                    0.50980392, 0.50980392, 0.50196078, )Tj
T*
(                    0.50196078, 0.50196078, .25\);)Tj
T*
(      glAccum \(GL_ACCUM, 0.125\);)Tj
T*
(   })Tj
T*
(   glAccum \(GL_RETURN, 1.0\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 27)Tj
ET
endstream
endobj
1140 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1142 0 obj
<<
/Length 3140
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 697.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(})Tj
0 -3 TD
(/*  Main Loop)Tj
0 -1.5 TD
( *  Be certain you request an accumulation buffer.)Tj
T*
( */)Tj
T*
(int main\(int argc, char** argv\))Tj
T*
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB)Tj
T*
(                        | GLUT_ACCUM | GLUT_DEPTH\); )Tj
T*
(   glutInitWindowSize \(400, 400\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 353.000 Tm
(Soft Shadows)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 331.000 Tm
(To accumulate soft shadows due to multiple light sources, render the shadows with one light turned on at)Tj
T*
(a time, and accumulate them together. This can be combined with spatial jittering to antialias the scene at)Tj
T*
[(the same time. \(See )-17("Shadows" in Chapter 14)22( for more information about drawing shadows.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 273.000 Tm
(Jittering)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 251.000 Tm
(If you need to take nine or sixteen samples to antialias an image, you might think that the best choice of)Tj
T*
(points is an equally spaced grid across the pixel. Surprisingly, this is not necessarily true. In fact,)Tj
T*
(sometimes it's a good idea to take points that lie in adjacent pixels. You might want a uniform)Tj
T*
(distribution or a normalized distribution, clustering toward the center of the pixel. \(The aforementioned)Tj
T*
[(SIGGRAPH paper discusses these issues.\) In addition, )-16(Table 10-5)]TJ
26.4 0 TD
( shows a few sets of reasonable)Tj
-26.4 -1.5 TD
(jittering values to be used for some selected sample counts. Most of the examples in the table are)Tj
T*
(uniformly distributed in the pixel, and all lie within the pixel.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 149.910 m
463.000 149.910 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 142.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Count)-1236(Values)]TJ
ET
Q
124.000 136.390 m
463.000 136.390 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 128.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(2)-3167({0.25, 0.75}, {0.75, 0.25})]TJ
0 -1.4444 TD
[(3)-3167({0.5033922635, 0.8317967229}, {0.7806016275, 0.2504380877},)]TJ
3.6667 -1.3333 TD
({0.2261828938, 0.4131553612})Tj
-3.6667 -1.4444 TD
[(4)-3167({0.375, 0.25}, {0.125, 0.75}, {0.875, 0.25}, {0.625, 0.75})]TJ
T*
[(5)-3167({0.5, 0.5}, {0.3, 0.1}, {0.7, 0.9}, {0.9, 0.3}, {0.1, 0.7})]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 10,  The Framebuffer - 28)Tj
ET
endstream
endobj
1143 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1145 0 obj
<<
/Length 2077
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(6)-3167({0.4646464646, 0.4646464646}, {0.1313131313, 0.7979797979},)]TJ
3.6667 -1.3333 TD
({0.5353535353, 0.8686868686}, {0.8686868686, 0.5353535353},)Tj
T*
({0.7979797979, 0.1313131313}, {0.2020202020, 0.2020202020})Tj
-3.6667 -1.4444 TD
[(8)-3167({0.5625, 0.4375}, {0.0625, 0.9375}, {0.3125, 0.6875}, {0.6875, 0.8125}, {0.8125,)]TJ
3.6667 -1.3333 TD
(0.1875}, {0.9375, 0.5625}, {0.4375, 0.0625}, {0.1875, 0.3125})Tj
-3.6667 -1.4444 TD
[(9)-3167({0.5, 0.5}, {0.1666666666, 0.9444444444}, {0.5, 0.1666666666},)]TJ
3.6667 -1.3333 TD
({0.5, 0.8333333333}, {0.1666666666, 0.2777777777},)Tj
T*
({0.8333333333, 0.3888888888}, {0.1666666666, 0.6111111111},)Tj
T*
({0.8333333333, 0.7222222222}, {0.8333333333, 0.0555555555})Tj
-3.6667 -1.4444 TD
[(12)-2667({0.4166666666, 0.625}, {0.9166666666, 0.875}, {0.25, 0.375},)]TJ
3.6667 -1.3333 TD
({0.4166666666, 0.125}, {0.75, 0.125}, {0.0833333333, 0.125}, {0.75,)Tj
T*
(0.625},)Tj
T*
({0.25, 0.875}, {0.5833333333, 0.375}, {0.9166666666, 0.375},)Tj
T*
({0.0833333333, 0.625}, {0.583333333, 0.875})Tj
-3.6667 -1.4444 TD
[(16)-2667({0.375, 0.4375}, {0.625, 0.0625}, {0.875, 0.1875}, {0.125, 0.0625},)]TJ
3.6667 -1.3333 TD
({0.375, 0.6875}, {0.875, 0.4375}, {0.625, 0.5625}, {0.375, 0.9375},)Tj
T*
({0.625, 0.3125}, {0.125, 0.5625}, {0.125, 0.8125}, {0.375, 0.1875},)Tj
T*
({0.875, 0.9375}, {0.875, 0.6875}, {0.125, 0.3125}, {0.625, 0.8125})Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 496.260 m
463.010 496.260 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 480.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 10-5 )Tj
/F11 1 Tf
5.2 0 TD
[(\(continued\)        )11(Sample Jittering Values)]TJ
ET
Q
124.000 441.260 m
547.000 441.260 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 29)Tj
ET
endstream
endobj
1146 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1148 0 obj
<<
/Length 4477
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 11)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Tessellators and Quadrics)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Render concave filled polygons by first tessellating them into convex polygons, which can be)Tj
0 -1.6 TD
(rendered using standard OpenGL routines.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use the GLU library to create quadrics objects to render and model the surfaces of spheres and)Tj
0 -1.5 TD
(cylinders and to tessellate disks \(circles\) and partial disks \(arcs\).)Tj
-1.9 -2.7 TD
(The OpenGL library \(GL\) is designed for low-level operations, both streamlined and accessible to)Tj
0 -1.5 TD
(hardware acceleration. The OpenGL Utility Library \(GLU\) complements the OpenGL library, supporting)Tj
T*
(higher-level operations. Some of the GLU operations are covered in other chapters. Mipmapping)Tj
T*
(\()Tj
/F15 1 Tf
0.3 0 TD
(gluBuild*DMipmaps\(\))Tj
/F11 1 Tf
9.1 0 TD
(\) and image scaling \()Tj
/F15 1 Tf
8.4 0 TD
(gluScaleImage\(\))Tj
/F11 1 Tf
6.6 0 TD
(\) are discussed along with other facets of)Tj
-24.4 -1.5 TD
[(texture mapping in )6(Chapter 9)16(.)0( Several matrix transformation GLU routines \()]TJ
/F15 1 Tf
30.6 0 TD
(gluOrtho2D\(\))Tj
/F11 1 Tf
5.5 0 TD
(,)Tj
/F15 1 Tf
-36.1 -1.5 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(gluLookAt\(\))Tj
/F11 1 Tf
4.8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(gluProject\(\))Tj
/F11 1 Tf
4.9 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(gluUnProject\(\))Tj
/F11 1 Tf
6.1 0 TD
[(\) are described in )-35(Chapter 3)16(.)0( The use of)]TJ
/F15 1 Tf
-25.6 -1.5 TD
(gluPickMatrix\(\))Tj
/F11 1 Tf
6.4 0 TD
[( is explained in )-66(Chapter 13)16(. The GLU NURBS facilities, which are built atop OpenGL)]TJ
-6.4 -1.5 TD
[(evaluators, are covered in )25(Chapter 12)16(. Only two GLU topics remain: polygon tessellators and quadric)]TJ
T*
(surfaces, and those topics are discussed in this chapter.)Tj
0 -2.1 TD
(To optimize performance, the basic OpenGL only renders convex polygons, but the GLU contains)Tj
0 -1.5 TD
(routines to tessellate concave polygons into convex ones, which the basic OpenGL can handle. Where the)Tj
T*
(basic OpenGL operates upon simple primitives, such as points, lines, and filled polygons, the GLU can)Tj
T*
(create higher-level objects, such as the surfaces of spheres, cylinders, and cones.)Tj
0 -2.1 TD
(This chapter has the following major sections.)Tj
/F33 1 Tf
0.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Polygon Tessellation")34( explains how to tessellate convex polygons into easier-to-render convex)]TJ
0 -1.5 TD
(polygons.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Quadrics: Rendering Spheres, Cylinders, and Disks" describes how to generate spheres, cylinders,)Tj
0 -1.6 TD
(circles and arcs, including data such as surface normals and texture coordinates.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 226.000 Tm
(Polygon Tessellation)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 204.000 Tm
[(As discussed in )-27("Describing Points, Lines, and Polygons" in Chapter 2)-9(,)0( OpenGL can directly display)]TJ
0 -1.5 TD
(only simple convex polygons. A polygon is simple if the edges intersect only at vertices, there are no)Tj
T*
(duplicate vertices, and exactly two edges meet at any vertex. If your application requires the display of)Tj
T*
(concave polygons, polygons containing holes, or polygons with intersecting edges, those polygons must)Tj
T*
(first be subdivided into simple convex polygons before they can be displayed. Such subdivision is called)Tj
/F13 1 Tf
T*
(tessellation)Tj
/F11 1 Tf
4.7 0 TD
(, and the GLU provides a collection of routines that perform tessellation. These routines take)Tj
-4.7 -1.5 TD
(as input arbitrary contours, which describe hard-to-render polygons, and they return some combination of)Tj
T*
(triangles, triangle meshes, triangle fans, or lines.)Tj
0 -2.1 TD
(Figure 11-1 shows some contours of polygons that require tessellation: from left to right, a concave)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 1)Tj
ET
endstream
endobj
1149 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1150 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im96
/Width 526
/Height 143
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.95)
>>
stream
endstream
endobj
1152 0 obj
<<
/Length 3919
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(polygon, a polygon with a hole, and a self-intersecting polygon.)Tj
ET
Q
/GS1 gs
q
423 0 0 115 124 581.5801 cm
/Im96 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 569.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 11-1 )Tj
/F11 1 Tf
5.6 0 TD
(Contours That Require Tessellation)Tj
-5.6 -2.1 TD
(If you think a polygon may need tessellation, follow these typical steps.)Tj
T*
[(1.)-1050(Create a new tessellation object with )]TJ
/F15 1 Tf
16.7 0 TD
(gluNewTess\(\))Tj
/F11 1 Tf
5.5 0 TD
(.)Tj
-22.2 -2.1 TD
[(2.)-1050(Use )]TJ
/F15 1 Tf
3.6 0 TD
(gluTessCallback\(\))Tj
/F11 1 Tf
7.3 0 TD
( several times to register callback functions to perform operations during the)Tj
-9.1 -1.5 TD
(tessellation. The trickiest case for a callback function is when the tessellation algorithm detects an)Tj
T*
(intersection and must call the function registered for the GLU_TESS_COMBINE callback.)Tj
-1.8 -2.1 TD
[(3.)-1050(Specify tessellation properties by calling )]TJ
/F15 1 Tf
18.3 0 TD
(gluTessProperty\(\))Tj
/F11 1 Tf
7.3 0 TD
(. The most important property is the)Tj
-23.8 -1.5 TD
(winding rule, which determines the regions that should be filled and those that should remain)Tj
T*
(unshaded.)Tj
-1.8 -2.1 TD
[(4.)-1050(Create and render tessellated polygons by specifying the contours of one or more closed polygons. If)]TJ
1.8 -1.5 TD
(the data for the object is static, encapsulate the tessellated polygons in a display list. \(If you don't)Tj
T*
(have to recalculate the tessellation over and over again, using display lists is more efficient.\))Tj
-1.8 -2.1 TD
[(5.)-1050(If you need to tessellate something else, you may reuse your tessellation object. If you are forever)]TJ
1.8 -1.5 TD
(finished with your tessellation object, you may delete it with )Tj
/F15 1 Tf
24.5 0 TD
(gluDeleteTess\(\))Tj
/F11 1 Tf
6.3 0 TD
(.)Tj
/F27 1 Tf
-32.6 -2.6 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(The tessellator described here was introduced in version 1.2 of the GLU. If you are using an older)Tj
-2.8 -1.4 TD
[(version of the GLU, you must use routines described in )17("Describing GLU Errors")-41(. To query which)]TJ
0 -1.5 TD
(version of GLU you have, use )Tj
/F15 1 Tf
12.3 0 TD
(gluGetString\(GLU_VERSION\))Tj
/F11 1 Tf
12.4 0 TD
(, which returns a string with your GLU)Tj
-24.7 -1.4 TD
(version number. If you don't seem to have )Tj
/F15 1 Tf
17.2 0 TD
(gluGetString\(\))Tj
/F11 1 Tf
5.9 0 TD
( in your GLU, then you have GLU 1.0, which)Tj
-23.1 -1.4 TD
(did not yet have the )Tj
/F15 1 Tf
8.1 0 TD
(gluGetString\(\))Tj
/F11 1 Tf
5.9 0 TD
( routine.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 226.000 Tm
(Create a Tessellation Object)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 204.000 Tm
(As a complex polygon is being described and tessellated, it has associated data, such as the vertices,)Tj
0 -1.5 TD
(edges, and callback functions. All this data is tied to a single tessellation object. To perform tessellation,)Tj
T*
(your program first has to create a tessellation object using the routine )Tj
/F15 1 Tf
27.9 0 TD
(gluNewTess\(\))Tj
/F11 1 Tf
5.5 0 TD
(.)Tj
/F15 1 Tf
-33.4 -2.1 TD
[(GLUtesselator*)-10( gluNewTess)-15(\(void\);)]TJ
1.8 -1.5 TD
(Creates a new tessellation object and returns a pointer to it. A null pointer is returned if the creation)Tj
T*
(fails.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(A single tessellation object can be reused for all your tessellations. This object is required only because)Tj
0 -1.5 TD
(library routines might need to do their own tessellations, and they should be able to do so without)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 2)Tj
ET
endstream
endobj
1153 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im96 1150 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1155 0 obj
<<
/Length 4027
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(interfering with any tessellation that your program is doing. It might also be useful to have multiple)Tj
0 -1.5 TD
(tessellation objects if you want to use different sets of callbacks for different tessellations. A typical)Tj
T*
(program, however, allocates a single tessellation object and uses it for all its tessellations. There's no real)Tj
T*
(need to free it because it uses a small amount of memory. On the other hand, it never hurts to be tidy.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 637.000 Tm
(Tessellation Callback Routines)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 616.000 Tm
(After you create a tessellation object, you must provide a series of callback routines to be called at)Tj
T*
(appropriate times during the tessellation. After specifying the callbacks, you describe the contours of one)Tj
T*
(or more polygons using GLU routines. When the description of the contours is complete, the tessellation)Tj
T*
(facility invokes your callback routines as necessary.)Tj
0 -2.1 TD
(Any functions that are omitted are simply not called during the tessellation, and any information they)Tj
0 -1.5 TD
(might have returned to your program is lost. All are specified by the single routine )Tj
/F15 1 Tf
33.2 0 TD
(gluTessCallback\(\))Tj
/F11 1 Tf
7.4 0 TD
(.)Tj
/F15 1 Tf
-40.6 -2.1 TD
[(void )-28(gluTessCallback)68(\(GLUtesselator *)-27(tessobj)-22(, GLenum )-6(type)66(, void \(*)-95(fn)78(\)\(\)\);)]TJ
1.8 -1.5 TD
[(Associates the callback function )12(fn)-22( with the tessellation object tessobj)-22(. The type of the callback is)]TJ
T*
[(determined by the parameter )32(type)-34(, which can be GLU_TESS_BEGIN, GLU_TESS_BEGIN_DATA,)]TJ
T*
(GLU_TESS_EDGE_FLAG, GLU_TESS_EDGE_FLAG_DATA, GLU_TESS_VERTEX,)Tj
T*
(GLU_TESS_VERTEX_DATA, GLU_TESS_END, GLU_TESS_END_DATA, GLU_TESS_COMBINE,)Tj
T*
(GLU_TESS_COMBINE_DATA, GLU_TESS_ERROR, and GLU_TESS_ERROR_DATA. The twelve)Tj
T*
(possible callback functions have the following prototypes:)Tj
T*
[(GLU_TESS_BEGIN void )34(begin)-78(\(GLenum )27(type)66(\);)]TJ
T*
[(GLU_TESS_BEGIN_DATA void )35(begin)-78(\(GLenum )27(type)66(,)]TJ
0 -1.1 TD
[(void *)-28(user_data\);)]TJ
0 -1.5 TD
[(GLU_TESS_EDGE_FLAG void )-43(edgeFlag)77(\(GLboolean )-16(flag)-44(\);)]TJ
T*
[(GLU_TESS_EDGE_FLAG_DATA void )-43(edgeFlag)77(\(GLboolean )-16(flag)-44(,)]TJ
0 -1.1 TD
[(void *)-28(user_data\);)]TJ
0 -1.5 TD
[(GLU_TESS_VERTEX void vertex)43(\(void *vertex_data)-78(\);)]TJ
T*
[(GLU_TESS_VERTEX_DATA void vertex)43(\(void *vertex_data)-78(,)]TJ
0 -1.1 TD
[(void *)-28(user_data\);)]TJ
0 -1.5 TD
[(GLU_TESS_END void )-10(end)44(\(void\);)]TJ
T*
[(GLU_TESS_END_DATA void )-10(end)44(\(void *user_data\);)]TJ
T*
[(GLU_TESS_ERROR void )-44(error)11(\(GLenum )27(errno)22(\);)]TJ
T*
[(GLU_TESS_ERROR_DATA void )-43(error)11(\(GLenum )27(errno)22(, void *)-28(user_data\);)]TJ
T*
[(GLU_TESS_COMBINE void )34(combine)-12(\(GLdouble )-16(coords)22([3],)]TJ
0 -1.1 TD
0.028 Tw
[(void *vertex_data)22([4],)]TJ
T*
0.038 Tw
[(GLfloat weight)67([4],)]TJ
T*
0.028 Tw
[(void **outData)-22(\);)]TJ
0 -1.5 TD
0.000 Tw
[(GLU_TESS_COMBINE_DATA void )35(combine)-12(\(GLdouble )-16(coords)22([3],)]TJ
0 -1.1 TD
0.028 Tw
[(void *vertex_data)22([4],)]TJ
T*
0.038 Tw
[(GLfloat weight)67([4],)]TJ
T*
0.028 Tw
[(void **outData)-22(,)]TJ
T*
0.000 Tw
[(void *)-28(user_data\);)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(To change a callback routine, simply call )Tj
/F15 1 Tf
16.7 0 TD
(gluTessCallback\(\))Tj
/F11 1 Tf
7.4 0 TD
( with the new routine. To eliminate a)Tj
-24.1 -1.5 TD
(callback routine without replacing it with a new one, pass )Tj
/F15 1 Tf
23.3 0 TD
(gluTessCallback\(\))Tj
/F11 1 Tf
7.3 0 TD
( a null pointer for the)Tj
-30.6 -1.5 TD
(appropriate function.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 3)Tj
ET
endstream
endobj
1156 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1158 0 obj
<<
/Length 3845
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(As tessellation proceeds, the callback routines are called in a manner)Tj
0 -1.1 TD
(similar to how you use the OpenGL commands )Tj
/F15 1 Tf
19.2 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glEdgeFlag*\(\))Tj
/F11 1 Tf
5.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.6 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
(. \(See)Tj
-39.6 -1.2 TD
[("Marking Polygon Boundary Edges" in Chapter 2)28( for more information about )]TJ
/F15 1 Tf
31.3 0 TD
(glEdgeFlag*\(\))Tj
/F11 1 Tf
5.9 0 TD
(.\) The)Tj
-37.2 -1.1 TD
(combine callback is used to create new vertices where edges intersect. The error callback is invoked)Tj
T*
(during the tessellation only if something goes wrong.)Tj
0 -2.1 TD
(For every tessellator object created, a GLU_TESS_BEGIN callback is invoked with one of four possible)Tj
0 -1.5 TD
(parameters: GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, GL_TRIANGLES, and)Tj
T*
(GL_LINE_LOOP. When the tessellator decomposes the polygons, the tessellation algorithm will decide)Tj
T*
(which type of triangle primitive is most efficient to use. \(If the GLU_TESS_BOUNDARY_ONLY)Tj
T*
(property is enabled, then GL_LINE_LOOP  is used for rendering.\))Tj
0 -2.1 TD
(Since edge flags make no sense in a triangle fan or triangle strip, if there is a callback associated with)Tj
0 -1.5 TD
(GLU_TESS_EDGE_FLAG that enables edge flags, the GLU_TESS_BEGIN callback is called only with)Tj
T*
(GL_TRIANGLES. The GLU_TESS_EDGE_FLAG callback works exactly analogously to the OpenGL)Tj
/F15 1 Tf
T*
(glEdgeFlag*\(\))Tj
/F11 1 Tf
5.9 0 TD
( call.)Tj
-5.9 -2.1 TD
(After the GLU_TESS_BEGIN callback routine is called and before the callback associated with)Tj
0 -1.5 TD
(GLU_TESS_END is called, some combination of the GLU_TESS_EDGE_FLAG and)Tj
T*
(GLU_TESS_VERTEX callbacks is invoked \(usually by calls to )Tj
/F15 1 Tf
25.8 0 TD
(gluTessVertex\(\))Tj
/F11 1 Tf
6.3 0 TD
(, which is described on)Tj
-32.1 -1.5 TD
[(page 425)38(\). The associated edge flags and vertices are interpreted exactly as they are in OpenGL between)]TJ
/F15 1 Tf
T*
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and the matching )Tj
/F15 1 Tf
7.4 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
(.)Tj
-14.2 -2.1 TD
(If something goes wrong, the error callback is passed a GLU error number. A character string describing)Tj
0 -1.5 TD
(the error is obtained using the routine )Tj
/F15 1 Tf
15.2 0 TD
(gluErrorString\(\))Tj
/F11 1 Tf
6.7 0 TD
[(. \(See )27("Describing GLU Errors")-41( for more)]TJ
-21.9 -1.5 TD
(information about this routine.\))Tj
0 -2.1 TD
(Example 11-1)Tj
5.6 0 TD
( shows a portion of tess.c, where a tessellation object is created and several callbacks are)Tj
-5.6 -1.5 TD
(registered.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 11-1 )Tj
/F11 1 Tf
6.7 0 TD
(Registering Tessellation Callbacks: tess.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(/*  a portion of init\(\) */)Tj
0 -1.5 TD
(tobj = gluNewTess\(\);)Tj
T*
(gluTessCallback\(tobj, GLU_TESS_VERTEX,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &glVertex3dv\);)Tj
T*
(gluTessCallback\(tobj, GLU_TESS_BEGIN,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &beginCallback\);)Tj
T*
(gluTessCallback\(tobj, GLU_TESS_END,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &endCallback\);)Tj
T*
(gluTessCallback\(tobj, GLU_TESS_ERROR,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &errorCallback\);)Tj
0 -3 TD
(/*  the callback routines registered by gluTessCallback\(\) */)Tj
T*
(void beginCallback\(GLenum which\))Tj
0 -1.5 TD
({)Tj
T*
(   glBegin\(which\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 4)Tj
ET
endstream
endobj
1159 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1161 0 obj
<<
/Length 2762
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(})Tj
0 -3 TD
(void endCallback\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glEnd\(\);)Tj
T*
(})Tj
0 -3 TD
(void errorCallback\(GLenum errorCode\))Tj
0 -1.5 TD
({)Tj
T*
(   const GLubyte *estring;)Tj
0 -3 TD
(   estring = gluErrorString\(errorCode\);)Tj
0 -1.5 TD
(   fprintf \(stderr, "Tessellation Error: %s\\n", estring\);)Tj
T*
(   exit \(0\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
0.017 Tw
[(In Example )17(11-1)]TJ
6.7 0 TD
0.000 Tw
(, the registered GLU_TESS_VERTEX callback is simply )Tj
/F15 1 Tf
23.2 0 TD
(glVertex3dv\(\))Tj
/F11 1 Tf
5.5 0 TD
(, and only the)Tj
-35.4 -1.5 TD
(coordinates at each vertex are passed along. However, if you want to specify more information at every)Tj
T*
(vertex, such as a color value, a surface normal vector, or texture coordinate, you'll have to make a more)Tj
T*
[(complex callback routine. )10(Example 11-2)]TJ
16.2 0 TD
( shows the start of another tessellated object, further along in)Tj
-16.2 -1.5 TD
(program tess.c. The registered function )Tj
/F15 1 Tf
15.9 0 TD
(vertexCallback\(\))Tj
/F11 1 Tf
6.7 0 TD
( expects to receive a parameter that is a pointer)Tj
-22.6 -1.5 TD
(to six double-length floating point values: the )Tj
/F15 1 Tf
18.5 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(z)Tj
/F11 1 Tf
0.3 0 TD
( coordinates and the red, green, and blue color)Tj
-22.4 -1.5 TD
(values, respectively, for that vertex.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 11-2 )Tj
/F11 1 Tf
6.7 0 TD
(Vertex and Combine Callbacks: tess.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(/*  a different portion of init\(\) */)Tj
0 -1.5 TD
(   gluTessCallback\(tobj, GLU_TESS_VERTEX,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &vertexCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_BEGIN,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &beginCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_END,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &endCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_ERROR,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &errorCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_COMBINE,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &combineCallback\);)Tj
0 -3 TD
(/*  new callback routines registered by these calls */)Tj
0 -1.5 TD
(void vertexCallback\(GLvoid *vertex\))Tj
T*
({)Tj
T*
(   const GLdouble *pointer;)Tj
0 -3 TD
(   pointer = \(GLdouble *\) vertex;)Tj
0 -1.5 TD
(   glColor3dv\(pointer+3\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 5)Tj
ET
endstream
endobj
1162 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1164 0 obj
<<
/Length 3777
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glVertex3dv\(vertex\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void combineCallback\(GLdouble coords[3], )Tj
0 -1.5 TD
(                     GLdouble *vertex_data[4],)Tj
T*
(                     GLfloat weight[4], GLdouble **dataOut \))Tj
T*
({)Tj
T*
(   GLdouble *vertex;)Tj
T*
(   int i;)Tj
0 -3 TD
(   vertex = \(GLdouble *\) malloc\(6 * sizeof\(GLdouble\)\);)Tj
0 -1.5 TD
(   vertex[0] = coords[0];)Tj
T*
(   vertex[1] = coords[1];)Tj
T*
(   vertex[2] = coords[2];)Tj
T*
(   for \(i = 3; i < 7; i++\))Tj
T*
(      vertex[i] = weight[0] * vertex_data[0][i] )Tj
T*
(                  + weight[1] * vertex_data[1][i])Tj
T*
(                  + weight[2] * vertex_data[2][i] )Tj
T*
(                  + weight[3] * vertex_data[3][i];)Tj
T*
(   *dataOut = vertex;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Example 11-2)Tj
5.6 0 TD
( also shows the use of the GLU_TESS_COMBINE callback. Whenever the tessellation)Tj
-5.6 -1.5 TD
(algorithm examines the input contours, detects an intersection, and decides it must create a new vertex,)Tj
T*
(the GLU_TESS_COMBINE callback is invoked. The callback is also called when the tessellator decides)Tj
T*
(to merge features of two vertices that are very close to one another. The newly created vertex is a linear)Tj
T*
(combination of up to four existing vertices, referenced by )Tj
/F15 1 Tf
23.3 0 TD
(vertex_data)Tj
/F11 1 Tf
4.7 0 TD
[([0..3] in )44(Example 11-2)170(. The)]TJ
-28 -1.5 TD
(coefficients of the linear combination are given by )Tj
/F15 1 Tf
20.4 0 TD
(weight)Tj
/F11 1 Tf
2.7 0 TD
([0..3]; these weights sum to 1.0. )Tj
/F15 1 Tf
13.1 0 TD
(coords)Tj
/F11 1 Tf
2.7 0 TD
( gives)Tj
-38.9 -1.5 TD
(the location of the new vertex.)Tj
0 -2.1 TD
(The registered callback routine must allocate memory for another vertex, perform a weighted)Tj
0 -1.5 TD
(interpolation of data using )Tj
/F15 1 Tf
10.8 0 TD
(vertex_data)Tj
/F11 1 Tf
4.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(weight)Tj
/F11 1 Tf
2.7 0 TD
(, and return the new vertex pointer as )Tj
/F15 1 Tf
15.1 0 TD
(dataOut)Tj
/F11 1 Tf
3.3 0 TD
(.)Tj
/F15 1 Tf
-38.5 -1.5 TD
(combineCallback\(\))Tj
/F11 1 Tf
7.7 0 TD
[( in )78(Example 11-2)170( interpolates the RGB color value. The function allocates a)]TJ
-7.7 -1.5 TD
(six-element array, puts the )Tj
/F15 1 Tf
10.9 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( coordinates in the first three elements, and then puts the weighted)Tj
-14.8 -1.5 TD
(average of the RGB color values in the last three elements.)Tj
/F27 1 Tf
0 -3 TD
(User-Specified Data)Tj
/F11 1 Tf
0 -2.1 TD
(Six kinds of callbacks can be registered. Since there are two versions of each kind of callback, there are)Tj
0 -1.5 TD
(twelve callbacks in all. For each kind of callback, there is one with user-specified data and one without.)Tj
T*
(The user-specified data is given by the application to )Tj
/F15 1 Tf
21.4 0 TD
(gluTessBeginPolygon\(\))Tj
/F11 1 Tf
9.4 0 TD
( and is then passed,)Tj
-30.8 -1.5 TD
(unaltered, to each *DATA callback routine. With GLU_TESS_BEGIN_DATA, the user-specified data)Tj
T*
(may be used for "per-polygon" data. If you specify both versions of a particular callback, the callback)Tj
T*
(with )Tj
/F15 1 Tf
2 0 TD
(user_data)Tj
/F11 1 Tf
4 0 TD
( is used, and the other is ignored. So, although there are twelve callbacks, you can have a)Tj
-6 -1.5 TD
(maximum of six callback functions active at any time.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 6)Tj
ET
endstream
endobj
1165 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1168 0 obj
<<
/Length 4209
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 703.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(For instance, )17(Example 11-2)170( uses smooth shading, so )]TJ
/F15 1 Tf
21.2 0 TD
(vertexCallback\(\))Tj
/F11 1 Tf
6.7 0 TD
( specifies an RGB color for every)Tj
-27.9 -1.5 TD
(vertex. If you want to do lighting and smooth shading, the callback would specify a surface normal for)Tj
T*
(every vertex. However, if you want lighting and flat shading, you might specify only one surface normal)Tj
T*
(for every polygon, not for every vertex. In that case, you might choose to use the)Tj
T*
(GLU_TESS_BEGIN_DATA callback and pass the vertex coordinates and surface normal in the)Tj
/F15 1 Tf
T*
(user_data)Tj
/F11 1 Tf
4 0 TD
( pointer.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 599.000 Tm
(Tessellation Properties)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 577.000 Tm
(Prior to tessellation and rendering, you may use )Tj
/F15 1 Tf
19.4 0 TD
(gluTessProperty\(\))Tj
/F11 1 Tf
7.2 0 TD
( to set several properties to affect the)Tj
-26.6 -1.5 TD
(tessellation algorithm. The most important and complicated of these properties is the winding rule, which)Tj
T*
(determines what is considered "interior" and "exterior.")Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluTessProperty)12(\(GLUtesselator *)-27(tessobj)78(, GLenum )-6(property)-56(,)]TJ
0 -1.1 TD
0.050 Tw
[(GLdouble value)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(For the tessellation object )23(tessobj)-22(, the current value of )11(property)-56( is set to )56(value)-34(. property)44( is one of)]TJ
T*
(GLU_TESS_BOUNDARY_ONLY, GLU_TESS_TOLERANCE, or GLU_TESS_WINDING_RULE.)Tj
T*
[(If )-39(property)44( is GLU_TESS_BOUNDARY_ONLY, )-41(value)66( is either GL_TRUE or GL_FALSE. When set)]TJ
T*
(to GL_TRUE, polygons are no longer tessellated into filled polygons; line loops are drawn to)Tj
T*
(outline the contours that separate the polygon interior and exterior. The default value is GL_FALSE.)Tj
T*
[(\(See )-29(gluTessNormal\(\))79( to see how to control the winding direction of the contours.\))]TJ
T*
[(If )-39(property)44( is GLU_TESS_TOLERANCE, )-53(value)66( is a distance used to calculate whether two vertices)]TJ
T*
(are close together enough to be merged by the GLU_TESS_COMBINE callback. The tolerance value)Tj
T*
(is multiplied by the largest coordinate magnitude of an input vertex to determine the maximum)Tj
T*
(distance any feature can move as a result of a single merge operation. Feature merging may not be)Tj
T*
(supported by your implementation, and the tolerance value is only a hint. The default tolerance)Tj
T*
(value is zero.)Tj
T*
[(The GLU_TESS_WINDING_RULE )46(property)-56( determines which parts of the polygon are on the)]TJ
T*
[(interior and which are the exterior and should not be filled. )14(value)-34( can be one of)]TJ
T*
(GLU_TESS_WINDING_ODD \(the default\), GLU_TESS_WINDING_NONZERO,)Tj
T*
(GLU_TESS_WINDING_POSITIVE, GLU_TESS_WINDING_NEGATIVE, or)Tj
T*
(GLU_TESS_WINDING_ABS_GEQ_TWO.)Tj
/F27 1 Tf
-1.8 -3 TD
(Winding Numbers and Winding Rules)Tj
/F11 1 Tf
0 -2.1 TD
(For a single contour, the winding number of a point is the signed number of revolutions we make around)Tj
0 -1.5 TD
(that point while traveling once around the contour \(where a counterclockwise revolution is positive and a)Tj
T*
(clockwise revolution is negative\). When there are several contours, the individual winding numbers are)Tj
T*
(summed. This procedure associates a signed integer value with each point in the plane. Note that the)Tj
T*
(winding number is the same for all points in a single region.)Tj
0 -2.1 TD
[(Figure 11-2)226( shows three sets of contours and winding numbers for points inside those contours. In the)]TJ
0 -1.5 TD
(left set, all three contours are counterclockwise, so each nested interior region adds one to the winding)Tj
T*
(number. For the middle set, the two interior contours are drawn clockwise, so the winding number)Tj
T*
(decreases and actually becomes negative.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 7)Tj
ET
endstream
endobj
1169 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1170 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im97
/Width 526
/Height 191
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.96)
>>
stream
endstream
endobj
1172 0 obj
<<
/Length 1394
>>
stream
q
1 i 
124.000 717.180 423.000 -153.590 re
W n
/GS1 gs
q
423 0 0 154 124 563.18 cm
/Im97 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 551.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 11-2 )Tj
/F11 1 Tf
5.6 0 TD
(Winding Numbers for Sample Contours)Tj
-5.6 -2.1 TD
(The winding rule classifies a region as )Tj
/F15 1 Tf
15.6 0 TD
(inside)Tj
/F11 1 Tf
2.4 0 TD
( if its winding number belongs to the chosen category \(odd,)Tj
-18 -1.5 TD
(nonzero, positive, negative, or "absolute value of greater than or equal to two"\). The odd and nonzero)Tj
T*
(rules are common ways to define the interior. The positive, negative, and "absolute value>=2" winding)Tj
T*
(rules have some limited use for polygon CSG \(computational solid geometry\) operations.)Tj
0 -2.1 TD
(The program tesswind.c demonstrates the effects of winding rules. The four sets of contours shown in)Tj
0 -1.5 TD
[(Figure 11-3)226( are rendered. The user can then cycle through the different winding rule properties to see)]TJ
T*
(their effects. For each winding rule, the dark areas represent interiors. Note the effect of clockwise and)Tj
T*
(counterclockwise winding.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 8)Tj
ET
endstream
endobj
1173 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im97 1170 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1174 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im98
/Width 512
/Height 638
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.97)
>>
stream
endstream
endobj
1176 0 obj
<<
/Length 897
>>
stream
/GS1 gs
q
423 0 0 527 124 193 cm
/Im98 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 180.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 11-3 )Tj
/F11 1 Tf
5.6 0 TD
(How Winding Rules Define Interiors)Tj
/F27 1 Tf
-5.6 -3 TD
(CSG Uses for Winding Rules)Tj
/F11 1 Tf
0 -2.1 TD
(GLU_TESS_WINDING_ODD and GLU_TESS_WINDING_NONZERO are the most commonly used)Tj
0 -1.5 TD
(winding rules. They work for the most typical cases of shading.)Tj
0 -2.1 TD
(The winding rules are also designed for computational solid geometry \(CSG\) operations. Thy make it)Tj
0 -1.5 TD
(easy to find the union, difference, or intersection \(Boolean operations\) of several contours.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 9)Tj
ET
endstream
endobj
1177 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im98 1174 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1179 0 obj
<<
/Length 4602
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 705.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(First, assume that each contour is defined so that the winding number is zero for each exterior region and)Tj
0 -1.5 TD
(one for each interior region. \(Each contour must not intersect itself.\) Under this model, counterclockwise)Tj
T*
(contours define the outer boundary of the polygon, and clockwise contours define holes. Contours may)Tj
T*
(be nested, but a nested contour must be oriented oppositely from the contour that contains it.)Tj
0 -2.1 TD
(If the original polygons do not satisfy this description, they can be converted to this form by first running)Tj
0 -1.5 TD
(the tessellator with the GLU_TESS_BOUNDARY_ONLY property turned on. This returns a list of)Tj
T*
(contours satisfying the restriction just described. By creating two tessellator objects, the callbacks from)Tj
T*
(one tessellator can be fed directly as input to the other.)Tj
0 -2.1 TD
(Given two or more polygons of the preceding form, CSG operations can be implemented as follows.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(UNION)Tj
/F33 1 Tf
3.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(To calculate the union of several contours, draw all input contours as a single polygon.)Tj
-4.2 -1.6 TD
(The winding number of each resulting region is the number of original polygons that cover it. The)Tj
0 -1.5 TD
(union can be extracted by using the GLU_TESS_WINDING_NONZERO or)Tj
T*
(GLU_TESS_WINDING_POSITIVE winding rules. Note that with the nonzero winding rule, we)Tj
T*
(would get the same result if all contour orientations were reversed.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(INTERSECTION)Tj
/F33 1 Tf
7.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(This only works for two contours at a time. Draw a single polygon using two)Tj
-8.2 -1.6 TD
(contours. Extract the result using GLU_TESS_WINDING_ABS_GEQ_TWO.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(DIFFERENCE)Tj
/F33 1 Tf
6.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Suppose you want to compute A diff \(B union C union D\). Draw a single polygon)Tj
-7.1 -1.6 TD
(consisting of the unmodified contours from A, followed by the contours of B, C, and D, with their)Tj
0 -1.5 TD
(vertex order reversed. To extract the result, use the GLU_TESS_WINDING_POSITIVE winding)Tj
T*
(rule. \(If B, C, and D are the result of a GLU_TESS_BOUNDARY_ONLY operation, an alternative)Tj
T*
(to reversing the vertex order is to use )Tj
/F15 1 Tf
15.1 0 TD
(gluTessNormal\(\))Tj
/F11 1 Tf
6.8 0 TD
( to reverse the sign of the supplied normal.)Tj
/F27 1 Tf
-23.8 -3.5 TD
(Other Tessellation Property Routines)Tj
/F11 1 Tf
0 -2.2 TD
(There are complementary routines, which work alongside )Tj
/F15 1 Tf
23.3 0 TD
(gluTessProperty\(\))Tj
/F11 1 Tf
7.3 0 TD
(. )Tj
/F15 1 Tf
0.5 0 TD
(gluGetTessProperty\(\))Tj
/F11 1 Tf
-31.1 -1.5 TD
(retrieves the current values of tessellator properties. If the tessellator is being used to generate wire frame)Tj
T*
(outlines instead of filled polygons, )Tj
/F15 1 Tf
14.1 0 TD
(gluTessNormal\(\))Tj
/F11 1 Tf
6.8 0 TD
( can be used to determine the winding direction of)Tj
-20.9 -1.5 TD
(the tessellated polygons.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluGetTessProperty)56(\(GLUtesselator *)-27(tessobj)-22(, GLenum )-6(property)44(,)]TJ
0 -1.1 TD
[(GLdouble *)-49(value)66(\);)]TJ
1.8 -1.5 TD
[(For the tessellation object )23(tessobj)-22(, the current value of )11(property)-56( is returned to )90(value)-34(. Values for)]TJ
T*
[(property)44( and value)-34( are the same as for )-33(gluTessProperty\(\))-22(.)]TJ
-1.8 -2.1 TD
[(void )-28(gluTessNormal)13(\(GLUtesselator *)-27(tessobj)78(, GLdouble )-49(x)44(,)0( GLdouble )-49(y)44(,)]TJ
0 -1.1 TD
0.050 Tw
[(GLdouble z)89(\))0(;)]TJ
1.8 -1.5 TD
0.000 Tw
[(For the tessellation object )23(tessobj)-22(, gluTessNormal\(\))-21( defines a normal vector, which controls the)]TJ
T*
(winding direction of generated polygons. Before tessellation, all input data is projected into a plane)Tj
T*
(perpendicular to the normal. Then, all output triangles are oriented counterclockwise, with respect)Tj
T*
(to the normal. \(Clockwise orientation can be obtained by reversing the sign of the supplied normal.\))Tj
T*
(The default normal is \(0, 0, 0\).)Tj
/F11 1 Tf
-1.8 -2.1 TD
(If you have some knowledge about the location and orientation of the input data, then using)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 10)Tj
ET
endstream
endobj
1180 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1182 0 obj
<<
/Length 4871
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(gluTessNormal\(\))Tj
/F11 1 Tf
6.8 0 TD
0.000 Tw
( can increase the speed of the tessellation. For example, if you know that all polygons lie)Tj
-6.8 -1.5 TD
(on the x-y plane, call )Tj
/F15 1 Tf
8.7 0 TD
(gluTessNormal)Tj
/F11 1 Tf
6.1 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(tessobj)Tj
/F11 1 Tf
2.8 0 TD
(, 0, 0, 1\).)Tj
-17.9 -2.1 TD
(The default normal is \(0, 0, 0\), and its effect is not immediately obvious. In this case, it is expected that)Tj
0 -1.5 TD
(the input data lies approximately in a plane, and a plane is fitted to the vertices, no matter how they are)Tj
T*
(truly connected. The sign of the normal is chosen so that the sum of the signed areas of all input contours)Tj
T*
(is nonnegative \(where a counterclockwise contour has a positive area\). Note that if the input data does)Tj
T*
(not lie approximately in a plane, then projection perpendicular to the computed normal may substantially)Tj
T*
(change the geometry.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 571.000 Tm
(Polygon Definition)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 549.000 Tm
(After all the tessellation properties have been set and the callback actions have been registered, it is)Tj
T*
(finally time to describe the vertices that compromise input contours and tessellate the polygons.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluTessBeginPolygon )73(\(GLUtesselator *)-27(tessobj)-22(, void *)-28(user_data\);)]TJ
0 -1.1 TD
0.028 Tw
[(void gluTessEndPolygon )79(\(GLUtesselator )28(*)-27(tessobj)-22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Begins and ends the specification of a polygon to be tessellated and associates a tessellation object,)Tj
T*
[(tessobj)-22(, with it. )29(user_data points to a user-defined data structure, which is passed along all the)]TJ
T*
(GLU_TESS_*_DATA callback functions that have been bound.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(Calls to )Tj
/F15 1 Tf
3.3 0 TD
(gluTessBeginPolygon\(\))Tj
/F11 1 Tf
9.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(gluTessEndPolygon\(\))Tj
/F11 1 Tf
8.6 0 TD
( surround the definition of one or more)Tj
-23.3 -1.5 TD
(contours. When )Tj
/F15 1 Tf
6.6 0 TD
(gluTessEndPolygon\(\))Tj
/F11 1 Tf
8.6 0 TD
( is called, the tessellation algorithm is implemented, and the)Tj
-15.2 -1.5 TD
(tessellated polygons are generated and rendered. The callback functions and tessellation properties that)Tj
T*
(were bound and set to the tessellation object using )Tj
/F15 1 Tf
20.4 0 TD
(gluTessCallback\(\) )Tj
/F11 1 Tf
7.5 0 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(gluTessProperty\(\))Tj
/F11 1 Tf
7.3 0 TD
( are used.)Tj
/F15 1 Tf
-36.9 -2.1 TD
0.028 Tw
[(void gluTessBeginContour )102(\(GLUtesselator )28(*)-27(tessobj)-22(\);)]TJ
0 -1.1 TD
[(void gluTessEndContour )80(\(GLUtesselator )28(*)-27(tessobj)-22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Begins and ends the specification of a closed contour, which is a portion of a polygon. A closed)Tj
T*
[(contour consists of zero or more calls to )-9(gluTessVertex\(\))33(, which defines the vertices. The last vertex)]TJ
T*
(of each contour is automatically linked to the first.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(In practice, a minimum of three vertices is needed for a meaningful contour.)Tj
/F15 1 Tf
T*
[(void )-28(gluTessVertex )17(\(GLUtesselator *)-27(tessobj)78(, GLdouble )-49(coords)22([3],)]TJ
0 -1.1 TD
[(void *)-28(vertex_data)22(\);)]TJ
1.8 -1.5 TD
[(Specifies a vertex in the current contour for the tessellation object. )45(coords)-78( contains the)]TJ
T*
(three-dimensional vertex coordinates, and )Tj
17.2 0 TD
[(vertex_data)22( is a pointer that's sent to the callback)]TJ
-17.2 -1.5 TD
[(associated with GLU_TESS_VERTEX or GLU_TESS_VERTEX_DATA. Typically, )16(vertex_data)]TJ
T*
(contains vertex coordinates, surface normals, texture coordinates, color information, or whatever)Tj
T*
(else the application may find useful.)Tj
/F11 1 Tf
-1.8 -2.1 TD
[(In the program tess.c, a portion of which is shown in )6(Example 11-3)]TJ
26.9 0 TD
(, two polygons are defined. One)Tj
-26.9 -1.5 TD
(polygon is a rectangular contour with a triangular hole inside, and the other is a smooth-shaded,)Tj
T*
(self-intersecting, five-pointed star. For efficiency, both polygons are stored in display lists. The first)Tj
T*
(polygon consists of two contours; the outer one is wound counterclockwise, and the "hole" is wound)Tj
T*
(clockwise. For the second polygon, the )Tj
/F15 1 Tf
15.9 0 TD
(star)Tj
/F11 1 Tf
1.5 0 TD
( array contains both the coordinate and color data, and its)Tj
-17.4 -1.5 TD
(tessellation callback, )Tj
/F15 1 Tf
8.6 0 TD
(vertexCallback\(\))Tj
/F11 1 Tf
6.7 0 TD
(, uses both.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 11)Tj
ET
endstream
endobj
1183 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1185 0 obj
<<
/Length 3230
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(It is important that each vertex is in a different memory location because the vertex data is not copied by)Tj
/F15 1 Tf
0 -1.5 TD
(gluTessVertex\(\))Tj
/F11 1 Tf
6.3 0 TD
(; only the pointer \()Tj
/F15 1 Tf
7.5 0 TD
(vertex_data)Tj
/F11 1 Tf
4.7 0 TD
(\) is saved. A program that reuses the same memory for)Tj
-18.5 -1.5 TD
(several vertices may not get the desired result.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(In )Tj
/F15 1 Tf
1.1 0 TD
(gluTessVertex\(\))Tj
/F11 1 Tf
6.3 0 TD
(, it may seem redundant to specify the vertex coordinate data twice, for both the)Tj
/F15 1 Tf
-10.2 -1.4 TD
(coords)Tj
/F11 1 Tf
2.7 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(vertex_data)Tj
/F11 1 Tf
4.7 0 TD
( parameters; however, both are necessary. )Tj
/F15 1 Tf
17 0 TD
(coords)Tj
/F11 1 Tf
2.7 0 TD
( refers only to the vertex)Tj
-29.1 -1.4 TD
(coordinates. )Tj
/F15 1 Tf
5.1 0 TD
(vertex_data)Tj
/F11 1 Tf
4.7 0 TD
( uses the coordinate data, but may also use other information for each vertex.)Tj
/F27 1 Tf
-9.8 -2.1 TD
(Example 11-3 )Tj
/F11 1 Tf
6.7 0 TD
(Polygon Definition: tess.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(   GLdouble rect[4][3] = {50.0, 50.0, 0.0,)Tj
0 -1.5 TD
(                          200.0, 50.0, 0.0,)Tj
T*
(                          200.0, 200.0, 0.0,)Tj
T*
(                          50.0, 200.0, 0.0};)Tj
T*
(   GLdouble tri[3][3] = {75.0, 75.0, 0.0,)Tj
T*
(                         125.0, 175.0, 0.0,)Tj
T*
(                         175.0, 75.0, 0.0};)Tj
T*
(   GLdouble star[5][6] = {250.0, 50.0, 0.0, 1.0, 0.0, 1.0,)Tj
T*
(                          325.0, 200.0, 0.0, 1.0, 1.0, 0.0,)Tj
T*
(                          400.0, 50.0, 0.0, 0.0, 1.0, 1.0,)Tj
T*
(                          250.0, 150.0, 0.0, 1.0, 0.0, 0.0,)Tj
T*
(                          400.0, 150.0, 0.0, 0.0, 1.0, 0.0};)Tj
0 -3 TD
(   startList = glGenLists\(2\);)Tj
0 -1.5 TD
(   tobj = gluNewTess\(\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_VERTEX,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &glVertex3dv\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_BEGIN,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &beginCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_END,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &endCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_ERROR,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &errorCallback\);)Tj
0 -3 TD
(   glNewList\(startList, GL_COMPILE\);)Tj
0 -1.5 TD
(   glShadeModel\(GL_FLAT\);)Tj
T*
(   gluTessBeginPolygon\(tobj, NULL\);)Tj
T*
(      gluTessBeginContour\(tobj\);)Tj
T*
(         gluTessVertex\(tobj, rect[0], rect[0]\);)Tj
T*
(         gluTessVertex\(tobj, rect[1], rect[1]\);)Tj
T*
(         gluTessVertex\(tobj, rect[2], rect[2]\);)Tj
T*
(         gluTessVertex\(tobj, rect[3], rect[3]\);)Tj
T*
(      gluTessEndContour\(tobj\);)Tj
T*
(      gluTessBeginContour\(tobj\);)Tj
T*
(         gluTessVertex\(tobj, tri[0], tri[0]\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 12)Tj
ET
endstream
endobj
1186 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1188 0 obj
<<
/Length 2667
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(         gluTessVertex\(tobj, tri[1], tri[1]\);)Tj
0 -1.5 TD
(         gluTessVertex\(tobj, tri[2], tri[2]\);)Tj
T*
(      gluTessEndContour\(tobj\);)Tj
T*
(   gluTessEndPolygon\(tobj\);)Tj
T*
(   glEndList\(\);)Tj
0 -3 TD
(   gluTessCallback\(tobj, GLU_TESS_VERTEX,)Tj
0 -1.5 TD
(                   \(GLvoid \(*\) \(\)\) &vertexCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_BEGIN,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &beginCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_END,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &endCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_ERROR,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &errorCallback\);)Tj
T*
(   gluTessCallback\(tobj, GLU_TESS_COMBINE,)Tj
T*
(                   \(GLvoid \(*\) \(\)\) &combineCallback\);)Tj
0 -3 TD
(   glNewList\(startList + 1, GL_COMPILE\);)Tj
0 -1.5 TD
(   glShadeModel\(GL_SMOOTH\);)Tj
T*
(   gluTessProperty\(tobj, GLU_TESS_WINDING_RULE,)Tj
T*
(                   GLU_TESS_WINDING_POSITIVE\);)Tj
T*
(   gluTessBeginPolygon\(tobj, NULL\);)Tj
T*
(      gluTessBeginContour\(tobj\);)Tj
T*
(         gluTessVertex\(tobj, star[0], star[0]\);)Tj
T*
(         gluTessVertex\(tobj, star[1], star[1]\);)Tj
T*
(         gluTessVertex\(tobj, star[2], star[2]\);)Tj
T*
(         gluTessVertex\(tobj, star[3], star[3]\);)Tj
T*
(         gluTessVertex\(tobj, star[4], star[4]\);)Tj
T*
(      gluTessEndContour\(tobj\);)Tj
T*
(   gluTessEndPolygon\(tobj\);)Tj
T*
(   glEndList\(\);)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 231.000 Tm
(Deleting a Tessellator Object)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 209.000 Tm
(If you no longer need a tessellation object, you can delete it and free all associated memory with)Tj
/F15 1 Tf
T*
(gluDeleteTess\(\))Tj
/F11 1 Tf
6.3 0 TD
(.)Tj
/F15 1 Tf
-6.3 -2.1 TD
0.028 Tw
[(void gluDeleteTess)67(\(GLUtesselator )28(*)-27(tessobj)-22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Deletes the specified tessellation object, )-22(tessobj)-22(, and frees all associated memory.)]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 130.000 Tm
(Tessellator Performance Tips)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 108.000 Tm
(For best performance, remember these rules.)Tj
0 -2.1 TD
[(1.)-1050(Cache the output of the tessellator in a display list or other user structure. To obtain the)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 13)Tj
ET
endstream
endobj
1189 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1191 0 obj
<<
/Length 4323
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(post-tessellation vertex coordinates, tessellate the polygons while in feedback mode. \(See)Tj
0 -1.5 TD
[("Feedback" in Chapter 13)43(.\))]TJ
-1.8 -2.1 TD
[(2.)-1050(Use )]TJ
/F15 1 Tf
3.6 0 TD
(gluTessNormal\(\))Tj
/F11 1 Tf
6.8 0 TD
( to supply the polygon normal.)Tj
-10.4 -2.1 TD
[(3.)-1050(Use the same tessellator object to render many polygons rather than allocate a new tessellator for)]TJ
1.8 -1.5 TD
(each one. \(In a multithreaded, multiprocessor environment, you may get better performance using)Tj
T*
(several tessellators.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 590.000 Tm
(Describing GLU Errors)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 569.000 Tm
(The GLU provides a routine for obtaining a descriptive string for an error code. This routine is not)Tj
T*
(limited to tessellation but is also used for NURBS and quadrics errors, as well as errors in the base GL.)Tj
T*
[(\(See )27("Error Handling" in Chapter 14)-7( for information about OpenGL's error handling facility.\))]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 510.000 Tm
(Backward Compatibility)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 488.000 Tm
(If you are using the 1.0 or 1.1 version of GLU, you have a much less powerful tessellator available. The)Tj
T*
(1.0/1.1 tessellator handles only simple nonconvex polygons or simple polygons containing holes. It does)Tj
T*
(not properly tessellate intersecting contours \(no COMBINE callback\), nor process per-polygon data.)Tj
0 -2.1 TD
(The 1.0/1.1 tessellator has some similarities to the current tessellator. )Tj
/F15 1 Tf
27.9 0 TD
(gluNewTess\(\))Tj
/F11 1 Tf
5.5 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(gluDeleteTess\(\))Tj
/F11 1 Tf
-35.4 -1.5 TD
(are used for both tessellators. The main vertex specification routine remains )Tj
/F15 1 Tf
30.6 0 TD
(gluTessVertex\(\))Tj
/F11 1 Tf
6.3 0 TD
(. The)Tj
-36.9 -1.5 TD
(callback mechanism is controlled by )Tj
/F15 1 Tf
14.9 0 TD
(gluTessCallback\(\))Tj
/F11 1 Tf
7.3 0 TD
(, although there are only five callback functions)Tj
-22.2 -1.5 TD
(that can be registered, a subset of the current twelve.)Tj
0 -2.1 TD
(Here are the prototypes for the 1.0/1.1 tessellator. The 1.0/1.1 tessellator still works in GLU 1.2, but its)Tj
0 -1.5 TD
(use is no longer recommended.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void gluBeginPolygon)45(\(GLUtriangulatorObj )28(*)-26(tessobj)-22(\);)]TJ
0 -1.1 TD
0.000 Tw
[(void )-28(gluNextContour)46(\(GLUtriangulatorObj *)-26(tessobj)-22(, GLenum )-6(type)66(\);)]TJ
T*
0.028 Tw
[(void gluEndPolygon)23(\(GLUtriangulatorObj )28(*)-26(tessobj)78(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(The outermost contour must be specified first, and it does not require an initial call to)Tj
T*
[(gluNextContour\(\))12(. For polygons without holes, only one contour is defined, and )14(gluNextContour\(\))12( is)]TJ
T*
(not used. If a polygon has multiple contours \(that is, holes or holes within holes\), the contours are)Tj
T*
[(specified one after the other, each preceded by )-30(gluNextContour\(\))12(. gluTessVertex\(\))33( is called for each)]TJ
T*
(vertex of a contour.)Tj
T*
[(For )-50(gluNextContour\(\))12(, type can be GLU_EXTERIOR, GLU_INTERIOR, GLU_CCW, GLU_CW, or)]TJ
T*
(GLU_UNKNOWN. These serve only as hints to the tessellation. If you get them right, the tessellation)Tj
T*
(might go faster. If you get them wrong, they're ignored, and the tessellation still works. For)Tj
T*
(polygons with holes, one contour is the exterior contour and the other's interior. The first contour is)Tj
T*
(assumed to be of type GLU_EXTERIOR. Choosing clockwise and counterclockwise orientation is)Tj
T*
(arbitrary in three dimensions; however, there are two different orientations in any plane, and the)Tj
T*
(GLU_CCW and GLU_CW types should be used consistently. Use GLU_UNKNOWN if you don't)Tj
T*
(have a clue.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(It is highly recommended that you convert GLU 1.0/1.1 code to the new tessellation interface for GLU)Tj
0 -1.5 TD
(1.2 by following these steps.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 14)Tj
ET
endstream
endobj
1192 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1194 0 obj
<<
/Length 5075
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(1.)-1050(Change references to the major data structure type from GLUtriangulatorObj to GLUtesselator. In)]TJ
1.8 -1.5 TD
(GLU 1.2, GLUtriangulatorObj and GLUtesselator are defined to be the same type.)Tj
-1.8 -2.1 TD
[(2.)-1050(Convert )]TJ
/F15 1 Tf
5.3 0 TD
(gluBeginPolygon\(\))Tj
/F11 1 Tf
7.6 0 TD
( to two commands: )Tj
/F15 1 Tf
7.9 0 TD
(gluTessBeginPolygon\(\))Tj
/F11 1 Tf
9.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluTessBeginContour\(\))Tj
/F11 1 Tf
9.4 0 TD
(.)Tj
-39.7 -1.5 TD
(All contours must be explicitly started, including the first one.)Tj
-1.8 -2.1 TD
[(3.)-1050(Convert )]TJ
/F15 1 Tf
5.3 0 TD
(gluNextContour\(\))Tj
/F11 1 Tf
7.1 0 TD
( to both )Tj
/F15 1 Tf
3.3 0 TD
(gluTessEndContour\(\))Tj
/F11 1 Tf
8.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluTessBeginContour\(\))Tj
/F11 1 Tf
9.4 0 TD
(. You have to)Tj
-33.9 -1.5 TD
(end the previous contour before starting the next one.)Tj
-1.8 -2.1 TD
[(4.)-1050(Convert )]TJ
/F15 1 Tf
5.3 0 TD
(gluEndPolygon\(\))Tj
/F11 1 Tf
6.9 0 TD
( to both )Tj
/F15 1 Tf
3.3 0 TD
(gluTessEndContour\(\))Tj
/F11 1 Tf
8.6 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(gluTessEndPolygon\(\))Tj
/F11 1 Tf
8.6 0 TD
(. The final contour)Tj
-32.9 -1.5 TD
(must be closed.)Tj
-1.8 -2.1 TD
[(5.)-1050(Change references to constants to )]TJ
/F15 1 Tf
15.5 0 TD
(gluTessCallback\(\))Tj
/F11 1 Tf
7.3 0 TD
(. In GLU 1.2, GLU_BEGIN, GLU_VERTEX,)Tj
-21 -1.5 TD
(GLU_END, GLU_ERROR, and GLU_EDGE_FLAG are defined as synonyms for)Tj
T*
(GLU_TESS_BEGIN, GLU_TESS_VERTEX, GLU_TESS_END, GLU_TESS_ERROR, and)Tj
T*
(GLU_TESS_EDGE_FLAG.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 482.000 Tm
(Quadrics: Rendering Spheres, Cylinders, and Disks)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 460.000 Tm
(The base OpenGL library only provides support for modeling and rendering simple points, lines, and)Tj
T*
(convex filled polygons. Neither 3D objects, nor commonly used 2D objects such as circles, are directly)Tj
T*
(available.)Tj
0 -2.1 TD
(Throughout this book, you've been using GLUT to create some 3D objects. The GLU also provides)Tj
0 -1.5 TD
(routines to model and render tessellated, polygonal approximations for a variety of 2D and 3D shapes)Tj
T*
(\(spheres, cylinders, disks, and parts of disks\), which can be calculated with quadric equations. This)Tj
T*
(includes routines to draw the quadric surfaces in a variety of styles and orientations. Quadric surfaces are)Tj
T*
(defined by the following general quadratic equation:)Tj
/F15 1 Tf
0 -2.4 TD
(a)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
/F15 1 Tf
0.5 0.2 TD
(x)Tj
/F11 1 Tf
0.4 0.3 TD
(2)Tj
/F15 1 Tf
0.5 -0.3 TD
( + a)Tj
/F11 1 Tf
1.7 -0.2 TD
(2)Tj
/F15 1 Tf
0.5 0.2 TD
(y)Tj
/F11 1 Tf
0.5 0.3 TD
(2)Tj
/F15 1 Tf
0.5 -0.3 TD
( + a)Tj
/F11 1 Tf
1.6 -0.2 TD
(3)Tj
/F15 1 Tf
0.5 0.2 TD
(z)Tj
/F11 1 Tf
0.4 0.3 TD
(2)Tj
/F15 1 Tf
0.5 -0.3 TD
( + a)Tj
/F11 1 Tf
1.7 -0.2 TD
(4)Tj
/F15 1 Tf
0.5 0.2 TD
(xy + a)Tj
/F11 1 Tf
2.6 -0.2 TD
(5)Tj
/F15 1 Tf
0.5 0.2 TD
(yx + a)Tj
/F11 1 Tf
2.5 -0.2 TD
(6)Tj
/F15 1 Tf
0.5 0.2 TD
(xz + a)Tj
/F11 1 Tf
2.5 -0.2 TD
(7)Tj
/F15 1 Tf
0.5 0.2 TD
(x + a)Tj
/F11 1 Tf
2.2 -0.2 TD
(8)Tj
/F15 1 Tf
0.5 0.2 TD
(y + a)Tj
/F11 1 Tf
2.1 -0.2 TD
(9)Tj
/F15 1 Tf
0.5 0.2 TD
(z + a)Tj
/F11 1 Tf
2 -0.2 TD
(10)Tj
/F15 1 Tf
1 0.2 TD
( = 0)Tj
/F11 1 Tf
-27.7 -2.3 TD
(\(See David Rogers' )Tj
/F15 1 Tf
8.1 0 TD
(Procedural Elements for Computer Graphics.)Tj
/F11 1 Tf
18.4 0 TD
( New York, NY: McGraw-Hill Book)Tj
-26.5 -1.5 TD
(Company, 1985.)Tj
/F15 1 Tf
6.6 0 TD
(\))Tj
/F11 1 Tf
0.4 0 TD
( Creating and rendering a quadric surface is similar to using the tessellator. To use a)Tj
-7 -1.5 TD
(quadrics object, follow these steps.)Tj
0 -2.1 TD
[(1.)-1050(To create a quadrics object, use )]TJ
/F15 1 Tf
14.7 0 TD
(gluNewQuadric\(\))Tj
/F11 1 Tf
7 0 TD
(.)Tj
-21.7 -2.1 TD
[(2.)-1050(Specify the rendering attributes for the quadrics object \(unless you're satisfied with the default)]TJ
1.8 -1.5 TD
(values\).)Tj
0 -2.1 TD
[(1.)-1050(Use )]TJ
/F15 1 Tf
3.6 0 TD
(gluQuadricOrientation\(\))Tj
/F11 1 Tf
9.9 0 TD
( to control the winding direction and differentiate the interior from)Tj
-11.7 -1.5 TD
(the exterior.)Tj
-1.8 -2.1 TD
[(2.)-1050(Use )]TJ
/F15 1 Tf
3.6 0 TD
(gluQuadricDrawStyle\(\))Tj
/F11 1 Tf
9.5 0 TD
( to choose between rendering the object as points, lines, or filled)Tj
-11.3 -1.5 TD
(polygons.)Tj
-1.8 -2.1 TD
[(3.)-1050(For lit quadrics objects, use )]TJ
/F15 1 Tf
13.1 0 TD
(gluQuadricNormals\(\))Tj
/F11 1 Tf
8.7 0 TD
( to specify one normal per vertex or one)Tj
-20 -1.5 TD
(normal per face. The default is that no normals are generated at all.)Tj
-1.8 -2.1 TD
[(4.)-1050(For textured quadrics objects, use )]TJ
/F15 1 Tf
15.5 0 TD
(gluQuadricTexture\(\))Tj
/F11 1 Tf
8.4 0 TD
( if you want to generate texture)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 15)Tj
ET
endstream
endobj
1195 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1197 0 obj
<<
/Length 4331
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 160.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(coordinates.)Tj
-3.6 -2.1 TD
0.000 Tw
[(3.)-1050(Prepare for problems by registering an error-handling routine with )]TJ
/F15 1 Tf
28.6 0 TD
(gluQuadricCallback\(\))Tj
/F11 1 Tf
8.9 0 TD
(. Then, if)Tj
-35.7 -1.5 TD
(an error occurs during rendering, the routine you've specified is invoked.)Tj
-1.8 -2.1 TD
[(4.)-1050(Now invoke the rendering routine for the desired type of quadrics object:)]TJ
/F15 1 Tf
31 0 TD
( gluSphere\(\))Tj
/F11 1 Tf
5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(gluCylinder\(\))Tj
/F11 1 Tf
5.5 0 TD
(,)Tj
/F15 1 Tf
-40.2 -1.5 TD
(gluDisk\(\))Tj
/F11 1 Tf
3.8 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(gluPartialDisk\(\))Tj
/F11 1 Tf
6.6 0 TD
(. For best performance for static data, encapsulate the quadrics object)Tj
-12 -1.5 TD
(in a display list.)Tj
-1.8 -2.1 TD
[(5.)-1050(When you're completely finished with it, destroy this object with )]TJ
/F15 1 Tf
28.2 0 TD
(gluDeleteQuadric\(\))Tj
/F11 1 Tf
7.8 0 TD
(. If you need to)Tj
-34.2 -1.5 TD
(create another quadric, it's best to reuse your quadrics object.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 554.000 Tm
(Manage Quadrics Objects)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 533.000 Tm
(A quadrics object consists of parameters, attributes, and callbacks that are stored in a data structure of)Tj
T*
(type GLUquadricObj. A quadrics object may generate vertices, normals, texture coordinates, and other)Tj
T*
(data, all of which may be used immediately or stored in a display list for later use. The following routines)Tj
T*
(create, destroy, and report upon errors of a quadrics object.)Tj
/F15 1 Tf
0 -2.1 TD
0.038 Tw
[(GLUquadricObj* gluNewQuadric)-10( )38(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Creates a new quadrics object and returns a pointer to it. A null pointer is returned if the routine)Tj
T*
(fails.)Tj
-1.8 -2.1 TD
[(void )-28(gluDeleteQuadric)22( \(GLUquadricObj *)45(qobj)-22(\);)]TJ
1.8 -1.5 TD
[(Destroys the quadrics object )22(qobj)-22( and frees up any memory used by it.)]TJ
-1.8 -2.1 TD
[(void )-28(gluQuadricCallback)23( \(GLUquadricObj *)45(qobj)-22(, GLenum )-6(which)-11(, void \(*fn)-22(\)\(\)\);)]TJ
1.8 -1.5 TD
[(Defines a function )-16(fn)-22( to be called in special circumstances. GLU_ERROR is the only legal value for)]TJ
T*
[(which)-11(, so )39(fn)-22( is called when an error occurs. If )-38(fn)78( is NULL, any existing callback is erased.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(For GLU_ERROR, )Tj
/F15 1 Tf
8 0 TD
(fn)Tj
/F11 1 Tf
0.8 0 TD
( is called with one parameter, which is the error code. )Tj
/F15 1 Tf
21.7 0 TD
(gluErrorString\(\))Tj
/F11 1 Tf
6.7 0 TD
( can be used)Tj
-37.2 -1.5 TD
(to convert the error code into an ASCII string.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 285.000 Tm
(Control Quadrics Attributes)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 263.000 Tm
(The following routines affect the kinds of data generated by the quadrics routines. Use these routines)Tj
T*
(before you actually specify the primitives.)Tj
0 -2.1 TD
(Example 11-4)Tj
5.6 0 TD
[(, quadric.c, on )-56(page 435)38(, demonstrates changing the drawing style and the kind of normals)]TJ
-5.6 -1.5 TD
(generated as well as creating quadrics objects, error handling, and drawing the primitives.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluQuadricDrawStyle)34( \(GLUquadricObj *)45(qobj)-22(, GLenum )-6(drawStyle\);)]TJ
1.8 -1.5 TD
[(For the quadrics object )-33(qobj)78(, drawStyle controls the rendering style. Legal values for )-71(drawStyle are)]TJ
T*
(GLU_POINT, GLU_LINE, GLU_SILHOUETTE, and GLU_FILL.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(GLU_POINT and GLU_LINE specify that primitives should be rendered as a point at every vertex or a)Tj
0 -1.5 TD
(line between each pair of connected vertices.)Tj
0 -2.1 TD
(GLU_SILHOUETTE specifies that primitives are rendered as lines, except that edges separating)Tj
0 -1.5 TD
(coplanar faces are not drawn. This is most often used for )Tj
/F15 1 Tf
22.9 0 TD
(gluDisk\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(gluPartialDisk\(\))Tj
/F11 1 Tf
6.6 0 TD
(.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 16)Tj
ET
endstream
endobj
1198 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1201 0 obj
<<
/Length 4940
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(GLU_FILL specifies rendering by filled polygons, where the polygons are drawn in a counterclockwise)Tj
0 -1.5 TD
(fashion with respect to their normals. This may be affected by )Tj
/F15 1 Tf
25.1 0 TD
(gluQuadricOrientation\(\))Tj
/F11 1 Tf
9.9 0 TD
(.)Tj
/F15 1 Tf
-35 -2.1 TD
[(void )-28(gluQuadricOrientation)-21( \(GLUquadricObj *)45(qobj)-22(, GLenum )-6(orientation)45(\);)]TJ
1.8 -1.5 TD
[(For the quadrics object )-33(qobj)78(, orientation)-55( is either GLU_OUTSIDE \(the default\) or GLU_INSIDE,)]TJ
T*
(which controls the direction in which normals are pointing.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(For )Tj
/F15 1 Tf
1.6 0 TD
(gluSphere\(\))Tj
/F11 1 Tf
4.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluCylinder\(\))Tj
/F11 1 Tf
5.4 0 TD
(, the definitions of outside and inside are obvious. For )Tj
/F15 1 Tf
21.9 0 TD
(gluDisk\(\))Tj
/F11 1 Tf
3.8 0 TD
( and)Tj
/F15 1 Tf
-39.4 -1.5 TD
(gluPartialDisk\(\))Tj
/F11 1 Tf
6.6 0 TD
(, the positive )Tj
/F15 1 Tf
5.4 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( side of the disk is considered to be outside.)Tj
/F15 1 Tf
-12.4 -2.1 TD
[(void )-28(gluQuadricNormals)57( \(GLUquadricObj *)-55(qobj)-22(, GLenum )94(normals)-22(\);)]TJ
1.8 -1.5 TD
[(For the quadrics object )-33(qobj)78(, normals)-22( is one of GLU_NONE \(the default\), GLU_FLAT, or)]TJ
T*
(GLU_SMOOTH.)Tj
-1.8 -2.1 TD
(gluQuadricNormals\(\))Tj
/F11 1 Tf
8.7 0 TD
( is used to specify when to generate normal vectors. GLU_NONE means that no)Tj
-8.7 -1.5 TD
(normals are generated and is intended for use without lighting. GLU_FLAT generates one normal for)Tj
T*
(each facet, which is often best for lighting with flat shading. GLU_SMOOTH generates one normal for)Tj
T*
(every vertex of the quadric, which is usually best for lighting with smooth shading.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluQuadricTexture)67( \(GLUquadricObj *)-55(qobj)-22(,)]TJ
0 -1.1 TD
0.049 Tw
[(GLboolean textureCoords)23(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(For the quadrics object )-33(qobj)78(, textureCoords)-77( is either GL_FALSE \(the default\) or GL_TRUE. If the)]TJ
T*
[(value of )44(textureCoords)-77( is GL_TRUE, then texture coordinates are generated for the quadrics object.)]TJ
T*
(The manner in which the texture coordinates are generated varies, depending upon the type of)Tj
T*
(quadrics object rendered.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 371.000 Tm
(Quadrics Primitives)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 350.000 Tm
(The following routines actually generate the vertices and other data that constitute a quadrics object. In)Tj
T*
(each case, )Tj
/F15 1 Tf
4.3 0 TD
(qobj)Tj
/F11 1 Tf
1.8 0 TD
( refers to a quadrics object created by )Tj
/F15 1 Tf
15.2 0 TD
(gluNewQuadric\(\))Tj
/F11 1 Tf
7.1 0 TD
(.)Tj
/F15 1 Tf
-28.4 -2.1 TD
[(void )-28(gluSphere)55( \(GLUquadricObj *)-55(qobj)78(, GLdouble )-49(radius)-44(,)]TJ
0 -1.1 TD
0.016 Tw
[(GLint slices)22(, )16(GLint stacks)44(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Draws a sphere of the given radius)-44(, centered around the origin, \(0, 0, 0\). The sphere is subdivided)]TJ
T*
[(around the )12(z)-11( axis into a number of slices)22( \(similar to longitude\) and along the )8(z)-11( axis into a number of)]TJ
T*
[(stacks)44( \(latitude\).)]TJ
T*
[(If texture coordinates are also generated by the quadrics facility, the )-22(t)-22( coordinate ranges from 0.0 at)]TJ
T*
[(z)-11( = -radius to 1.0 at )]TJ
8.3 0 TD
[(z)89( = radius, with )-95(t)78( increasing linearly along longitudinal lines. Meanwhile, )-13(s)]TJ
-8.3 -1.5 TD
[(ranges from 0.0 at the +)-13(y)44( axis, to 0.25 at the +)-35(x)44( axis, to 0.5 at the -)]TJ
27 0 TD
[(y)44( axis, to 0.75 at the -)]TJ
8.6 0 TD
[(x)-56( axis, and)]TJ
-35.6 -1.5 TD
[(back to 1.0 at the +)42(y)-56( axis.)]TJ
-1.8 -2.1 TD
[(void )-28(gluCylinder)-21( \(GLUquadricObj *)45(qobj)-22(, GLdouble )51(baseRadius)12(,)]TJ
0 -1.1 TD
0.049 Tw
[(GLdouble topRadius)56(, )49(GLdouble height,)]TJ
T*
0.016 Tw
[(GLint slices)22(, )16(GLint stacks)44(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Draws a cylinder oriented along the )-21(z)-11( axis, with the base of the cylinder at )46(z)-11( = 0 and the top at z)-11( =)]TJ
T*
[(height. Like a sphere, the cylinder is subdivided around the z)-11( axis into a number of slices)22( and along)]TJ
T*
[(the )-28(z)-11( axis into a number of stacks)44(. baseRadius)12( is the radius of the cylinder at z)-11( = 0. )-25(topRadius)56( is the)]TJ
T*
[(radius of the cylinder at )-38(z)-11( = height. If )37(topRadius)56( is set to zero, then a cone is generated.)]TJ
T*
[(If texture coordinates are generated by the quadrics facility, then the )33(t)-22( coordinate ranges linearly)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 17)Tj
ET
endstream
endobj
1202 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1204 0 obj
<<
/Length 4224
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(from 0.0 at )-32(z)-11( = 0 to 1.0 at )82(z)-11( = )-25(height. The )-50(s)89( texture coordinates are generated the same way as they)]TJ
0 -1.5 TD
(are for a sphere.)Tj
/F27 1 Tf
-1.8 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(The cylinder is not closed at the top or bottom. The disks at the base and at the top are not drawn.)Tj
/F15 1 Tf
-2.8 -2.1 TD
[(void )-28(gluDisk)11( \(GLUquadricObj *)45(qobj)-22(, GLdouble )-49(innerRadius)90(,)]TJ
0 -1.1 TD
[(GLdouble )-50(outerRadius)90(, GLint )-16(slices)22(, GLint )-16(rings)-44(\);)]TJ
1.8 -1.5 TD
[(Draws a disk on the )-49(z)89( = 0 plane, with a radius of outerRadius)-10( and a concentric circular hole with a)]TJ
T*
[(radius of )34(innerRadius)-10(. If )-39(innerRadius)-10( is 0, then no hole is created. The disk is subdivided around the)]TJ
T*
[(z)-11( axis into a number of slices)22( \(like slices of pizza\) and also about the )-15(z)-11( axis into a number of)]TJ
T*
0.028 Tw
[(concentric rings)56(.)]TJ
T*
0.000 Tw
[(With respect to orientation, the +z)-11( side of the disk is considered to be "outside"; that is, any normals)]TJ
T*
[(generated point along the +)31(z)-11( axis. Otherwise, the normals point along the -)]TJ
30.2 0 TD
[(z)-11( axis.)]TJ
-30.2 -1.5 TD
(If texture coordinates are generated by the quadrics facility, then the texture coordinates are)Tj
T*
[(generated linearly such that where R=)-19(outerRadius)-10(, the values for s)-11( and t)78( at \(R, 0, 0\) is \(1, 0.5\), at \(0,)]TJ
T*
(R, 0\) they are \(0.5, 1\), at \(-R, 0, 0\) they are \(0, 0.5\), and at \(0, -R, 0\) they are \(0.5, 0\).)Tj
-1.8 -2.1 TD
[(void )-28(gluPartialDisk)46( \(GLUquadricObj *)-55(qobj)78(, GLdouble )-49(innerRadius)-10(,)]TJ
0 -1.1 TD
[(GLdouble )-50(outerRadius)90(, GLint )-16(slices)22(, GLint )-16(rings)-44(,)]TJ
T*
0.049 Tw
[(GLdouble startAngle)67(, )49(GLdouble sweepAngle)78(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Draws a partial disk on the )24(z)-11( = 0 plane. A partial disk is similar to a complete disk, in terms of)]TJ
T*
[(outerRadius)-10(, innerRadius)-10(, slices)22(, and )-50(rings)56(. The difference is that only a portion of a partial disk is)]TJ
T*
[(drawn, starting from )-42(startAngle)67( through )-33(startAngle)-33(+)75(sweepAngle)-22( \(where )-23(startAngle)-33( and sweepAngle)]TJ
T*
[(are measured in degrees, where 0 degrees is along the +)-42(y)44( axis, 90 degrees along the +)47(x)-56( axis, 180)]TJ
T*
(along the -)Tj
4.3 0 TD
[(y)-56( axis, and 270 along the -)]TJ
10.7 0 TD
[(x)44( axis\).)]TJ
-15 -1.5 TD
(A partial disk handles orientation and texture coordinates in the same way as a complete disk.)Tj
/F27 1 Tf
-1.8 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(For all quadrics objects, it's better to use the )Tj
/F15 1 Tf
18 0 TD
(*Radius)Tj
/F11 1 Tf
3.3 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(height)Tj
/F11 1 Tf
2.5 0 TD
(, and similar arguments to scale them)Tj
-27.1 -1.4 TD
(rather than the )Tj
/F15 1 Tf
6 0 TD
(glScale*\(\))Tj
/F11 1 Tf
4.1 0 TD
( command so that the unit-length normals that are generated don't have to be)Tj
-10.1 -1.4 TD
(renormalized. Set the )Tj
/F15 1 Tf
8.8 0 TD
(rings)Tj
/F11 1 Tf
2 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(stacks)Tj
/F11 1 Tf
2.4 0 TD
( arguments to values other than one to force lighting calculations at)Tj
-15.2 -1.5 TD
(a finer granularity, especially if the material specularity is high.)Tj
0 -2.1 TD
(Example 11-4)Tj
5.6 0 TD
( shows each of the quadrics primitives being drawn, as well as the effects of different)Tj
-5.6 -1.5 TD
(drawing styles.)Tj
/F27 1 Tf
0 -2 TD
(Example 11-4 )Tj
/F11 1 Tf
6.7 0 TD
(Quadrics Objects: quadric.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdio.h>)Tj
T*
(#include <stdlib.h>)Tj
0 -3 TD
(GLuint startList;)Tj
T*
(void errorCallback\(GLenum errorCode\))Tj
0 -1.5 TD
({)Tj
T*
(   const GLubyte *estring;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 18)Tj
ET
endstream
endobj
1205 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1207 0 obj
<<
/Length 2043
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 697.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   estring = gluErrorString\(errorCode\);)Tj
0 -1.5 TD
(   fprintf\(stderr, "Quadric Error: %s\\n", estring\);)Tj
T*
(   exit\(0\);)Tj
T*
(})Tj
0 -3 TD
(void init\(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   GLUquadricObj *qobj;)Tj
T*
(   GLfloat mat_ambient[] = { 0.5, 0.5, 0.5, 1.0 };)Tj
T*
(   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(   GLfloat mat_shininess[] = { 50.0 };)Tj
T*
(   GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };)Tj
T*
(   GLfloat model_ambient[] = { 0.5, 0.5, 0.5, 1.0 };)Tj
0 -3 TD
(   glClearColor\(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_AMBIENT, mat_ambient\);)Tj
0 -1.5 TD
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SHININESS, mat_shininess\);)Tj
T*
(   glLightfv\(GL_LIGHT0, GL_POSITION, light_position\);)Tj
T*
(   glLightModelfv\(GL_LIGHT_MODEL_AMBIENT, model_ambient\);)Tj
0 -3 TD
(   glEnable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
0 -3 TD
(/* Create 4 display lists, each with a different quadric object.)Tj
0 -1.5 TD
( * Different drawing styles and surface normal specifications)Tj
T*
( * are demonstrated.)Tj
T*
( */)Tj
T*
(   startList = glGenLists\(4\);)Tj
T*
(   qobj = gluNewQuadric\(\);)Tj
T*
(   gluQuadricCallback\(qobj, GLU_ERROR, errorCallback\);)Tj
0 -3 TD
(   gluQuadricDrawStyle\(qobj, GLU_FILL\); /* smooth shaded */)Tj
0 -1.5 TD
(   gluQuadricNormals\(qobj, GLU_SMOOTH\);)Tj
T*
(   glNewList\(startList, GL_COMPILE\);)Tj
T*
(      gluSphere\(qobj, 0.75, 15, 10\);)Tj
T*
(   glEndList\(\);)Tj
0 -3 TD
(   gluQuadricDrawStyle\(qobj, GLU_FILL\); /* flat shaded */)Tj
0 -1.5 TD
(   gluQuadricNormals\(qobj, GLU_FLAT\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 19)Tj
ET
endstream
endobj
1208 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1210 0 obj
<<
/Length 1802
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glNewList\(startList+1, GL_COMPILE\);)Tj
0 -1.5 TD
(      gluCylinder\(qobj, 0.5, 0.3, 1.0, 15, 5\);)Tj
T*
(   glEndList\(\);)Tj
0 -3 TD
(   gluQuadricDrawStyle\(qobj, GLU_LINE\); /* wireframe */)Tj
0 -1.5 TD
(   gluQuadricNormals\(qobj, GLU_NONE\);)Tj
T*
(   glNewList\(startList+2, GL_COMPILE\);)Tj
T*
(      gluDisk\(qobj, 0.25, 1.0, 20, 4\);)Tj
T*
(   glEndList\(\);)Tj
0 -3 TD
(   gluQuadricDrawStyle\(qobj, GLU_SILHOUETTE\);)Tj
0 -1.5 TD
(   gluQuadricNormals\(qobj, GLU_NONE\);)Tj
T*
(   glNewList\(startList+3, GL_COMPILE\);)Tj
T*
(      gluPartialDisk\(qobj, 0.0, 1.0, 20, 4, 0.0, 225.0\);)Tj
T*
(   glEndList\(\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear \(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glPushMatrix\(\);)Tj
0 -3 TD
(   glEnable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glShadeModel \(GL_SMOOTH\);)Tj
T*
(   glTranslatef\(-1.0, -1.0, 0.0\);)Tj
T*
(   glCallList\(startList\);)Tj
0 -3 TD
(   glShadeModel \(GL_FLAT\);)Tj
0 -1.5 TD
(   glTranslatef\(0.0, 2.0, 0.0\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glRotatef\(300.0, 1.0, 0.0, 0.0\);)Tj
T*
(   glCallList\(startList+1\);)Tj
T*
(   glPopMatrix\(\);)Tj
0 -3 TD
(   glDisable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glColor3f\(0.0, 1.0, 1.0\);)Tj
T*
(   glTranslatef\(2.0, -2.0, 0.0\);)Tj
T*
(   glCallList\(startList+2\);)Tj
0 -3 TD
(   glColor3f\(1.0, 1.0, 0.0\);)Tj
0 -1.5 TD
(   glTranslatef\(0.0, 2.0, 0.0\);)Tj
T*
(   glCallList\(startList+3\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 20)Tj
ET
endstream
endobj
1211 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1213 0 obj
<<
/Length 1648
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glPopMatrix\(\);)Tj
0 -1.5 TD
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape \(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho\(-2.5, 2.5, -2.5*\(GLfloat\)h/\(GLfloat\)w,)Tj
T*
(         2.5*\(GLfloat\)h/\(GLfloat\)w, -10.0, 10.0\);)Tj
T*
(   else)Tj
T*
(      glOrtho\(-2.5*\(GLfloat\)w/\(GLfloat\)h,)Tj
T*
(         2.5*\(GLfloat\)w/\(GLfloat\)h, -2.5, 2.5, -10.0, 10.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(void keyboard\(unsigned char key, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize\(500, 500\); )Tj
T*
(   glutInitWindowPosition\(100, 100\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutKeyboardFunc\(keyboard\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 11,  Tessellators and Quadrics - 21)Tj
ET
endstream
endobj
1214 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1216 0 obj
<<
/Length 265
>>
stream
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 663.960 m
547.000 663.960 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 22)Tj
ET
endstream
endobj
1217 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1219 0 obj
<<
/Length 3941
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 12)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Evaluators and NURBS)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F27 1 Tf
8 -2.1 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use OpenGL evaluator commands to draw basic curves and surfaces)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use the GLU's higher-level NURBS facility to draw more complex curves and surfaces)Tj
-1.9 -2.8 TD
[(Note that this chapter presumes a number of prerequisites; they're listed in )10("Prerequisites.")]TJ
0 -2.1 TD
(At the lowest level, graphics hardware draws points, line segments, and polygons, which are usually)Tj
0 -1.5 TD
(triangles and quadrilaterals. Smooth curves and surfaces are drawn by approximating them with large)Tj
T*
(numbers of small line segments or polygons. However, many useful curves and surfaces can be described)Tj
T*
(mathematically by a small number of parameters such as a few )Tj
/F15 1 Tf
25.4 0 TD
(control points)Tj
/F11 1 Tf
5.6 0 TD
(. Saving the 16 control)Tj
-31 -1.5 TD
(points for a surface requires much less storage than saving 1000 triangles together with the normal vector)Tj
T*
(information at each vertex. In addition, the 1000 triangles only approximate the true surface, but the)Tj
T*
(control points accurately describe the real surface.)Tj
0 -2.1 TD
(Evaluators provide a way to specify points on a curve or surface \(or part of one\) using only the control)Tj
0 -1.5 TD
(points. The curve or surface can then be rendered at any precision. In addition, normal vectors can be)Tj
T*
(calculated for surfaces automatically. You can use the points generated by an evaluator in many)Tj
0 -1.6 TD
(ways)Tj
/F33 1 Tf
2.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(to draw dots where the surface would be, to draw a wireframe version of the surface, or to draw a)Tj
-3.1 -1.6 TD
(fully lighted, shaded, and even textured version.)Tj
0 -2.1 TD
(You can use evaluators to describe any polynomial or rational polynomial splines or surfaces of any)Tj
0 -1.5 TD
(degree. These include almost all splines and spline surfaces in use today, including B-splines, NURBS)Tj
T*
(\(Non-Uniform Rational B-Spline\) surfaces, B\351zier curves and surfaces, and Hermite splines. Since)Tj
T*
(evaluators provide only a low-level description of the points on a curve or surface, they're typically used)Tj
T*
(underneath utility libraries that provide a higher-level interface to the programmer. The GLU's NURBS)Tj
0 -1.6 TD
(facility is such a higher-level interface)Tj
/F33 1 Tf
15.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the NURBS routines encapsulate lots of complicated code.)Tj
-16.4 -1.6 TD
(Much of the final rendering is done with evaluators, but for some conditions \(trimming curves, for)Tj
0 -1.5 TD
(example\) the NURBS routines use planar polygons for rendering.)Tj
0 -2.1 TD
(This chapter contains the following major sections.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Prerequisites")-17( discusses what knowledge is assumed for this chapter. It also gives several)]TJ
0 -1.6 TD
(references where you can obtain this information.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Evaluators")-6( explains how evaluators work and how to control them using the appropriate OpenGL)]TJ
0 -1.6 TD
(commands.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("The GLU NURBS Interface")-36( describes the GLU routines for creating NURBS surfaces.)]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 76.000 Tm
(Prerequisites)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 1)Tj
ET
endstream
endobj
1220 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1222 0 obj
<<
/Length 5017
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 702.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Evaluators make splines and surfaces that are based on a B\351zier \(or Bernstein\) basis. The defining)Tj
0 -1.5 TD
(formulas for the functions in this basis are given in this chapter, but the discussion doesn't include)Tj
T*
(derivations or even lists of all their interesting mathematical properties. If you want to use evaluators to)Tj
T*
(draw curves and surfaces using other bases, you must know how to convert your basis to a B\351zier basis.)Tj
T*
(In addition, when you render a B\351zier surface or part of it using evaluators, you need to determine the)Tj
T*
(granularity of your subdivision. Your decision needs to take into account the trade-off between)Tj
T*
(high-quality \(highly subdivided\) images and high speed. Determining an appropriate subdivision strategy)Tj
0 -1.6 TD
(can be quite complicated)Tj
/F33 1 Tf
10 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(too complicated to be discussed here.)Tj
-11 -2.2 TD
(Similarly, a complete discussion of NURBS is beyond the scope of this book. The GLU NURBS)Tj
0 -1.5 TD
(interface is documented here, and programming examples are provided for readers who already)Tj
T*
(understand the subject. In what follows, you already should know about NURBS control points, knot)Tj
T*
(sequences, and trimming curves.)Tj
0 -2.1 TD
(If you lack some of these prerequisites, the following references will help.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Farin, Gerald E., )Tj
/F15 1 Tf
6.9 0 TD
(Curves and Surfaces for Computer-Aided Geometric Design, Fourth Edition)Tj
/F11 1 Tf
30.7 0 TD
(. San)Tj
-37.6 -1.6 TD
(Diego, CA: Academic Press, 1996.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Farin, Gerald E., )Tj
/F15 1 Tf
6.9 0 TD
(NURB Curves and Surfaces: from Projective Geometry to Practical Use.)Tj
/F11 1 Tf
-6.9 -1.6 TD
(Wellesley, MA: A. K. Peters Ltd., 1995.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Farin, Gerald E., editor, )Tj
/F15 1 Tf
9.8 0 TD
(NURBS for Curve and Surface Design)Tj
/F11 1 Tf
15.3 0 TD
(, Society for Industrial and Applied)Tj
-25.1 -1.6 TD
(Mathematics, Philadelphia, PA, 1991.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Hoschek, Josef and Dieter Lasser, )Tj
/F15 1 Tf
13.9 0 TD
(Fundamentals of Computer Aided Geometric Design.)Tj
/F11 1 Tf
21.3 0 TD
( Wellesley,)Tj
-35.2 -1.6 TD
(MA: A. K. Peters Ltd., 1993.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Piegl, Les and Wayne Tiller, )Tj
/F15 1 Tf
11.7 0 TD
(The NURBS Book)Tj
/F11 1 Tf
7.2 0 TD
(. New York, NY: Springer-Verlag, 1995.)Tj
/F27 1 Tf
-20.8 -2.7 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Some terms used in this chapter might have slightly different meanings in other books on spline)Tj
-2.8 -1.5 TD
(curves and surfaces, since there isn't total agreement among the practitioners of this art. Generally, the)Tj
0 -1.4 TD
(OpenGL meanings are a bit more restrictive. For example, OpenGL evaluators always use B\351zier bases;)Tj
T*
(in other contexts, evaluators might refer to the same concept, but with an arbitrary basis.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 230.000 Tm
(Evaluators)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 208.000 Tm
(A B\351zier curve is a vector-valued function of one variable)Tj
/F15 1 Tf
0 -2.1 TD
(C)Tj
/F11 1 Tf
0.7 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(\) = [)Tj
/F15 1 Tf
1.7 0 TD
(X)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.4 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(\)  )Tj
/F15 1 Tf
0.8 0 TD
(Y)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(\)  )Tj
/F15 1 Tf
0.8 0 TD
(Z)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(\)])Tj
-9.1 -2.1 TD
(where )Tj
/F15 1 Tf
2.7 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( varies in some domain \(say [0,1]\). A B\351zier surface patch is a vector-valued function of two)Tj
-3.2 -1.5 TD
(variables)Tj
/F15 1 Tf
0 -2.1 TD
(S)Tj
/F11 1 Tf
0.5 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(u,v)Tj
/F11 1 Tf
1.2 0 TD
(\) = [)Tj
/F15 1 Tf
1.8 0 TD
(X)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(u,v)Tj
/F11 1 Tf
1.2 0 TD
(\)  )Tj
/F15 1 Tf
0.8 0 TD
(Y)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(u,v)Tj
/F11 1 Tf
1.2 0 TD
(\)  )Tj
/F15 1 Tf
0.8 0 TD
(Z)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(u,v)Tj
/F11 1 Tf
1.2 0 TD
(\)])Tj
-11.7 -2.1 TD
(where )Tj
/F15 1 Tf
2.7 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( can both vary in some domain. The range isn't necessarily three-dimensional as shown)Tj
-5.6 -1.5 TD
(here. You might want two-dimensional output for curves on a plane or texture coordinates, or you might)Tj
T*
(want four-dimensional output to specify RGBA information. Even one-dimensional output may make)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 2)Tj
ET
endstream
endobj
1223 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1224 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im99
/Width 187
/Height 189
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.98)
>>
stream
endstream
endobj
1226 0 obj
<<
/Length 3018
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(sense for gray levels.)Tj
0 -2.1 TD
(For each )Tj
/F15 1 Tf
3.7 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( \(or )Tj
/F15 1 Tf
1.7 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(, in the case of a surface\), the formula for )Tj
/F15 1 Tf
16.7 0 TD
(C\(\))Tj
/F11 1 Tf
1.4 0 TD
( \(or )Tj
/F15 1 Tf
1.6 0 TD
(S\(\))Tj
/F11 1 Tf
1.2 0 TD
(\) calculates a point on the)Tj
-29.7 -1.5 TD
(curve \(or surface\). To use an evaluator, first define the function )Tj
/F15 1 Tf
25.6 0 TD
(C\(\))Tj
/F11 1 Tf
1.4 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(S\(\))Tj
/F11 1 Tf
1.2 0 TD
(, enable it, and then use the)Tj
/F15 1 Tf
-29.5 -1.5 TD
(glEvalCoord1\(\))Tj
/F11 1 Tf
6.3 0 TD
( or )Tj
/F15 1 Tf
1.4 0 TD
(glEvalCoord2\(\))Tj
/F11 1 Tf
6.3 0 TD
( command instead of )Tj
/F15 1 Tf
8.6 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.6 0 TD
(. This way, the curve or surface)Tj
-27.2 -1.6 TD
(vertices can be used like any other vertices)Tj
/F33 1 Tf
17.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(to form points or lines, for example. In addition, other)Tj
-18.1 -1.6 TD
(commands automatically generate series of vertices that produce a regular mesh uniformly spaced in )Tj
/F15 1 Tf
40.5 0 TD
(u)Tj
/F11 1 Tf
-40.5 -1.5 TD
(\(or in )Tj
/F15 1 Tf
2.4 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
(\). One- and two-dimensional evaluators are similar, but the description is somewhat simpler)Tj
-5.3 -1.5 TD
(in one dimension, so that case is discussed first.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 569.000 Tm
(One-Dimensional Evaluators)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 548.000 Tm
(This section presents an example of using one-dimensional evaluators to draw a curve. It then describes)Tj
T*
(the commands and equations that control evaluators.)Tj
/F27 1 Tf
0 -3 TD
(One-Dimensional Example: A Simple B\351zier Curve)Tj
/F11 1 Tf
0 -2.1 TD
[(The program shown in )33(Example 12-1)170( draws a cubic B\351zier curve using four control points, as shown in)]TJ
0 -1.5 TD
[(Figure 12-1)226(.)]TJ
ET
Q
/GS1 gs
q
187 0 0 189 124 263.7 cm
/Im99 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 251.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 12-1 )Tj
/F11 1 Tf
5.6 0 TD
(B\351zier Curve)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 12-1 )Tj
/F11 1 Tf
6.7 0 TD
(B\351zier Curve with Four Control Points: bezcurve.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <GL/glut.h>)Tj
0 -3 TD
(GLfloat ctrlpoints[4][3] = {)Tj
0 -1.5 TD
(        { -4.0, -4.0, 0.0}, { -2.0, 4.0, 0.0}, )Tj
T*
(        {2.0, -4.0, 0.0}, {4.0, 4.0, 0.0}};)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 3)Tj
ET
endstream
endobj
1227 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im99 1224 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1229 0 obj
<<
/Length 1769
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor\(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glShadeModel\(GL_FLAT\);)Tj
T*
(   glMap1f\(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, 4, &ctrlpoints[0][0]\);)Tj
T*
(   glEnable\(GL_MAP1_VERTEX_3\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i;)Tj
0 -3 TD
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glColor3f\(1.0, 1.0, 1.0\);)Tj
T*
(   glBegin\(GL_LINE_STRIP\);)Tj
T*
(      for \(i = 0; i <= 30; i++\) )Tj
T*
(         glEvalCoord1f\(\(GLfloat\) i/30.0\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   /* The following code displays the control points as dots. */)Tj
T*
(   glPointSize\(5.0\);)Tj
T*
(   glColor3f\(1.0, 1.0, 0.0\);)Tj
T*
(   glBegin\(GL_POINTS\);)Tj
T*
(      for \(i = 0; i < 4; i++\) )Tj
T*
(         glVertex3fv\(&ctrlpoints[i][0]\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho\(-5.0, 5.0, -5.0*\(GLfloat\)h/\(GLfloat\)w, )Tj
T*
(               5.0*\(GLfloat\)h/\(GLfloat\)w, -5.0, 5.0\);)Tj
T*
(   else)Tj
T*
(      glOrtho\(-5.0*\(GLfloat\)w/\(GLfloat\)h, )Tj
T*
(               5.0*\(GLfloat\)w/\(GLfloat\)h, -5.0, 5.0, -5.0, 5.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 4)Tj
ET
endstream
endobj
1230 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1232 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im100
/Width 176
/Height 48
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.99)
>>
stream
endstream
endobj
1234 0 obj
<<
/Length 3224
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(500, 500\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(A cubic B\351zier curve is described by four control points, which appear in this example in the )Tj
/F15 1 Tf
37.7 0 TD
(ctrlpoints[])Tj
-37.7 -1.5 TD
([])Tj
/F11 1 Tf
0.8 0 TD
( array. This array is one of the arguments to )Tj
/F15 1 Tf
17.7 0 TD
(glMap1f\(\))Tj
/F11 1 Tf
4.1 0 TD
(. All the arguments for this command are as)Tj
-22.6 -1.5 TD
(follows:)Tj
0 -2.1 TD
(GL_MAP1_VERTEX_3)Tj
8 -1.2 TD
(Three-dimensional control points are provided and three-dimensional vertices are)Tj
0 -1.1 TD
(produced)Tj
-8 -2.1 TD
[(0.0)-6750(Low value of parameter )]TJ
/F15 1 Tf
17.8 0 TD
(u)Tj
/F11 1 Tf
-17.8 -2.1 TD
[(1.0)-6750(High value of parameter )]TJ
/F15 1 Tf
18 0 TD
(u)Tj
/F11 1 Tf
-18 -2.1 TD
[(3)-7500(The number of floating-point values to advance in the data between one control point)]TJ
8 -1.5 TD
(and the next)Tj
-8 -2.1 TD
[(4)-7500(The order of the spline, which is the degree+1: in this case, the degree is 3 \(since this)]TJ
8 -1.5 TD
(is a cubic curve\))Tj
/F15 1 Tf
-8 -2.1 TD
(&ctrlpoints[0][0])Tj
/F11 1 Tf
8 0 TD
(Pointer to the first control point's data)Tj
-8 -2.2 TD
(Note that the second and third arguments control the parameterization of the curve)Tj
/F33 1 Tf
33 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(as the variable )Tj
/F15 1 Tf
6 0 TD
(u)Tj
/F11 1 Tf
-40 -1.6 TD
(ranges from 0.0 to 1.0, the curve goes from one end to the other. The call to )Tj
/F15 1 Tf
30.5 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( enables the)Tj
-34.8 -1.5 TD
(one-dimensional evaluator for three-dimensional vertices.)Tj
0 -2.1 TD
(The curve is drawn in the routine )Tj
/F15 1 Tf
13.5 0 TD
(display\(\) )Tj
/F11 1 Tf
3.8 0 TD
(between the )Tj
/F15 1 Tf
5.1 0 TD
(glBegin\(\) )Tj
/F11 1 Tf
4 0 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( calls. Since the evaluator)Tj
-31.2 -1.5 TD
(is enabled, the command )Tj
/F15 1 Tf
10.2 0 TD
(glEvalCoord1f\(\))Tj
/F11 1 Tf
6.6 0 TD
( is just like issuing a )Tj
/F15 1 Tf
8.4 0 TD
(glVertex\(\))Tj
/F11 1 Tf
4 0 TD
( command with the coordinates)Tj
-29.2 -1.5 TD
(of a vertex on the curve corresponding to the input parameter )Tj
/F15 1 Tf
24.7 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(.)Tj
/F27 1 Tf
-25.2 -2.9 TD
(Defining and Evaluating a One-Dimensional Evaluator)Tj
/F11 1 Tf
0 -2.2 TD
(The Bernstein polynomial of degree )Tj
/F15 1 Tf
14.7 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( \(or order )Tj
/F15 1 Tf
4 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(+1\) is given by)Tj
ET
Q
/GS1 gs
q
176 0 0 48 124 85.26 cm
/Im100 Do
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 5)Tj
ET
endstream
endobj
1235 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im100 1232 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1236 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im101
/Width 154
/Height 67
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.100)
>>
stream
endstream
endobj
1237 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im102
/Width 94
/Height 51
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.101)
>>
stream
endstream
endobj
1239 0 obj
<<
/Length 4613
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(If Pi represents a set of control points \(one-, two-, three-, or even four- dimensional\), then the equation)Tj
ET
Q
/GS1 gs
q
154 0 0 67 124 629.84 cm
/Im101 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 611.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(represents a B\351zier curve as )Tj
/F15 1 Tf
11.7 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( varies from 0.0 to 1.0. To represent the same curve but allowing )Tj
/F15 1 Tf
26.2 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( to vary)Tj
-38.9 -1.5 TD
(between )Tj
/F15 1 Tf
3.6 0 TD
(u)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(u)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
0.5 0.2 TD
( instead of 0.0 and 1.0, evaluate)Tj
ET
Q
q
94 0 0 51 124 528.84 cm
/Im102 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 510.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(The command )Tj
/F15 1 Tf
6 0 TD
(glMap1\(\))Tj
/F11 1 Tf
3.8 0 TD
( defines a one-dimensional evaluator that uses these equations.)Tj
/F15 1 Tf
-9.8 -2.1 TD
[(void )-28(glMap1)11({fd}\(GLenum )6(target)-11(, TYPE)34(u1, TYPE)34(u2, GLint )-16(stride)-22(,)]TJ
0 -1.1 TD
[(GLint )-16(order)22(, const TYPE*points)45(\);)]TJ
1.8 -1.5 TD
(Defines a one-dimensional evaluator. The )Tj
17.1 0 TD
[(target)89( parameter specifies what the control points)]TJ
-17.1 -1.5 TD
[(represent, as shown in )-49(Table 12-1)]TJ
13.6 0 TD
[(, and therefore how many values need to be supplied in )34(points)-55(. The)]TJ
-13.6 -1.5 TD
(points can represent vertices, RGBA color data, normal vectors, or texture coordinates. For)Tj
T*
(example, with GL_MAP1_COLOR_4, the evaluator generates color data along a curve in)Tj
T*
(four-dimensional \(RGBA\) color space. You also use the parameter values listed in )Tj
33.2 0 TD
(Table 12-1)Tj
4.4 0 TD
( to)Tj
-37.6 -1.5 TD
[(enable each defined evaluator before you invoke it. Pass the appropriate value to )33(glEnable\(\))-23( or)]TJ
T*
[(glDisable\(\))-44( to enable or disable the evaluator.)]TJ
T*
[(The second two parameters for glMap1*\(\))-23(, u1 and u2, indicate the range for the variable u. The)]TJ
T*
[(variable )-17(stride)-22( is the number of single- or double-precision values \(as appropriate\) in each block of)]TJ
T*
(storage. Thus, it's an offset value between the beginning of one control point and the beginning of)Tj
T*
(the next.)Tj
T*
[(The )-50(order)22( is the degree plus one, and it should agree with the number of control points. The )-13(points)]TJ
T*
(parameter points to the first coordinate of the first control point. Using the example data structure)Tj
T*
[(for )17(glMap1*\(\))-23(, use the following for points)45(:)]TJ
/F7 1 Tf
-1.8 -2.1 TD
(\(GLfloat *\)\(&ctlpoints[0].x\))Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
1 i 
124.000 235.840 m
457.000 235.840 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 228.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Parameter)-16483(Meaning)]TJ
ET
Q
124.000 222.320 m
457.000 222.320 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 214.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(GL_MAP1_VERTEX_3)Tj
/F15 1 Tf
19 0 TD
0.000 Tw
(x, y, z)Tj
/F11 1 Tf
2.2222 0 TD
( vertex coordinates)Tj
-21.2222 -1.4444 TD
(GL_MAP1_VERTEX_4)Tj
/F15 1 Tf
19 0 TD
(x, y, z, w )Tj
/F11 1 Tf
3.6667 0 TD
(vertex coordinates)Tj
-22.6667 -1.4444 TD
[(GL_MAP1_INDEX)-10889(color index)]TJ
T*
[(GL_MAP1_COLOR_4)-9610(R, G, B, A)]TJ
T*
[(GL_MAP1_NORMAL)-9666(normal coordinates)]TJ
T*
(GL_MAP1_TEXTURE_COORD_1)Tj
/F15 1 Tf
19 0 TD
(s)Tj
/F11 1 Tf
0.4444 0 TD
( texture coordinates)Tj
-19.4444 -1.4444 TD
(GL_MAP1_TEXTURE_COORD_2)Tj
/F15 1 Tf
19 0 TD
(s, t)Tj
/F11 1 Tf
1.2222 0 TD
( texture coordinates)Tj
-20.2222 -1.4444 TD
(GL_MAP1_TEXTURE_COORD_3)Tj
/F15 1 Tf
19 0 TD
(s, t, r)Tj
/F11 1 Tf
2.1111 0 TD
( texture coordinates)Tj
-21.1111 -1.4444 TD
(GL_MAP1_TEXTURE_COORD_4)Tj
/F15 1 Tf
19 0 TD
(s, t, r, q)Tj
/F11 1 Tf
3.1111 0 TD
( texture coordinates)Tj
ET
Q
124.000 102.360 m
457.010 102.360 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 86.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 12-1 )Tj
/F11 1 Tf
5.2 0 TD
(Types of Control Points for glMap1*\(\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 6)Tj
ET
endstream
endobj
1240 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im101 1236 0 R
/Im102 1237 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1242 0 obj
<<
/Length 4440
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(More than one evaluator can be evaluated at a time. If you have both a GL_MAP1_VERTEX_3 and a)Tj
0 -1.5 TD
(GL_MAP1_COLOR_4 evaluator defined and enabled, for example, then calls to )Tj
/F15 1 Tf
32.6 0 TD
(glEvalCoord1\(\))Tj
/F11 1 Tf
-32.6 -1.5 TD
(generate both a position and a color. Only one of the vertex evaluators can be enabled at a time, although)Tj
T*
(you might have defined both of them. Similarly, only one of the texture evaluators can be active. Other)Tj
T*
(than that, however, evaluators can be used to generate any combination of vertex, normal, color, and)Tj
T*
(texture-coordinate data. If more than one evaluator of the same type is defined and enabled, the one of)Tj
T*
(highest dimension is used.)Tj
0 -2.1 TD
(Use)Tj
/F15 1 Tf
1.6 0 TD
( glEvalCoord1*\(\))Tj
/F11 1 Tf
7 0 TD
( to evaluate a defined and enabled one-dimensional map.)Tj
/F15 1 Tf
-8.6 -2.1 TD
0.028 Tw
[(void glEvalCoord1)68({fd}\()-89(TYPE )28(u)84(\))0(;)]TJ
0 -1.1 TD
[(void glEvalCoord1)68({fd})-22(v)-56(\()33(TYPE )28(*u)-16(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Causes evaluation of the enabled one-dimensional maps. The argument )Tj
28.9 0 TD
(u is the value \(or a pointer)Tj
-28.9 -1.5 TD
(to the value, in the vector version of the command\) of the domain coordinate.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(For evaluated vertices, values for color, color index, normal vectors, and texture coordinates are)Tj
0 -1.5 TD
(generated by evaluation. Calls to )Tj
/F15 1 Tf
13.4 0 TD
(glEvalCoord*\(\))Tj
/F11 1 Tf
6.3 0 TD
( do not use the current values for color, color index,)Tj
-19.7 -1.5 TD
(normal vectors, and texture coordinates. )Tj
/F15 1 Tf
16.3 0 TD
(glEvalCoord*\(\))Tj
/F11 1 Tf
6.3 0 TD
( also leaves those values unchanged.)Tj
/F27 1 Tf
-22.6 -3 TD
(Defining Evenly Spaced Coordinate Values in One Dimension)Tj
/F11 1 Tf
0 -2.1 TD
(You can use )Tj
/F15 1 Tf
5.2 0 TD
(glEvalCoord1\(\))Tj
/F11 1 Tf
6.3 0 TD
( with any values for )Tj
/F15 1 Tf
8.2 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(, but by far the most common use is with evenly)Tj
-20.2 -1.5 TD
[(spaced values, as shown previously in )-28(Example 12-1)]TJ
21.1 0 TD
(. To obtain evenly spaced values, define a)Tj
-21.1 -1.5 TD
(one-dimensional grid using )Tj
/F15 1 Tf
11.2 0 TD
(glMapGrid1*\(\))Tj
/F11 1 Tf
6.2 0 TD
( and then apply it using )Tj
/F15 1 Tf
9.6 0 TD
(glEvalMesh1\(\))Tj
/F11 1 Tf
5.9 0 TD
(.)Tj
/F15 1 Tf
-32.9 -2.1 TD
0.001 Tw
[(void )-27(glMapGrid1{fd}\(GLint n, TYPE)34(u1, TYPE)34(u2\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Defines a grid that goes from u1 to )-22(u2 in )-22(n steps, which are evenly spaced.)]TJ
-1.8 -2.1 TD
[(void )-28(glEvalMesh1)78(\(GLenum )-73(mode)66(, GLint )-16(p1, GLint )-16(p2\);)]TJ
1.8 -1.5 TD
[(Applies the currently defined map grid to all enabled evaluators. The )46(mode)-34( can be either GL_POINT)]TJ
T*
(or GL_LINE, depending on whether you want to draw points or a connected line along the curve.)Tj
T*
[(The call has exactly the same effect as issuing a )-11(glEvalCoord1\(\))34( for each of the steps between and)]TJ
T*
[(including )28(p1 and p2, where 0 <= )-55(p1, p2 <= )50(n. Programmatically, it's equivalent to the following:)]TJ
/F7 1 Tf
-1.8 -2.1 TD
(glBegin\(GL_POINTS\);    /* OR glBegin\(GL_LINE_STRIP\); */)Tj
0 -1.5 TD
( for \(i = p1; i <= p2; i++\) )Tj
0 -1 TD
(    glEvalCoord1\(u1 + i*\(u2-u1\)/n\);)Tj
0 -1.1 TD
(glEnd\(\);)Tj
/F15 1 Tf
1.8 -1.5 TD
[(except that if )17(i)-22( = 0 or )-36(i)78( = )-25(n, then )-28(glEvalCoord1\(\))34( is called with exactly )17(u1 or )-11(u2 as its parameter.)]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 188.000 Tm
(Two-Dimensional Evaluators)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 167.000 Tm
(In two dimensions, everything is similar to the one-dimensional case, except that all the commands must)Tj
T*
(take two parameters, )Tj
/F15 1 Tf
8.6 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
(, into account. Points, colors, normals, or texture coordinates must be)Tj
-11.4 -1.5 TD
(supplied over a surface instead of a curve. Mathematically, the definition of a B\351zier surface patch is)Tj
T*
(given by)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 7)Tj
ET
endstream
endobj
1243 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1244 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im103
/Width 229
/Height 70
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.102)
>>
stream
endstream
endobj
1246 0 obj
<<
/Length 4375
>>
stream
/GS1 gs
q
229 0 0 70 124 650 cm
/Im103 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 619.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(where )Tj
/F15 1 Tf
2.7 0 TD
0.000 Tw
(P)Tj
/F11 1 Tf
0.6 -0.2 TD
(ij)Tj
0.6 0.2 TD
( are a set of )Tj
/F15 1 Tf
4.8 0 TD
(m*n)Tj
/F11 1 Tf
1.7 0 TD
( control points, and the )Tj
/F15 1 Tf
9.5 0 TD
(B)Tj
/F11 1 Tf
0.6 -0.2 TD
(i)Tj
0.3 0.2 TD
( are the same Bernstein polynomials for one)Tj
-20.8 -1.7 TD
(dimension. As before, the )Tj
/F15 1 Tf
10.6 0 TD
(P)Tj
/F11 1 Tf
0.6 -0.2 TD
(ij)Tj
0.5 0.2 TD
( can represent vertices, normals, colors, or texture coordinates.)Tj
-11.7 -2.3 TD
(The procedure to use two-dimensional evaluators is similar to the procedure for one dimension.)Tj
0 -2.1 TD
[(1.)-1050(Define the evaluator\(s\) with )]TJ
/F15 1 Tf
13.3 0 TD
(glMap2*\(\))Tj
/F11 1 Tf
4.3 0 TD
(.)Tj
-17.6 -2.1 TD
[(2.)-1050(Enable them by passing the appropriate value to )]TJ
/F15 1 Tf
21.3 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
(.)Tj
-25.6 -2.1 TD
[(3.)-1050(Invoke them either by calling )]TJ
/F15 1 Tf
13.8 0 TD
(glEvalCoord2\(\))Tj
/F11 1 Tf
6.4 0 TD
( between a )Tj
/F15 1 Tf
4.5 0 TD
(glBegin\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3.1 0 TD
( pair or by specifying)Tj
-31.7 -1.5 TD
(and then applying a mesh with )Tj
/F15 1 Tf
12.5 0 TD
(glMapGrid2\(\))Tj
/F11 1 Tf
5.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEvalMesh2\(\))Tj
/F11 1 Tf
6 0 TD
(.)Tj
/F27 1 Tf
-27.9 -3.5 TD
(Defining and Evaluating a Two-Dimensional Evaluator)Tj
/F11 1 Tf
0 -2.1 TD
(Use )Tj
/F15 1 Tf
1.8 0 TD
(glMap2*\(\))Tj
/F11 1 Tf
4.3 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEvalCoord2*\(\))Tj
/F11 1 Tf
6.9 0 TD
( to define and then invoke a two-dimensional evaluator.)Tj
/F15 1 Tf
-14.9 -2.1 TD
[(void )-28(glMap2)11({fd}\(GLenum )6(target)-11(, TYPE)34(u1, TYPE)34(u2, GLint )-16(ustride)-22(,)]TJ
0 -1.1 TD
[(GLint )-16(uorder)22(,)-50( TYPE)84(v1)-56(, TYPE)34(v2)-56(, GLint )84(vstride)-78(,)]TJ
T*
[(GLint )-16(vorder)-34(, TYPE points)30(\);)]TJ
1.8 -1.5 TD
[(The )-50(target)89( parameter can have any of the values in )-73(Table 12-1)]TJ
25 0 TD
(, except that the string MAP1 is)Tj
-25 -1.5 TD
[(replaced with MAP2. As before, these values are also used with )51(glEnable\(\))-23( to enable the)]TJ
T*
[(corresponding evaluator. Minimum and maximum values for both )40(u )-50(and )50(v)-56( are provided as )-22(u1, u2,)]TJ
T*
[(v1)44(, and )-50(v2)44(. The parameters )-44(ustride)-22( and vstride)22( indicate the number of single- or double-precision)]TJ
T*
(values \(as appropriate\) between independent settings for these values, allowing users to select a)Tj
T*
(subrectangle of control points out of a much larger array. For example, if the data appears in the)Tj
T*
(form)Tj
/F7 1 Tf
-1.8 -2 TD
(GLfloat ctlpoints[100][100][3];)Tj
/F15 1 Tf
1.8 -1.2 TD
[(and you want to use the 4x4 subset beginning at ctlpoints[20][30], choose )-24(ustride)-22( to be 100*3 and)]TJ
0 -1.1 TD
[(vstride)22( to be 3. The starting point, )-59(points)45(, should be set to &ctlpoints[20][30][0]. Finally, the order)]TJ
T*
[(parameters, )-44(uorder)22( and vorder)66(, can be different, allowing patches that are cubic in one direction)]TJ
T*
(and quadratic in the other, for example.)Tj
-1.8 -2.1 TD
[(void )-28(glEvalCoord2)68({fd}\()-89(TYPE u, TYPE v)13(\))0(;)]TJ
0 -1.1 TD
0.028 Tw
[(void glEvalCoord2)68({fd})-22(v)-56(\()33(TYPE )28(*values)40(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Causes evaluation of the enabled two-dimensional maps. The arguments )Tj
29.3 0 TD
[(u )50(and v)-6( are the values \(or a)]TJ
-29.3 -1.5 TD
[(pointer to the )40(values)-45( u and v, in the vector version of the command\) for the domain coordinates. If)]TJ
T*
(either of the vertex evaluators is enabled \(GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4\), then)Tj
T*
(the normal to the surface is computed analytically. This normal is associated with the generated)Tj
T*
(vertex if automatic normal generation has been enabled by passing GL_AUTO_NORMAL to)Tj
T*
[(glEnable\(\))-23(. If it's disabled, the corresponding enabled normal map is used to produce a normal. If)]TJ
T*
(no such map exists, the current normal is used.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 8)Tj
ET
endstream
endobj
1247 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im103 1244 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1248 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im104
/Width 173
/Height 168
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.103)
>>
stream
endstream
endobj
1250 0 obj
<<
/Length 2049
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Two-Dimensional Example: A B\351zier Surface)Tj
/F11 1 Tf
0 -2.1 TD
(Example 12-2)Tj
5.6 0 TD
[( draws a wireframe B\351zier surface using evaluators, as shown in )-360(Figure 12-2)]TJ
30.9 0 TD
(. In this)Tj
-36.5 -1.5 TD
(example, the surface is drawn with nine curved lines in each direction. Each curve is drawn as 30)Tj
T*
(segments. To get the whole program, add the )Tj
/F15 1 Tf
18.3 0 TD
(reshape\(\))Tj
/F11 1 Tf
3.8 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(main\(\))Tj
/F11 1 Tf
2.6 0 TD
[( routines from )17(Example 12-1)170(.)]TJ
ET
Q
/GS1 gs
q
173 0 0 168 124 477.1 cm
/Im104 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 464.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 12-2 )Tj
/F11 1 Tf
5.6 0 TD
(B\351zier Surface)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 12-2 )Tj
/F11 1 Tf
6.7 0 TD
(B\351zier Surface: bezsurf.c)Tj
/F7 1 Tf
-6.7 -2.3 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <GL/glut.h>)Tj
0 -3 TD
(GLfloat ctrlpoints[4][4][3] = {)Tj
0 -1.5 TD
(   {{-1.5, -1.5, 4.0}, {-0.5, -1.5, 2.0}, )Tj
T*
(    {0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}}, )Tj
T*
(   {{-1.5, -0.5, 1.0}, {-0.5, -0.5, 3.0}, )Tj
T*
(    {0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}}, )Tj
T*
(   {{-1.5, 0.5, 4.0}, {-0.5, 0.5, 0.0}, )Tj
T*
(    {0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}}, )Tj
T*
(   {{-1.5, 1.5, -2.0}, {-0.5, 1.5, -2.0}, )Tj
T*
(    {0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}})Tj
T*
(};)Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i, j;)Tj
0 -3 TD
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glColor3f\(1.0, 1.0, 1.0\);)Tj
T*
(   glPushMatrix \(\);)Tj
T*
(   glRotatef\(85.0, 1.0, 1.0, 1.0\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 9)Tj
ET
endstream
endobj
1251 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im104 1248 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1253 0 obj
<<
/Length 3262
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   for \(j = 0; j <= 8; j++\) {)Tj
0 -1.5 TD
(      glBegin\(GL_LINE_STRIP\);)Tj
T*
(      for \(i = 0; i <= 30; i++\))Tj
T*
(         glEvalCoord2f\(\(GLfloat\)i/30.0, \(GLfloat\)j/8.0\);)Tj
T*
(      glEnd\(\);)Tj
T*
(      glBegin\(GL_LINE_STRIP\);)Tj
T*
(      for \(i = 0; i <= 30; i++\))Tj
T*
(         glEvalCoord2f\(\(GLfloat\)j/8.0, \(GLfloat\)i/30.0\);)Tj
T*
(      glEnd\(\);)Tj
T*
(   })Tj
T*
(   glPopMatrix \(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glMap2f\(GL_MAP2_VERTEX_3, 0, 1, 3, 4,)Tj
T*
(           0, 1, 12, 4, &ctrlpoints[0][0][0]\);)Tj
T*
(   glEnable\(GL_MAP2_VERTEX_3\);)Tj
T*
(   glMapGrid2f\(20, 0.0, 1.0, 20, 0.0, 1.0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glShadeModel\(GL_FLAT\);)Tj
T*
(})Tj
/F27 1 Tf
0 -3.1 TD
(Defining Evenly Spaced Coordinate Values in Two Dimensions)Tj
/F11 1 Tf
0 -2.1 TD
(In two dimensions, the )Tj
/F15 1 Tf
9.4 0 TD
(glMapGrid2*\(\))Tj
/F11 1 Tf
6.1 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glEvalMesh2\(\))Tj
/F11 1 Tf
5.9 0 TD
( commands are similar to the one-dimensional)Tj
-23.4 -1.5 TD
(versions, except that both )Tj
/F15 1 Tf
10.5 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( information must be included.)Tj
/F15 1 Tf
-13.4 -2.1 TD
0.001 Tw
[(void )-27(glMapGrid2{fd}\(GLint nu, TYPE)34(u1, TYPE)34(u2,)]TJ
0 -1.1 TD
0.000 Tw
[(GLint )-16(nv)44(, TYPE)-66(v1)44(, TYPE)34(v2)-56(\);)]TJ
T*
[(void )-28(glEvalMesh2)78(\(GLenum )-73(mode)66(, GLint )-16(i1)-22(, GLint )-16(i2)-22(, GLint )-16(j1)78(, GLint )-16(j2)-22(\);)]TJ
1.8 -1.5 TD
(Defines a two-dimensional map grid that goes from )Tj
20.9 0 TD
[(u1 to )-22(u2 in )78(nu evenly spaced steps, from )-79(v1)44( to )-22(v2)]TJ
-20.9 -1.5 TD
[(in )28(nv)-56( steps \()33(glMapGrid2*\(\))-33(\), and then applies this grid to all enabled evaluators \()64(glEvalMesh2\(\))-56(\).)]TJ
T*
(The only significant difference from the one-dimensional versions of these two commands is that in)Tj
T*
[(glEvalMesh2\(\))44( the )-78(mode)66( parameter can be GL_FILL as well as GL_POINT or GL_LINE. GL_FILL)]TJ
T*
(generates filled polygons using the quad-mesh primitive. Stated precisely, )Tj
29.8 0 TD
[(glEvalMesh2\(\))44( is nearly)]TJ
-29.8 -1.5 TD
[(equivalent to one of the following three code fragments. \(It's nearly equivalent because when)33( i)-72( is)]TJ
T*
[(equal to nu or )-11(j)-22( to )78(nv)-56(, the parameter is exactly equal to )-11(u2 or )-11(v2)44(, not to )-44(u1+)75(nu*\()-67(u2-)]TJ
33.5 0 TD
[(u1\)/)11(nu, which)]TJ
-33.5 -1.5 TD
(might be slightly different due to round-off error.\))Tj
/F7 1 Tf
-1.8 -2 TD
(glBegin\(GL_POINTS\);                /* mode == GL_POINT */ )Tj
0 -1.1 TD
(for \(i = nu1; i <= nu2; i++\) )Tj
0 -1 TD
(    for \(j = nv1; j <= nv2; j++\) )Tj
0 -1.1 TD
(        glEvalCoord2\(u1 + i*\(u2-u1\)/nu, v1+j*\(v2-v1\)/nv\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 10)Tj
ET
endstream
endobj
1254 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1255 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im105
/Width 170
/Height 167
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.104)
>>
stream
endstream
endobj
1257 0 obj
<<
/Length 2464
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(glEnd\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(or)Tj
/F7 1 Tf
T*
0.000 Tw
(for \(i = nu1; i <= nu2; i++\) {     /* mode == GL_LINE */)Tj
0 -1.1 TD
(    glBegin\(GL_LINES\); )Tj
0 -1 TD
(        for \(j = nv1; j <= nv2; j++\) )Tj
0 -1.1 TD
(            glEvalCoord2\(u1 + i*\(u2-u1\)/nu, v1+j*\(v2-v1\)/nv\); )Tj
0 -1 TD
(    glEnd\(\); )Tj
0 -1.1 TD
(} )Tj
0 -1 TD
(for \(j = nv1; j <= nv2; j++\) { )Tj
0 -1.1 TD
(    glBegin\(GL_LINES\); )Tj
0 -1 TD
(    for \(i = nu1; i <= nu2; i++\)  )Tj
0 -1.1 TD
(        glEvalCoord2\(u1 + i*\(u2-u1\)/nu, v1+j*\(v2-v1\)/nv\); )Tj
T*
(    glEnd\(\); )Tj
0 -1 TD
(})Tj
/F11 1 Tf
0 -2.1 TD
(or)Tj
/F7 1 Tf
T*
(for \(i = nu1; i < nu2; i++\) {     /* mode == GL_FILL */ )Tj
0 -1.1 TD
(    glBegin\(GL_QUAD_STRIP\);)Tj
0 -1 TD
(    for \(j = nv1; j <= nv2; j++\) { )Tj
0 -1.1 TD
(        glEvalCoord2\(u1 + i*\(u2-u1\)/nu, v1+j*\(v2-v1\)/nv\);)Tj
0 -1 TD
(        glEvalCoord2\(u1 + \(i+1\)*\(u2-u1\)/nu, v1+j*\(v2-v1\)/nv\);)Tj
0 -1.1 TD
(    glEnd\(\); )Tj
0 -1 TD
(})Tj
/F11 1 Tf
0 -2.2 TD
(Example 12-3)Tj
5.6 0 TD
[( shows the differences necessary to draw the same B\351zier surface as )-362(Example 12-2)]TJ
33.4 0 TD
(, but)Tj
-39 -1.5 TD
(using )Tj
/F15 1 Tf
2.4 0 TD
(glMapGrid2\(\))Tj
/F11 1 Tf
5.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glEvalMesh2\(\))Tj
/F11 1 Tf
6 0 TD
( to subdivide the square domain into a uniform 8x8 grid. This)Tj
-16 -1.5 TD
[(program also adds lighting and shading, as shown in )24(Figure 12-3)226(.)]TJ
ET
Q
/GS1 gs
q
170 0 0 167 124 216.1 cm
/Im105 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 203.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 12-3 )Tj
/F11 1 Tf
5.6 0 TD
(Lit, Shaded B\351zier Surface Drawn with a Mesh)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 12-3 )Tj
/F11 1 Tf
6.7 0 TD
(Lit, Shaded B\351zier Surface Using a Mesh: bezmesh.c)Tj
/F7 1 Tf
-6.7 -2.3 TD
(void initlights\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat ambient[] = {0.2, 0.2, 0.2, 1.0};)Tj
T*
(   GLfloat position[] = {0.0, 0.0, 2.0, 1.0};)Tj
T*
(   GLfloat mat_diffuse[] = {0.6, 0.6, 0.6, 1.0};)Tj
T*
(   GLfloat mat_specular[] = {1.0, 1.0, 1.0, 1.0};)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 11)Tj
ET
endstream
endobj
1258 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im105 1255 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1260 0 obj
<<
/Length 2415
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   GLfloat mat_shininess[] = {50.0};)Tj
0 -3 TD
(   glEnable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHT0\);)Tj
0 -3 TD
(   glLightfv\(GL_LIGHT0, GL_AMBIENT, ambient\);)Tj
0 -1.5 TD
(   glLightfv\(GL_LIGHT0, GL_POSITION, position\);)Tj
0 -3 TD
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, mat_diffuse\);)Tj
0 -1.5 TD
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SHININESS, mat_shininess\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glPushMatrix\(\);)Tj
T*
(   glRotatef\(85.0, 1.0, 1.0, 1.0\);)Tj
T*
(   glEvalMesh2\(GL_FILL, 0, 20, 0, 20\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor\(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glMap2f\(GL_MAP2_VERTEX_3, 0, 1, 3, 4,)Tj
T*
(           0, 1, 12, 4, &ctrlpoints[0][0][0]\);)Tj
T*
(   glEnable\(GL_MAP2_VERTEX_3\);)Tj
T*
(   glEnable\(GL_AUTO_NORMAL\);)Tj
T*
(   glMapGrid2f\(20, 0.0, 1.0, 20, 0.0, 1.0\);)Tj
T*
(   initlights\(\);)Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 188.000 Tm
(Using Evaluators for Textures)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 166.000 Tm
(Example 12-4)Tj
5.6 0 TD
( enables two evaluators at the same time: The first generates three-dimensional points on)Tj
-5.6 -1.5 TD
[(the same B\351zier surface as )-242(Example 12-3)170(, and the second generates texture coordinates. In this case, the)]TJ
T*
(texture coordinates are the same as the )Tj
/F15 1 Tf
15.7 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( coordinates of the surface, but a special flat B\351zier patch)Tj
-18.6 -1.5 TD
(must be created to do this.)Tj
0 -2.1 TD
(The flat patch is defined over a square with corners at \(0, 0\), \(0, 1\), \(1, 0\), and \(1, 1\); it generates \(0, 0\) at)Tj
0 -1.5 TD
(corner \(0, 0\), \(0, 1\) at corner \(0, 1\), and so on. Since it's of order two \(linear degree plus one\), evaluating)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 12)Tj
ET
endstream
endobj
1261 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1263 0 obj
<<
/Length 2349
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(this texture at the point \()Tj
/F15 1 Tf
9.8 0 TD
(u, v)Tj
/F11 1 Tf
1.4 0 TD
(\) generates texture coordinates \()Tj
/F15 1 Tf
12.9 0 TD
(s, t)Tj
/F11 1 Tf
1.1 0 TD
(\). It's enabled at the same time as the)Tj
-25.2 -1.5 TD
[(vertex evaluator, so both take effect when the surface is drawn. \(See )50("Plate 19" in Appendix I)-28(.\) If you)]TJ
T*
(want the texture to repeat three times in each direction, change every 1.0 in the array )Tj
/F15 1 Tf
34.1 0 TD
(texpts[][][])Tj
/F11 1 Tf
4.7 0 TD
( to 3.0.)Tj
-38.8 -1.5 TD
(Since the texture wraps in this example, the surface is rendered with nine copies of the texture map.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 12-4 )Tj
/F11 1 Tf
6.7 0 TD
(Using Evaluators for Textures: texturesurf.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <math.h>)Tj
0 -3 TD
(GLfloat ctrlpoints[4][4][3] = {)Tj
0 -1.5 TD
(   {{ -1.5, -1.5, 4.0}, { -0.5, -1.5, 2.0}, )Tj
T*
(    {0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}}, )Tj
T*
(   {{ -1.5, -0.5, 1.0}, { -0.5, -0.5, 3.0}, )Tj
T*
(    {0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}}, )Tj
T*
(   {{ -1.5, 0.5, 4.0}, { -0.5, 0.5, 0.0}, )Tj
T*
(    {0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}}, )Tj
T*
(   {{ -1.5, 1.5, -2.0}, { -0.5, 1.5, -2.0}, )Tj
T*
(    {0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}})Tj
T*
(};)Tj
T*
(GLfloat texpts[2][2][2] = {{{0.0, 0.0}, {0.0, 1.0}}, )Tj
T*
(                        {{1.0, 0.0}, {1.0, 1.0}}};)Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glColor3f\(1.0, 1.0, 1.0\);)Tj
T*
(   glEvalMesh2\(GL_FILL, 0, 20, 0, 20\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
T*
(#define imageWidth 64)Tj
T*
(#define imageHeight 64)Tj
T*
(GLubyte image[3*imageWidth*imageHeight];)Tj
0 -3 TD
(void makeImage\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int i, j;)Tj
T*
(   float ti, tj;)Tj
T*
(   )Tj
T*
(   for \(i = 0; i < imageWidth; i++\) {)Tj
T*
(      ti = 2.0*3.14159265*i/imageWidth;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 13)Tj
ET
endstream
endobj
1264 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1266 0 obj
<<
/Length 2176
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      for \(j = 0; j < imageHeight; j++\) {)Tj
0 -1.5 TD
(         tj = 2.0*3.14159265*j/imageHeight;)Tj
T*
(         image[3*\(imageHeight*i+j\)] = )Tj
T*
(              \(GLubyte\) 127*\(1.0+sin\(ti\)\);)Tj
T*
(         image[3*\(imageHeight*i+j\)+1] = )Tj
T*
(              \(GLubyte\) 127*\(1.0+cos\(2*tj\)\);)Tj
T*
(         image[3*\(imageHeight*i+j\)+2] = )Tj
T*
(              \(GLubyte\) 127*\(1.0+cos\(ti+tj\)\);)Tj
T*
(      })Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glMap2f\(GL_MAP2_VERTEX_3, 0, 1, 3, 4,)Tj
T*
(           0, 1, 12, 4, &ctrlpoints[0][0][0]\);)Tj
T*
(   glMap2f\(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, )Tj
T*
(           0, 1, 4, 2, &texpts[0][0][0]\);)Tj
T*
(   glEnable\(GL_MAP2_TEXTURE_COORD_2\);)Tj
T*
(   glEnable\(GL_MAP2_VERTEX_3\);)Tj
T*
(   glMapGrid2f\(20, 0.0, 1.0, 20, 0.0, 1.0\);)Tj
T*
(   makeImage\(\);)Tj
T*
(   glTexEnvf\(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, )Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexParameteri\(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, )Tj
T*
(                   GL_NEAREST\);)Tj
T*
(   glTexImage2D\(GL_TEXTURE_2D, 0, 3, imageWidth, imageHeight, 0,)Tj
T*
(                GL_RGB, GL_UNSIGNED_BYTE, image\);)Tj
T*
(   glEnable\(GL_TEXTURE_2D\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glShadeModel \(GL_FLAT\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   if \(w <= h\))Tj
T*
(      glOrtho\(-4.0, 4.0, -4.0*\(GLfloat\)h/\(GLfloat\)w, )Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 14)Tj
ET
endstream
endobj
1267 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1270 0 obj
<<
/Length 2996
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(              4.0*\(GLfloat\)h/\(GLfloat\)w, -4.0, 4.0\);)Tj
0 -1.5 TD
(   else)Tj
T*
(      glOrtho\(-4.0*\(GLfloat\)w/\(GLfloat\)h, )Tj
T*
(              4.0*\(GLfloat\)w/\(GLfloat\)h, -4.0, 4.0, -4.0, 4.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   glRotatef\(85.0, 1.0, 1.0, 1.0\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize \(500, 500\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0;)Tj
T*
(})Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 363.000 Tm
(The GLU NURBS Interface)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 341.000 Tm
(Although evaluators are the only OpenGL primitive available to draw curves and surfaces directly, and)Tj
T*
(even though they can be implemented very efficiently in hardware, they're often accessed by applications)Tj
T*
(through higher-level libraries. The GLU provides a NURBS \(Non-Uniform Rational B-Spline\) interface)Tj
T*
(built on top of the OpenGL evaluator commands.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 267.000 Tm
(A Simple NURBS Example)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 246.000 Tm
(If you understand NURBS, writing OpenGL code to manipulate NURBS curves and surfaces is relatively)Tj
T*
(easy, even with lighting and texture mapping. Follow these steps to draw NURBS curves or untrimmed)Tj
T*
[(NURBS surfaces. \(See )-12("Trim a NURBS Surface" for information about trimmed surfaces.\))]TJ
0 -2.1 TD
[(1.)-1050(If you intend to use lighting with a NURBS surface, call )]TJ
/F15 1 Tf
24.6 0 TD
(glEnable\(\))Tj
/F11 1 Tf
4.3 0 TD
( with GL_AUTO_NORMAL to)Tj
-27.1 -1.5 TD
(automatically generate surface normals. \(Or you can calculate your own.\))Tj
-1.8 -2.1 TD
[(2.)-1050(Use )]TJ
/F15 1 Tf
3.6 0 TD
(gluNewNurbsRenderer\(\))Tj
/F11 1 Tf
9.9 0 TD
( to create a pointer to a NURBS object, which is referred to when)Tj
-11.7 -1.5 TD
(creating your NURBS curve or surface.)Tj
-1.8 -2.1 TD
[(3.)-1050(If desired, call )]TJ
/F15 1 Tf
7.8 0 TD
(gluNurbsProperty\(\))Tj
/F11 1 Tf
7.9 0 TD
( to choose rendering values, such as the maximum size of lines or)Tj
-13.9 -1.5 TD
(polygons that are used to render your NURBS object.)Tj
-1.8 -2.1 TD
[(4.)-1050(Call )]TJ
/F15 1 Tf
3.7 0 TD
(gluNurbsCallback\(\))Tj
/F11 1 Tf
8 0 TD
( if you want to be notified when an error is encountered. \(Error checking)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 15)Tj
ET
endstream
endobj
1271 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1272 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im106
/Width 161
/Height 138
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.105)
>>
stream
endstream
endobj
1274 0 obj
<<
/Length 2603
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(may slightly degrade performance but is still highly recommended.\))Tj
-1.8 -2.1 TD
[(5.)-1050(Start your curve or surface by calling )]TJ
/F15 1 Tf
16.9 0 TD
(gluBeginCurve\(\))Tj
/F11 1 Tf
6.8 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(gluBeginSurface\(\))Tj
/F11 1 Tf
7.3 0 TD
(.)Tj
-32.3 -2.1 TD
[(6.)-1050(Generate and render your curve or surface. Call )]TJ
/F15 1 Tf
21.1 0 TD
(gluNurbsCurve\(\))Tj
/F11 1 Tf
6.8 0 TD
( or )Tj
/F15 1 Tf
1.4 0 TD
(gluNurbsSurface\(\))Tj
/F11 1 Tf
7.4 0 TD
( at least once)Tj
-34.9 -1.5 TD
(with the control points \(rational or nonrational\), knot sequence, and order of the polynomial basis)Tj
T*
(function for your NURBS object. You might call these functions additional times to specify surface)Tj
T*
(normals and/or texture coordinates.)Tj
-1.8 -2.1 TD
[(7.)-1050(Call )]TJ
/F15 1 Tf
3.7 0 TD
(gluEndCurve\(\))Tj
/F11 1 Tf
6 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(gluEndSurface\(\) )Tj
/F11 1 Tf
6.9 0 TD
(to complete the curve or surface.)Tj
-17.9 -2.6 TD
(Example 12-5)Tj
5.6 0 TD
( renders a NURBS surface in the shape of a symmetrical hill with control points ranging)Tj
-5.6 -1.5 TD
(from -3.0 to 3.0. The basis function is a cubic B-spline, but the knot sequence is nonuniform, with a)Tj
T*
(multiplicity of 4 at each endpoint, causing the basis function to behave like a B\351zier curve in each)Tj
T*
[(direction. The surface is lighted, with a dark gray diffuse reflection and white specular highlights. )31(Figure)]TJ
T*
(12-4)Tj
1.8 0 TD
( shows the surface as a lit wireframe.)Tj
ET
Q
/GS1 gs
q
161 0 0 138 124 364.84 cm
/Im106 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 352.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 12-4 )Tj
/F11 1 Tf
5.6 0 TD
(NURBS Surface)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 12-5 )Tj
/F11 1 Tf
6.7 0 TD
(NURBS Surface: surface.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(GLfloat ctlpoints[4][4][3];)Tj
0 -1.5 TD
(int showPoints = 0;)Tj
0 -3 TD
(GLUnurbsObj *theNurb;)Tj
T*
(void init_surface\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   int u, v;)Tj
T*
(   for \(u = 0; u < 4; u++\) {)Tj
T*
(      for \(v = 0; v < 4; v++\) {)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 16)Tj
ET
endstream
endobj
1275 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im106 1272 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1277 0 obj
<<
/Length 1873
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(         ctlpoints[u][v][0] = 2.0*\(\(GLfloat\)u - 1.5\);)Tj
0 -1.5 TD
(         ctlpoints[u][v][1] = 2.0*\(\(GLfloat\)v - 1.5\);)Tj
0 -3 TD
(         if \( \(u == 1 || u == 2\) && \(v == 1 || v == 2\)\))Tj
0 -1.5 TD
(            ctlpoints[u][v][2] = 3.0;)Tj
T*
(         else)Tj
T*
(            ctlpoints[u][v][2] = -3.0;)Tj
T*
(      })Tj
T*
(   }    )Tj
T*
(}    )Tj
0 -3 TD
(void nurbsError\(GLenum errorCode\))Tj
0 -1.5 TD
({)Tj
T*
(   const GLubyte *estring;)Tj
0 -3 TD
(   estring = gluErrorString\(errorCode\);)Tj
0 -1.5 TD
(   fprintf \(stderr, "Nurbs Error: %s\\n", estring\);)Tj
T*
(   exit \(0\);)Tj
T*
(})Tj
T*
(   )Tj
T*
(void init\(void\))Tj
T*
({)Tj
T*
(   GLfloat mat_diffuse[] = { 0.7, 0.7, 0.7, 1.0 };)Tj
T*
(   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };)Tj
T*
(   GLfloat mat_shininess[] = { 100.0 };)Tj
0 -3 TD
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glMaterialfv\(GL_FRONT, GL_DIFFUSE, mat_diffuse\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SPECULAR, mat_specular\);)Tj
T*
(   glMaterialfv\(GL_FRONT, GL_SHININESS, mat_shininess\);)Tj
0 -3 TD
(   glEnable\(GL_LIGHTING\);)Tj
0 -1.5 TD
(   glEnable\(GL_LIGHT0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glEnable\(GL_AUTO_NORMAL\);)Tj
T*
(   glEnable\(GL_NORMALIZE\);)Tj
0 -3 TD
(   init_surface\(\);)Tj
T*
(   theNurb = gluNewNurbsRenderer\(\);)Tj
0 -1.5 TD
(   gluNurbsProperty\(theNurb, GLU_SAMPLING_TOLERANCE, 25.0\);)Tj
T*
(   gluNurbsProperty\(theNurb, GLU_DISPLAY_MODE, GLU_FILL\);)Tj
T*
(   gluNurbsCallback\(theNurb, GLU_ERROR, )Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 17)Tj
ET
endstream
endobj
1278 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1280 0 obj
<<
/Length 1732
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(                    \(GLvoid \(*\)\(\)\) nurbsError\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};)Tj
T*
(   int i, j;)Tj
0 -3 TD
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   glPushMatrix\(\);)Tj
0 -1.5 TD
(   glRotatef\(330.0, 1.,0.,0.\);)Tj
T*
(   glScalef \(0.5, 0.5, 0.5\);)Tj
0 -3 TD
(   gluBeginSurface\(theNurb\);)Tj
0 -1.5 TD
(   gluNurbsSurface\(theNurb, )Tj
T*
(                   8, knots, 8, knots,)Tj
T*
(                   4 * 3, 3, &ctlpoints[0][0][0], )Tj
T*
(                   4, 4, GL_MAP2_VERTEX_3\);)Tj
T*
(   gluEndSurface\(theNurb\);)Tj
0 -3 TD
(   if \(showPoints\) {)Tj
0 -1.5 TD
(      glPointSize\(5.0\);)Tj
T*
(      glDisable\(GL_LIGHTING\);)Tj
T*
(      glColor3f\(1.0, 1.0, 0.0\);)Tj
T*
(      glBegin\(GL_POINTS\);)Tj
T*
(      for \(i = 0; i < 4; i++\) {)Tj
T*
(         for \(j = 0; j < 4; j++\) {)Tj
T*
(            glVertex3f\(ctlpoints[i][j][0], )Tj
T*
(                       ctlpoints[i][j][1], ctlpoints[i][j][2]\);)Tj
T*
(         })Tj
T*
(      })Tj
T*
(      glEnd\(\);)Tj
T*
(      glEnable\(GL_LIGHTING\);)Tj
T*
(   })Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 18)Tj
ET
endstream
endobj
1281 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1283 0 obj
<<
/Length 2043
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glLoadIdentity\(\);)Tj
0 -1.5 TD
(   gluPerspective \(45.0, \(GLdouble\)w/\(GLdouble\)h, 3.0, 8.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   glTranslatef \(0.0, 0.0, -5.0\);)Tj
T*
(})Tj
T*
(void keyboard\(unsigned char key, int x, int y\))Tj
T*
({)Tj
T*
(   switch \(key\) {)Tj
T*
(      case `c':)Tj
T*
(      case `C':)Tj
T*
(         showPoints = !showPoints;)Tj
T*
(         glutPostRedisplay\(\);)Tj
T*
(         break;)Tj
T*
(      case 27:)Tj
T*
(         exit\(0\);)Tj
T*
(         break;)Tj
T*
(      default:)Tj
T*
(         break;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize \(500, 500\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutKeyboardFunc \(keyboard\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0; )Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 158.000 Tm
(Manage a NURBS Object)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 136.000 Tm
[(As shown in )-49(Example 12-5)]TJ
10.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(gluNewNurbsRenderer\(\))Tj
/F11 1 Tf
9.9 0 TD
( returns a new NURBS object, whose type is a)Tj
-21.3 -1.5 TD
(pointer to a GLUnurbsObj structure. You must make this object before using any other NURBS routine.)Tj
T*
(When you're done with a NURBS object, you may use )Tj
/F15 1 Tf
22.2 0 TD
(gluDeleteNurbsRenderer\(\))Tj
/F11 1 Tf
10.8 0 TD
( to free up the memory)Tj
-33 -1.5 TD
(that was used.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 19)Tj
ET
endstream
endobj
1284 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1286 0 obj
<<
/Length 3969
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
-0.029 Tw
[(GLUnurbsObj* gluNewNurbsRenderer)-77( )-29(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Creates a new NURBS object, )-22(nobj)-22(. Returns a pointer to the new object, or zero, if OpenGL cannot)]TJ
T*
(allocate memory for a new NURBS object.)Tj
-1.8 -2.1 TD
[(void )-28(gluDeleteNurbsRenderer)55( \(GLUnurbsObj *)12(nobj)-22(\);)]TJ
1.8 -1.5 TD
[(Destroys the NURBS object )33(nobj)-22(.)]TJ
/F27 1 Tf
-1.8 -3 TD
(Control NURBS Rendering Properties)Tj
/F11 1 Tf
0 -2.1 TD
(A set of properties associated with a NURBS object affects the way the object is rendered. These)Tj
0 -1.5 TD
(properties include how the surface is rasterized \(for example, filled or wireframe\) and the precision of)Tj
T*
(tessellation.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluNurbsProperty)-21(\(GLUnurbsObj *)62(nobj)-22(, GLenum )-6(property)44(,)]TJ
0 -1.1 TD
0.038 Tw
[(GLfloat value)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Controls attributes of a NURBS object, )20(nobj)-22(. The )50(property)-56( argument specifies the property and can)]TJ
T*
(be GLU_DISPLAY_MODE, GLU_CULLING, GLU_SAMPLING_METHOD,)Tj
T*
(GLU_SAMPLING_TOLERANCE, GLU_PARAMETRIC_TOLERANCE, GLU_U_STEP,)Tj
T*
[(GLU_V_STEP, or GLU_AUTO_LOAD_MATRIX. The )-42(value)66( argument indicates what the property)]TJ
T*
(should be.)Tj
T*
(The default value for GLU_DISPLAY_MODE is GLU_FILL, which causes the surface to be)Tj
T*
(rendered as polygons. If GLU_OUTLINE_POLYGON is used for the display-mode property, only)Tj
T*
(the outlines of polygons created by tessellation are rendered. GLU_OUTLINE_PATCH renders the)Tj
T*
[(outlines of patches and trimming curves. \(See "Create a NURBS Curve or Surface")13(.\))]TJ
T*
(GLU_CULLING can speed up performance by not performing tessellation if the NURBS object falls)Tj
T*
(completely outside the viewing volume; set this property to GL_TRUE to enable culling \(the default)Tj
T*
(is GL_FALSE\).)Tj
T*
(Since a NURBS object is rendered as primitives, it's sampled at different values of its parameter\(s\))Tj
T*
[(\()33(u)0( and v)-56(\))0( and broken down into small line segments or polygons for rendering. If )-8(property)44( is)]TJ
T*
[(GLU_SAMPLING_METHOD, then )-27(value)66( is set to one of GLU_PATH_LENGTH \(which is the)]TJ
T*
(default\), GLU_PARAMETRIC_ERROR, or GLU_DOMAIN_DISTANCE, which specifies how a)Tj
T*
[(NURBS curve or surface should be tessellated. When )28(value)-34( is set to GLU_PATH_LENGTH, the)]TJ
T*
(surface is rendered so that the maximum length, in pixels, of the edges of tessellated polygons is no)Tj
T*
(greater than what is specified by GLU_SAMPLING_TOLERANCE. When set to)Tj
T*
(GLU_PARAMETRIC_ERROR, then the value specified by GLU_PARAMETRIC_TOLERANCE is)Tj
T*
(the maximum distance, in pixels, between tessellated polygons and the surfaces they approximate.)Tj
T*
(When set to GLU_DOMAIN_DISTANCE, the application specifies, in parametric coordinates, how)Tj
T*
[(many sample points per unit length are taken in the )35(u and v)-56( dimensions, using the values for)]TJ
T*
(GLU_U_STEP and GLU_V_STEP.)Tj
T*
[(If )-39(property)44( is GLU_SAMPLING_TOLERANCE and the sampling method is GLU_PATH_LENGTH,)]TJ
T*
[(value)-34( controls the maximum length, in pixels, to use for tessellated polygons. The default value of)]TJ
T*
[(50.0 makes the largest sampled line segment or polygon edge 50.0 pixels long. If )-16(property)44( is)]TJ
T*
(GLU_PARAMETRIC_TOLERANCE and the sampling method is GLU_PARAMETRIC_ERROR,)Tj
T*
[(value)-34( controls the maximum distance, in pixels, between the tessellated polygons and the surfaces)]TJ
T*
(they approximate. The default value for GLU_PARAMETRIC_TOLERANCE is 0.5, which makes the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 20)Tj
ET
endstream
endobj
1287 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1289 0 obj
<<
/Length 3875
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(tessellated polygons within one-half pixel of the approximated surface. If the sampling method is)Tj
0 -1.5 TD
[(GLU_DOMAIN_DISTANCE and )-43(property)44( is either GLU_U_STEP or GLU_V_STEP, then value)-34( is)]TJ
T*
(the number of sample points per unit length taken along the u or v dimension, respectively, in)Tj
T*
(parametric coordinates. The default for both GLU_U_STEP and GLU_V_STEP is 100.)Tj
T*
(The GLU_AUTO_LOAD_MATRIX property determines whether the projection matrix, modelview)Tj
T*
(matrix, and viewport are downloaded from the OpenGL server \(GL_TRUE, the default\), or whether)Tj
T*
[(the application must supply these matrices with )-48(gluLoadSamplingMatrices\(\))34( \(GL_FALSE\).)]TJ
-1.8 -2.1 TD
[(void )-28(gluLoadSamplingMatrices)68( \(GLUnurbsObj *)-88(nobj)78(, const GLfloat )-76(modelMatrix)67([16], const GLfloat)]TJ
0 -1.5 TD
[(projMatrix)-11([16], const GLint )24(viewport[4]\);)]TJ
1.8 -1.5 TD
(If the GLU_AUTO_LOAD_MATRIX is turned off, the modelview and projection matrices and the)Tj
T*
[(viewport specified in )-16(gluLoadSamplingMatrices\(\))34( are used to compute sampling and culling)]TJ
T*
(matrices for each NURBS curve or surface.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(If you need to query the current value for a NURBS property, you may use )Tj
/F15 1 Tf
30.2 0 TD
(gluGetNurbsProperty\(\))Tj
/F11 1 Tf
9.4 0 TD
(.)Tj
/F15 1 Tf
-39.6 -2.1 TD
0.028 Tw
[(void gluGetNurbsProperty )101(\(GLUnurbsObj )-10(*nobj)-22(, )28(GLenum )22(property)44(,)]TJ
0 -1.1 TD
0.038 Tw
[(GLfloat *value)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Given the )10(property)-56( to be queried for the NURBS object )23(nobj)-22(, return its current )40(value)-34(.)]TJ
/F27 1 Tf
-1.8 -3 TD
(Handle NURBS Errors)Tj
/F11 1 Tf
0 -2.1 TD
(Since there are 37 different errors specific to NURBS functions, it's a good idea to register an error)Tj
0 -1.5 TD
[(callback to let you know if you've stumbled into one of them. In )-44(Example 12-5)]TJ
31.7 0 TD
(, the callback function)Tj
-31.7 -1.5 TD
(was registered with)Tj
/F7 1 Tf
0 -2 TD
(gluNurbsCallback\(theNurb, GLU_ERROR, \(GLvoid \(*\)\(\)\) nurbsError\);)Tj
/F15 1 Tf
0 -2.2 TD
[(void )-28(gluNurbsCallback)35( \(GLUnurbsObj *)12(nobj)-22(, GLenum )-6(which)-11(,)]TJ
0 -1.1 TD
[(void \(*fn)-22(\)\(GLenum )61(errorCode)-78(\)\);)]TJ
1.8 -1.5 TD
[(which)-11( is the type of callback; it must be GLU_ERROR. When a NURBS function detects an error)]TJ
T*
[(condition, )-22(fn)-22( is invoked with the error code as its only argument. )13(errorCode)22( is one of 37 error)]TJ
T*
[(conditions, named GLU_NURBS_ERROR1 through GLU_NURBS_ERROR37. Use )13(gluErrorString\(\))]TJ
T*
(to describe the meaning of those error codes.)Tj
/F11 1 Tf
-1.8 -2.1 TD
0.017 Tw
[(In Example )17(12-5)]TJ
6.7 0 TD
0.000 Tw
(, the )Tj
/F15 1 Tf
2 0 TD
(nurbsError\(\))Tj
/F11 1 Tf
5.2 0 TD
( routine was registered as the error callback function:)Tj
/F7 1 Tf
-13.9 -2 TD
(void nurbsError\(GLenum errorCode\))Tj
0 -1.5 TD
({)Tj
T*
(   const GLubyte *estring;)Tj
0 -3 TD
(   estring = gluErrorString\(errorCode\);)Tj
0 -1.5 TD
(   fprintf \(stderr, "Nurbs Error: %s\\n", estring\);)Tj
T*
(   exit \(0\);)Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 102.000 Tm
(Create a NURBS Curve or Surface)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 81.000 Tm
(To render a NURBS surface, )Tj
/F15 1 Tf
11.8 0 TD
(gluNurbsSurface\(\))Tj
/F11 1 Tf
7.5 0 TD
( is bracketed by )Tj
/F15 1 Tf
6.5 0 TD
(gluBeginSurface\(\))Tj
/F11 1 Tf
7.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluEndSurface\(\))Tj
/F11 1 Tf
6.6 0 TD
(.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 21)Tj
ET
endstream
endobj
1290 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1292 0 obj
<<
/Length 4457
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The bracketing routines save and restore the evaluator state.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluBeginSurface)67( \(GLUnurbsObj *nobj\);)]TJ
0 -1.1 TD
[(void )-28(gluEndSurface)45( \(GLUnurbsObj *nobj\);)]TJ
1.8 -1.5 TD
[(After )-50(gluBeginSurface\(\))33(, one or more calls to )6(gluNurbsSurface\(\))45( defines the attributes of the surface.)]TJ
T*
(Exactly one of these calls must have a surface type of GL_MAP2_VERTEX_3 or)Tj
T*
[(GL_MAP2_VERTEX_4 to generate vertices. Use )-12(gluEndSurface\(\))11( to end the definition of a surface.)]TJ
T*
[(Trimming of NURBS surfaces is also supported between )-19(gluBeginSurface\(\))33( and gluEndSurface\(\).)]TJ
T*
[(\(See )-29("Trim a NURBS Surface".\))]TJ
-1.8 -2.1 TD
[(void )-28(gluNurbsSurface)-21( \(GLUnurbsObj *)12(nobj)78(, GLint )-16(uknot_count)-55(,)]TJ
0 -1.1 TD
[(GLfloat *)-38(uknot)22(, GLint )-16(vknot_count)-11(, GLfloat *)62(vknot)-34(,)]TJ
T*
[(GLint )-16(u_stride)-22(, GLint )84(v_stride)-78(, GLfloat *)62(ctlarray)-78(,)]TJ
T*
0.016 Tw
[(GLint uorder)22(, )16(GLint vorder)-34(, )16(GLenum )10(type)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Describes the vertices \(or surface normals or texture coordinates\) of a NURBS surface, )33(nobj)-22(.)]TJ
T*
[(Several of the values must be specified for both )39(u and v)-56( parametric directions, such as the knot)]TJ
T*
[(sequences \()38(uknot)-78( and vknot)66(\), knot counts \(uknot_count)-55( and vknot_count)-11(\), and order of the)]TJ
T*
[(polynomial \()-16(uorder)22( and vorder)-34(\) for the NURBS surface. Note that the number of control points isn't)]TJ
T*
(specified. Instead, it's derived by determining the number of control points along each parameter as)Tj
T*
(the number of knots minus the order. Then, the number of control points for the surface is equal to)Tj
T*
[(the number of control points in each parametric direction, multiplied by one another. The )-31(ctlarray)]TJ
T*
(argument points to an array of control points.)Tj
T*
[(The last parameter, )12(type)-34(, is one of the two-dimensional evaluator types. Commonly, you might use)]TJ
T*
(GL_MAP2_VERTEX_3 for nonrational or GL_MAP2_VERTEX_4 for rational control points,)Tj
T*
(respectively. You might also use other types, such as GL_MAP2_TEXTURE_COORD_* or)Tj
T*
(GL_MAP2_NORMAL to calculate and assign texture coordinates or surface normals. For example,)Tj
T*
(to create a lighted \(with surface normals\) and textured NURBS surface, you may need to call this)Tj
T*
(sequence:)Tj
/F7 1 Tf
-1.8 -2.1 TD
(gluBeginSurface\(nobj\);)Tj
0 -1.5 TD
(   gluNurbsSurface\(nobj, ..., GL_MAP2_TEXTURE_COORD_2\);)Tj
T*
(   gluNurbsSurface\(nobj, ..., GL_MAP2_NORMAL\);)Tj
T*
(   gluNurbsSurface\(nobj, ..., GL_MAP2_VERTEX_3\);)Tj
T*
(gluEndSurface\(nobj\);)Tj
/F15 1 Tf
1.8 -1.5 TD
[(The )-50(u_stride)78( and v_stride)-78( arguments represent the number of floating-point values between control)]TJ
T*
[(points in each parametric direction. The evaluator type, as well as its order, affects the )14(u_stride)-22( and)]TJ
T*
[(v_stride)22( values. In )-11(Example 12-5)]TJ
13.2 0 TD
[(, u_stride)-22( is 12 \(4 * 3\) because there are three coordinates for each)]TJ
-13.2 -1.5 TD
[(vertex \(set by GL_MAP2_VERTEX_3\) and four control points in the parametric )7(v)44( direction; )-55(v_stride)]TJ
T*
[(is 3 because each vertex had three coordinates, and v)44( control points are adjacent to one another.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(Drawing a NURBS curve is similar to drawing a surface, except that all calculations are done with one)Tj
0 -1.5 TD
(parameter, )Tj
/F15 1 Tf
4.5 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(, rather than two. Also, for curves, )Tj
/F15 1 Tf
14 0 TD
(gluBeginCurve\(\))Tj
/F11 1 Tf
6.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluEndCurve\(\))Tj
/F11 1 Tf
6 0 TD
( are the bracketing)Tj
-33.6 -1.5 TD
(routines.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void gluBeginCurve)56( )28(\(GLUnurbsObj )40(*nobj)-22(\);)]TJ
0 -1.1 TD
[(void gluEndCurve)34( )28(\(GLUnurbsObj )40(*nobj)-22(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(After )-50(gluBeginCurve\(\))22(, one or more calls to )6(gluNurbsCurve\(\))34( define the attributes of the surface.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 22)Tj
ET
endstream
endobj
1293 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1295 0 obj
<<
/Length 5073
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Exactly one of these calls must have a surface type of GL_MAP1_VERTEX_3 or)Tj
0 -1.5 TD
[(GL_MAP1_VERTEX_4 to generate vertices. Use )-12(gluEndCurve\(\) to end the definition of a surface.)]TJ
-1.8 -2.1 TD
[(void )-28(gluNurbsCurve)68( \(GLUnurbsObj *)-88(nobj)78(, GLint )-16(uknot_count)-55(,)]TJ
0 -1.1 TD
[(GLfloat *)-38(uknot)22(, GLint )-16(u_stride)78(, GLfloat *)-38(ctlarray)22(,)]TJ
T*
0.016 Tw
[(GLint uorder)22(, )16(GLenum )10(type)-34(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Defines a NURBS curve for the object )-28(nobj)78(. The arguments have the same meaning as those for)]TJ
T*
[(gluNurbsSurface\(\))45(. Note that this routine requires only one knot sequence and one declaration of the)]TJ
T*
[(order of the NURBS object. If this curve is defined within a )19(gluBeginCurve\(\)/gluEndCurve\(\) pair,)]TJ
T*
(then the type can be any of the valid one-dimensional evaluator types \(such as)Tj
T*
(GL_MAP1_VERTEX_3 or GL_MAP1_VERTEX_4\).)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 549.000 Tm
(Trim a NURBS Surface)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 528.000 Tm
(To create a trimmed NURBS surface with OpenGL, start as if you were creating an untrimmed surface.)Tj
T*
(After calling )Tj
/F15 1 Tf
5.3 0 TD
(gluBeginSurface\(\))Tj
/F11 1 Tf
7.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(gluNurbsSurface\(\))Tj
/F11 1 Tf
7.5 0 TD
( but before calling )Tj
/F15 1 Tf
7.5 0 TD
(gluEndSurface\(\))Tj
/F11 1 Tf
6.6 0 TD
(, start a trim by)Tj
-36.2 -1.5 TD
(calling )Tj
/F15 1 Tf
3 0 TD
(gluBeginTrim\(\))Tj
/F11 1 Tf
6.2 0 TD
(.)Tj
/F15 1 Tf
-9.2 -2.1 TD
[(void )-28(gluBeginTrim)57( \(GLUnurbsObj *)12(nobj)-22(\);)]TJ
0 -1.1 TD
[(void )-28(gluEndTrim)35( \(GLUnurbsObj *)12(nobj)-22(\);)]TJ
1.8 -1.5 TD
(Marks the beginning and end of the definition of a trimming loop. A trimming loop is a set of)Tj
T*
(oriented, trimming curve segments \(forming a closed curve\) that defines the boundaries of a NURBS)Tj
T*
(surface.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(You can create two kinds of trimming curves, a piecewise linear curve with )Tj
/F15 1 Tf
30.5 0 TD
(gluPwlCurve\(\))Tj
/F11 1 Tf
5.9 0 TD
( or a NURBS)Tj
-36.4 -1.5 TD
(curve with )Tj
/F15 1 Tf
4.5 0 TD
(gluNurbsCurve\(\))Tj
/F11 1 Tf
6.8 0 TD
(. A piecewise linear curve doesn't look like what's conventionally called a)Tj
-11.3 -1.5 TD
(curve, because it's a series of straight lines. A NURBS curve for trimming must lie within the unit square)Tj
T*
(of parametric \()Tj
/F15 1 Tf
5.9 0 TD
(u)Tj
/F11 1 Tf
0.5 0 TD
(,)Tj
/F15 1 Tf
0.3 0 TD
( v)Tj
/F11 1 Tf
0.7 0 TD
(\) space. The type for a NURBS trimming curve is usually GLU_MAP1_TRIM2. Less)Tj
-7.4 -1.5 TD
(often, the type is GLU_MAP1_TRIM3, where the curve is described in a two-dimensional homogeneous)Tj
T*
(space \()Tj
/F15 1 Tf
2.8 0 TD
(u', v', w)Tj
/F11 1 Tf
3.3 0 TD
('\) by \()Tj
/F15 1 Tf
2.5 0 TD
(u, v)Tj
/F11 1 Tf
1.4 0 TD
(\) = \()Tj
/F15 1 Tf
1.8 0 TD
(u'/w)Tj
/F11 1 Tf
1.7 0 TD
(', )Tj
/F15 1 Tf
0.9 0 TD
(v'/w)Tj
/F11 1 Tf
1.7 0 TD
('\).)Tj
/F15 1 Tf
-16.1 -2.1 TD
[(void )-28(gluPwlCurve)-21( \(GLUnurbsObj *)12(nobj)78(, GLint )-16(count)22(, GLfloat *)-38(array)22(,)]TJ
0 -1.1 TD
0.016 Tw
[(GLint stride)-22(, )16(GLenum )10(type)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Describes a piecewise linear trimming curve for the NURBS object )11(nobj)-22(. There are )-33(count)22( points on)]TJ
T*
[(the curve, and they're given by )37(array)-78(. The )50(type)-34( can be either GLU_MAP1_TRIM_2 \(the most)]TJ
T*
[(common\) or GLU_MAP1_TRIM_3 \(\()16(u, v, w)11(\))0( homogeneous parameter space\). The type affects)]TJ
T*
[(whether )-28(stride)-22(, the number of floating-point values to the next vertex, is 2 or 3.)]TJ
/F11 1 Tf
-1.8 -2.2 TD
(You need to consider the orientation of trimming curves)Tj
/F33 1 Tf
22.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, whether they're counterclockwise or)Tj
-23.5 -1.7 TD
(clockwise)Tj
/F33 1 Tf
4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(to make sure you include the desired part of the surface. If you imagine walking along a)Tj
-5 -1.6 TD
(curve, everything to the left is included and everything to the right is trimmed away. For example, if your)Tj
0 -1.5 TD
(trim consists of a single counterclockwise loop, everything inside the loop is included. If the trim consists)Tj
T*
(of two nonintersecting counterclockwise loops with nonintersecting interiors, everything inside either of)Tj
T*
(them is included. If it consists of a counterclockwise loop with two clockwise loops inside it, the)Tj
T*
(trimming region has two holes in it. The outermost trimming curve must be counterclockwise. Often, you)Tj
T*
(run a trimming curve around the entire unit square to include everything within it, which is what you get)Tj
T*
(by default by not specifying any trimming curves.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 23)Tj
ET
endstream
endobj
1296 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1297 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im107
/Width 437
/Height 250
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.106)
>>
stream
endstream
endobj
1298 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im108
/Width 528
/Height 191
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.107)
>>
stream
endstream
endobj
1300 0 obj
<<
/Length 2042
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Trimming curves must be closed and nonintersecting. You can combine trimming curves, so long as the)Tj
0 -1.5 TD
(endpoints of the trimming curves meet to form a closed curve. You can nest curves, creating islands that)Tj
T*
(float in space. Be sure to get the curve orientations right. For example, an error results if you specify a)Tj
T*
(trimming region with two counterclockwise curves, one enclosed within another: The region between the)Tj
T*
(curves is to the left of one and to the right of the other, so it must be both included and excluded, which)Tj
T*
[(is impossible. )-48(Figure 12-5)]TJ
10.4 0 TD
( illustrates a few valid possibilities.)Tj
ET
Q
/GS1 gs
q
423 0 0 242 124 379.84 cm
/Im107 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 367.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 12-5 )Tj
/F11 1 Tf
5.6 0 TD
(Parametric Trimming Curves)Tj
-5.6 -2.1 TD
[(Figure 12-6)226( shows the same small hill as in )-9(Figure 12-4)226(, this time with a trimming curve that's a)]TJ
0 -1.5 TD
(combination of a piecewise linear curve and a NURBS curve. The program that creates this figure is)Tj
T*
(similar to that shown in Example 12-5)Tj
15.3 0 TD
[(; the differences are in the routines shown in )-74(Example 12-6)]TJ
23.7 0 TD
(.)Tj
ET
Q
q
423 0 0 153 124 148.85 cm
/Im108 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 136.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 12-6 )Tj
/F11 1 Tf
5.6 0 TD
(Trimmed NURBS Surface)Tj
/F27 1 Tf
-5.6 -2.1 TD
(Example 12-6 )Tj
/F11 1 Tf
6.7 0 TD
(Trimming a NURBS Surface: trim.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 12,  Evaluators and NURBS - 24)Tj
ET
endstream
endobj
1301 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im107 1297 0 R
/Im108 1298 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1304 0 obj
<<
/Length 2497
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};)Tj
0 -1.5 TD
(   GLfloat edgePt[5][2] = /* counter clockwise */)Tj
T*
(      {{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}, {0.0, 1.0}, )Tj
T*
(       {0.0, 0.0}};)Tj
T*
(   GLfloat curvePt[4][2] = /* clockwise */ )Tj
T*
(      {{0.25, 0.5}, {0.25, 0.75}, {0.75, 0.75}, {0.75, 0.5}};)Tj
T*
(   GLfloat curveKnots[8] = )Tj
T*
(      {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};)Tj
T*
(   GLfloat pwlPt[4][2] = /* clockwise */ )Tj
T*
(      {{0.75, 0.5}, {0.5, 0.25}, {0.25, 0.5}};)Tj
0 -3 TD
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
0 -1.5 TD
(   glPushMatrix\(\);)Tj
T*
(   glRotatef\(330.0, 1.,0.,0.\);)Tj
T*
(   glScalef \(0.5, 0.5, 0.5\);)Tj
0 -3 TD
(   gluBeginSurface\(theNurb\);)Tj
0 -1.5 TD
(   gluNurbsSurface\(theNurb, 8, knots, 8, knots,)Tj
T*
(                   4 * 3, 3, &ctlpoints[0][0][0], )Tj
T*
(                   4, 4, GL_MAP2_VERTEX_3\);)Tj
T*
(   gluBeginTrim \(theNurb\);)Tj
T*
(      gluPwlCurve \(theNurb, 5, &edgePt[0][0], 2,)Tj
T*
(                   GLU_MAP1_TRIM_2\);)Tj
T*
(   gluEndTrim \(theNurb\);)Tj
T*
(   gluBeginTrim \(theNurb\);)Tj
T*
(      gluNurbsCurve \(theNurb, 8, curveKnots, 2, )Tj
T*
(                     &curvePt[0][0], 4, GLU_MAP1_TRIM_2\);)Tj
T*
(      gluPwlCurve \(theNurb, 3, &pwlPt[0][0], 2,)Tj
T*
(                   GLU_MAP1_TRIM_2\);)Tj
T*
(   gluEndTrim \(theNurb\);)Tj
T*
(   gluEndSurface\(theNurb\);)Tj
T*
(        )Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
0.017 Tw
[(In Example )17(12-6)]TJ
6.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(gluBeginTrim\(\))Tj
/F11 1 Tf
6.2 0 TD
0.000 Tw
( and )Tj
/F15 1 Tf
2 0 TD
(gluEndTrim\(\))Tj
/F11 1 Tf
5.5 0 TD
( bracket each trimming curve. The first trim, with)Tj
-20.9 -1.5 TD
(vertices defined by the array )Tj
/F15 1 Tf
11.6 0 TD
(edgePt[][])Tj
/F11 1 Tf
4.4 0 TD
(, goes counterclockwise around the entire unit square of)Tj
-16 -1.5 TD
(parametric space. This ensures that everything is drawn, provided it isn't removed by a clockwise)Tj
T*
(trimming curve inside of it. The second trim is a combination of a NURBS trimming curve and a)Tj
T*
(piecewise linear trimming curve. The NURBS curve ends at the points \(0.9, 0.5\) and \(0.1, 0.5\), where it)Tj
T*
(is met by the piecewise linear curve, forming a closed clockwise curve.)Tj
ET
Q
endstream
endobj
1305 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1307 0 obj
<<
/Length 267
>>
stream
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 718.340 m
547.000 718.340 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 26)Tj
ET
endstream
endobj
1308 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1310 0 obj
<<
/Length 4057
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 13)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Selection and Feedback)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(After reading this chapter, you'll be able to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Create applications that allow the user to select a region of the screen or pick an object drawn on the)Tj
0 -1.6 TD
(screen)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use the OpenGL feedback mode to obtain the results of rendering calculations)Tj
-1.9 -2.7 TD
(Some graphics applications simply draw static images of two- and three-dimensional objects. Other)Tj
0 -1.5 TD
(applications allow the user to identify objects on the screen and then to move, modify, delete, or)Tj
T*
(otherwise manipulate those objects. OpenGL is designed to support exactly such interactive applications.)Tj
T*
(Since objects drawn on the screen typically undergo multiple rotations, translations, and perspective)Tj
T*
(transformations, it can be difficult for you to determine which object a user is selecting in a)Tj
T*
(three-dimensional scene. To help you, OpenGL provides a selection mechanism that automatically tells)Tj
T*
(you which objects are drawn inside a specified region of the window. You can use this mechanism)Tj
T*
(together with a special utility routine to determine which object within the region the user is specifying,)Tj
T*
(or )Tj
/F15 1 Tf
1.1 0 TD
(picking)Tj
/F11 1 Tf
2.9 0 TD
(, with the cursor.)Tj
-4 -2.1 TD
(Selection is actually a mode of operation for OpenGL; feedback is another such mode. In feedback mode,)Tj
0 -1.5 TD
(you use your graphics hardware and OpenGL to perform the usual rendering calculations. Instead of)Tj
T*
(using the calculated results to draw an image on the screen, however, OpenGL returns \(or feeds back\) the)Tj
T*
(drawing information to you. For example, if you want to draw three-dimensional objects on a plotter)Tj
T*
(rather than the screen, you would draw the items in feedback mode, collect the drawing instructions, and)Tj
T*
(then convert them to commands the plotter can understand.)Tj
0 -2.1 TD
(In both selection and feedback modes, drawing information is returned to the application rather than)Tj
0 -1.7 TD
(being sent to the framebuffer, as it is in rendering mode. Thus, the screen remains frozen)Tj
/F33 1 Tf
35.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(no drawing)Tj
-36.5 -1.6 TD
(occurs)Tj
/F33 1 Tf
2.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(while OpenGL is in selection or feedback mode. In these modes, the contents of the color,)Tj
-3.6 -1.6 TD
(depth, stencil, and accumulation buffers are not affected. This chapter explains each of these modes in its)Tj
0 -1.5 TD
(own section:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Selection")39( discusses how to use selection mode and related routines to allow a user of your)]TJ
0 -1.6 TD
(application to pick an object drawn on the screen.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Feedback")49( describes how to obtain information about what would be drawn on the screen and how)]TJ
0 -1.6 TD
(that information is formatted.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 147.000 Tm
(Selection)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 125.000 Tm
(Typically, when you're planning to use OpenGL's selection mechanism, you first draw your scene into)Tj
0 -1.5 TD
(the framebuffer, and then you enter selection mode and redraw the scene. However, once you're in)Tj
T*
(selection mode, the contents of the framebuffer don't change until you exit selection mode. When you)Tj
T*
(exit selection mode, OpenGL returns a list of the primitives that intersect the viewing volume \(remember)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 1)Tj
ET
endstream
endobj
1311 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1313 0 obj
<<
/Length 4821
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(that the viewing volume is defined by the current modelview and projection matrices and any additional)Tj
0 -1.5 TD
[(clipping planes, as explained in )34(Chapter 3)16(.\) Each primitive that intersects the viewing volume causes a)]TJ
T*
(selection )Tj
/F15 1 Tf
3.8 0 TD
(hit)Tj
/F11 1 Tf
1.1 0 TD
(. The list of primitives is actually returned as an array of integer-valued )Tj
/F15 1 Tf
28.7 0 TD
(names)Tj
/F11 1 Tf
2.6 0 TD
( and related)Tj
-36.2 -1.6 TD
(data)Tj
/F33 1 Tf
1.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the )Tj
/F15 1 Tf
1.4 0 TD
(hit records)Tj
/F33 1 Tf
4.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that correspond to the current contents of the )Tj
/F15 1 Tf
18.2 0 TD
(name stack)Tj
/F11 1 Tf
4.4 0 TD
(. You construct the name)Tj
-32.1 -1.6 TD
(stack by loading names onto it as you issue primitive drawing commands while in selection mode. Thus,)Tj
0 -1.5 TD
(when the list of names is returned, you can use it to determine which primitives might have been selected)Tj
T*
(on the screen by the user.)Tj
0 -2.1 TD
(In addition to this selection mechanism, OpenGL provides a utility routine designed to simplify selection)Tj
0 -1.5 TD
(in some cases by restricting drawing to a small region of the viewport. Typically, you use this routine to)Tj
T*
(determine which objects are drawn near the cursor, so that you can identify which object the user is)Tj
T*
(picking. \(You can also delimit a selection region by specifying additional clipping planes. Remember)Tj
T*
(that these planes act in world space, not in screen space.\) Since picking is a special case of selection,)Tj
T*
(selection is described first in this chapter, and then picking.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 494.000 Tm
(The Basic Steps)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 473.000 Tm
(To use the selection mechanism, you need to perform the following steps.)Tj
0 -2.1 TD
[(1.)-1050(Specify the array to be used for the returned hit records with )]TJ
/F15 1 Tf
26.2 0 TD
(glSelectBuffer\(\))Tj
/F11 1 Tf
6.3 0 TD
(.)Tj
-32.5 -2.1 TD
[(2.)-1050(Enter selection mode by specifying GL_SELECT with )]TJ
/F15 1 Tf
23.9 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
(.)Tj
-30.5 -2.1 TD
[(3.)-1050(Initialize the name stack using )]TJ
/F15 1 Tf
14.2 0 TD
(glInitNames\(\))Tj
/F11 1 Tf
5.6 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glPushName\(\))Tj
/F11 1 Tf
5.8 0 TD
(.)Tj
-27.5 -2.1 TD
[(4.)-1050(Define the viewing volume you want to use for selection. Usually this is different from the viewing)]TJ
1.8 -1.5 TD
(volume you originally used to draw the scene, so you probably want to save and then restore the)Tj
T*
(current transformation state with )Tj
/F15 1 Tf
13.3 0 TD
(glPushMatrix\(\))Tj
/F11 1 Tf
6.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glPopMatrix\(\))Tj
/F11 1 Tf
5.8 0 TD
(.)Tj
-29 -2.1 TD
[(5.)-1050(Alternately issue primitive drawing commands and commands to manipulate the name stack so that)]TJ
1.8 -1.5 TD
(each primitive of interest has an appropriate name assigned.)Tj
-1.8 -2.1 TD
[(6.)-1050(Exit selection mode and process the returned selection data \(the hit records\).)]TJ
0 -2.6 TD
(The following paragraphs describe )Tj
/F15 1 Tf
14.2 0 TD
(glSelectBuffer\(\))Tj
/F11 1 Tf
6.3 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
(. In the next section, the)Tj
-29 -1.5 TD
(commands to manipulate the name stack are described.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glSelectBuffer)67(\(GLsizei )-61(size, GLuint *)-16(buffer)-11(\);)]TJ
1.8 -1.5 TD
[(Specifies the array to be used for the returned selection data. The )-27(buffer)-11( argument is a pointer to an)]TJ
T*
[(array of unsigned integers into which the data is put, and )26(size indicates the maximum number of)]TJ
T*
[(values that can be stored in the array. You need to call glSelectBuffer\(\))33( before entering selection)]TJ
T*
(mode.)Tj
-1.8 -2.1 TD
0.016 Tw
[(GLint glRenderMode)44(\(GLenum )-57(mode)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Controls whether the application is in rendering, selection, or feedback mode. The )8(mode)-34( argument)]TJ
T*
(can be one of GL_RENDER \(the default\), GL_SELECT, or GL_FEEDBACK. The application)Tj
T*
[(remains in a given mode until )-33(glRenderMode\(\))10( is called again with a different argument. Before)]TJ
T*
[(entering selection mode, )-45(glSelectBuffer\(\))33( must be called to specify the selection array. Similarly,)]TJ
T*
[(before entering feedback mode, )-40(glFeedbackBuffer\(\))32( must be called to specify the feedback array.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 2)Tj
ET
endstream
endobj
1314 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1316 0 obj
<<
/Length 3388
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(The return value for )34(glRenderMode\(\))10( has meaning if the current render mode \(that is, not the mode)]TJ
0 -1.5 TD
(parameter\) is either GL_SELECT or GL_FEEDBACK. The return value is the number of selection)Tj
T*
(hits or the number of values placed in the feedback array when either mode is exited; a negative)Tj
T*
(value means that the selection or feedback array has overflowed. You can use GL_RENDER_MODE)Tj
T*
[(with )-27(glGetIntegerv\(\))21( to obtain the current mode.)]TJ
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 622.000 Tm
(Creating the Name Stack)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 601.000 Tm
(As mentioned in the previous section, the name stack forms the basis for the selection information that's)Tj
T*
(returned to you. To create the name stack, first initialize it with )Tj
/F15 1 Tf
25.5 0 TD
(glInitNames\(\))Tj
/F11 1 Tf
5.6 0 TD
(, which simply clears the)Tj
-31.1 -1.5 TD
(stack, and then add integer names to it while issuing corresponding drawing commands. As you might)Tj
T*
(expect, the commands to manipulate the stack allow you to push a name onto it \()Tj
/F15 1 Tf
32.3 0 TD
(glPushName\(\))Tj
/F11 1 Tf
5.8 0 TD
(\), pop a)Tj
-38.1 -1.5 TD
(name off of it \()Tj
/F15 1 Tf
6.1 0 TD
(glPopName\(\))Tj
/F11 1 Tf
5.3 0 TD
(\), and replace the name on the top of the stack with a different one)Tj
-11.4 -1.5 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(glLoadName\(\))Tj
/F11 1 Tf
5.9 0 TD
-0.033 Tw
[(\). Example )-33(13-1)]TJ
6.4 0 TD
0.000 Tw
( shows what your name-stack manipulation code might look like with)Tj
-12.6 -1.5 TD
(these commands.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 13-1 )Tj
/F11 1 Tf
6.7 0 TD
(Creating a Name Stack)Tj
/F7 1 Tf
-6.7 -2.4 TD
(glInitNames\(\);)Tj
0 -1.5 TD
(glPushName\(0\);)Tj
0 -3 TD
(glPushMatrix\(\);   /* save the current transformation state */)Tj
T*
(    /* create your desired viewing volume here */)Tj
T*
(    glLoadName\(1\);)Tj
0 -1.5 TD
(    drawSomeObject\(\);)Tj
T*
(    glLoadName\(2\);)Tj
T*
(    drawAnotherObject\(\);)Tj
T*
(    glLoadName\(3\);)Tj
T*
(    drawYetAnotherObject\(\);)Tj
T*
(    drawJustOneMoreObject\(\);)Tj
0 -3 TD
(glPopMatrix \(\);   /* restore the previous transformation state*/)Tj
/F11 1 Tf
0 -2.1 TD
(In this example, the first two objects to be drawn have their own names, and the third and fourth objects)Tj
0 -1.5 TD
(share a single name. With this setup, if either or both of the third and fourth objects causes a selection hit,)Tj
T*
(only one hit record is returned to you. You can have multiple objects share the same name if you don't)Tj
T*
(need to differentiate between them when processing the hit records.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glInitNames)-10(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Clears the name stack so that it's empty.)Tj
-1.8 -2.1 TD
0.028 Tw
[(void glPushName)12(\(GLuint )45(name)-34(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Pushes )-17(name)66( onto the name stack. Pushing a name beyond the capacity of the stack generates the)]TJ
T*
(error GL_STACK_OVERFLOW. The name stack's depth can vary among different OpenGL)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 3)Tj
ET
endstream
endobj
1317 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1319 0 obj
<<
/Length 4838
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(implementations, but it must be able to contain at least sixty-four names. You can use the parameter)Tj
0 -1.5 TD
[(GL_NAME_STACK_DEPTH with )48(glGetIntegerv\(\))-79( to obtain the depth of the name stack.)]TJ
-1.8 -2.1 TD
0.028 Tw
[(void glPopName)23(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Pops one name off the top of the name stack. Popping an empty stack generates the error)Tj
T*
(GL_STACK_UNDERFLOW.)Tj
-1.8 -2.1 TD
0.028 Tw
[(void glLoadName)68(\(GLuint )-55(name)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Replaces the value on the top of the name stack with name)-34(. If the stack is empty, which it is right)]TJ
T*
[(after )39(glInitNames\(\))-44( is called, )11(glLoadName\(\))34( generates the error GL_INVALID_OPERATION. To)]TJ
T*
[(avoid this, if the stack is initially empty, call )19(glPushName\(\))-22( at least once to put something on the)]TJ
T*
[(name stack before calling )-45(glLoadName\(\))34(.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
(Calls to )Tj
/F15 1 Tf
3.3 0 TD
(glPushName\(\))Tj
/F11 1 Tf
5.8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glPopName\(\))Tj
/F11 1 Tf
5.4 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glLoadName\(\))Tj
/F11 1 Tf
5.8 0 TD
( are ignored if you're not in selection mode.)Tj
-23 -1.5 TD
(You might find that it simplifies your code to use these calls throughout your drawing code, and then use)Tj
T*
(the same drawing code for both selection and normal rendering modes.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 484.000 Tm
(The Hit Record)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 463.000 Tm
(In selection mode, a primitive that intersects the viewing volume causes a selection hit. Whenever a)Tj
T*
(name-stack manipulation command is executed or )Tj
/F15 1 Tf
20.3 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
( is called, OpenGL writes a hit record)Tj
-26.9 -1.5 TD
(into the selection array if there's been a hit since the last time the stack was manipulated or)Tj
/F15 1 Tf
0 -1.6 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
( was called. With this process, objects that share the same name)Tj
/F33 1 Tf
25.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, an object)Tj
-33.1 -1.7 TD
(that's composed of more than one primitive)Tj
/F33 1 Tf
17.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(don't generate multiple hit records. Also, hit records aren't)Tj
-18.5 -1.6 TD
(guaranteed to be written into the array until )Tj
/F15 1 Tf
17.6 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
( is called.)Tj
/F27 1 Tf
-24.2 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(In addition to primitives, valid coordinates produced by )Tj
/F15 1 Tf
22.6 0 TD
(glRasterPos\(\) )Tj
/F11 1 Tf
5.8 0 TD
(can cause a selection hit.)Tj
-31.2 -1.4 TD
(Also, in the case of polygons, no hit occurs if the polygon would have been culled.)Tj
0 -2.1 TD
(Each hit record consists of four items, in order.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The number of names on the name stack when the hit occurred.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Both the minimum and maximum window-coordinate )Tj
/F15 1 Tf
21.8 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( values of all vertices of the primitives that)Tj
-22.2 -1.6 TD
(intersected the viewing volume since the last recorded hit. These two values, which lie in the range)Tj
0 -1.8 TD
([0,1], are each multiplied by 2)Tj
12.1 0.3 TD
(32)Tj
1 -0.3 TD
(-1 and rounded to the nearest unsigned integer.)Tj
/F33 1 Tf
-14.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(The contents of the name stack at the time of the hit, with the bottommost element first.)Tj
-1.9 -2.8 TD
(When you enter selection mode, OpenGL initializes a pointer to the beginning of the selection array.)Tj
0 -1.5 TD
(Each time a hit record is written into the array, the pointer is updated accordingly. If writing a hit record)Tj
T*
(would cause the number of values in the array to exceed the )Tj
/F15 1 Tf
24.2 0 TD
(size)Tj
/F11 1 Tf
1.5 0 TD
( argument specified with)Tj
/F15 1 Tf
-25.7 -1.5 TD
(glSelectBuffer\(\))Tj
/F11 1 Tf
6.3 0 TD
(, OpenGL writes as much of the record as fits in the array and sets an overflow flag.)Tj
-6.3 -1.5 TD
(When you exit selection mode with )Tj
/F15 1 Tf
14.4 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.7 0 TD
(, this command returns the number of hit records)Tj
-21.1 -1.5 TD
(that were written \(including a partial record if there was one\), clears the name stack, resets the overflow)Tj
T*
(flag, and resets the stack pointer. If the overflow flag had been set, the return value is -1.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 81.000 Tm
(A Selection Example)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 4)Tj
ET
endstream
endobj
1320 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1322 0 obj
<<
/Length 2419
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.017 Tw
[(In Example )17(13-2)]TJ
6.7 0 TD
0.000 Tw
(, four triangles \(green, red, and two yellow triangles, created by calling )Tj
/F15 1 Tf
28.7 0 TD
(drawTriangle\(\))Tj
/F11 1 Tf
6.1 0 TD
(\))Tj
-41.5 -1.5 TD
(and a wireframe box representing the viewing volume \()Tj
/F15 1 Tf
22.2 0 TD
(drawViewVolume\(\))Tj
/F11 1 Tf
7.8 0 TD
(\) are drawn to the screen.)Tj
-30 -1.5 TD
(Then the triangles are rendered again \()Tj
/F15 1 Tf
15.4 0 TD
(selectObjects\(\)\))Tj
/F11 1 Tf
6.4 0 TD
(, but this time in selection mode. The)Tj
-21.8 -1.5 TD
(corresponding hit records are processed in )Tj
/F15 1 Tf
17.2 0 TD
(processHits\(\))Tj
/F11 1 Tf
5.4 0 TD
(, and the selection array is printed out. The first)Tj
-22.6 -1.5 TD
(triangle generates a hit, the second one doesn't, and the third and fourth ones together generate a single)Tj
T*
(hit.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 13-2 )Tj
/F11 1 Tf
6.7 0 TD
(Selection Example: select.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(void drawTriangle \(GLfloat x1, GLfloat y1, GLfloat x2, )Tj
0 -1.5 TD
(    GLfloat y2, GLfloat x3, GLfloat y3, GLfloat z\))Tj
T*
({)Tj
T*
(   glBegin \(GL_TRIANGLES\);)Tj
T*
(   glVertex3f \(x1, y1, z\);)Tj
T*
(   glVertex3f \(x2, y2, z\);)Tj
T*
(   glVertex3f \(x3, y3, z\);)Tj
T*
(   glEnd \(\);)Tj
T*
(})Tj
0 -3 TD
(void drawViewVolume \(GLfloat x1, GLfloat x2, GLfloat y1, )Tj
0 -1.5 TD
(                     GLfloat y2, GLfloat z1, GLfloat z2\))Tj
T*
({)Tj
T*
(   glColor3f \(1.0, 1.0, 1.0\);)Tj
T*
(   glBegin \(GL_LINE_LOOP\);)Tj
T*
(   glVertex3f \(x1, y1, -z1\);)Tj
T*
(   glVertex3f \(x2, y1, -z1\);)Tj
T*
(   glVertex3f \(x2, y2, -z1\);)Tj
T*
(   glVertex3f \(x1, y2, -z1\);)Tj
T*
(   glEnd \(\);)Tj
0 -3 TD
(   glBegin \(GL_LINE_LOOP\);)Tj
0 -1.5 TD
(   glVertex3f \(x1, y1, -z2\);)Tj
T*
(   glVertex3f \(x2, y1, -z2\);)Tj
T*
(   glVertex3f \(x2, y2, -z2\);)Tj
T*
(   glVertex3f \(x1, y2, -z2\);)Tj
T*
(   glEnd \(\);)Tj
0 -3 TD
(   glBegin \(GL_LINES\);  /*  4 lines     */)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 5)Tj
ET
endstream
endobj
1323 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1325 0 obj
<<
/Length 2113
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glVertex3f \(x1, y1, -z1\);)Tj
0 -1.5 TD
(   glVertex3f \(x1, y1, -z2\);)Tj
T*
(   glVertex3f \(x1, y2, -z1\);)Tj
T*
(   glVertex3f \(x1, y2, -z2\);)Tj
T*
(   glVertex3f \(x2, y1, -z1\);)Tj
T*
(   glVertex3f \(x2, y1, -z2\);)Tj
T*
(   glVertex3f \(x2, y2, -z1\);)Tj
T*
(   glVertex3f \(x2, y2, -z2\);)Tj
T*
(   glEnd \(\);)Tj
T*
(})Tj
0 -3 TD
(void drawScene \(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   gluPerspective \(40.0, 4.0/3.0, 1.0, 100.0\);)Tj
0 -3 TD
(   glMatrixMode \(GL_MODELVIEW\);)Tj
0 -1.5 TD
(   glLoadIdentity \(\);)Tj
T*
(   gluLookAt \(7.5, 7.5, 12.5, 2.5, 2.5, -5.0, 0.0, 1.0, 0.0\);)Tj
T*
(   glColor3f \(0.0, 1.0, 0.0\);   /*  green triangle      */)Tj
T*
(   drawTriangle \(2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -5.0\);)Tj
T*
(   glColor3f \(1.0, 0.0, 0.0\);   /*  red triangle        */)Tj
T*
(   drawTriangle \(2.0, 7.0, 3.0, 7.0, 2.5, 8.0, -5.0\);)Tj
T*
(   glColor3f \(1.0, 1.0, 0.0\);   /*  yellow triangles    */)Tj
T*
(   drawTriangle \(2.0, 2.0, 3.0, 2.0, 2.5, 3.0, 0.0\);)Tj
T*
(   drawTriangle \(2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -10.0\);)Tj
T*
(   drawViewVolume \(0.0, 5.0, 0.0, 5.0, 0.0, 10.0\);)Tj
T*
(})Tj
0 -3 TD
(void processHits \(GLint hits, GLuint buffer[]\))Tj
0 -1.5 TD
({)Tj
T*
(   unsigned int i, j;)Tj
T*
(   GLuint names, *ptr;)Tj
0 -3 TD
(   printf \("hits = %d\\n", hits\);)Tj
0 -1.5 TD
(   ptr = \(GLuint *\) buffer;)Tj
T*
(   for \(i = 0; i < hits; i++\) { /*  for each hit  */)Tj
T*
(      names = *ptr;)Tj
T*
(      printf \(" number of names for hit = %d\\n", names\); ptr++;)Tj
T*
(      printf\("  z1 is %g;", \(float\) *ptr/0x7fffffff\); ptr++;)Tj
T*
(      printf\(" z2 is %g\\n", \(float\) *ptr/0x7fffffff\); ptr++;)Tj
T*
(      printf \("   the name is "\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 6)Tj
ET
endstream
endobj
1326 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1328 0 obj
<<
/Length 1656
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      for \(j = 0; j < names; j++\) {     /*  for each name */)Tj
0 -1.5 TD
(         printf \("%d ", *ptr\); ptr++;)Tj
T*
(      })Tj
T*
(      printf \("\\n"\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(#define BUFSIZE 512)Tj
T*
(void selectObjects\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLuint selectBuf[BUFSIZE];)Tj
T*
(   GLint hits;)Tj
0 -3 TD
(   glSelectBuffer \(BUFSIZE, selectBuf\);)Tj
0 -1.5 TD
(   \(void\) glRenderMode \(GL_SELECT\);)Tj
0 -3 TD
(   glInitNames\(\);)Tj
0 -1.5 TD
(   glPushName\(0\);)Tj
0 -3 TD
(   glPushMatrix \(\);)Tj
0 -1.5 TD
(   glMatrixMode \(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   glOrtho \(0.0, 5.0, 0.0, 5.0, 0.0, 10.0\);)Tj
T*
(   glMatrixMode \(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(   glLoadName\(1\);)Tj
T*
(   drawTriangle \(2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -5.0\);)Tj
T*
(   glLoadName\(2\);)Tj
T*
(   drawTriangle \(2.0, 7.0, 3.0, 7.0, 2.5, 8.0, -5.0\);)Tj
T*
(   glLoadName\(3\);)Tj
T*
(   drawTriangle \(2.0, 2.0, 3.0, 2.0, 2.5, 3.0, 0.0\);)Tj
T*
(   drawTriangle \(2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -10.0\);)Tj
T*
(   glPopMatrix \(\);)Tj
T*
(   glFlush \(\);)Tj
0 -3 TD
(   hits = glRenderMode \(GL_RENDER\);)Tj
0 -1.5 TD
(   processHits \(hits, selectBuf\);)Tj
T*
(} )Tj
0 -3 TD
(void init \(void\) )Tj
0 -1.5 TD
({)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 7)Tj
ET
endstream
endobj
1329 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1331 0 obj
<<
/Length 2861
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glShadeModel\(GL_FLAT\);)Tj
0 -1.5 TD
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   drawScene \(\);)Tj
T*
(   selectObjects \(\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
T*
(   glutInitWindowSize \(200, 200\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0; )Tj
T*
(})Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 338.000 Tm
(Picking)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 316.000 Tm
(As an extension of the process described in the previous section, you can use selection mode to)Tj
T*
(determine if objects are picked. To do this, you use a special picking matrix in conjunction with the)Tj
T*
(projection matrix to restrict drawing to a small region of the viewport, typically near the cursor. Then you)Tj
T*
(allow some form of input, such as clicking a mouse button, to initiate selection mode. With selection)Tj
T*
(mode established and with the special picking matrix used, objects that are drawn near the cursor cause)Tj
T*
(selection hits. Thus, during picking you're typically determining which objects are drawn near the cursor.)Tj
0 -2.1 TD
(Picking is set up almost exactly like regular selection mode is, with the following major differences.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Picking is usually triggered by an input device. In the following code examples, pressing the left)Tj
0 -1.6 TD
(mouse button invokes a function that performs picking.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(You use the utility routine )Tj
/F15 1 Tf
10.8 0 TD
(gluPickMatrix\(\))Tj
/F11 1 Tf
6.4 0 TD
( to multiply a special picking matrix onto the current)Tj
-17.2 -1.5 TD
(projection matrix. This routine should be called prior to multiplying a standard projection matrix)Tj
T*
(\(such as )Tj
/F15 1 Tf
3.5 0 TD
(gluPerspective\(\))Tj
/F11 1 Tf
6.6 0 TD
( or )Tj
/F15 1 Tf
1.3 0 TD
(glOrtho\(\))Tj
/F11 1 Tf
3.9 0 TD
(\). You'll probably want to save the contents of the projection)Tj
-15.3 -1.5 TD
(matrix first, so the sequence of operations may look like this:)Tj
/F7 1 Tf
0 -2.1 TD
(glMatrixMode \(GL_PROJECTION\);)Tj
0 -1.5 TD
(glPushMatrix \(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 8)Tj
ET
endstream
endobj
1332 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1335 0 obj
<<
/Length 4342
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 143.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(glLoadIdentity \(\);)Tj
0 -1.5 TD
(gluPickMatrix \(...\);)Tj
T*
(gluPerspective, glOrtho, gluOrtho2D, or glFrustum)Tj
T*
(   /* ... draw scene for picking ; perform picking ... */)Tj
T*
(glPopMatrix\(\);)Tj
/F11 1 Tf
-1.9 -2.7 TD
[(Another completely different way to perform picking is described in )9("Object Selection Using the Back)]TJ
0 -1.5 TD
[(Buffer" in Chapter 14)13(. This technique uses color values to identify different components of an object.)]TJ
/F15 1 Tf
0 -2.1 TD
[(void )-28(gluPickMatrix)78(\(GLdouble )-16(x)-56(,)0( GLdouble )51(y)-56(,)0( GLdouble )51(width)23(,)]TJ
0 -1.1 TD
0.050 Tw
[(GLdouble height, )50(GLint )134(viewport[4])-21(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Creates a projection matrix that restricts drawing to a small region of the viewport and multiplies)Tj
T*
[(that matrix onto the current matrix stack. The center of the picking region is \()-15(x, y)-12(\))0( in window)]TJ
T*
[(coordinates, typically the cursor location. )29(width)-77( and height define the size of the picking region in)]TJ
T*
(screen coordinates. \(You can think of the width and height as the sensitivity of the picking device.\))Tj
T*
[(viewport[])-22( indicates the current viewport boundaries, which can be obtained by calling)]TJ
/F7 1 Tf
-1.8 -2.1 TD
(glGetIntegerv\(GL_VIEWPORT, GLint *viewport\);)Tj
/F27 1 Tf
8 -2.2 TD
(Advanced)Tj
/F11 1 Tf
-8 -2.1 TD
(The net result of the matrix created by )Tj
/F15 1 Tf
15.6 0 TD
(gluPickMatrix\(\))Tj
/F11 1 Tf
6.4 0 TD
( is to transform)Tj
-22 -1.2 TD
(the clipping region into the unit cube -1 )Tj
/F33 1 Tf
16.1 0 TD
(\243)Tj
/F11 1 Tf
0.6 0 TD
( \()Tj
/F15 1 Tf
0.5 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(\) )Tj
/F33 1 Tf
0.6 0 TD
(\243)Tj
/F11 1 Tf
0.6 0 TD
( 1 \(or -)Tj
/F15 1 Tf
2.7 0 TD
(w)Tj
/F33 1 Tf
0.7 0 TD
(\243)Tj
/F11 1 Tf
0.5 0 TD
( \()Tj
/F15 1 Tf
0.6 0 TD
(wx)Tj
/F11 1 Tf
1.1 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(wy)Tj
/F11 1 Tf
1.1 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(wz)Tj
/F11 1 Tf
1.1 0 TD
(\) )Tj
/F33 1 Tf
0.6 0 TD
(\243)Tj
/F15 1 Tf
0.5 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(\). The picking matrix)Tj
-31.3 -1.2 TD
(effectively performs an orthogonal transformation that maps a subregion of this unit cube to the unit)Tj
0 -1.1 TD
(cube. Since the transformation is arbitrary, you can make picking work for different sorts)Tj
0 -1.3 TD
(of regions)Tj
/F33 1 Tf
4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, for rotated rectangular portions of the window. In certain situations, you might)Tj
-5 -1.2 TD
(find it easier to specify additional clipping planes to define the picking region.)Tj
0 -2.1 TD
(Example 13-3)Tj
5.6 0 TD
( illustrates simple picking. It also demonstrates how to use multiple names to identify)Tj
-5.6 -1.6 TD
(different components of a primitive, in this case the row and column of a selected object. A 3)Tj
/F33 1 Tf
37.3 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(3 grid of)Tj
-37.8 -1.6 TD
(squares is drawn, with each square a different color. The board[3][3] array maintains the current amount)Tj
0 -1.5 TD
(of blue for each square. When the left mouse button is pressed, the )Tj
/F15 1 Tf
26.9 0 TD
(pickSquares\(\))Tj
/F11 1 Tf
5.6 0 TD
( routine is called to)Tj
-32.5 -1.6 TD
(identify which squares were picked by the mouse. Two names identify each square in the grid)Tj
/F33 1 Tf
37.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(one)Tj
-38.5 -1.5 TD
(identifies the row, and the other the column. Also, when the left mouse   button is pressed, the color of all)Tj
T*
(squares under the cursor position changes.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 13-3 )Tj
/F11 1 Tf
6.7 0 TD
(Picking Example: picksquare.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
T*
(#include <GL/glut.h>)Tj
0 -3 TD
(int board[3][3];   /*  amount of color for each square  */)Tj
T*
(/*  Clear color value for every square on the board   */)Tj
0 -1.5 TD
(void init\(void\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 9)Tj
ET
endstream
endobj
1336 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1338 0 obj
<<
/Length 1828
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
({)Tj
0 -1.5 TD
(   int i, j;)Tj
T*
(   for \(i = 0; i < 3; i++\) )Tj
T*
(      for \(j = 0; j < 3; j ++\))Tj
T*
(         board[i][j] = 0;)Tj
T*
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(})Tj
0 -3 TD
(void drawSquares\(GLenum mode\))Tj
0 -1.5 TD
({)Tj
T*
(   GLuint i, j;)Tj
T*
(   for \(i = 0; i < 3; i++\) {)Tj
T*
(      if \(mode == GL_SELECT\))Tj
T*
(         glLoadName \(i\);)Tj
T*
(      for \(j = 0; j < 3; j ++\) {)Tj
T*
(         if \(mode == GL_SELECT\))Tj
T*
(            glPushName \(j\);)Tj
T*
(         glColor3f \(\(GLfloat\) i/3.0, \(GLfloat\) j/3.0, )Tj
T*
(                    \(GLfloat\) board[i][j]/3.0\);)Tj
T*
(         glRecti \(i, j, i+1, j+1\);)Tj
T*
(         if \(mode == GL_SELECT\))Tj
T*
(            glPopName \(\);)Tj
T*
(      })Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(/*  processHits prints out the contents of the )Tj
0 -1.5 TD
( *  selection array.)Tj
T*
( */)Tj
T*
(void processHits \(GLint hits, GLuint buffer[]\))Tj
T*
({)Tj
T*
(   unsigned int i, j;)Tj
T*
(   GLuint ii, jj, names, *ptr;)Tj
0 -3 TD
(   printf \("hits = %d\\n", hits\);)Tj
0 -1.5 TD
(   ptr = \(GLuint *\) buffer;)Tj
T*
(   for \(i = 0; i < hits; i++\) { /*  for each hit  */)Tj
T*
(      names = *ptr;)Tj
T*
(      printf \(" number of names for this hit = %d\\n", names\);)Tj
T*
(         ptr++;)Tj
T*
(      printf\("  z1 is %g;", \(float\) *ptr/0x7fffffff\); ptr++;)Tj
T*
(      printf\(" z2 is %g\\n", \(float\) *ptr/0x7fffffff\); ptr++;)Tj
T*
(      printf \("   names are "\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 10)Tj
ET
endstream
endobj
1339 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1341 0 obj
<<
/Length 1741
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      for \(j = 0; j < names; j++\) { /*  for each name */)Tj
0 -1.5 TD
(         printf \("%d ", *ptr\);)Tj
T*
(         if \(j == 0\)  /*  set row and column  */)Tj
T*
(            ii = *ptr;)Tj
T*
(         else if \(j == 1\))Tj
T*
(            jj = *ptr;)Tj
T*
(         ptr++;)Tj
T*
(      })Tj
T*
(      printf \("\\n"\);)Tj
T*
(      board[ii][jj] = \(board[ii][jj] + 1\) % 3;)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(#define BUFSIZE 512)Tj
T*
(void pickSquares\(int button, int state, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   GLuint selectBuf[BUFSIZE];)Tj
T*
(   GLint hits;)Tj
T*
(   GLint viewport[4];)Tj
0 -3 TD
(   if \(button != GLUT_LEFT_BUTTON || state != GLUT_DOWN\))Tj
0 -1.5 TD
(      return;)Tj
0 -3 TD
(   glGetIntegerv \(GL_VIEWPORT, viewport\);)Tj
T*
(   glSelectBuffer \(BUFSIZE, selectBuf\);)Tj
0 -1.5 TD
(   \(void\) glRenderMode \(GL_SELECT\);)Tj
0 -3 TD
(   glInitNames\(\);)Tj
0 -1.5 TD
(   glPushName\(0\);)Tj
0 -3 TD
(   glMatrixMode \(GL_PROJECTION\);)Tj
0 -1.5 TD
(   glPushMatrix \(\);)Tj
T*
(   glLoadIdentity \(\);)Tj
T*
(/*  create 5x5 pixel picking region near cursor location      */)Tj
T*
(   gluPickMatrix \(\(GLdouble\) x, \(GLdouble\) \(viewport[3] - y\), )Tj
T*
(                  5.0, 5.0, viewport\);)Tj
T*
(   gluOrtho2D \(0.0, 3.0, 0.0, 3.0\);)Tj
T*
(   drawSquares \(GL_SELECT\);)Tj
0 -3 TD
(   glMatrixMode \(GL_PROJECTION\);)Tj
0 -1.5 TD
(   glPopMatrix \(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 11)Tj
ET
endstream
endobj
1342 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1344 0 obj
<<
/Length 1869
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glFlush \(\);)Tj
0 -3 TD
(   hits = glRenderMode \(GL_RENDER\);)Tj
0 -1.5 TD
(   processHits \(hits, selectBuf\);)Tj
T*
(   glutPostRedisplay\(\);)Tj
T*
(} )Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   drawSquares \(GL_RENDER\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, w, h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   gluOrtho2D \(0.0, 3.0, 0.0, 3.0\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode \(GLUT_SINGLE | GLUT_RGB\);)Tj
T*
(   glutInitWindowSize \(100, 100\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow \(argv[0]\);)Tj
T*
(   init \(\);)Tj
T*
(   glutMouseFunc \(pickSquares\);)Tj
T*
(   glutReshapeFunc \(reshape\);)Tj
T*
(   glutDisplayFunc\(display\); )Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0; )Tj
T*
(})Tj
/F27 1 Tf
0 -3 TD
(Picking with Multiple Names and a Hierarchical Model)Tj
/F11 1 Tf
0 -2.1 TD
(Multiple names can also be used to choose parts of a hierarchical object in a scene. For example, if you)Tj
0 -1.5 TD
(were rendering an assembly line of automobiles, you might want the user to move the mouse to pick the)Tj
T*
(third bolt on the left front tire of the third car in line. A different name can be used to identify each level)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 12)Tj
ET
endstream
endobj
1345 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1347 0 obj
<<
/Length 2138
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(of hierarchy: which car, which tire, and finally which bolt. As another example, one name can be used to)Tj
0 -1.5 TD
(describe a single molecule among other molecules, and additional names can differentiate individual)Tj
T*
(atoms within that molecule.)Tj
0 -2.1 TD
(Example 13-4)Tj
5.6 0 TD
[( is a modification of )6(Example 3-4)170(, which draws an automobile with four identical wheels,)]TJ
-5.6 -1.5 TD
(each of which has five identical bolts. Code has been added to manipulate the name stack with the object)Tj
T*
(hierarchy.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 13-4 )Tj
/F11 1 Tf
6.7 0 TD
(Creating Multiple Names)Tj
/F7 1 Tf
-6.7 -2.4 TD
(draw_wheel_and_bolts\(\))Tj
0 -1.5 TD
({)Tj
T*
(    long i;)Tj
0 -3 TD
(    draw_wheel_body\(\);)Tj
0 -1.5 TD
(    for \(i = 0; i < 5; i++\) {)Tj
T*
(        glPushMatrix\(\);)Tj
T*
(            glRotate\(72.0*i, 0.0, 0.0, 1.0\);)Tj
T*
(            glTranslatef\(3.0, 0.0, 0.0\);)Tj
T*
(            glPushName\(i\);)Tj
T*
(                draw_bolt_body\(\);)Tj
T*
(            glPopName\(\);)Tj
T*
(        glPopMatrix\(\);)Tj
T*
(    })Tj
T*
( })Tj
0 -3 TD
(draw_body_and_wheel_and_bolts\(\))Tj
0 -1.5 TD
({)Tj
T*
(    draw_car_body\(\);)Tj
T*
(    glPushMatrix\(\);)Tj
T*
(        glTranslate\(40, 0, 20\);  /* first wheel position*/)Tj
T*
(        glPushName\(1\);           /* name of wheel number 1 */)Tj
T*
(            draw_wheel_and_bolts\(\);)Tj
T*
(        glPopName\(\);)Tj
T*
(    glPopMatrix\(\);)Tj
T*
(    glPushMatrix\(\);)Tj
T*
(        glTranslate\(40, 0, -20\); /* second wheel position */)Tj
T*
(        glPushName\(2\);           /* name of wheel number 2 */)Tj
T*
(            draw_wheel_and_bolts\(\);)Tj
T*
(        glPopName\(\);)Tj
T*
(    glPopMatrix\(\);)Tj
0 -3 TD
(    /* draw last two wheels similarly */)Tj
0 -1.5 TD
( })Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 13)Tj
ET
endstream
endobj
1348 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1350 0 obj
<<
/Length 2630
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Example 13-5)Tj
5.6 0 TD
[( uses the routines in Example 13-4)170( to draw three different cars, numbered 1, 2, and 3.)]TJ
/F27 1 Tf
-5.6 -2.1 TD
(Example 13-5 )Tj
/F11 1 Tf
6.7 0 TD
(Using Multiple Names)Tj
/F7 1 Tf
-6.7 -2.4 TD
(draw_three_cars\(\))Tj
0 -1.5 TD
({)Tj
T*
(    glInitNames\(\);)Tj
T*
(    glPushMatrix\(\);)Tj
T*
(        translate_to_first_car_position\(\);)Tj
T*
(        glPushName\(1\);)Tj
T*
(            draw_body_and_wheel_and_bolts\(\);)Tj
T*
(        glPopName\(\);)Tj
T*
(    glPopMatrix\(\);)Tj
0 -3 TD
(    glPushMatrix\(\);)Tj
0 -1.5 TD
(        translate_to_second_car_position\(\);)Tj
T*
(        glPushName\(2\);)Tj
T*
(            draw_body_and_wheel_and_bolts\(\);)Tj
T*
(        glPopName\(\);)Tj
T*
(    glPopMatrix\(\);)Tj
0 -3 TD
(    glPushMatrix\(\);)Tj
0 -1.5 TD
(        translate_to_third_car_position\(\);)Tj
T*
(        glPushName\(3\);)Tj
T*
(            draw_body_and_wheel_and_bolts\(\);)Tj
T*
(        glPopName\(\);)Tj
T*
(    glPopMatrix\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Assuming that picking is performed, the following are some possible name-stack return values and their)Tj
0 -1.5 TD
(interpretations. In these examples, at most one hit record is returned; also, )Tj
/F15 1 Tf
29.8 0 TD
(d1)Tj
/F11 1 Tf
1 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(d2)Tj
/F11 1 Tf
1 0 TD
( are depth values.)Tj
-33.7 -2.1 TD
(2 )Tj
/F15 1 Tf
0.8 0 TD
(d1d2)Tj
/F11 1 Tf
2 0 TD
( 2 1 Car 2, wheel 1)Tj
-2.8 -2.1 TD
(1 )Tj
/F15 1 Tf
0.8 0 TD
(d1d2)Tj
/F11 1 Tf
2 0 TD
( 3 Car 3 body)Tj
-2.8 -2.1 TD
(3 )Tj
/F15 1 Tf
0.8 0 TD
(d1d2)Tj
/F11 1 Tf
2 0 TD
( 1 1 0 Bolt 0 on wheel 1 on car 1)Tj
-2.8 -2.1 TD
(empty The pick was outside all cars)Tj
T*
(The last interpretation assumes that the bolt and wheel don't occupy the same picking region. A user)Tj
0 -1.5 TD
(might well pick both the wheel and the bolt, yielding two hits. If you receive multiple hits, you have to)Tj
T*
(decide which hit to process, perhaps by using the depth values to determine which picked object is)Tj
T*
(closest to the viewpoint. The use of depth values is explored further in the next section.)Tj
/F27 1 Tf
0 -3 TD
(Picking and Depth Values)Tj
/F11 1 Tf
0 -2.1 TD
(Example 13-6)Tj
5.6 0 TD
( demonstrates how to use depth values when picking to determine which object is picked.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 14)Tj
ET
endstream
endobj
1351 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1353 0 obj
<<
/Length 2509
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(This program draws three overlapping rectangles in normal rendering mode. When the left mouse button)Tj
0 -1.5 TD
(is pressed, the )Tj
/F15 1 Tf
5.9 0 TD
(pickRects\(\))Tj
/F11 1 Tf
4.5 0 TD
( routine is called. This routine returns the cursor position, enters selection)Tj
-10.4 -1.5 TD
(mode, initializes the name stack, and multiplies the picking matrix onto the stack before the orthographic)Tj
T*
(projection matrix. A selection hit occurs for each rectangle the cursor is over when the left mouse button)Tj
T*
(is clicked. Finally, the contents of the selection buffer are examined to identify which named objects)Tj
T*
(were within the picking region near the cursor.)Tj
0 -2.1 TD
(The rectangles in this program are drawn at different depth, or )Tj
/F15 1 Tf
25.2 0 TD
(z)Tj
/F11 1 Tf
0.3 0 TD
(, values. Since only one name is used to)Tj
-25.5 -1.5 TD
(identify all three rectangles, only one hit can be recorded. However, if more than one rectangle is picked,)Tj
T*
(that single hit has different minimum and maximum )Tj
/F15 1 Tf
21.1 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( values.)Tj
/F27 1 Tf
-21.5 -2.1 TD
(Example 13-6 )Tj
/F11 1 Tf
6.7 0 TD
(Picking with Depth Values: pickdepth.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClearColor\(0.0, 0.0, 0.0, 0.0\);)Tj
T*
(   glEnable\(GL_DEPTH_TEST\);)Tj
T*
(   glShadeModel\(GL_FLAT\);)Tj
T*
(   glDepthRange\(0.0, 1.0\);  /* The default z mapping */)Tj
T*
(})Tj
0 -3 TD
(void drawRects\(GLenum mode\))Tj
0 -1.5 TD
({)Tj
T*
(   if \(mode == GL_SELECT\))Tj
T*
(      glLoadName\(1\);)Tj
T*
(   glBegin\(GL_QUADS\);)Tj
T*
(   glColor3f\(1.0, 1.0, 0.0\);)Tj
T*
(   glVertex3i\(2, 0, 0\);)Tj
T*
(   glVertex3i\(2, 6, 0\);)Tj
T*
(   glVertex3i\(6, 6, 0\);)Tj
T*
(   glVertex3i\(6, 0, 0\);)Tj
T*
(   glEnd\(\);)Tj
T*
(   if \(mode == GL_SELECT\))Tj
T*
(      glLoadName\(2\);)Tj
T*
(   glBegin\(GL_QUADS\);)Tj
T*
(   glColor3f\(0.0, 1.0, 1.0\);)Tj
T*
(   glVertex3i\(3, 2, -1\);)Tj
T*
(   glVertex3i\(3, 8, -1\);)Tj
T*
(   glVertex3i\(8, 8, -1\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 15)Tj
ET
endstream
endobj
1354 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1356 0 obj
<<
/Length 1743
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glVertex3i\(8, 2, -1\);)Tj
0 -1.5 TD
(   glEnd\(\);)Tj
T*
(   if \(mode == GL_SELECT\))Tj
T*
(      glLoadName\(3\);)Tj
T*
(   glBegin\(GL_QUADS\);)Tj
T*
(   glColor3f\(1.0, 0.0, 1.0\);)Tj
T*
(   glVertex3i\(0, 2, -2\);)Tj
T*
(   glVertex3i\(0, 7, -2\);)Tj
T*
(   glVertex3i\(5, 7, -2\);)Tj
T*
(   glVertex3i\(5, 2, -2\);)Tj
T*
(   glEnd\(\);)Tj
T*
(})Tj
0 -3 TD
(void processHits\(GLint hits, GLuint buffer[]\))Tj
0 -1.5 TD
({)Tj
T*
(   unsigned int i, j;)Tj
T*
(   GLuint names, *ptr;)Tj
0 -3 TD
(   printf\("hits = %d\\n", hits\);)Tj
0 -1.5 TD
(   ptr = \(GLuint *\) buffer;)Tj
T*
(   for \(i = 0; i < hits; i++\) {  /* for each hit  */)Tj
T*
(      names = *ptr;)Tj
T*
(      printf\(" number of names for hit = %d\\n", names\); ptr++;)Tj
T*
(      printf\("  z1 is %g;", \(float\) *ptr/0x7fffffff\); ptr++;)Tj
T*
(      printf\(" z2 is %g\\n", \(float\) *ptr/0x7fffffff\); ptr++;)Tj
T*
(      printf\("   the name is "\);)Tj
T*
(      for \(j = 0; j < names; j++\) {  /* for each name */)Tj
T*
(         printf\("%d ", *ptr\); ptr++;)Tj
T*
(      })Tj
T*
(      printf\("\\n"\);)Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(#define BUFSIZE 512)Tj
T*
(void pickRects\(int button, int state, int x, int y\))Tj
0 -1.5 TD
({)Tj
T*
(   GLuint selectBuf[BUFSIZE];)Tj
T*
(   GLint hits;)Tj
T*
(   GLint viewport[4];)Tj
0 -3 TD
(   if \(button != GLUT_LEFT_BUTTON || state != GLUT_DOWN\))Tj
0 -1.5 TD
(      return;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 16)Tj
ET
endstream
endobj
1357 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1359 0 obj
<<
/Length 1691
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glGetIntegerv\(GL_VIEWPORT, viewport\);)Tj
0 -3 TD
(   glSelectBuffer\(BUFSIZE, selectBuf\);)Tj
0 -1.5 TD
(   \(void\) glRenderMode\(GL_SELECT\);)Tj
0 -3 TD
(   glInitNames\(\);)Tj
0 -1.5 TD
(   glPushName\(0\);)Tj
0 -3 TD
(   glMatrixMode\(GL_PROJECTION\);)Tj
0 -1.5 TD
(   glPushMatrix\(\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(/*  create 5x5 pixel picking region near cursor location */)Tj
T*
(   gluPickMatrix\(\(GLdouble\) x, \(GLdouble\) \(viewport[3] - y\),)Tj
T*
(                 5.0, 5.0, viewport\);)Tj
T*
(   glOrtho\(0.0, 8.0, 0.0, 8.0, -0.5, 2.5\);)Tj
T*
(   drawRects\(GL_SELECT\);)Tj
T*
(   glPopMatrix\(\);)Tj
T*
(   glFlush\(\);)Tj
0 -3 TD
(   hits = glRenderMode\(GL_RENDER\);)Tj
0 -1.5 TD
(   processHits\(hits, selectBuf\);)Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glClear\(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT\);)Tj
T*
(   drawRects\(GL_RENDER\);)Tj
T*
(   glFlush\(\);)Tj
T*
(})Tj
0 -3 TD
(void reshape\(int w, int h\))Tj
0 -1.5 TD
({)Tj
T*
(   glViewport\(0, 0, \(GLsizei\) w, \(GLsizei\) h\);)Tj
T*
(   glMatrixMode\(GL_PROJECTION\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(   glOrtho\(0.0, 8.0, 0.0, 8.0, -0.5, 2.5\);)Tj
T*
(   glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(   glLoadIdentity\(\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char **argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 17)Tj
ET
endstream
endobj
1360 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1362 0 obj
<<
/Length 4063
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH\);)Tj
0 -1.5 TD
(   glutInitWindowSize \(200, 200\);)Tj
T*
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutMouseFunc\(pickRects\);)Tj
T*
(   glutReshapeFunc\(reshape\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0; )Tj
T*
(})Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F33 1 Tf
-7.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
0.050 Tw
[(Modify Example )50(13-6)]TJ
8.9 0 TD
0.000 Tw
( to add additional calls to )Tj
/F15 1 Tf
10.3 0 TD
(glPushName\(\))Tj
/F11 1 Tf
5.8 0 TD
( so that multiple names are on the)Tj
-25 -1.6 TD
(stack when the selection hit occurs. What will the contents of the selection buffer be?)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(By default, )Tj
/F15 1 Tf
4.7 0 TD
(glDepthRange\(\))Tj
/F11 1 Tf
6.4 0 TD
( sets the mapping of the )Tj
/F15 1 Tf
9.8 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( values to [0.0,1.0]. Try modifying the)Tj
/F15 1 Tf
-21.3 -1.6 TD
(glDepthRange\(\))Tj
/F11 1 Tf
6.4 0 TD
( values and see how it affects the )Tj
/F15 1 Tf
13.5 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( values that are returned in the selection array.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 429.000 Tm
(Hints for Writing a Program That Uses Selection)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 408.000 Tm
(Most programs that allow a user to interactively edit some geometry provide a mechanism for the user to)Tj
0 -1.5 TD
(pick items or groups of items for editing. For two-dimensional drawing programs \(for example, text)Tj
T*
(editors, page-layout programs, and circuit-design programs\), it might be easier to do your own picking)Tj
T*
(calculations instead of using the OpenGL picking mechanism. Often, it's easy to find bounding boxes for)Tj
T*
(two-dimensional objects and to organize them in some hierarchical data structure to speed up searches.)Tj
T*
(For example, picking that uses the OpenGL style in a VLSI layout program containing millions of)Tj
T*
(rectangles can be relatively slow. However, using simple bounding-box information when rectangles are)Tj
T*
(typically aligned with the screen could make picking in such a program extremely fast. The code is)Tj
T*
(probably simpler to write, too.)Tj
0 -2.1 TD
(As another example, since only geometric objects cause hits, you might want to create your own method)Tj
0 -1.5 TD
(for picking text. Setting the current raster position is a geometric operation, but it effectively creates only)Tj
T*
(a single pickable point at the current raster position, which is typically at the lower-left corner of the text.)Tj
T*
(If your editor needs to manipulate individual characters within a text string, some other picking)Tj
T*
(mechanism must be used. You could draw little rectangles around each character during picking mode,)Tj
T*
(but it's almost certainly easier to handle text as a special case.)Tj
0 -2.1 TD
(If you decide to use OpenGL picking, organize your program and its data structures so that it's easy to)Tj
0 -1.5 TD
(draw appropriate lists of objects in either selection or normal drawing mode. This way, when the user)Tj
T*
(picks something, you can use the same data structures for the pick operation that you use to display the)Tj
T*
(items on the screen. Also, consider whether you want to allow the user to select multiple objects. One)Tj
T*
(way to do this is to store a bit for each item indicating whether it's selected \(however, this method)Tj
T*
(requires traversing your entire list of items to find the selected items\). You might find it useful to)Tj
T*
(maintain a list of pointers to selected items to speed up this search. It's probably a good idea to keep the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 18)Tj
ET
endstream
endobj
1363 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1366 0 obj
<<
/Length 4193
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(selection bit for each item as well, since when you're drawing the entire picture, you might want to draw)Tj
0 -1.5 TD
(selected items differently \(for example, in a different color or with a selection box around them\). Finally,)Tj
T*
(consider the selection user interface. You might want to allow the user to do the following:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Select an item)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Sweep-select a group of items \(see the next paragraphs for a description of this behavior\))Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Add an item to the selection)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Add a sweep selection to the current selections)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Delete an item from a selection)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Choose a single item from a group of overlapping items)Tj
-1.9 -2.8 TD
(A typical solution for a two-dimensional drawing program might work as follows.)Tj
0 -2.1 TD
[(1.)-1050(All selection is done by pointing with the mouse cursor and using the left mouse button. In what)]TJ
1.8 -1.5 TD
(follows, )Tj
/F15 1 Tf
3.5 0 TD
(cursor)Tj
/F11 1 Tf
2.6 0 TD
( means the cursor tied to the mouse, and )Tj
/F15 1 Tf
16.3 0 TD
(button)Tj
/F11 1 Tf
2.6 0 TD
( means the left mouse button.)Tj
-26.8 -2.1 TD
[(2.)-1050(Clicking on an item selects it and deselects all other currently selected items. If the cursor is on top)]TJ
1.8 -1.5 TD
(of multiple items, the smallest is selected. \(In three dimensions, many other strategies work to)Tj
T*
(disambiguate a selection.\))Tj
-1.8 -2.1 TD
[(3.)-1050(Clicking down where there is no item, holding the button down while dragging the cursor, and then)]TJ
1.8 -1.5 TD
(releasing the button selects all the items in a screen-aligned rectangle whose corners are determined)Tj
T*
(by the cursor positions when the button went down and where it came up. This is called a )Tj
/F15 1 Tf
36 0 TD
(sweep)Tj
-36 -1.5 TD
(selection)Tj
/F11 1 Tf
3.6 0 TD
(. All items not in the swept-out region are deselected. \(You must decide whether an item is)Tj
-3.6 -1.5 TD
(selected only if it's completely within the sweep region, or if any part of it falls within the region.)Tj
T*
(The completely within strategy usually works best.\))Tj
-1.8 -2.1 TD
[(4.)-1050(If the Shift key is held down and the user clicks on an item that isn't currently selected, that item is)]TJ
1.8 -1.5 TD
(added to the selected list. If the clicked-upon item is selected, it's deleted from the selection list.)Tj
-1.8 -2.1 TD
[(5.)-1050(If a sweep selection is performed with the Shift key pressed, the items swept out are added to the)]TJ
1.8 -1.5 TD
(current selection.)Tj
-1.8 -2.1 TD
[(6.)-1050(In an extremely cluttered region, it's often hard to do a sweep selection. When the button goes down,)]TJ
1.8 -1.5 TD
(the cursor might lie on top of some item, and normally that item would be selected. You can make)Tj
T*
(any operation a sweep selection, but a typical user interface interprets a button-down on an item plus)Tj
T*
(a mouse motion as a select-plus-drag operation. To solve this problem, you can have an enforced)Tj
T*
(sweep selection by holding down, say, the Alt key. With this, the following set of operations)Tj
T*
(constitutes a sweep selection: Alt-button down, sweep, button up. Items under the cursor when the)Tj
T*
(button goes down are ignored.)Tj
-1.8 -2.1 TD
[(7.)-1050(If the Shift key is held during this sweep selection, the items enclosed in the sweep region are added)]TJ
1.8 -1.5 TD
(to the current selection.)Tj
-1.8 -2.1 TD
[(8.)-1050(Finally, if the user clicks on multiple items, select just one of them. If the cursor isn't moved \(or)]TJ
1.8 -1.5 TD
(maybe not moved more than a pixel\), and the user clicks again in the same place, deselect the item)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 19)Tj
ET
endstream
endobj
1367 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1369 0 obj
<<
/Length 4464
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(originally selected, and select a different item under the cursor. Use repeated clicks at the same point)Tj
0 -1.5 TD
(to cycle through all the possibilities.)Tj
-1.8 -2.6 TD
(Different rules can apply in particular situations. In a text editor, you probably don't have to worry about)Tj
0 -1.5 TD
(characters on top of each other, and selections of multiple characters are always contiguous characters in)Tj
T*
(the document. Thus, you need to mark only the first and last selected characters to identify the complete)Tj
T*
(selection. With text, often the best way to handle selection is to identify the positions between characters)Tj
T*
(rather than the characters themselves. This allows you to have an empty selection when the beginning)Tj
T*
(and end of the selection are between the same pair of characters; it also allows you to put the cursor)Tj
T*
(before the first character in the document or after the final one with no special-case code.)Tj
0 -2.1 TD
(In three-dimensional editors, you might provide ways to rotate and zoom between selections, so)Tj
0 -1.5 TD
(sophisticated schemes for cycling through the possible selections might be unnecessary. On the other)Tj
T*
(hand, selection in three dimensions is difficult because the cursor's position on the screen usually gives)Tj
T*
(no indication of its depth.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 480.000 Tm
(Feedback)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 458.000 Tm
(Feedback is similar to selection in that once you're in either mode, no pixels are produced and the screen)Tj
T*
(is frozen. Drawing does not occur; instead, information about primitives that would have been rendered)Tj
T*
(is sent back to the application. The key difference between selection and feedback modes is what)Tj
T*
(information is sent back. In selection mode, assigned names are returned to an array of integer values. In)Tj
T*
(feedback mode, information about transformed primitives is sent back to an array of floating-point)Tj
T*
(values. The values sent back to the feedback array consist of tokens that specify what type of primitive)Tj
T*
(\(point, line, polygon, image, or bitmap\) has been processed and transformed, followed by vertex, color,)Tj
T*
(or other data for that primitive. The values returned are fully transformed by lighting and viewing)Tj
T*
(operations. Feedback mode is initiated by calling )Tj
/F15 1 Tf
19.9 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
( with GL_FEEDBACK as the)Tj
-26.5 -1.5 TD
(argument.)Tj
0 -2.1 TD
(Here's how you enter and exit feedback mode.)Tj
T*
[(1.)-1050(Call )]TJ
/F15 1 Tf
3.7 0 TD
(glFeedbackBuffer\(\))Tj
/F11 1 Tf
7.8 0 TD
( to specify the array to hold the feedback information. The arguments to this)Tj
-9.7 -1.5 TD
(command describe what type of data and how much of it gets written into the array.)Tj
-1.8 -2.1 TD
[(2.)-1050(Call )]TJ
/F15 1 Tf
3.7 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
( with GL_FEEDBACK as the argument to enter feedback mode. \(For this step,)Tj
-8.5 -1.5 TD
(you can ignore the value returned by )Tj
/F15 1 Tf
14.9 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
(.\) After this point, primitives aren't rasterized)Tj
-21.5 -1.5 TD
(to produce pixels until you exit feedback mode, and the contents of the framebuffer don't change.)Tj
-1.8 -2.1 TD
[(3.)-1050(Draw your primitives. While issuing drawing commands, you can make several calls to)]TJ
/F15 1 Tf
1.8 -1.5 TD
(glPassThrough\(\) )Tj
/F11 1 Tf
7 0 TD
(to insert markers into the returned feedback data and thus facilitate parsing.)Tj
-8.8 -2.1 TD
[(4.)-1050(Exit feedback mode by calling )]TJ
/F15 1 Tf
14.3 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
( with GL_RENDER as the argument if you want to)Tj
-19.1 -1.5 TD
(return to normal drawing mode. The integer value returned by )Tj
/F15 1 Tf
25.1 0 TD
(glRenderMode\(\))Tj
/F11 1 Tf
6.6 0 TD
( is the number of)Tj
-31.7 -1.5 TD
(values stored in the feedback array.)Tj
-1.8 -2.1 TD
[(5.)-1050(Parse the data in the feedback array.)]TJ
/F15 1 Tf
0 -2.6 TD
[(void )-28(glFeedbackBuffer)66(\(GLsizei )-61(size, GLenum )-6(type)66(, GLfloat *)-38(buffer)-11(\);)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 20)Tj
ET
endstream
endobj
1370 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1372 0 obj
<<
/Length 5612
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(Establishes a buffer for the feedback data: )51(buffer)-11( is a pointer to an array where the data is stored.)]TJ
0 -1.5 TD
[(The )-50(size argument indicates the maximum number of values that can be stored in the array. The )62(type)]TJ
T*
(argument describes the information fed back for each vertex in the feedback array; its possible)Tj
T*
[(values and their meaning are shown in )7(Table 13-1)]TJ
20.2 0 TD
[(. glFeedbackBuffer\(\))32( must be called before)]TJ
-20.2 -1.5 TD
[(feedback mode is entered. In the table,)43( k)-6( is 1 in color-index mode and 4 in RGBA mode.)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 640.000 m
473.000 640.000 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F17 1 Tf
8.000 0.000 0.000 8.000 124.000 632.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(type)Tj
/F27 1 Tf
1.625 0 TD
0.000 Tw
[( Argument)-10499(Coordinates)-1290(Color)-1639(Texture)-1137(Total Values)]TJ
ET
Q
124.000 626.480 m
473.000 626.480 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 618.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_2D)-12167(x, y)-4833(-)-3214(-)-3658(2)]TJ
0 -1.4444 TD
[(GL_3D)-12167(x, y, z)-3889(-)-3214(-)-3658(3)]TJ
T*
[(GL_3D_COLOR)-8277(x, y, z)-3889(k)-3278(-)-3658(3)0( + k)]TJ
T*
[(GL_3D_COLOR_TEXTURE)-3221(x, y, z)-3889(k)-3278(4)-3722(7)0( + k)]TJ
T*
[(GL_4D_COLOR_TEXTURE)-3221(x, y, z, w)-2667(k)-3278(4)-3722(8)0( + k)]TJ
ET
Q
124.000 558.720 m
473.010 558.720 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 542.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 13-1 )Tj
/F11 1 Tf
5.2 0 TD
(glFeedbackBuffer\(\) )Tj
/F15 1 Tf
8.1 0 TD
(type)Tj
/F11 1 Tf
1.7 0 TD
( Values)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 514.000 Tm
(The Feedback Array)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 492.000 Tm
(In feedback mode, each primitive that would be rasterized \(or each call to )Tj
/F15 1 Tf
29.7 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
(, or)Tj
/F15 1 Tf
-40.7 -1.5 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
(, if the raster position is valid\) generates a block of values that's copied into the feedback)Tj
-6 -1.5 TD
(array. The number of values is determined by the )Tj
/F15 1 Tf
19.9 0 TD
(type)Tj
/F11 1 Tf
1.7 0 TD
( argument to )Tj
/F15 1 Tf
5.3 0 TD
(glFeedbackBuffer\(\))Tj
/F11 1 Tf
7.8 0 TD
[(, as listed in )-71(Table)]TJ
-34.7 -1.5 TD
(13-1)Tj
1.8 0 TD
(. Use the appropriate value for the type of primitives you're drawing: GL_2D or GL_3D for unlit)Tj
-1.8 -1.5 TD
(two- or three-dimensional primitives, GL_3D_COLOR for lit, three-dimensional primitives, and)Tj
T*
(GL_3D_COLOR_TEXTURE or GL_4D_COLOR_TEXTURE for lit, textured, three- or)Tj
T*
(four-dimensional primitives.)Tj
0 -2.1 TD
(Each block of feedback values begins with a code indicating the primitive type, followed by values that)Tj
0 -1.5 TD
(describe the primitive's vertices and associated data. Entries are also written for pixel rectangles. In)Tj
T*
(addition, pass-through markers that you've explicitly created can be returned in the array; the next)Tj
T*
[(section explains these markers in more detail. Table 13-2)192( shows the syntax for the feedback array;)]TJ
T*
[(remember that the data associated with each returned vertex is as described in )-43(Table 13-1)]TJ
35.7 0 TD
(. Note that a)Tj
-35.7 -1.5 TD
(polygon can have )Tj
/F15 1 Tf
7.3 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( vertices returned. Also, the )Tj
/F15 1 Tf
11.3 0 TD
(x, y, z)Tj
/F11 1 Tf
2.3 0 TD
( coordinates returned by feedback are window)Tj
-21.4 -1.5 TD
(coordinates; if )Tj
/F15 1 Tf
6 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( is returned, it's in clip coordinates. For bitmaps and pixel rectangles, the coordinates)Tj
-6.7 -1.5 TD
(returned are those of the current raster position. In the table, note that GL_LINE_RESET_TOKEN is)Tj
T*
(returned only when the line stipple is reset for that line segment.)Tj
ET
Q
124.000 249.940 m
465.000 249.940 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 242.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Primitive Type)-2663(Code)-14125(Associated Data)]TJ
ET
Q
124.000 236.420 m
465.000 236.420 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 228.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(Point)-6332(GL_POINT_TOKEN)-6111(vertex)]TJ
0 -1.4444 TD
0.000 Tw
[(Line)-6611(GL_LINE_TOKEN or)]TJ
8.4444 -1.3333 TD
(GL_LINE_RESET_TOKEN)Tj
14.7778 1.3333 TD
(vertex vertex)Tj
-23.2222 -2.7778 TD
[(Polygon)-5110(GL_POLYGON_TOKEN)-4278(n vertex vertex ... vertex)]TJ
0 -1.4444 TD
[(Bitmap)-5499(GL_BITMAP_TOKEN)-5277(vertex)]TJ
T*
[(Pixel Rectangle)-2138(GL_DRAW_PIXEL_TOKEN or)]TJ
8.4444 -1.3333 TD
(GL_COPY_PIXEL_TOKEN)Tj
14.7778 1.3333 TD
(vertex)Tj
-23.2222 -2.7778 TD
[(Pass-through)-2991(GL_PASS_THROUGH_TOKEN)-1277(a floating-point number)]TJ
ET
Q
124.000 131.610 m
465.010 131.610 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 115.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 13-2 )Tj
/F11 1 Tf
5.2 0 TD
(Feedback Array Syntax)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 87.000 Tm
(Using Markers in Feedback Mode)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 21)Tj
ET
endstream
endobj
1373 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F17 1374 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1376 0 obj
<<
/Length 3412
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Feedback occurs after transformations, lighting, polygon culling, and interpretation of polygons by)Tj
/F15 1 Tf
0 -1.5 TD
(glPolygonMode\(\))Tj
/F11 1 Tf
7.1 0 TD
(. It might also occur after polygons with more than three edges are broken up into)Tj
-7.1 -1.5 TD
(triangles \(if your particular OpenGL implementation renders polygons by performing this)Tj
T*
(decomposition\). Thus, it might be hard for you to recognize the primitives you drew in the feedback data)Tj
T*
(you receive. To help parse the feedback data, call )Tj
/F15 1 Tf
20 0 TD
(glPassThrough\(\))Tj
/F11 1 Tf
6.8 0 TD
( as needed in your sequence of)Tj
-26.8 -1.5 TD
(drawing commands to insert a marker. You might use the markers to separate the feedback values)Tj
T*
(returned from different primitives, for example. This command causes GL_PASS_THROUGH_TOKEN)Tj
T*
(to be written into the feedback array, followed by the floating-point value you pass in as an argument.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glPassThrough)13(\(GLfloat )23(token)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Inserts a marker into the stream of values written into the feedback array, if called in feedback)Tj
T*
(mode. The marker consists of the code GL_PASS_THROUGH_TOKEN followed by a single)Tj
T*
(floating-point value, )Tj
8.4 0 TD
[(token)-34(. This command has no effect when called outside of feedback mode.)]TJ
-8.4 -1.5 TD
[(Calling )-49(glPassThrough\(\))79( between )-23(glBegin\(\))-23( and glEnd\(\))55( generates a GL_INVALID_OPERATION)]TJ
T*
(error.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 481.000 Tm
(A Feedback Example)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 460.000 Tm
(Example 13-7)Tj
5.6 0 TD
( demonstrates the use of feedback mode. This program draws a lit, three-dimensional scene)Tj
-5.6 -1.5 TD
(in normal rendering mode. Then, feedback mode is entered, and the scene is redrawn. Since the program)Tj
T*
(draws lit, untextured, three-dimensional objects, the type of feedback data is GL_3D_COLOR. Since)Tj
T*
(RGBA mode is used, each unclipped vertex generates seven values for the feedback buffer: )Tj
/F15 1 Tf
36.9 0 TD
(x, y, z, r, g, b,)Tj
/F11 1 Tf
-36.9 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
(.)Tj
-2.2 -2.1 TD
(In feedback mode, the program draws two lines as part of a line strip and then inserts a pass-through)Tj
0 -1.5 TD
(marker. Next, a point is drawn at \(-100.0, -100.0, -100.0\), which falls outside the orthographic viewing)Tj
T*
(volume and thus doesn't put any values into the feedback array. Finally, another pass-through marker is)Tj
T*
(inserted, and another point is drawn.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 13-7 )Tj
/F11 1 Tf
6.7 0 TD
(Feedback Mode: feedback.c)Tj
/F7 1 Tf
-6.7 -2.4 TD
(#include <GL/gl.h>)Tj
0 -1.5 TD
(#include <GL/glu.h>)Tj
T*
(#include <GL/glut.h>)Tj
T*
(#include <stdlib.h>)Tj
T*
(#include <stdio.h>)Tj
0 -3 TD
(void init\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   glEnable\(GL_LIGHTING\);)Tj
T*
(   glEnable\(GL_LIGHT0\);)Tj
T*
(})Tj
0 -3 TD
(void drawGeometry \(GLenum mode\))Tj
0 -1.5 TD
({)Tj
T*
(   glBegin \(GL_LINE_STRIP\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 22)Tj
ET
endstream
endobj
1377 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1379 0 obj
<<
/Length 1747
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glNormal3f \(0.0, 0.0, 1.0\);)Tj
0 -1.5 TD
(   glVertex3f \(30.0, 30.0, 0.0\);)Tj
T*
(   glVertex3f \(50.0, 60.0, 0.0\);)Tj
T*
(   glVertex3f \(70.0, 40.0, 0.0\);)Tj
T*
(   glEnd \(\);)Tj
T*
(   if \(mode == GL_FEEDBACK\))Tj
T*
(      glPassThrough \(1.0\);)Tj
T*
(   glBegin \(GL_POINTS\);)Tj
T*
(   glVertex3f \(-100.0, -100.0, -100.0\);  /*  will be clipped  */)Tj
T*
(   glEnd \(\);)Tj
T*
(   if \(mode == GL_FEEDBACK\))Tj
T*
(      glPassThrough \(2.0\);)Tj
T*
(   glBegin \(GL_POINTS\);)Tj
T*
(   glNormal3f \(0.0, 0.0, 1.0\);)Tj
T*
(   glVertex3f \(50.0, 50.0, 0.0\);)Tj
T*
(   glEnd \(\);)Tj
T*
(})Tj
0 -3 TD
(void print3DcolorVertex \(GLint size, GLint *count, )Tj
0 -1.5 TD
(                         GLfloat *buffer\))Tj
T*
({)Tj
T*
(   int i;)Tj
0 -3 TD
(   printf \("  "\);)Tj
0 -1.5 TD
(   for \(i = 0; i < 7; i++\) {)Tj
T*
(      printf \("%4.2f ", buffer[size-\(*count\)]\);)Tj
T*
(      *count = *count - 1;)Tj
T*
(   })Tj
T*
(   printf \("\\n"\);)Tj
T*
(})Tj
0 -3 TD
(void printBuffer\(GLint size, GLfloat *buffer\))Tj
0 -1.5 TD
({)Tj
T*
(   GLint count;)Tj
T*
(   GLfloat token;)Tj
0 -3 TD
(   count = size;)Tj
0 -1.5 TD
(   while \(count\) {)Tj
T*
(      token = buffer[size-count]; count--;)Tj
T*
(      if \(token == GL_PASS_THROUGH_TOKEN\) {)Tj
T*
(         printf \("GL_PASS_THROUGH_TOKEN\\n"\);)Tj
T*
(         printf \("  %4.2f\\n", buffer[size-count]\);)Tj
T*
(         count--;)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 23)Tj
ET
endstream
endobj
1380 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1382 0 obj
<<
/Length 1844
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(      })Tj
0 -1.5 TD
(      else if \(token == GL_POINT_TOKEN\) {)Tj
T*
(         printf \("GL_POINT_TOKEN\\n"\);)Tj
T*
(         print3DcolorVertex \(size, &count, buffer\);)Tj
T*
(      })Tj
T*
(      else if \(token == GL_LINE_TOKEN\) {)Tj
T*
(         printf \("GL_LINE_TOKEN\\n"\);)Tj
T*
(         print3DcolorVertex \(size, &count, buffer\);)Tj
T*
(         print3DcolorVertex \(size, &count, buffer\);)Tj
T*
(      })Tj
T*
(      else if \(token == GL_LINE_RESET_TOKEN\) {)Tj
T*
(         printf \("GL_LINE_RESET_TOKEN\\n"\);)Tj
T*
(         print3DcolorVertex \(size, &count, buffer\);)Tj
T*
(         print3DcolorVertex \(size, &count, buffer\);)Tj
T*
(      })Tj
T*
(   })Tj
T*
(})Tj
0 -3 TD
(void display\(void\))Tj
0 -1.5 TD
({)Tj
T*
(   GLfloat feedBuffer[1024];)Tj
T*
(   GLint size;)Tj
0 -3 TD
(   glMatrixMode \(GL_PROJECTION\);)Tj
0 -1.5 TD
(   glLoadIdentity \(\);)Tj
T*
(   glOrtho \(0.0, 100.0, 0.0, 100.0, 0.0, 1.0\);)Tj
0 -3 TD
(   glClearColor \(0.0, 0.0, 0.0, 0.0\);)Tj
0 -1.5 TD
(   glClear\(GL_COLOR_BUFFER_BIT\);)Tj
T*
(   drawGeometry \(GL_RENDER\);)Tj
0 -3 TD
(   glFeedbackBuffer \(1024, GL_3D_COLOR, feedBuffer\);)Tj
0 -1.5 TD
(   \(void\) glRenderMode \(GL_FEEDBACK\);)Tj
T*
(   drawGeometry \(GL_FEEDBACK\);)Tj
0 -3 TD
(   size = glRenderMode \(GL_RENDER\);)Tj
0 -1.5 TD
(   printBuffer \(size, feedBuffer\);)Tj
T*
(})Tj
0 -3 TD
(int main\(int argc, char** argv\))Tj
0 -1.5 TD
({)Tj
T*
(   glutInit\(&argc, argv\);)Tj
T*
(   glutInitDisplayMode\(GLUT_SINGLE | GLUT_RGB\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 24)Tj
ET
endstream
endobj
1383 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1385 0 obj
<<
/Length 2715
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F7 1 Tf
10.000 0.000 0.000 10.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(   glutInitWindowSize \(100, 100\);)Tj
0 -1.5 TD
(   glutInitWindowPosition \(100, 100\);)Tj
T*
(   glutCreateWindow\(argv[0]\);)Tj
T*
(   init\(\);)Tj
T*
(   glutDisplayFunc\(display\);)Tj
T*
(   glutMainLoop\(\);)Tj
T*
(   return 0; )Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(Running this program generates the following output:)Tj
/F7 1 Tf
T*
(GL_LINE_RESET_TOKEN)Tj
0 -1.5 TD
( 30.00 30.00 0.00 0.84 0.84 0.84 1.00)Tj
T*
( 50.00 60.00 0.00 0.84 0.84 0.84 1.00)Tj
T*
(GL_LINE_TOKEN)Tj
T*
( 50.00 60.00 0.00 0.84 0.84 0.84 1.00)Tj
T*
( 70.00 40.00 0.00 0.84 0.84 0.84 1.00)Tj
T*
(GL_PASS_THROUGH_TOKEN)Tj
T*
( 1.00)Tj
T*
(GL_PASS_THROUGH_TOKEN)Tj
T*
( 2.00)Tj
T*
(GL_POINT_TOKEN)Tj
T*
( 50.00 50.00 0.00 0.84 0.84 0.84 1.00)Tj
/F11 1 Tf
0 -2.1 TD
(Thus, the line strip drawn with these commands results in two primitives:)Tj
/F7 1 Tf
T*
(glBegin\(GL_LINE_STRIP\);)Tj
0 -1.5 TD
(    glNormal3f \(0.0, 0.0, 1.0\);)Tj
T*
(    glVertex3f \(30.0, 30.0, 0.0\);)Tj
T*
(    glVertex3f \(50.0, 60.0, 0.0\);)Tj
T*
(    glVertex3f \(70.0, 40.0, 0.0\);)Tj
T*
(glEnd\(\);)Tj
/F11 1 Tf
0 -2.1 TD
(The first primitive begins with GL_LINE_RESET_TOKEN, which indicates that the primitive is a line)Tj
0 -1.5 TD
(segment and that the line stipple is reset. The second primitive begins with GL_LINE_TOKEN, so it's)Tj
T*
(also a line segment, but the line stipple isn't reset and hence continues from where the previous line)Tj
T*
(segment left off. Each of the two vertices for these lines generates seven values for the feedback array.)Tj
T*
(Note that the RGBA values for all four vertices in these two lines are \(0.84, 0.84, 0.84, 1.0\), which is a)Tj
T*
(very light gray color with the maximum alpha value. These color values are a result of the interaction of)Tj
T*
(the surface normal and lighting parameters.)Tj
0 -2.1 TD
(Since no feedback data is generated between the first and second pass-through markers, you can deduce)Tj
0 -1.5 TD
(that any primitives drawn between the first two calls to )Tj
/F15 1 Tf
22.3 0 TD
(glPassThrough\(\))Tj
/F11 1 Tf
6.8 0 TD
( were clipped out of the viewing)Tj
-29.1 -1.5 TD
(volume. Finally, the point at \(50.0, 50.0, 0.0\) is drawn, and its associated data is copied into the feedback)Tj
T*
(array.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(In both feedback and selection modes, information on objects is returned prior to any fragment)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 13,  Selection and Feedback - 25)Tj
ET
endstream
endobj
1386 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1388 0 obj
<<
/Length 1153
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(tests. Thus, objects that would not be drawn due to failure of the scissor, alpha, depth, or stencil tests may)Tj
0 -1.4 TD
(still have their data processed and returned in both feedback and selection modes.)Tj
/F27 1 Tf
8 -2.2 TD
(Try This)Tj
/F11 1 Tf
-8 -2.1 TD
[(Make changes to )27(Example 13-7)170( and see how they affect the feedback values that are returned. For)]TJ
0 -1.5 TD
(example, change the coordinate values of )Tj
/F15 1 Tf
16.8 0 TD
(glOrtho\(\))Tj
/F11 1 Tf
3.8 0 TD
(. Change the lighting variables, or eliminate lighting)Tj
-20.6 -1.5 TD
(altogether and change the feedback type to GL_3D. Or add more primitives to see what other geometry)Tj
T*
(\(such as filled polygons\) contributes to the feedback array.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 570.350 m
547.000 570.350 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 26)Tj
ET
endstream
endobj
1389 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1391 0 obj
<<
/Length 3844
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Chapter 14)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Now That You Know)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 672.000 Tm
(Chapter Objectives)Tj
/F11 1 Tf
0 -2.1 TD
(This chapter doesn't have objectives in the same way that previous chapters do. It's simply a collection)Tj
0 -1.5 TD
(of topics that describe ideas you might find useful for your application. Some topics, such as error)Tj
T*
(handling, don't fit into other categories, but are too short for an entire chapter.)Tj
0 -2.1 TD
(OpenGL is kind of a bag of low-level tools; now that you know about those tools, you can use them to)Tj
0 -1.5 TD
(implement higher-level functions. This chapter presents several examples of such higher-level)Tj
T*
(capabilities.)Tj
0 -2.1 TD
(This chapter discusses a variety of techniques based on OpenGL commands that illustrate some of the)Tj
0 -1.5 TD
(not-so-obvious uses to which you can put these commands. The examples are in no particular order and)Tj
T*
(aren't related to each other. The idea is to read the section headings and skip to the examples that you)Tj
T*
(find interesting. For your convenience, the headings are listed and explained briefly here.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(Most of the examples in the rest of this guide are complete and can be compiled and run as is. In)Tj
-2.8 -1.4 TD
(this chapter, however, there are no complete programs, and you have to do a bit of work on your own to)Tj
T*
(make them run.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Error Handling" tells you how to check for OpenGL error conditions.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Which Version Am I Using?")15( describes how to find out details about the implementation, including)]TJ
0 -1.6 TD
(the version number. This can be useful for writing applications that are backward compatible with)Tj
0 -1.5 TD
(earlier versions of OpenGL.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Extensions to the Standard")11( presents techniques to identify and use vendor-specific extensions to)]TJ
0 -1.6 TD
(the OpenGL standard.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Cheesy Translucency" explains how to use polygon stippling to achieve translucency; this is)Tj
0 -1.6 TD
(particularly useful when you don't have blending hardware available.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("An Easy Fade Effect")20( shows how to use polygon stippling to create the effect of a fade into the)]TJ
0 -1.6 TD
(background.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Object Selection Using the Back Buffer")32( describes how to use the back buffer in a double-buffered)]TJ
0 -1.5 TD
(system to handle simple object picking.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Cheap Image Transformation")-8( discusses how to draw a distorted version of a bitmapped image by)]TJ
0 -1.5 TD
(drawing each pixel as a quadrilateral.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Displaying Layers")-23( explains how to display multiple different layers of materials and indicate)]TJ
0 -1.6 TD
(where the materials overlap.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Antialiased Characters" describes how to draw smoother fonts.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Drawing Round Points")-16( describes how to draw near-round points.)]TJ
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Interpolating Images")21( shows how to smoothly blend from one image to the another.)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 1)Tj
ET
endstream
endobj
1392 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1394 0 obj
<<
/Length 4136
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
("Making Decals" explains how to draw two images, where one is a sort of decal that should always)Tj
0 -1.6 TD
(appear on top of the other.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Drawing Filled, Concave Polygons Using the Stencil Buffer")-27( tells you how to draw concave)]TJ
0 -1.6 TD
(polygons, nonsimple polygons, and polygons with holes by using the stencil buffer.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Finding Interference Regions")37( describes how to determine where three-dimensional pieces overlap.)]TJ
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Shadows")27( describes how to draw shadows of lit objects.)]TJ
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Hidden-Line Removal")219( discusses how to draw a wireframe object with hidden lines removed by)]TJ
0 -1.6 TD
(using the stencil buffer.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Texture-Mapping Applications")Tj
13.2 0 TD
( describes several clever uses for texture mapping, such as rotating)Tj
-13.2 -1.6 TD
(and warping images.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Drawing Depth-Buffered Images")Tj
14 0 TD
( tells you how to combine images in a depth-buffered)Tj
-14 -1.6 TD
(environment.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Dirichlet Domains")33( explains how to find the Dirichlet domain of a set of points using the depth)]TJ
0 -1.6 TD
(buffer.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Life in the Stencil Buffer")-29( explains how to implement the Game of Life using the stencil buffer.)]TJ
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Alternative Uses for glDrawPixels\(\) and glCopyPixels\(\)")-12( describes how to use these two)]TJ
0 -1.6 TD
(commands for such effects as fake video, airbrushing, and transposed images.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 358.000 Tm
(Error Handling)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 336.000 Tm
(The truth is, your program will make mistakes. Use of error-handling routines are essential during)Tj
0 -1.5 TD
(development and are highly recommended for commercially released applications. \(Unless you can give)Tj
T*
(a 100% guarantee your program will never generate an OpenGL error condition. Get real!\) OpenGL has)Tj
T*
(simple error-handling routines for the base GL and GLU libraries.)Tj
0 -2.1 TD
(When OpenGL detects an error \(in either the base GL or GLU\), it records a current error code. The)Tj
0 -1.5 TD
(command that caused the error is ignored, so it has no effect on OpenGL state or on the framebuffer)Tj
T*
(contents. \(If the error recorded was GL_OUT_OF_MEMORY, however, the results of the command are)Tj
0 -1.6 TD
(undefined.\) Once recorded, the current error code isn't cleared)Tj
/F33 1 Tf
25 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(that is, additional errors aren't)Tj
-26 -1.7 TD
(recorded)Tj
/F33 1 Tf
3.5 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(until you call the query command )Tj
/F15 1 Tf
13.7 0 TD
(glGetError\(\))Tj
/F11 1 Tf
5.2 0 TD
(, which returns the current error code. After)Tj
-23.4 -1.6 TD
(you've queried and cleared the current error code, or if there's no error to begin with, )Tj
/F15 1 Tf
34.4 0 TD
(glGetError\(\))Tj
/F11 1 Tf
-34.4 -1.5 TD
(returns GL_NO_ERROR.)Tj
/F15 1 Tf
0 -2.1 TD
[(GLenum)44( glGetError)-49(\(void\);)]TJ
1.8 -1.5 TD
(Returns the value of the error flag. When an error occurs in either the GL or GLU, the error flag is)Tj
T*
(set to the appropriate error code value. If GL_NO_ERROR is returned, there has been no detectable)Tj
T*
[(error since the last call to )12(glGetError\(\))-33(, or since the GL was initialized. No other errors are)]TJ
T*
[(recorded until )45(glGetError\(\))-33( is called, the error code is returned, and the flag is reset to)]TJ
T*
(GL_NO_ERROR.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 2)Tj
ET
endstream
endobj
1395 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1399 0 obj
<<
/Length 4075
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(It is strongly recommended that you call )Tj
/F15 1 Tf
16.4 0 TD
(glGetError\(\))Tj
/F11 1 Tf
5.2 0 TD
( at least once in each )Tj
/F15 1 Tf
8.5 0 TD
(display\(\))Tj
/F11 1 Tf
3.6 0 TD
[( routine. )-17(Table 14-1)]TJ
-33.7 -1.5 TD
(lists the basic defined OpenGL error codes.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 680.900 m
462.000 680.900 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 124.000 673.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Error Code)-10776(Description)]TJ
ET
Q
124.000 667.380 m
462.000 667.380 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 659.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_INVALID_ENUM)-4779(GLenum argument out of range)]TJ
0 -1.4444 TD
[(GL_INVALID_VALUE)-4335(Numeric argument out of range)]TJ
T*
[(GL_INVALID_OPERATION)-2056(Operation illegal in current state)]TJ
T*
[(GL_STACK_OVERFLOW)-3055(Command would cause a stack overflow)]TJ
T*
[(GL_STACK_UNDERFLOW)-2332(Command would cause a stack underflow)]TJ
T*
[(GL_OUT_OF_MEMORY)-3555(Not enough memory left to execute command)]TJ
ET
Q
124.000 586.570 m
462.010 586.570 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 570.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 14-1 )Tj
/F11 1 Tf
5.2 0 TD
(OpenGL Error Codes)Tj
-5.2 -2.1 TD
(There are also thirty-seven GLU NURBS errors \(with non-descriptive constant names,)Tj
0 -1.5 TD
(GLU_NURBS_ERROR1, GLU_NURBS_ERROR2, and so on\), fourteen tessellator errors)Tj
T*
(\(GLU_TESS_MISSING_BEGIN_POLYGON, GLU_TESS_MISSING_END_POLYGON,)Tj
T*
(GLU_TESS_MISSING_BEGIN_CONTOUR, GLU_TESS_MISSING_END_CONTOUR,)Tj
T*
(GLU_TESS_COORD_TOO_LARGE, GLU_TESS_NEED_COMBINE_CALLBACK, and eight)Tj
T*
(generically named GLU_TESS_ERROR*\), and GLU_INCOMPATIBLE_GL_VERSION. Also, the)Tj
T*
(GLU defines the error codes GLU_INVALID_ENUM, GLU_INVALID_VALUE, and)Tj
T*
(GLU_OUT_OF_MEMORY, which have the same meaning as the related OpenGL codes.)Tj
0 -2.1 TD
(To obtain a printable, descriptive string corresponding to either a GL or GLU error code, use the GLU)Tj
0 -1.5 TD
(routine )Tj
/F15 1 Tf
3.1 0 TD
(gluErrorString\(\))Tj
/F11 1 Tf
6.7 0 TD
(.)Tj
/F15 1 Tf
-9.8 -2.1 TD
[(const GLubyte*)6( gluErrorString)-48(\(GLenum )27(errorCode)22(\);)]TJ
1.8 -1.5 TD
(Returns a pointer to a descriptive string that corresponds to the OpenGL or GLU error number)Tj
T*
[(passed in errorCode)22(.)]TJ
/F11 1 Tf
-1.8 -2.1 TD
0.017 Tw
[(In Example )17(14-1)]TJ
6.7 0 TD
0.000 Tw
(, a simple error handling routine is shown.)Tj
/F27 1 Tf
-6.7 -2.1 TD
(Example 14-1 )Tj
/F11 1 Tf
6.7 0 TD
(Querying and Printing an Error)Tj
/F7 1 Tf
-6.7 -2.3 TD
(GLenum errCode;)Tj
0 -1.5 TD
(const GLubyte *errString;)Tj
0 -3 TD
(if \(\(errCode = glGetError\(\)\) != GL_NO_ERROR\) {)Tj
0 -1.5 TD
(    errString = gluErrorString\(errCode\);)Tj
T*
(   fprintf \(stderr, "OpenGL Error: %s\\n", errString\);)Tj
T*
(})Tj
/F27 1 Tf
0 -2.2 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(The string returned by )Tj
/F15 1 Tf
9.2 0 TD
(gluErrorString\(\))Tj
/F11 1 Tf
6.7 0 TD
( must not be altered or freed by the application.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 147.000 Tm
(Which Version Am I Using?)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 125.000 Tm
(The portability of OpenGL applications is one of OpenGL's attractive features. However, new versions)Tj
0 -1.5 TD
(of OpenGL introduce new features, which may introduce backward compatibility problems. In addition,)Tj
T*
(you may want your application to perform equally well on a variety of implementations. For example,)Tj
T*
(you might make texture mapping the default rendering mode on one machine, but only have flat shading)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 3)Tj
ET
endstream
endobj
1400 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1402 0 obj
<<
/Length 3556
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(on another. You can use )Tj
/F15 1 Tf
9.9 0 TD
(glGetString\(\))Tj
/F11 1 Tf
5.4 0 TD
( to obtain release information about your OpenGL implementation.)Tj
/F15 1 Tf
-15.3 -2.1 TD
[(const GLubyte*)6( glGetString)18(\(GLenum )27(name)-34(\);)]TJ
1.8 -1.5 TD
[(Returns a pointer to a string that describes an aspect of the OpenGL implementation. )20(name)-34( can be)]TJ
T*
(one of the following: GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_EXTENSIONS.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(GL_VENDOR returns the name of the company responsible for the OpenGL implementation.)Tj
0 -1.5 TD
(GL_RENDERER returns an identifier of the renderer, which is usually the hardware platform. For more)Tj
T*
[(about GL_EXTENSIONS, see the next section, )-23("Extensions to the Standard.")]TJ
0 -2.1 TD
(GL_VERSION returns a string that identifies the version number of this implementation of OpenGL.)Tj
0 -1.5 TD
(The version string is laid out as follows:)Tj
0 -2.1 TD
(<version number><space><vendor-specific information>)Tj
T*
(The version number is either of the form)Tj
T*
(major_number.minor_number)Tj
T*
(or)Tj
T*
(major_number.minor_number.release_number)Tj
T*
(where the numbers all have one or more digits. The vendor-specific information is optional. For example,)Tj
0 -1.5 TD
(if this OpenGL implementation is from the fictitious XYZ Corporation, the string returned might be)Tj
0 -2.1 TD
(1.1.4 XYZ-OS 3.2)Tj
T*
(which means that this implementation is XYZ's fourth release of an OpenGL library that conforms to the)Tj
0 -1.5 TD
(specification for OpenGL Version 1.1. It probably also means this is release 3.2 of XYZ's proprietary)Tj
T*
(operating system.)Tj
0 -2.1 TD
(Another way to query the version number for OpenGL is to look for the symbolic constant \(use the)Tj
0 -1.5 TD
(preprocessor statement #ifdef\) named GL_VERSION_1_1. The absence of the constant)Tj
T*
(GL_VERSION_1_1 means that you have OpenGL Version 1.0.)Tj
/F27 1 Tf
0 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(If running from client to server, such as when performing indirect rendering with the OpenGL)Tj
-2.8 -1.4 TD
(extension to the X Window System, the client and server may be different versions. If your client version)Tj
T*
(is ahead of your server, your client might request an operation that is not supported on your server.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 231.000 Tm
(Utility Library Version)Tj
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 209.000 Tm
(gluGetString\(\))Tj
/F11 1 Tf
5.8 0 TD
( is a query function for the Utility Library \(GLU\) and is similar to )Tj
/F15 1 Tf
26.6 0 TD
(glGetString\(\))Tj
/F11 1 Tf
5.4 0 TD
(.)Tj
/F15 1 Tf
-37.8 -2.1 TD
[(const GLubyte*)6( gluGetString)18(\(GLenum )27(name)-34(\);)]TJ
1.8 -1.5 TD
[(Returns a pointer to a string that describes an aspect of the OpenGL implementation. )20(name)-34( can be)]TJ
T*
(one of the following: GLU_VERSION, or GLU_EXTENSIONS.)Tj
/F11 1 Tf
-1.8 -2.1 TD
(Note that )Tj
/F15 1 Tf
3.9 0 TD
(gluGetString\(\))Tj
/F11 1 Tf
5.9 0 TD
( was not available in GLU 1.0. Another way to query the version number for)Tj
-9.8 -1.5 TD
(GLU is to look for the symbolic constant GLU_VERSION_1_1. The absence of the constant)Tj
T*
(GLU_VERSION_1_1 means that you have GLU 1.0.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 4)Tj
ET
endstream
endobj
1403 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1405 0 obj
<<
/Length 3447
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Extensions to the Standard)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 685.000 Tm
(OpenGL has a formal written specification that describes what operations comprise the library. An)Tj
0 -1.5 TD
(individual vendor or a group of vendors may decide to include additional functionality to their released)Tj
T*
(implementation.)Tj
0 -2.1 TD
(New routine and symbolic constant names clearly indicate whether a feature is part of the OpenGL)Tj
0 -1.5 TD
(standard or a vendor-specific extension. To make a vendor-specific name, the vendor appends a company)Tj
T*
(identifier \(in uppercase\) and, if needed, additional information, such as a machine name. For example, if)Tj
T*
(XYZ Corporation wants to add a new routine and symbolic constant, they might be of the form)Tj
/F15 1 Tf
T*
(glCommandXYZ\(\))Tj
/F11 1 Tf
7.3 0 TD
( and GL_DEFINITION_XYZ. If XYZ Corporation wants to have an extension that is)Tj
-7.3 -1.5 TD
(available only on its FooBar graphics board, then the names might be )Tj
/F15 1 Tf
28 0 TD
(glCommandXYZfb\(\))Tj
/F11 1 Tf
8.1 0 TD
( and)Tj
-36.1 -1.5 TD
(GL_DEFINITION_XYZ_FB.)Tj
0 -2.1 TD
(If two of more vendors agree to implement the same extension, then the procedures and constants are)Tj
0 -1.5 TD
(suffixed with the more generic EXT \()Tj
/F15 1 Tf
15.1 0 TD
(glCommandEXT\(\))Tj
/F11 1 Tf
7.3 0 TD
( and GL_DEFINITION_EXT\).)Tj
-22.4 -2.1 TD
(If you want to know if a particular extension is supported on your implementation, use)Tj
/F15 1 Tf
0 -1.5 TD
(glGetString)Tj
/F11 1 Tf
4.7 0 TD
(\(GL_EXTENSIONS\). This returns a list of all the extensions in the implementation,)Tj
-4.7 -1.5 TD
[(separated by spaces. If you want to find out if a specific extension is supported, use the code in )48(Example)]TJ
T*
(14-2)Tj
1.8 0 TD
( to search through the list and match the extension name. Return GL_TRUE, if it is; GL_FALSE, if)Tj
-1.8 -1.5 TD
(it isn't.)Tj
/F27 1 Tf
0 -2.1 TD
(Example 14-2 )Tj
/F11 1 Tf
6.7 0 TD
(Find Out If An Extension Is Supported)Tj
/F7 1 Tf
-6.7 -2.4 TD
(static GLboolean QueryExtension\(char *extName\))Tj
0 -1.5 TD
({)Tj
T*
(  char *p = \(char *\) glGetString\(GL_EXTENSIONS\);)Tj
T*
(  char *end = p + strlen\(p\); )Tj
T*
(  while \(p < end\) {)Tj
T*
(   int n = strcspn\(p, " "\);)Tj
T*
(     if \(\(strlen\(extName\)==n\) && \(strncmp\(extName,p,n\)==0\)\) {)Tj
T*
(    return GL_TRUE;)Tj
T*
(   })Tj
T*
(   p += \(n + 1\);)Tj
T*
(  })Tj
T*
(  return GL_FALSE;)Tj
T*
(  })Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 168.000 Tm
(Cheesy Translucency)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 146.000 Tm
(You can use polygon stippling to simulate a translucent material. This is an especially good solution for)Tj
T*
(systems that don't have blending hardware. Since polygon stipple patterns are 32x32 bits, or 1024 bits,)Tj
T*
(you can go from opaque to transparent in 1023 steps. \(In practice, that's many more steps than you)Tj
T*
(need!\) For example, if you want a surface that lets through 29 percent of the light, simply make up a)Tj
T*
(stipple pattern where 29 percent \(roughly 297\) of the pixels in the mask are zero and the rest are one.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 5)Tj
ET
endstream
endobj
1406 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1408 0 obj
<<
/Length 3157
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Even if your surfaces have the same translucency, don't use the same stipple pattern for each one, as they)Tj
0 -1.5 TD
(cover exactly the same bits on the screen. Make up a different pattern for each by randomly selecting the)Tj
T*
[(appropriate number of pixels to be zero. \(See "Displaying Points, Lines, and Polygons" in Chapter 2)-8( for)]TJ
T*
(more information about polygon stippling.\))Tj
0 -2.1 TD
(If you don't like the effect with random pixels turned on, you can use regular patterns, but they don't)Tj
0 -1.5 TD
(work as well when transparent surfaces are stacked. This is often not a problem because most scenes)Tj
T*
(have relatively few translucent regions that overlap. In a picture of an automobile with translucent)Tj
T*
(windows, your line of sight can go through at most two windows, and usually it's only one.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 566.000 Tm
(An Easy Fade Effect)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 544.000 Tm
(Suppose you have an image that you want to fade gradually to some background color. Define a series of)Tj
T*
(polygon stipple patterns, each of which has more bits turned on so that they represent denser and denser)Tj
T*
(patterns. Then use these patterns repeatedly with a polygon large enough to cover the region over which)Tj
T*
(you want to fade. For example, suppose you want to fade to black in 16 steps. First define 16 different)Tj
T*
(pattern arrays:)Tj
/F7 1 Tf
0 -2 TD
(GLubyte stips[16][4*32];)Tj
/F11 1 Tf
0 -2.3 TD
(Then load them in such a way that each has one-sixteenth of the pixels in a 32)Tj
/F33 1 Tf
31.2 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(32 stipple pattern turned)Tj
-31.8 -1.5 TD
(on and that the bitwise OR of all the stipple patterns is all ones. After that, the following code does the)Tj
T*
(trick:)Tj
/F7 1 Tf
0 -2.1 TD
(draw_the_picture\(\); )Tj
0 -1.5 TD
(glColor3f\(0.0, 0.0, 0.0\);    /* set color to black */ )Tj
T*
(for \(i = 0; i < 16; i++\) { )Tj
T*
(    glPolygonStipple\(&stips[i][0]\); )Tj
T*
(    draw_a_polygon_large_enough_to_cover_the_whole_region\(\); )Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(In some OpenGL implementations, you might get better performance by first compiling the stipple)Tj
0 -1.5 TD
(patterns into display lists. During your initialization, do something like this:)Tj
/F7 1 Tf
0 -2.1 TD
(#define STIP_OFFSET 100 )Tj
0 -1.5 TD
(for \(i = 0; i < 16; i++\) { )Tj
T*
(    glNewList\(i+STIP_OFFSET, GL_COMPILE\); )Tj
T*
(    glPolygonStipple\(&stips[i][0]\); )Tj
T*
(    glEndList\(\); )Tj
T*
(} )Tj
/F11 1 Tf
0 -2.1 TD
(Then, replace this line in the first code fragment)Tj
/F7 1 Tf
T*
(glPolygonStipple\(&stips[i][0]\); )Tj
/F11 1 Tf
T*
(with)Tj
/F7 1 Tf
T*
(glCallList\(i\); )Tj
/F11 1 Tf
T*
(By compiling the command to set the stipple into a display list, OpenGL might be able to rearrange the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 6)Tj
ET
endstream
endobj
1409 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1411 0 obj
<<
/Length 4367
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(data in the )Tj
/F15 1 Tf
4.4 0 TD
(stips[ ][ ])Tj
/F11 1 Tf
3.9 0 TD
( array into the hardware-specific form required for maximum stipple-setting speed.)Tj
-8.3 -2.1 TD
(Another application for this technique is if you're drawing a changing picture and want to leave some)Tj
0 -1.5 TD
(blur behind that gradually fades out to give some indication of past motion. For example, suppose you're)Tj
T*
(simulating a planetary system and you want to leave trails on the planets to show a recent portion of their)Tj
T*
(path. Again, assuming you want to fade in sixteen steps, set up the stipple patterns as before \(using the)Tj
T*
(display-list version, say\), and have the main simulation loop look something like this:)Tj
/F7 1 Tf
0 -2.1 TD
(current_stipple = 0; )Tj
0 -1.5 TD
(while \(1\) {                         /* loop forever */ )Tj
T*
(    draw_the_next_frame\(\); )Tj
T*
(    glCallList\(current_stipple++\); )Tj
T*
(    if \(current_stipple == 16\) current_stipple = 0; )Tj
T*
(    glColor3f\(0.0, 0.0, 0.0\);       /* set color to black */ )Tj
T*
(    draw_a_polygon_large_enough_to_cover_the_whole_region\(\); )Tj
T*
(} )Tj
/F11 1 Tf
0 -2.1 TD
(Each time through the loop, you clear one-sixteenth of the pixels. Any pixel that hasn't had a planet on it)Tj
0 -1.5 TD
(for sixteen frames is certain to be cleared to black. Of course, if your system supports blending in)Tj
T*
[(hardware, it's easier to blend in a certain amount of background color with each frame. \(See )6("Displaying)]TJ
T*
[(Points, Lines, and Polygons" in Chapter 2)44( for polygon stippling details, )-43(Chapter 7)16( for more information)]TJ
T*
[(about display lists, and )18("Blending" in Chapter 6)-22( for information about blending.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 389.000 Tm
(Object Selection Using the Back Buffer)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 367.000 Tm
[(Although the OpenGL selection mechanism \(see )21("Selection" in Chapter 13)-67(\) is powerful and flexible, it)]TJ
T*
(can be cumbersome to use. Often, the situation is simple: Your application draws a scene composed of a)Tj
T*
(substantial number of objects; the user points to an object with the mouse, and the application needs to)Tj
T*
(find the item under the tip of the cursor.)Tj
0 -2.1 TD
(One way to do this requires your application to be running in double-buffer mode. When the user picks)Tj
0 -1.5 TD
(an object, the application redraws the entire scene in the back buffer, but instead of using the normal)Tj
T*
(colors for objects, it encodes some kind of object identifier for each object's color. The application then)Tj
T*
(simply reads back the pixel under the cursor, and the value of that pixel encodes the number of the)Tj
T*
(picked object. If many picks are expected for a single, static picture, you can read the entire color buffer)Tj
T*
(once and look in your copy for each attempted pick, rather than read back each pixel individually.)Tj
0 -2.1 TD
(Note that this scheme has an advantage over standard selection in that it picks the object that's in front if)Tj
0 -1.5 TD
(multiple objects appear at the same pixel, one behind the other. Since the image with false colors is)Tj
T*
(drawn in the back buffer, the user never sees it; you can redraw the back buffer \(or copy it from the front)Tj
0 -1.6 TD
(buffer\) before swapping the buffers. In color-index mode, the encoding is simple)Tj
/F33 1 Tf
32.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(send the object)Tj
-33.4 -1.6 TD
(identifier as the index. In RGBA mode, encode the bits of the identifier into the R, G, and B components.)Tj
0 -2.1 TD
(Be aware that you can run out of identifiers if there are too many objects in the scene. For example,)Tj
0 -1.5 TD
(suppose you're running in color-index mode on a system that has 4-bit buffers for color-index)Tj
T*
(information \(16 possible different indices\) in each of the color buffers, but the scene has thousands of)Tj
T*
(pickable items. To address this issue, the picking can be done in a few passes. To think about this in)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 7)Tj
ET
endstream
endobj
1412 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1414 0 obj
<<
/Length 4200
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(concrete terms, assume there are fewer than 4096 items, so all the object identifiers can be encoded in 12)Tj
0 -1.5 TD
(bits. In the first pass, draw the scene using indices composed of the 4 high-order bits, then use the second)Tj
T*
(and third passes to draw the middle 4 bits and the 4 low-order bits. After each pass, read the pixel under)Tj
T*
(the cursor, extract the bits, and pack them together at the end to get the object identifier.)Tj
0 -2.1 TD
(With this method, the picking takes three times as long, but that's often acceptable. Note that after you)Tj
0 -1.5 TD
(have the high-order 4 bits, you eliminate 15/16 of all objects, so you really need to draw only 1/16 of)Tj
T*
(them for the second pass. Similarly, after the second pass, 255 of the 256 possible items have been)Tj
T*
(eliminated. The first pass thus takes about as long as drawing a single frame does, but the second and)Tj
T*
(third passes can be up to 16 and 256 times as fast.)Tj
0 -2.1 TD
(If you're trying to write portable code that works on different systems, break up your object identifiers)Tj
0 -1.5 TD
(into chunks that fit on the lowest common denominator of those systems. Also, keep in mind that your)Tj
T*
(system might perform automatic dithering in RGB mode. If this is the case, turn off dithering.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 499.000 Tm
(Cheap Image Transformation)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 477.000 Tm
(If you want to draw a distorted version of a bitmapped image \(perhaps simply stretched or rotated, or)Tj
T*
(perhaps drastically modified by some mathematical function\), there are many possibilities. You can use)Tj
T*
(the image as a texture map, which allows you to scale, rotate, or otherwise distort the image. If you just)Tj
T*
(want to scale the image, you can use )Tj
/F15 1 Tf
14.9 0 TD
(glPixelZoom\(\))Tj
/F11 1 Tf
5.7 0 TD
(.)Tj
-20.6 -2.1 TD
(In many cases, you can achieve good results by drawing the image of each pixel as a quadrilateral.)Tj
0 -1.5 TD
(Although this scheme doesn't produce images that are as nice as those you would get by applying a)Tj
T*
(sophisticated filtering algorithm \(and it might not be sufficient for sophisticated users\), it's a lot quicker.)Tj
0 -2.1 TD
(To make the problem more concrete, assume that the original image is )Tj
/F15 1 Tf
28.4 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
( pixels by )Tj
/F15 1 Tf
4.2 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( pixels, with)Tj
-33.8 -1.6 TD
(coordinates chosen from [0,)Tj
/F15 1 Tf
11.2 0 TD
( m)Tj
/F11 1 Tf
0.9 0 TD
(-1] )Tj
/F33 1 Tf
1.5 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
( [0,)Tj
/F15 1 Tf
1.3 0 TD
( n)Tj
/F11 1 Tf
0.8 0 TD
(-1]. Let the distortion functions be )Tj
/F15 1 Tf
14 0 TD
(x\(m,n\))Tj
/F11 1 Tf
2.5 0 TD
( and)Tj
/F15 1 Tf
1.7 0 TD
( y\(m,n\))Tj
/F11 1 Tf
2.9 0 TD
(. For)Tj
-37.3 -1.6 TD
(example, if the distortion is simply a zooming by a factor of 3.2, then )Tj
/F15 1 Tf
28 0 TD
(x\(m,n\))Tj
/F11 1 Tf
2.6 0 TD
( = 3.2*)Tj
/F15 1 Tf
2.8 0 TD
(m)Tj
/F11 1 Tf
0.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(y\(m,n\) )Tj
/F11 1 Tf
2.9 0 TD
(= 3.2*)Tj
/F15 1 Tf
2.5 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(.)Tj
-41.9 -1.5 TD
(The following code draws the distorted image:)Tj
/F7 1 Tf
0 -2 TD
(glShadeModel\(GL_FLAT\);)Tj
0 -1.5 TD
(glScale\(3.2, 3.2, 1.0\);)Tj
T*
(for \(j=0; j < n; j++\) {)Tj
T*
(    glBegin\(GL_QUAD_STRIP\);)Tj
T*
(    for \(i=0; i <= m; i++\) {)Tj
T*
(        glVertex2i\(i,j\);)Tj
T*
(        glVertex2i\(i, j+1\);)Tj
T*
(        set_color\(i,j\);)Tj
T*
(    })Tj
T*
(    glEnd\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.2 TD
(This code draws each transformed pixel in a solid color equal to that pixel's color and scales the image)Tj
0 -1.5 TD
(size by 3.2. The routine )Tj
/F13 1 Tf
9.7 0 TD
(set_color\(\))Tj
/F11 1 Tf
4.5 0 TD
( stands for whatever the appropriate OpenGL command is to set the)Tj
-14.2 -1.5 TD
(color of the image pixel.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 8)Tj
ET
endstream
endobj
1415 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1417 0 obj
<<
/Length 3290
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The following is a slightly more complex version that distorts the image using the functions )Tj
/F15 1 Tf
37 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(i,j)Tj
/F11 1 Tf
0.9 0 TD
(\) and)Tj
/F15 1 Tf
-38.6 -1.5 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(\()Tj
/F15 1 Tf
0.4 0 TD
(i,j)Tj
/F11 1 Tf
0.8 0 TD
(\):)Tj
/F7 1 Tf
-1.6 -2.1 TD
(glShadeModel\(GL_FLAT\);)Tj
0 -1.5 TD
(for \(j=0; j < n; j++\) {)Tj
T*
(    glBegin\(GL_QUAD_STRIP\);)Tj
T*
(    for \(i=0; i <= m; i++\) {)Tj
T*
(        glVertex2i\(x\(i,j\), y\(i,j\)\);)Tj
T*
(        glVertex2i\(x\(i,j+1\), y\(i,j+1\)\);)Tj
T*
(        set_color\(i,j\);)Tj
T*
(    })Tj
T*
(    glEnd\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(An even better distorted image can be drawn with the following code:)Tj
/F7 1 Tf
T*
(glShadeModel\(GL_SMOOTH\);)Tj
0 -1.5 TD
(for \(j=0; j < \(n-1\); j++\) {)Tj
T*
(    glBegin\(GL_QUAD_STRIP\);)Tj
T*
(    for \(i=0; i < m; i++\) {)Tj
T*
(        set_color\(i,j\);)Tj
T*
(        glVertex2i\(x\(i,j\), y\(i,j\)\);)Tj
T*
(        set_color\(i,j+1\);)Tj
T*
(        glVertex2i\(x\(i,j+1\), y\(i,j+1\)\);)Tj
T*
(    })Tj
T*
(    glEnd\(\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
(This code smoothly interpolates color across each quadrilateral. Note that this version produces one)Tj
0 -1.5 TD
(fewer quadrilateral in each dimension than do the flat-shaded versions, because the color image is being)Tj
T*
(used to specify colors at the quadrilateral vertices. In addition, you can antialias the polygons with the)Tj
T*
(appropriate blending function \(GL_SRC_ALPHA, GL_ONE\) to get an even nicer image.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 248.000 Tm
(Displaying Layers)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 226.000 Tm
(In some applications such as semiconductor layout programs, you want to display multiple different)Tj
T*
(layers of materials and indicate where the materials overlap each other.)Tj
0 -2.1 TD
(As a simple example, suppose you have three different substances that can be layered. At any point, eight)Tj
0 -1.5 TD
[(possible combinations of layers can occur, as shown in )22(Table 14-2)191(.)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 164.190 m
481.000 164.190 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 147.000 156.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(Layer 1)-5497(Layer 2)-5372(Layer 3)-5372(Color)]TJ
ET
Q
124.000 150.670 m
481.000 150.670 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 143.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
[(0)-2056(absent)-5445(absent)-5334(absent)-5334(black)]TJ
0 -1.4444 TD
[(1)-2056(present)-5112(absent)-5334(absent)-5334(red)]TJ
0 -1.5556 TD
[(2)-2056(absent)-5445(present)-5000(absent)-5334(green)]TJ
0 -1.4444 TD
[(3)-2056(present)-5112(present)-5000(absent)-5334(blue)]TJ
T*
[(4)-2056(absent)-5445(absent)-5334(present)-5000(pink)]TJ
T*
[(5)-2056(present)-5112(absent)-5334(present)-5000(yellow)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 9)Tj
ET
endstream
endobj
1418 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1419 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im109
/Width 707
/Height 357
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.108)
>>
stream
endstream
endobj
1421 0 obj
<<
/Length 3366
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 124.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
[(6)-2056(absent)-5445(present)-5000(present)-5000(white)]TJ
0 -1.4445 TD
[(7)-2056(present)-5112(present)-5000(present)-5000(gray)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 691.410 m
481.010 691.410 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 675.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table 14-2 )Tj
/F11 1 Tf
5.2 0 TD
(Eight Combinations of Layers)Tj
-5.2 -2.1 TD
(You want your program to display eight different colors, depending on the layers present. One arbitrary)Tj
0 -1.5 TD
(possibility is shown in the last column of the table. To use this method, use color-index mode and load)Tj
T*
(your color map so that entry 0 is black, entry 1 is red, entry 2 is green, and so on. Note that if the)Tj
T*
(numbers from 0 through 7 are written in binary, the 4 bit is turned on whenever layer 3 appears, the 2 bit)Tj
T*
(whenever layer 2 appears, and the 1 bit whenever layer 1 appears.)Tj
0 -2.1 TD
(To clear the window, set the writemask to 7 \(all three layers\) and set the clearing color to 0. To draw)Tj
0 -1.5 TD
(your image, set the color to 7, and then when you want to draw something in layer )Tj
/F15 1 Tf
33.2 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(, set the writemask to)Tj
/F15 1 Tf
-33.7 -1.5 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(. In other types of applications, it might be necessary to selectively erase in a layer, in which case you)Tj
-0.5 -1.5 TD
[(would use the writemasks just discussed, but set the color to 0 instead of 7. \(See )-21("Masking Buffers" in)]TJ
T*
[(Chapter 10)16( for more information about writemasks.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 479.000 Tm
(Antialiased Characters)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 457.000 Tm
(Using the standard technique for drawing characters with )Tj
/F15 1 Tf
23.2 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
(, drawing each pixel of a character is)Tj
-27.5 -1.6 TD
(an all-or-nothing affair)Tj
/F33 1 Tf
9.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the pixel is either turned on or not. If you're drawing black characters on a)Tj
-10.2 -1.5 TD
(white background, for example, the resulting pixels are either black or white, never a shade of gray.)Tj
T*
(Much smoother, higher-quality images can be achieved if intermediate colors are used when rendering)Tj
T*
(characters \(grays, in this example\).)Tj
0 -2.1 TD
(Assuming that you're drawing black characters on a white background, imagine a highly magnified)Tj
0 -1.5 TD
(picture of the pixels on the screen, with a high-resolution character outline superimposed on it, as shown)Tj
T*
[(in the left side of )28(Figure 14-1)226(.)]TJ
ET
Q
q
124.000 330.380 422.990 -213.590 re
W n
q
423 0 0 214 124 116.38 cm
/Im109 Do
Q
Q
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 104.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 14-1 )Tj
/F11 1 Tf
5.6 0 TD
(Antialiased Characters)Tj
-5.6 -2.1 TD
(Notice that some of the pixels are completely enclosed by the character's outline and should be painted)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 10)Tj
ET
endstream
endobj
1422 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im109 1419 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1424 0 obj
<<
/Length 4373
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(black; some pixels are completely outside the outline and should be painted white; but many pixels)Tj
0 -1.5 TD
(should ideally be painted some shade of gray, where the darkness of the gray corresponds to the amount)Tj
T*
(of black in the pixel. If this technique is used, the resulting image on the screen looks better.)Tj
0 -2.1 TD
(If speed and memory usage are of no concern, each character can be drawn as a small image instead of as)Tj
0 -1.5 TD
(a bitmap. If you're using RGBA mode, however, this method might require up to 32 bits per pixel of the)Tj
T*
(character to be stored and drawn, instead of the 1 bit per pixel in a standard character. Alternatively, you)Tj
T*
(could use one 8-bit index per pixel and convert these indices to RGBA by table lookup during transfer. In)Tj
T*
(many cases, a compromise is possible that allows you to draw the character with a few gray levels)Tj
T*
(between black and white \(say, two or three\), and the resulting font description requires only 2 or 3 bits)Tj
T*
(per pixel of storage.)Tj
0 -2.1 TD
[(The numbers in the right side of )-16(Figure 14-1)226( indicate the approximate percentage coverage of each pixel:)]TJ
0 -1.5 TD
(0 means approximately empty, 1 means approximately one-third coverage, 2 means two-thirds, and 3)Tj
T*
(means completely covered. If pixels labeled 0 are painted white, pixels labeled 3 are painted black, and)Tj
T*
(pixels labeled 1 and 2 are painted one-third and two-thirds black, respectively, the resulting character)Tj
T*
(looks quite good. Only 2 bits are required to store the numbers 0, 1, 2, and 3, so for 2 bits per pixel, four)Tj
T*
(levels of gray can be saved.)Tj
0 -2.1 TD
(There are basically two methods to implement antialiased characters, depending on whether you're in)Tj
0 -1.5 TD
(RGBA or color-index mode.)Tj
0 -2.1 TD
(In RGBA mode, define three different character bitmaps, corresponding to where 1, 2, and 3 appear in)Tj
0 -1.5 TD
[(Figure 14-1)226(. Set the color to white, and clear for the background. Set the color to one-third gray \(RGB =)]TJ
T*
(\(0.666, 0.666, 0.666\)\), and draw all the pixels with a 1 in them. Then set RGB = \(0.333, 0.333, 0.333\),)Tj
T*
(draw with the 2 bitmap, and use RGB = \(0.0, 0.0, 0.0\) for the 3 bitmap. What you're doing is defining)Tj
T*
(three different fonts and redrawing the string three times, where each pass fills in the bits of the)Tj
T*
(appropriate color densities.)Tj
0 -2.1 TD
(In color-index mode, you can do exactly the same thing, but if you're willing to set up the color map)Tj
0 -1.5 TD
(correctly and use writemasks, you can get away with only two bitmaps per character and two passes per)Tj
T*
(string. In the preceding example, set up one bitmap that has a 1 wherever 1 or 3 appears in the character.)Tj
T*
(Set up a second bitmap that has a 1 wherever a 2 or a 3 appears. Load the color map so that 0 gives)Tj
T*
(white, 1 gives light gray, 2 gives dark gray, and 3 gives black. Set the color to 3 \(11 in binary\) and the)Tj
T*
(writemask to 1, and draw the first bitmap. Then change the writemask to 2, and draw the second. Where)Tj
T*
[(0 appears in )-17(Figure 14-1)226(, nothing is drawn in the framebuffer. Where 1, 2, and 3 appear, 1, 2, and 3)]TJ
T*
(appear in the framebuffer.)Tj
0 -2.2 TD
(For this example with only four gray levels, the savings is small)Tj
/F33 1 Tf
25.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(two passes instead of three. If eight)Tj
-26.6 -1.6 TD
(gray levels were used instead, the RGBA method would require seven passes, and the color-map masking)Tj
0 -1.5 TD
(technique would require only three. With sixteen gray levels, the comparison is fifteen passes to four)Tj
T*
[(passes. \(See )-17("Masking Buffers" in Chapter 10)61( for more information about writemasks and )-84("Bitmaps and)]TJ
T*
[(Fonts" in Chapter 8)26( for more information about drawing bitmaps.\))]TJ
/F27 1 Tf
0 -3 TD
(Try This)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Can you see how to do RGBA rendering using no more images than the optimized color-index case?)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 11)Tj
ET
endstream
endobj
1425 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1426 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im110
/Width 104
/Height 52
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.109)
>>
stream
endstream
endobj
1427 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im111
/Width 369
/Height 65
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.110)
>>
stream
endstream
endobj
1429 0 obj
<<
/Length 3578
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Hint: How are RGB fragments normally merged into the color buffer when antialiasing is desired?)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 671.000 Tm
(Drawing Round Points)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 649.000 Tm
(Draw near-round, aliased points by enabling point antialiasing, turning blending off, and using an alpha)Tj
0 -1.5 TD
[(function that passes only fragments with alpha greater than 0.5. \(See )37("Antialiasing")6( and )-56("Blending" in)]TJ
T*
[(Chapter 6)16( for more information about these topics.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 586.000 Tm
(Interpolating Images)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 564.000 Tm
(Suppose you have a pair of images \(where )Tj
/F15 1 Tf
17.2 0 TD
(image)Tj
/F11 1 Tf
2.5 0 TD
( can mean a bitmap image, or a picture generated using)Tj
-19.7 -1.5 TD
(geometry in the usual way\), and you want to smoothly blend from one to the other. This can be done)Tj
T*
(easily using the alpha component and appropriate blending operations. Let's say you want to accomplish)Tj
T*
(the blending in ten steps, where image A is shown in frame 0 and image B is shown in frame 9. The)Tj
0 -1.6 TD
(obvious approach is to draw image A with alpha equal to \(9-)Tj
/F33 1 Tf
24.2 0 TD
(i)Tj
/F11 1 Tf
0.4 0 TD
(\)/9 and image B with an alpha of )Tj
/F15 1 Tf
13.4 0 TD
(i)Tj
/F11 1 Tf
0.2 0 TD
(/9 in)Tj
-38.2 -1.6 TD
(frame )Tj
/F15 1 Tf
2.6 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
(.)Tj
-2.9 -2.1 TD
(The problem with this method is that both images must be drawn in each frame. A faster approach is to)Tj
0 -1.5 TD
(draw image A in frame 0. To get frame 1, blend in 1/9 of image B and 8/9 of what's there. For frame 2,)Tj
T*
(blend in 1/8 of image B with 7/8 of what's there. For frame 3, blend in 1/7 of image B with 6/7 of what's)Tj
T*
(there, and so on. For the last step, you're just drawing 1/1 of image B blended with 0/1 of what's left,)Tj
T*
(yielding image B exactly.)Tj
0 -2.1 TD
(To see that this works, if for frame )Tj
/F15 1 Tf
14.1 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
( you have)Tj
ET
Q
/GS1 gs
q
104 0 0 52 124 318.67 cm
/Im110 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 293.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(and you blend in B/\(9-)Tj
/F33 1 Tf
9.1 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
(\) with \(8-)Tj
/F33 1 Tf
3.8 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
(\)/\(9-)Tj
/F33 1 Tf
1.8 0 TD
(i)Tj
/F11 1 Tf
0.3 0 TD
(\) of what's there, you get)Tj
ET
Q
q
369 0 0 65 124 212.8 cm
/Im111 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 194.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(\(See )27("Blending" in Chapter 6)-22(.)0(\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 160.000 Tm
(Making Decals)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 138.000 Tm
(Suppose you're drawing a complex three-dimensional picture using depth-buffering to eliminate the)Tj
0 -1.5 TD
(hidden surfaces. Suppose further that one part of your picture is composed of coplanar figures A and B,)Tj
T*
(where B is a sort of decal that should always appear on top of figure A.)Tj
0 -2.1 TD
(Your first approach might be to draw B after you've drawn A, setting the depth-buffering function to)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 12)Tj
ET
endstream
endobj
1430 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im110 1426 0 R
/Im111 1427 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1433 0 obj
<<
/Length 2929
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(replace on greater or equal. Due to the finite precision of the floating-point representations of the)Tj
0 -1.5 TD
(vertices, however, round-off error can cause polygon B to be sometimes a bit in front and sometimes a)Tj
T*
(bit behind figure A. Here's one solution to this problem.)Tj
0 -2.1 TD
[(1.)-1050(Disable the depth buffer for writing, and render A.)]TJ
T*
[(2.)-1050(Enable the depth buffer for writing, and render B.)]TJ
T*
[(3.)-1050(Disable the color buffer for writing, and render A again.)]TJ
T*
[(4.)-1050(Enable the color buffer for writing.)]TJ
0 -2.6 TD
(Note that during the entire process, the depth-buffer test is enabled. In step 1, A is rendered wherever it)Tj
0 -1.5 TD
(should be, but none of the depth-buffer values are changed; thus, in step 2, wherever B appears over A, B)Tj
T*
(is guaranteed to be drawn. Step 3 simply makes sure that all of the depth values under A are updated)Tj
T*
(correctly, but since RGBA writes are disabled, the color pixels are unaffected. Finally, step 4 returns the)Tj
T*
(system to the default state \(writing is enabled both in the depth buffer and in the color buffer\).)Tj
0 -2.1 TD
(If a stencil buffer is available, the following simpler technique works.)Tj
T*
[(1.)-1050(Configure the stencil buffer to write one if the depth test passes, and zero otherwise. Render A.)]TJ
T*
[(2.)-1050(Configure the stencil buffer to make no stencil value change, but to render only where stencil values)]TJ
1.8 -1.5 TD
(are one. Disable the depth-buffer test and its update. Render B.)Tj
-1.8 -2.6 TD
(With this method, it's not necessary to initialize the contents of the stencil buffer at any time, because the)Tj
0 -1.5 TD
(stencil value of all pixels of interest \(that is, those rendered by A\) are set when A is rendered. Be sure to)Tj
T*
[(reenable the depth test and disable the stencil test before additional polygons are drawn. \(See )42("Selecting)]TJ
T*
[(Color Buffers for Writing and Reading,")41("Depth Test,")-17( and )-56("Stencil Test" in Chapter 10)61(.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 328.000 Tm
(Drawing Filled, Concave Polygons Using the Stencil Buffer)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 306.000 Tm
[(Consider the concave polygon 1234567 shown in )28(Figure 14-2)226(. Imagine that it's drawn as a series of)]TJ
T*
(triangles: 123, 134, 145, 156, 167, all of which are shown in the figure. The heavier line represents the)Tj
T*
(original polygon boundary. Drawing all these triangles divides the buffer into nine regions A, B, C, ..., I,)Tj
T*
(where region I is outside all the triangles.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 13)Tj
ET
endstream
endobj
1434 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1435 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im112
/Width 907
/Height 587
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.111)
>>
stream
endstream
endobj
1437 0 obj
<<
/Length 2877
>>
stream
q
1 i 
124.000 720.000 422.990 -273.760 re
W n
/GS1 gs
q
423 0 0 274 124 446 cm
/Im112 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 434.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure 14-2 )Tj
/F11 1 Tf
5.6 0 TD
(Concave Polygon)Tj
-5.6 -2.2 TD
(In the text of the figure, each of the region names is followed by a list of the triangles that cover it.)Tj
0 -1.5 TD
(Regions A, D, and F make up the original polygon; note that these three regions are covered by an odd)Tj
T*
(number of triangles. Every other region is covered by an even number of triangles \(possibly zero\). Thus,)Tj
T*
(to render the inside of the concave polygon, you just need to render regions that are enclosed by an odd)Tj
T*
(number of triangles. This can be done using the stencil buffer, with a two-pass algorithm.)Tj
0 -2.1 TD
(First, clear the stencil buffer and disable writing into the color buffer. Next, draw each of the triangles in)Tj
0 -1.5 TD
(turn, using the GL_INVERT function in the stencil buffer. \(For best performance, use triangle fans.\) This)Tj
T*
(flips the value between zero and a nonzero value every time a triangle is drawn that covers a pixel. After)Tj
T*
(all the triangles are drawn, if a pixel is covered an even number of times, the value in the stencil buffers)Tj
T*
(is zero; otherwise, it's nonzero. Finally, draw a large polygon over the whole region \(or redraw the)Tj
T*
(triangles\), but allow drawing only where the stencil buffer is nonzero.)Tj
/F27 1 Tf
0 -2 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(There's a slight generalization of the preceding technique, where you don't need to start with a)Tj
-2.8 -1.5 TD
(polygon vertex. In the 1234567 example, let P be any point on or off the polygon. Draw the triangles:)Tj
0 -1.4 TD
(P12, P23, P34, P45, P56, P67, and P71. Regions covered by an odd number of triangles are inside; other)Tj
T*
(regions are outside. This is a generalization in that if P happens to be one of the polygon's edges, one of)Tj
0 -1.5 TD
(the triangles is empty.)Tj
0 -2.1 TD
(This technique can be used to fill both nonsimple polygons \(polygons whose edges cross each other\) and)Tj
0 -1.5 TD
(polygons with holes. The following example illustrates how to handle a complicated polygon with two)Tj
T*
(regions, one four-sided and one five-sided. Assume further that there's a triangular and a four-sided hole)Tj
T*
(\(it doesn't matter in which regions the holes lie\). Let the two regions be abcd and efghi, and the holes jkl)Tj
T*
(and mnop. Let z be any point on the plane. Draw the following triangles:)Tj
0 -2.1 TD
(zab zbc zcd zda zef zfg zgh zhi zie zjk zkl zlj zmn zno zop zpm)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 14)Tj
ET
endstream
endobj
1438 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im112 1435 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1440 0 obj
<<
/Length 4888
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 703.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Mark regions covered by an odd number of triangles as )Tj
/F15 1 Tf
22.4 0 TD
(in)Tj
/F11 1 Tf
0.8 0 TD
(, and those covered by an even number as )Tj
/F15 1 Tf
16.9 0 TD
(out)Tj
/F11 1 Tf
1.3 0 TD
(.)Tj
-41.4 -1.5 TD
[(\(See )27("Stencil Test" in Chapter 10)-39( for more information about the stencil buffer.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 655.000 Tm
(Finding Interference Regions)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 633.000 Tm
(If you're designing a mechanical part made from smaller three-dimensional pieces, you often want to)Tj
T*
(display regions where the pieces overlap. In many cases, such regions indicate design errors where parts)Tj
T*
(of a machine interfere with each other. In the case of moving parts, it can be even more valuable, since a)Tj
T*
(search for interfering regions can be done through a complete mechanical cycle of the design. The)Tj
T*
(method for doing this is complicated, and the description here might be too brief. Complete details can)Tj
T*
(be found in the paper )Tj
/F15 1 Tf
8.7 0 TD
(Interactive Inspection of Solids: Cross-sections and Interferences)Tj
/F11 1 Tf
26.3 0 TD
(, by Jarek)Tj
-35 -1.5 TD
(Rossignac, Abe Megahed, and Bengt-Olaf Schneider \(SIGGRAPH 1992 Proceedings\).)Tj
0 -2.1 TD
[(The method is related to the capping algorithm described in )11("Stencil Test" in Chapter 10)-39(. The idea is to)]TJ
0 -1.5 TD
(pass an arbitrary clipping plane through the objects that you want to test for interference, and then)Tj
T*
(determine when a portion of the clipping plane is inside more than one object at a time. For a static)Tj
T*
(image, the clipping plane can be moved manually to highlight interfering regions; for a dynamic image, it)Tj
T*
(might be easier to use a grid of clipping planes to search for all possible interferences.)Tj
0 -2.1 TD
(Draw each of the objects you want to check and clip them against the clipping plane. Note which pixels)Tj
0 -1.5 TD
(are inside the object at that clipping plane using an odd-even count in the stencil buffer, as explained in)Tj
T*
(the preceding section. \(For properly formed objects, a point is inside the object if a ray drawn from that)Tj
T*
(point to the eye intersects an odd number of surfaces of the object.\) To find interferences, you need to)Tj
T*
(find pixels in the framebuffer where the clipping plane is in the interior of two or more regions at once;)Tj
T*
(in other words, in the intersection of the interiors of any pair of objects.)Tj
0 -2.1 TD
(If multiple objects need to be tested for mutual intersection, store 1 bit every time some intersection)Tj
0 -1.5 TD
(appears, and another bit wherever the clipping buffer is inside any of the objects \(the union of the)Tj
T*
(objects' interiors\). For each new object, determine its interior, find the intersection of that interior with)Tj
T*
(the union of the interiors of the objects so far tested, and keep track of the intersection points. Then add)Tj
T*
(the interior points of the new object to the union of the other objects' interiors.)Tj
0 -2.1 TD
(You can perform the operations described in the preceding paragraph by using different bits in the stencil)Tj
0 -1.6 TD
(buffer together with various masking operations. Three bits of stencil buffer are required per pixel)Tj
/F33 1 Tf
39.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(one)Tj
-40.2 -1.6 TD
(for the toggling to determine the interior of each object, one for the union of all interiors discovered so)Tj
0 -1.5 TD
(far, and one for the regions where interference has occurred so far. To make this discussion more)Tj
T*
(concrete, assume the 1 bit of the stencil buffer is for toggling interior/exterior, the 2 bit is the running)Tj
T*
(union, and the 4 bit is for interferences so far. For each object that you're going to render, clear the 1 bit)Tj
T*
(\(using a stencil mask of one and clearing to zero\), then toggle the 1 bit by keeping the stencil mask as)Tj
T*
(one and using the GL_INVERT stencil operation.)Tj
0 -2.1 TD
(You can find intersections and unions of the bits in the stencil buffers using the stenciling operations. For)Tj
0 -1.5 TD
(example, to make bits in buffer 2 be the union of the bits in buffers 1 and 2, mask the stencil to those 2)Tj
T*
(bits, and draw something over the entire object with the stencil function set to pass if anything nonzero)Tj
T*
(occurs. This happens if the bits in buffer 1, buffer 2, or both are turned on. If the comparison succeeds,)Tj
T*
(write a 1 in buffer 2. Also, make sure that drawing in the color buffer is disabled. An intersection)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 15)Tj
ET
endstream
endobj
1441 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1442 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im113
/Width 120
/Height 92
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.112)
>>
stream
endstream
endobj
1444 0 obj
<<
/Length 4702
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(calculation is similar)Tj
/F33 1 Tf
8.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(set the function to pass only if the value in the two buffers is equal to 3 \(bits)Tj
-9.3 -1.6 TD
[(turned on in both buffers 1 and 2\). Write the result into the correct buffer. \(See )19("Stencil Test" in Chapter)]TJ
0 -1.5 TD
(10.\))Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 643.000 Tm
(Shadows)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 621.000 Tm
(Every possible projection of three-dimensional space to three-dimensional space can be achieved with a)Tj
0 -1.6 TD
(suitable 4)Tj
/F33 1 Tf
3.9 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 invertible matrix and homogeneous coordinates. If the matrix isn't invertible but has rank 3,)Tj
-4.4 -1.6 TD
(it projects three-dimensional space onto a two-dimensional plane. Every such possible projection can be)Tj
T*
(achieved with a suitable rank-3 4)Tj
/F33 1 Tf
13.2 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(4 matrix. To find the shadow of an arbitrary object on an arbitrary)Tj
-13.8 -1.5 TD
(plane from an arbitrary light source \(possibly at infinity\), you need to find a matrix representing that)Tj
T*
(projection, multiply it on the matrix stack, and draw the object in the shadow color. Keep in mind that)Tj
T*
(you need to project onto each plane that you're calling the "ground.")Tj
0 -2.1 TD
(As a simple illustration, assume the light is at the origin, and the equation of the ground plane is)Tj
/F15 1 Tf
0 -1.7 TD
(ax)Tj
/F11 1 Tf
0.9 0 TD
(+)Tj
/F15 1 Tf
0.6 0 TD
(by)Tj
/F11 1 Tf
1 0 TD
(+)Tj
/F15 1 Tf
0.5 0 TD
(c)Tj
/F11 1 Tf
0.5 0 TD
(+)Tj
/F15 1 Tf
0.5 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
(=0. Given a vertex S=\()Tj
/F15 1 Tf
9.2 0 TD
(sx,sy,sz)Tj
/F11 1 Tf
2.9 0 TD
(,1\), the line from the light through S includes all points )Tj
/F33 1 Tf
22.3 0 TD
(a)Tj
/F11 1 Tf
0.6 0 TD
(S,)Tj
-39.5 -1.6 TD
(where )Tj
/F33 1 Tf
2.7 0 TD
(a)Tj
/F11 1 Tf
0.6 0 TD
( is an arbitrary real number. The point where this line intersects the plane occurs when)Tj
/F33 1 Tf
-3.3 -2.3 TD
(a)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.4 0 TD
(a*sz)Tj
/F11 1 Tf
1.7 0 TD
(+)Tj
/F15 1 Tf
0.6 0 TD
(b*sy)Tj
/F11 1 Tf
1.8 0 TD
(+)Tj
/F15 1 Tf
0.6 0 TD
(c*sz)Tj
/F11 1 Tf
1.7 0 TD
(\) + )Tj
/F15 1 Tf
1.4 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
( = 0,)Tj
-9.3 -2.2 TD
(so)Tj
/F33 1 Tf
T*
(a)Tj
/F11 1 Tf
0.6 0 TD
( = -)Tj
/F33 1 Tf
1.4 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
(/\()Tj
/F15 1 Tf
0.6 0 TD
(a*sx)Tj
/F11 1 Tf
1.9 0 TD
(+)Tj
/F15 1 Tf
0.5 0 TD
(b*sy)Tj
/F11 1 Tf
1.9 0 TD
(+)Tj
/F15 1 Tf
0.5 0 TD
(c*sz)Tj
/F11 1 Tf
1.7 0 TD
(\).)Tj
-9.6 -2.2 TD
(Plugging this back into the line, we get)Tj
T*
(-)Tj
/F33 1 Tf
0.3 0 TD
(d)Tj
/F15 1 Tf
0.5 0 TD
(\()Tj
/F33 1 Tf
0.4 0 TD
-0.003 Tc
(sx)Tj
/F15 1 Tf
1.1 0 TD
0.000 Tc
(,)Tj
/F33 1 Tf
0.2 0 TD
-0.003 Tc
(sy)Tj
/F15 1 Tf
1.3 0 TD
0.000 Tc
(,)Tj
/F33 1 Tf
0.2 0 TD
-0.003 Tc
(sz)Tj
/F15 1 Tf
1.1 0 TD
0.000 Tc
(\)/\()Tj
/F33 1 Tf
1 0 TD
(a)Tj
/F15 1 Tf
0.6 0 TD
(*)Tj
/F33 1 Tf
0.5 0 TD
-0.003 Tc
(sx)Tj
/F15 1 Tf
1.1 0 TD
0.000 Tc
(+)Tj
/F33 1 Tf
0.7 0 TD
(b)Tj
/F15 1 Tf
0.5 0 TD
(*)Tj
/F33 1 Tf
0.5 0 TD
-0.003 Tc
(sy)Tj
/F15 1 Tf
1.3 0 TD
0.000 Tc
(+)Tj
/F33 1 Tf
0.7 0 TD
(c)Tj
/F15 1 Tf
0.6 0 TD
(*)Tj
/F33 1 Tf
0.5 0 TD
-0.003 Tc
(sz)Tj
/F15 1 Tf
1 0 TD
0.000 Tc
(\))Tj
/F11 1 Tf
-14.1 -2.2 TD
(for the point of intersection.)Tj
0 -1.7 TD
(The matrix that maps S to this point for every S is)Tj
ET
Q
/GS1 gs
q
120 0 0 92 124 217.91 cm
/Im113 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 203.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(This matrix can be used if you first translate the world so that the light is at the origin.)Tj
0 -2.1 TD
(If the light is from an infinite source, all you have is a point S and a direction D = \()Tj
/F15 1 Tf
33.2 0 TD
(dx,dy,dz)Tj
/F11 1 Tf
3.3 0 TD
(\). Points along)Tj
-36.5 -1.5 TD
(the line are given by)Tj
0 -2.2 TD
(S + )Tj
/F33 1 Tf
1.6 0 TD
(a)Tj
/F11 1 Tf
0.7 0 TD
(D)Tj
-2.3 -2.2 TD
(Proceeding as before, the intersection of this line with the plane is given by)Tj
T*
(a\(sx+)Tj
/F33 1 Tf
2.2 0 TD
(a)Tj
/F11 1 Tf
0.7 0 TD
(dx\)+b\(sy+)Tj
/F33 1 Tf
4.1 0 TD
(a)Tj
/F11 1 Tf
0.7 0 TD
(dy\)+c\(sz+)Tj
/F33 1 Tf
4 0 TD
(a)Tj
/F11 1 Tf
0.7 0 TD
(dz\)+d = 0)Tj
-12.4 -2.3 TD
(Solving for )Tj
/F33 1 Tf
4.8 0 TD
(a)Tj
/F11 1 Tf
0.6 0 TD
(, plugging that back into the equation for a line, and then determining a projection matrix)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 16)Tj
ET
endstream
endobj
1445 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im113 1442 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1446 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im114
/Width 414
/Height 92
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.113)
>>
stream
endstream
endobj
1448 0 obj
<<
/Length 2935
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(gives)Tj
ET
Q
/GS1 gs
q
414 0 0 92 124 604.14 cm
/Im114 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 585.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(This matrix works given the plane and an arbitrary direction vector. There's no need to translate anything)Tj
0 -1.5 TD
[(first. \(See )38(Chapter 3)-84( and )44(Appendix F)51(.)0(\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 537.000 Tm
(Hidden-Line Removal)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 515.000 Tm
(If you want to draw a wireframe object with hidden lines removed, one approach is to draw the outlines)Tj
T*
(using lines and then fill the interiors of the polygons making up the surface with polygons having the)Tj
T*
(background color. With depth-buffering enabled, this interior fill covers any outlines that would be)Tj
T*
(obscured by faces closer to the eye. This method would work, except that there's no guarantee that the)Tj
T*
(interior of the object falls entirely inside the polygon's outline; in fact, it might overlap it in various)Tj
T*
(places.)Tj
0 -2.1 TD
(There's an easy, two-pass solution using either polygon offset or the stencil buffer. Polygon offset is)Tj
0 -1.5 TD
(usually the preferred technique, since polygon offset is almost always faster than stencil buffer. Both)Tj
T*
(methods are described here, so you can see how both approaches to the problem work.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 360.000 Tm
(Hidden-Line Removal with Polygon Offset)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 338.000 Tm
(To use polygon offset to accomplish hidden-line removal, the object is drawn twice. The highlighted)Tj
T*
(edges are drawn in the foreground color, using filled polygons but with the polygon mode GL_LINE to)Tj
T*
(rasterize it as a wireframe. Then the filled polygons are drawn with the default polygon mode, which fills)Tj
T*
(the interior of the wireframe, and with enough polygon offset to nudge the filled polygons a little farther)Tj
T*
(from the eye. With the polygon offset, the interior recedes just enough that the highlighted edges are)Tj
T*
(drawn without unpleasant visual artifacts.)Tj
/F7 1 Tf
0 -2 TD
(glEnable\(GL_DEPTH_TEST\);)Tj
0 -1.5 TD
(glPolygonMode\(GL_FRONT_AND_BACK, GL_LINE\);)Tj
T*
(set_color\(foreground\);)Tj
T*
(draw_object_with_filled_polygons\(\);)Tj
0 -3 TD
(glPolygonMode\(GL_FRONT_AND_BACK, GL_FILL\);)Tj
0 -1.5 TD
(glEnable\(GL_POLYGON_OFFSET_FILL\);)Tj
T*
(glPolygonOffset\(1.0, 1.0\);)Tj
T*
(set_color\(background\);)Tj
T*
(draw_object_with_filled_polygons\(\);)Tj
T*
(glDisable\(GL_POLYGON_OFFSET_FILL\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 17)Tj
ET
endstream
endobj
1449 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im114 1446 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1451 0 obj
<<
/Length 3248
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(You may need to adjust the amount of offset needed \(for wider lines, for example\). \(See "Polygon)Tj
0 -1.5 TD
(Offset" in Chapter 6 for more information.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 667.000 Tm
(Hidden-Line Removal with the Stencil Buffer)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 646.000 Tm
(Using the stencil buffer for hidden-line removal is a more complicated procedure. For each polygon,)Tj
T*
(you'll need to clear the stencil buffer, and then draw the outline both in the framebuffer and in the stencil)Tj
T*
(buffer. Then when you fill the interior, enable drawing only where the stencil buffer is still clear. To)Tj
T*
(avoid doing an entire stencil-buffer clear for each polygon, an easy way to clear it is simply to draw 0's)Tj
T*
(into the buffer using the same polygon outline. In this way, you need to clear the entire stencil buffer)Tj
T*
(only once.)Tj
0 -2.1 TD
(For example, the following code represents the inner loop you might use to perform such hidden-line)Tj
0 -1.5 TD
(removal. Each polygon is outlined in the foreground color, filled with the background color, and then)Tj
T*
(outlined again in the foreground color. The stencil buffer is used to keep the fill color of each polygon)Tj
T*
(from overwriting its outline. To optimize performance, the stencil and color parameters are changed only)Tj
T*
(twice per loop by using the same values both times the polygon outline is drawn.)Tj
/F7 1 Tf
0 -2.1 TD
(glEnable\(GL_STENCIL_TEST\);)Tj
0 -1.5 TD
(glEnable\(GL_DEPTH_TEST\);)Tj
T*
(glClear\(GL_STENCIL_BUFFER_BIT\);)Tj
T*
(glStencilFunc\(GL_ALWAYS, 0, 1\);)Tj
T*
(glStencilOp\(GL_INVERT, GL_INVERT, GL_INVERT\);)Tj
T*
(set_color\(foreground\);)Tj
T*
(for \(i=0; i < max; i++\) {)Tj
T*
(    outline_polygon\(i\);)Tj
T*
(    set_color\(background\);)Tj
T*
(    glStencilFunc\(GL_EQUAL, 0, 1\);)Tj
T*
(    glStencilOp\(GL_KEEP, GL_KEEP, GL_KEEP\);)Tj
T*
(    fill_polygon\(i\);)Tj
T*
(    set_color\(foreground\);)Tj
T*
(    glStencilFunc\(GL_ALWAYS, 0, 1\);)Tj
T*
(    glStencilOp\(GL_INVERT, GL_INVERT, GL_INVERT\);)Tj
T*
(    outline_polygon\(i\);)Tj
T*
(})Tj
/F11 1 Tf
0 -2.1 TD
[(\(See )27("Stencil Test" in Chapter 10)-39(.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 174.000 Tm
(Texture-Mapping Applications)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 152.000 Tm
(Texture mapping is quite powerful, and it can be used in some interesting ways. Here are a few advanced)Tj
0 -1.5 TD
(applications of texture mapping.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Antialiased text)Tj
/F33 1 Tf
6.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Define a texture map for each character at a relatively high resolution, and then)Tj
-7.3 -1.6 TD
(map them onto smaller areas using the filtering provided by texturing. This also makes text appear)Tj
0 -1.5 TD
(correctly on surfaces that aren't aligned with the screen, but are tilted and have some perspective)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 18)Tj
ET
endstream
endobj
1452 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1454 0 obj
<<
/Length 4548
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(distortion.)Tj
/F33 1 Tf
-1.8 -2.2 TD
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
(Antialiased lines)Tj
/F33 1 Tf
6.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(These can be done like antialiased text: Make the line in the texture several)Tj
-7.7 -1.6 TD
(pixels wide, and use the texture filtering to antialias the lines.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Image scaling and rotation)Tj
/F33 1 Tf
10.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(If you put an image into a texture map and use that texture to map onto)Tj
-11.6 -1.6 TD
(a polygon, rotating and scaling the polygon effectively rotates and scales the image.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Image warping)Tj
/F33 1 Tf
6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(As in the preceding example, store the image as a texture map, but map it to some)Tj
-7 -1.6 TD
(spline-defined surface \(use evaluators\). As you warp the surface, the image follows the warping.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Projecting images)Tj
/F33 1 Tf
7.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Put the image in a texture map, and project it as a spotlight, creating a slide)Tj
-8.2 -1.5 TD
[(projector effect. \(See )-36("The q Coordinate" in Chapter 9)11( for more information about how to model a)]TJ
T*
(spotlight using textures.\))Tj
-1.9 -2.7 TD
[(\(See )27(Chapter 3)16( for information about rotating and scaling, Chapter 9)-84( for more information about creating)]TJ
0 -1.5 TD
[(textures, and )-39(Chapter 12)16( for details on evaluators.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 469.000 Tm
(Drawing Depth-Buffered Images)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 447.000 Tm
(For complex static backgrounds, the rendering time for the geometric description of the background can)Tj
T*
(be greater than the time it takes to draw a pixel image of the rendered background. If there's a fixed)Tj
T*
(background and a relatively simple changing foreground, you may want to draw the background and its)Tj
T*
(associated depth-buffered version as an image rather than render it geometrically. The foreground might)Tj
T*
(also consist of items that are time-consuming to render, but whose framebuffer images and depth buffers)Tj
T*
(are available. You can render these items into a depth-buffered environment using a two-pass algorithm.)Tj
0 -2.1 TD
(For example, if you're drawing a model of a molecule made of spheres, you might have an image of a)Tj
0 -1.5 TD
(beautifully rendered sphere and its associated depth-buffer values that were calculated using Phong)Tj
T*
(shading or ray-tracing or by using some other scheme that isn't directly available through OpenGL. To)Tj
T*
(draw a complex model, you might be required to draw hundreds of such spheres, which should be)Tj
T*
(depth-buffered together.)Tj
0 -2.1 TD
(To add a depth-buffered image to the scene, first draw the image's depth-buffer values into the depth)Tj
0 -1.5 TD
(buffer using )Tj
/F15 1 Tf
5.1 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
(. Then enable depth-buffering, set the writemask to zero so that no drawing)Tj
-11.3 -1.5 TD
(occurs, and enable stenciling such that the stencil buffers get drawn whenever a write to the depth buffer)Tj
T*
(occurs.)Tj
0 -2.1 TD
(Then draw the image into the color buffer, masked by the stencil buffer you've just written so that)Tj
0 -1.5 TD
(writing occurs only when there's a 1 in the stencil buffer. During this write, set the stenciling function to)Tj
T*
(zero out the stencil buffer so that it's automatically cleared when it's time to add the next image to the)Tj
T*
(scene. If the objects are to be moved nearer to or farther from the viewer, you need to use an)Tj
T*
(orthographic projection; in these cases, you use GL_DEPTH_BIAS with )Tj
/F15 1 Tf
29.3 0 TD
(glPixelTransfer*\(\))Tj
/F11 1 Tf
7.5 0 TD
( to move the)Tj
-36.8 -1.5 TD
[(depth image. \(See )44("Coordinate System Survival Kit" in Chapter 2)-82(,)0( "Depth Test")33( and )44("Stencil Test" in)]TJ
T*
[(Chapter 10)16(, and )-6(Chapter 8)16( for details on )]TJ
/F15 1 Tf
16.3 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glPixelTransfer*\(\))Tj
/F11 1 Tf
7.5 0 TD
(.\))Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 80.000 Tm
(Dirichlet Domains)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 19)Tj
ET
endstream
endobj
1455 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1456 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im115
/Width 335
/Height 321
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.114)
>>
stream
endstream
endobj
1458 0 obj
<<
/Length 2303
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 706.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Given a set S of points on a plane, the Dirichlet domain or Voronoi polygon of one of the points is the set)Tj
0 -1.5 TD
(of all points in the plane closer to that point than to any other point in the set S. These points provide the)Tj
T*
[(solution to many problems in computational geometry. )25(Figure 14-3)226( shows outlines of the Dirichlet)]TJ
T*
(domains for a set of points.)Tj
ET
Q
/GS1 gs
q
335 0 0 321 124 326.06 cm
/Im115 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 313.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 14-3 )Tj
/F11 1 Tf
5.6 0 TD
(Dirichlet Domains)Tj
-5.6 -2.1 TD
(If you draw a depth-buffered cone with its apex at the point in a different color than each of the points in)Tj
0 -1.5 TD
(S, the Dirichlet domain for each point is drawn in that color. The easiest way to do this is to precompute)Tj
T*
(a cone's depth in an image and use the image as the depth-buffer values as described in the preceding)Tj
T*
(section. You don't need an image to draw in the framebuffer as in the case of shaded spheres, however.)Tj
T*
(While you're drawing into the depth buffer, use the stencil buffer to record the pixels where drawing)Tj
T*
(should occur by first clearing it and then writing nonzero values wherever the depth test succeeds. To)Tj
T*
(draw the Dirichlet region, draw a polygon over the entire window, but enable drawing only where the)Tj
T*
(stencil buffers are nonzero.)Tj
0 -2.1 TD
(You can do this perhaps more easily by rendering cones of uniform color with a simple depth buffer, but)Tj
0 -1.5 TD
(a good cone might require thousands of polygons. The technique described in this section can render)Tj
T*
(much higher-quality cones much more quickly. \(See )Tj
21.2 0 TD
("A Hidden-Surface Removal Survival Kit" in)Tj
-21.2 -1.5 TD
[(Chapter 5)16( and )-56("Depth Test" in Chapter 10)27(.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 88.000 Tm
(Life in the Stencil Buffer)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 20)Tj
ET
endstream
endobj
1459 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im115 1456 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1460 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im116
/Width 284
/Height 269
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.115)
>>
stream
endstream
endobj
1462 0 obj
<<
/Length 3263
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The Game of Life, invented by John Conway, is played on a rectangular grid where each grid location is)Tj
0 -1.5 TD
("alive" or "dead." To calculate the next generation from the current one, count the number of live)Tj
T*
(neighbors for each grid location \(the eight adjacent grid locations are neighbors\). A grid location is alive)Tj
T*
(in generation )Tj
/F15 1 Tf
5.5 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(+1 if it was alive in generation )Tj
/F15 1 Tf
12.5 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( and has exactly two or three live neighbors, or if it was)Tj
-19 -1.5 TD
(dead in generation )Tj
/F15 1 Tf
7.6 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( and has exactly three live neighbors. In all other cases, it is dead in generation )Tj
/F15 1 Tf
31.8 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(+1.)Tj
-40.4 -1.5 TD
(This game generates some incredibly interesting patterns given different initial configurations. \(See)Tj
T*
(Martin Gardner, "Mathematical Games," )Tj
/F15 1 Tf
16.6 0 TD
(Scientific American)Tj
/F11 1 Tf
7.9 0 TD
(, vol. 223, no. 4, October 1970, p. 120\255123.\))Tj
-24.5 -1.5 TD
[(Figure 14-4)226( shows six generations from a game.)]TJ
0 -28.3 TD
(.)Tj
ET
Q
/GS1 gs
q
284 0 0 269 126.5 322.84 cm
/Im116 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 308.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure 14-4 )Tj
/F11 1 Tf
5.6 0 TD
(Six Generations from the Game of Life)Tj
-5.6 -2.1 TD
(One way to create this game using OpenGL is to use a multipass algorithm. Keep the data in the color)Tj
0 -1.5 TD
(buffer, one pixel for each grid point. Assume that black \(all zeros\) is the background color, and the color)Tj
T*
(of a live pixel is nonzero. Initialize by clearing the depth and stencil buffers to zero, set the depth-buffer)Tj
T*
(writemask to zero, and set the depth comparison function so that it passes on not-equal. To iterate, read)Tj
T*
(the image off the screen, enable drawing into the depth buffer, and set the stencil function so that it)Tj
T*
(increments whenever a depth comparison succeeds but leaves the stencil buffer unchanged otherwise.)Tj
T*
(Disable drawing into the color buffer.)Tj
0 -2.1 TD
(Next, draw the image eight times, offset one pixel in each vertical, horizontal, and diagonal direction.)Tj
0 -1.5 TD
(When you're done, the stencil buffer contains a count of the number of live neighbors for each pixel.)Tj
T*
(Enable drawing to the color buffer, set the color to the color for live cells, and set the stencil function to)Tj
T*
(draw only if the value in the stencil buffer is 3 \(three live neighbors\). In addition, if this drawing occurs,)Tj
T*
(decrement the value in the stencil buffer. Then draw a rectangle covering the image; this paints each cell)Tj
T*
(that has exactly three live neighbors with the "alive" color.)Tj
0 -2.1 TD
(At this point, the stencil buffers contain 0, 1, 2, 4, 5, 6, 7, 8, and the values under the 2's are correct. The)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Chapter 14,  Now That You Know - 21)Tj
ET
endstream
endobj
1463 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/XObject <<
/Im116 1460 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1465 0 obj
<<
/Length 4173
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(values under 0, 1, 4, 5, 6, 7, and 8 must be cleared to the "dead" color. Set the stencil function to draw)Tj
0 -1.5 TD
(whenever the value is not 2, and to zero the stencil values in all cases. Then draw a large polygon of the)Tj
T*
("dead" color across the entire image. You're done.)Tj
0 -2.1 TD
(For a usable demonstration program, you might want to zoom the grid up to a size larger than a single)Tj
0 -1.5 TD
[(pixel; it's hard to see detailed patterns with a single pixel per grid point. \(See )-44("Coordinate System)]TJ
T*
[(Survival Kit" in Chapter 2)20(,)0( and )-6("Depth Test")33( and )-56("Stencil Test" in Chapter 10)61(.\))]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 596.000 Tm
(Alternative Uses for glDrawPixels\(\) and glCopyPixels\(\))Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 574.000 Tm
(You might think of )Tj
/F15 1 Tf
7.9 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
( as a way to draw a rectangular region of pixels to the screen.)Tj
-14.1 -1.5 TD
(Although this is often what it's used for, some other interesting uses are outlined here.)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Video)Tj
/F33 1 Tf
2.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Even if your machine doesn't have special video hardware, you can display short movie)Tj
-3.4 -1.5 TD
(clips by repeatedly drawing frames with )Tj
/F15 1 Tf
16.3 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
( in the same region of the back buffer and)Tj
-22.5 -1.5 TD
(then swapping the buffers. The size of the frames you can display with reasonable performance)Tj
0 -1.7 TD
(using this method depends on your hardware's drawing speed, so you might be limited to 100)Tj
/F33 1 Tf
37.5 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(100)Tj
-38 -1.5 TD
(pixel movies \(or smaller\) if you want smooth fake video.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Airbrush)Tj
/F33 1 Tf
3.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(In a paint program, your airbrush \(or paintbrush\) shape can be simulated using alpha)Tj
-4.6 -1.6 TD
(values. The color of the paint is represented as the color values. To paint with a circular brush in)Tj
0 -1.5 TD
(blue, repeatedly draw a blue square with )Tj
/F15 1 Tf
16.4 0 TD
(glDrawPixels\(\))Tj
/F11 1 Tf
6.2 0 TD
( where the alpha values are largest in the)Tj
-22.6 -1.5 TD
(center and taper to zero at the edges of a circle centered in the square. Draw using a blending)Tj
T*
(function that uses alpha of the incoming color and \(1-alpha\) of the color already at the pixel. If the)Tj
T*
(alpha values in the brush are all much less than one, you have to paint over an area repeatedly to get)Tj
T*
(a solid color. If the alpha values are near one, each brush stroke pretty much obliterates the colors)Tj
T*
(underneath.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Filtered Zooms)Tj
/F33 1 Tf
6.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(If you zoom a pixel image by a nonintegral amount, OpenGL effectively uses a)Tj
-7.1 -1.6 TD
(box filter, which can lead to rather severe aliasing effects. To improve the filtering, jitter the)Tj
0 -1.5 TD
(resulting image by amounts less than a pixel and redraw it multiple times, using alpha blending to)Tj
T*
(average the resulting pixels. The result is a filtered zoom.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Transposing Images)Tj
/F33 1 Tf
8.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(You can swap same-size images in place with )Tj
/F15 1 Tf
18.6 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
( using the XOR)Tj
-33.7 -1.6 TD
(operation. With this method, you can avoid having to read the images back into processor memory.)Tj
0 -1.5 TD
(If A and B represent the two images, the operation looks like this:)Tj
0 -2.1 TD
[(1.)-1050(A = A XOR B)]TJ
T*
[(2.)-1050(B = A XOR B)]TJ
T*
[(3.)-1050(A = A XOR B)]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 136.350 m
547.000 136.350 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix A,  Order of Operations - 22)Tj
ET
endstream
endobj
1466 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1468 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im117
/Width 549
/Height 216
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.116)
>>
stream
endstream
endobj
1470 0 obj
<<
/Length 2903
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix A)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Order of Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(This book describes all the operations performed between when vertices  are initially specified and)Tj
0 -1.5 TD
(fragments are finally written into the framebuffer. The chapters of this book are arranged in an order that)Tj
T*
(facilitates learning rather than in the exact order in which these operations are actually performed.)Tj
0 -1.6 TD
(Sometimes the exact order of operations doesn't matter)Tj
/F33 1 Tf
22.1 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, surfaces can be converted to)Tj
-23.1 -1.6 TD
(polygons and then transformed, or transformed first and then converted to polygons, with identical)Tj
T*
(results)Tj
/F33 1 Tf
2.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(and different implementations of OpenGL might do things differently.)Tj
-3.6 -2.2 TD
(This appendix describes a possible order; any implementation is required to give equivalent results. If)Tj
0 -1.5 TD
(you want more details than are presented here, see the )Tj
/F15 1 Tf
21.9 0 TD
(OpenGL Reference Manual)Tj
/F11 1 Tf
11 0 TD
(.)Tj
-32.9 -2.1 TD
(This appendix has the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Overview")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Geometric Operations")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Pixel Operations")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Fragment Operations")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Odds and Ends")Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 380.000 Tm
(Overview)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 358.000 Tm
[(This section gives an overview of the order of operations, as shown in )-24(Figure A-1)248(. Geometric data)]TJ
0 -1.5 TD
(\(vertices, lines, and polygons\) follows the path through the row of boxes that include evaluators and)Tj
T*
(per-vertex operations, while pixel data \(pixels, images, and bitmaps\) is treated differently for part of the)Tj
T*
(process. Both types of data undergo the rasterization and per-fragment operations before the final pixel)Tj
T*
(data is written into the framebuffer.)Tj
ET
Q
/GS1 gs
q
423 0 0 166 124 117.71 cm
/Im117 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 105.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure A-1 )Tj
/F11 1 Tf
5.2 0 TD
(Order of Operations)Tj
-5.2 -2.2 TD
(All data, whether it describes geometry or pixels, can be saved in a display list or processed immediately.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix A,  Order of Operations - 1)Tj
ET
endstream
endobj
1471 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im117 1468 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1473 0 obj
<<
/Length 4364
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(When a display list is executed, the data is sent from the display list just as if it were sent by the)Tj
0 -1.5 TD
(application.)Tj
0 -2.1 TD
(All geometric primitives are eventually described by vertices. If evaluators are used, that data is)Tj
0 -1.5 TD
(converted to vertices and treated as vertices from then on. Vertex data may also be stored in and used)Tj
T*
(from specialized vertex arrays. Per-vertex calculations are performed on each vertex, followed by)Tj
T*
(rasterization to fragments. For pixel data, pixel operations are performed, and the results are either stored)Tj
T*
(in the texture memory, used for polygon stippling, or rasterized to fragments.)Tj
0 -2.1 TD
(Finally, the fragments are subjected to a series of per-fragment operations, after which the final pixel)Tj
0 -1.5 TD
(values are drawn into the framebuffer.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 545.000 Tm
(Geometric Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 523.000 Tm
(Geometric data, whether it comes from a display list, an evaluator, the vertices of a rectangle, or as raw)Tj
T*
(data, consists of a set of vertices and the type of primitive it describes \(a vertex, line, or polygon\). Vertex)Tj
T*
(data includes not only the \()Tj
/F15 1 Tf
10.9 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.4 0 TD
(\) coordinates, but also a normal vector, texture coordinates, a RGBA)Tj
-14.3 -1.5 TD
(color, a color index, material properties, and edge-flag data. All these elements except the vertex's)Tj
T*
(coordinates can be specified in any order, and default values exist as well. As soon as the vertex)Tj
T*
(command )Tj
/F15 1 Tf
4.2 0 TD
(glVertex*\(\))Tj
/F11 1 Tf
4.5 0 TD
( is issued, the components are padded, if necessary, to four dimensions \(using )Tj
/F15 1 Tf
31.4 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( = 0)Tj
-40.5 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( = 1\), and the current values of all the elements are associated with the vertex. The complete set of)Tj
-2.4 -1.5 TD
(vertex data is then processed. \(If vertex arrays are used, vertex data may be batch processed and)Tj
T*
(processed vertices may be reused.\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 375.000 Tm
(Per-Vertex Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 353.000 Tm
(In the per-vertex operations stage of processing, each vertex's spatial coordinates are transformed by the)Tj
T*
(modelview matrix, while the normal vector is transformed by that matrix's inverse transpose and)Tj
T*
(renormalized if specified. If automatic texture generation is enabled, new texture coordinates are)Tj
T*
(generated from the transformed vertex coordinates, and they replace the vertex's old texture coordinates.)Tj
T*
(The texture coordinates are then transformed by the current texture matrix and passed on to the primitive)Tj
T*
(assembly step.)Tj
0 -2.1 TD
(Meanwhile, the lighting calculations, if enabled, are performed using the transformed vertex and normal)Tj
0 -1.5 TD
(vector coordinates, and the current material, lights, and lighting model. These calculations generate new)Tj
T*
(colors or indices that are clamped or masked to the appropriate range and passed on to the primitive)Tj
T*
(assembly step.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 183.000 Tm
(Primitive Assembly)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 162.000 Tm
(Primitive assembly differs, depending on whether the primitive is a point, a line, or a polygon. If flat)Tj
T*
(shading is enabled, the colors or indices of all the vertices in a line or polygon are set to the same value.)Tj
T*
(If special clipping planes are defined and enabled, they're used to clip primitives of all three types. \(The)Tj
T*
(clipping-plane equations are transformed by the inverse transpose of the modelview matrix when they're)Tj
T*
(specified.\) Point clipping simply passes or rejects vertices; line or polygon clipping can add additional)Tj
T*
(vertices depending on how the line or polygon is clipped. After this clipping, the spatial coordinates of)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix A,  Order of Operations - 2)Tj
ET
endstream
endobj
1474 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1476 0 obj
<<
/Length 4496
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(each vertex are transformed by the projection matrix, and the results are clipped against the standard)Tj
0 -1.6 TD
(viewing planes )Tj
/F15 1 Tf
6.3 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( = )Tj
/F33 1 Tf
1.1 0 TD
-0.049 Tc
(\261w)Tj
/F11 1 Tf
1.2 0 TD
0.000 Tc
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
( = )Tj
/F33 1 Tf
1 0 TD
0.051 Tc
(\261w)Tj
/F11 1 Tf
1.3 0 TD
0.000 Tc
(, and)Tj
/F15 1 Tf
1.9 0 TD
( z)Tj
/F11 1 Tf
0.6 0 TD
( = )Tj
/F33 1 Tf
1.1 0 TD
0.051 Tc
(\261w)Tj
/F11 1 Tf
1.2 0 TD
0.000 Tc
(.)Tj
-17.1 -2.2 TD
(If selection is enabled, any primitive not eliminated by clipping generates a selection-hit report, and no)Tj
0 -1.5 TD
(further processing is performed. Without selection, perspective division by )Tj
/F15 1 Tf
30.2 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( occurs and the viewport)Tj
-30.9 -1.5 TD
(and depth-range operations are applied. Also, if the primitive is a polygon, it's then subjected to a culling)Tj
T*
(test \(if culling is enabled\). A polygon might convert to vertices or lines, depending on the polygon mode.)Tj
0 -2.1 TD
(Finally, points, lines, and polygons are rasterized to fragments, taking into account polygon or line)Tj
0 -1.5 TD
(stipples, line width, and point size. Rasterization involves determining which squares of an integer grid in)Tj
T*
(window coordinates are occupied by the primitive. If antialiasing is enabled, coverage \(the portion of the)Tj
T*
(square that is occupied by the primitive\) is also computed. Color and depth values are also assigned to)Tj
T*
(each such square. If polygon offset is enabled, depth values are slightly modified by a calculated offset)Tj
T*
(value.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 499.000 Tm
(Pixel Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 477.000 Tm
(Pixels from host memory are first unpacked into the proper number of components. The OpenGL)Tj
T*
(unpacking facility handles a number of different formats. Next, the data is scaled, biased, and processed)Tj
T*
(using a pixel map. The results are clamped to an appropriate range depending on the data type and then)Tj
T*
(either written in the texture memory for use in texture mapping or rasterized to fragments.)Tj
0 -2.1 TD
(If pixel data is read from the framebuffer, pixel-transfer operations \(scale, bias, mapping, and clamping\))Tj
0 -1.5 TD
(are performed. The results are packed into an appropriate format and then returned to processor memory.)Tj
0 -2.1 TD
(The pixel copy operation is similar to a combination of the unpacking and transfer operations, except that)Tj
0 -1.5 TD
(packing and unpacking is unnecessary, and only a single pass is made through the transfer operations)Tj
T*
(before the data is written back into the framebuffer.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 316.000 Tm
(Texture Memory)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 294.000 Tm
(OpenGL Version 1.1 provides additional control over texture memory. Texture image data can be)Tj
T*
(specified from framebuffer memory, as well as processor memory. All or a portion of a texture image)Tj
T*
(may be replaced. Texture data may be stored in texture objects, which can be loaded into texture)Tj
T*
(memory. If there are too many texture objects to fit into texture memory at the same time, the textures)Tj
T*
(that have the highest priorities remain in the texture memory.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 201.000 Tm
(Fragment Operations)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 179.000 Tm
(If texturing is enabled, a texel is generated from texture memory for each fragment and applied to the)Tj
T*
(fragment. Then fog calculations are performed, if they're enabled, followed by the application of)Tj
T*
(coverage \(antialiasing\) values, if antialiasing is enabled.)Tj
0 -2.1 TD
(Next comes scissoring, followed by the alpha test \(in RGBA mode only\), the stencil test, and the)Tj
0 -1.5 TD
(depth-buffer test. If in RGBA mode, blending is performed. Blending is followed by dithering and)Tj
T*
(logical operation. All these operations may be disabled.)Tj
0 -2.1 TD
(The fragment is then masked by a color mask or an index mask, depending on the mode, and drawn into)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix A,  Order of Operations - 3)Tj
ET
endstream
endobj
1477 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1479 0 obj
<<
/Length 2166
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(the appropriate buffer. If fragments are being written into the stencil or depth buffer, masking occurs)Tj
0 -1.5 TD
(after the stencil and depth tests, and the results are drawn into the framebuffer without performing the)Tj
T*
(blending, dithering, or logical operation.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 646.000 Tm
(Odds and Ends)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 624.000 Tm
(Matrix operations deal with the current matrix stack, which can be the modelview, the projection, or the)Tj
T*
(texture matrix stack. The commands )Tj
/F15 1 Tf
14.8 0 TD
(glMultMatrix*\(\))Tj
/F11 1 Tf
6.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glLoadMatrix*\(\))Tj
/F11 1 Tf
6.7 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( are applied)Tj
-37.4 -1.5 TD
(to the top matrix on the stack, while )Tj
/F15 1 Tf
14.6 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glScale*\(\))Tj
/F11 1 Tf
4.1 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glOrtho\(\))Tj
/F11 1 Tf
3.8 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glFrustum\(\))Tj
/F11 1 Tf
-36.6 -1.5 TD
(are used to create a matrix that's multiplied by the top matrix. When the modelview matrix is modified,)Tj
T*
(its inverse transpose is also generated for normal vector transformation.)Tj
0 -2.1 TD
(The commands that set the current raster position are treated exactly like a vertex command up until)Tj
0 -1.5 TD
(when rasterization would occur. At this point, the value is saved and is used in the rasterization of pixel)Tj
T*
(data.)Tj
0 -2.1 TD
(The various )Tj
/F15 1 Tf
5 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.7 0 TD
( commands bypass all operations except scissoring, dithering, and writemasking.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 471.260 m
547.000 471.260 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 4)Tj
ET
endstream
endobj
1480 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1482 0 obj
<<
/Length 6621
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix B)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(State Variables)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(This appendix lists the queryable OpenGL state variables, their default values, and the commands for)Tj
0 -1.5 TD
(obtaining the values of these variables. The )Tj
/F15 1 Tf
17.6 0 TD
(OpenGL Reference Manual )Tj
/F11 1 Tf
11.3 0 TD
(contains detailed information on)Tj
-28.9 -1.5 TD
(all the commands and constants discussed in this appendix. This appendix has these major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("The Query Commands")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("OpenGL State Variables")Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 554.000 Tm
(The Query Commands)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 532.000 Tm
(In addition to the basic commands to obtain the values of simple state variables \(commands such as)Tj
/F15 1 Tf
0 -1.5 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(glIsEnabled\(\))Tj
/F11 1 Tf
5.5 0 TD
[(, which are described in )76("Basic State Management" in Chapter 2)-45(\), there)]TJ
-13.7 -1.5 TD
(are other specialized commands to return more complex state variables. The prototypes for these)Tj
T*
(specialized commands are listed here. Some of these routines, such as )Tj
/F15 1 Tf
28.2 0 TD
(glGetError\(\))Tj
/F11 1 Tf
5.2 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glGetString\(\))Tj
/F11 1 Tf
5.3 0 TD
(,)Tj
-40.6 -1.5 TD
(have been discussed in more detail elsewhere in the book.)Tj
0 -2.1 TD
(To find out when you need to use these commands and their corresponding symbolic constants, use the)Tj
0 -1.5 TD
[(tables in the next section, )-11("OpenGL State Variables." Also see the )]TJ
/F15 1 Tf
26.7 0 TD
(OpenGL Reference Manual)Tj
/F11 1 Tf
11 0 TD
(.)Tj
-37.7 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetClipPlane)Tj
/F11 1 Tf
6.3 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(plane)Tj
/F11 1 Tf
2.3 0 TD
(, GLdouble *)Tj
/F15 1 Tf
5.3 0 TD
(equation)Tj
/F11 1 Tf
3.5 0 TD
(\);)Tj
-23.5 -2.1 TD
(GLenum )Tj
/F15 1 Tf
3.8 0 TD
(glGetError)Tj
/F11 1 Tf
4.5 0 TD
(\(void\);)Tj
-8.3 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetLight)Tj
/F11 1 Tf
4.4 0 TD
({if})Tj
/F15 1 Tf
1.5 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(light)Tj
/F11 1 Tf
1.8 0 TD
(, GLenum )Tj
/F15 1 Tf
4.4 0 TD
(pname)Tj
/F11 1 Tf
2.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(TYPE)Tj
/F11 1 Tf
2.4 0 TD
( *)Tj
/F15 1 Tf
0.7 0 TD
(params)Tj
/F11 1 Tf
3 0 TD
(\);)Tj
-27.9 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetMap)Tj
/F11 1 Tf
4.1 0 TD
({ifd})Tj
/F15 1 Tf
2.1 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(target)Tj
/F11 1 Tf
2.4 0 TD
(, GLenum )Tj
/F15 1 Tf
4.3 0 TD
(query)Tj
/F11 1 Tf
2.3 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(TYPE)Tj
/F11 1 Tf
2.3 0 TD
( *)Tj
/F15 1 Tf
0.8 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
(\);)Tj
-25.7 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetMaterial)Tj
/F11 1 Tf
5.8 0 TD
({if})Tj
/F15 1 Tf
1.5 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(face)Tj
/F11 1 Tf
1.7 0 TD
(, GLenum )Tj
/F15 1 Tf
4.3 0 TD
(pname)Tj
/F11 1 Tf
2.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(TYPE)Tj
/F11 1 Tf
2.4 0 TD
( *)Tj
/F15 1 Tf
0.7 0 TD
(params)Tj
/F11 1 Tf
3 0 TD
(\);)Tj
-29.1 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetPixelMap)Tj
/F11 1 Tf
6.1 0 TD
({f ui us})Tj
/F15 1 Tf
3.5 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.2 0 TD
(map)Tj
/F11 1 Tf
1.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(TYPE)Tj
/F11 1 Tf
2.3 0 TD
( *)Tj
/F15 1 Tf
0.8 0 TD
(values)Tj
/F11 1 Tf
2.5 0 TD
(\);)Tj
-24 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetPolygonStipple)Tj
/F11 1 Tf
8.4 0 TD
(\(GLubyte *)Tj
/F15 1 Tf
4.6 0 TD
(mask)Tj
/F11 1 Tf
2.1 0 TD
(\);)Tj
-17.1 -2.1 TD
(const GLubyte * )Tj
/F15 1 Tf
6.9 0 TD
(glGetString)Tj
/F11 1 Tf
4.7 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(name)Tj
/F11 1 Tf
2.2 0 TD
(\);)Tj
-17.9 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetTexEnv)Tj
/F11 1 Tf
5.2 0 TD
({if})Tj
/F15 1 Tf
1.6 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(target)Tj
/F11 1 Tf
2.4 0 TD
(, GLenum )Tj
/F15 1 Tf
4.3 0 TD
(pname)Tj
/F11 1 Tf
2.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(TYPE)Tj
/F11 1 Tf
2.3 0 TD
( *)Tj
/F15 1 Tf
0.7 0 TD
(params)Tj
/F11 1 Tf
3 0 TD
(\);)Tj
-29.3 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetTexGen)Tj
/F11 1 Tf
5.4 0 TD
({ifd})Tj
/F15 1 Tf
2 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(coord)Tj
/F11 1 Tf
2.3 0 TD
(, GLenum )Tj
/F15 1 Tf
4.4 0 TD
(pname)Tj
/F11 1 Tf
2.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(TYPE)Tj
/F11 1 Tf
2.4 0 TD
( *)Tj
/F15 1 Tf
0.7 0 TD
(params)Tj
/F11 1 Tf
3 0 TD
(\);)Tj
-29.9 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetTexImage)Tj
/F11 1 Tf
6.2 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(target)Tj
/F11 1 Tf
2.4 0 TD
(, GLint )Tj
/F15 1 Tf
3.2 0 TD
(level)Tj
/F11 1 Tf
1.8 0 TD
(, GLenum )Tj
/F15 1 Tf
4.4 0 TD
(format)Tj
/F11 1 Tf
2.6 0 TD
(,)Tj
-26.7 -1.1 TD
(GLenum )Tj
/F15 1 Tf
3.8 0 TD
(type)Tj
/F11 1 Tf
1.7 0 TD
(, GLvoid *)Tj
/F15 1 Tf
4.3 0 TD
(pixels)Tj
/F11 1 Tf
2.4 0 TD
(\);)Tj
-12.2 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetTexLevelParameter)Tj
/F11 1 Tf
10.1 0 TD
({if})Tj
/F15 1 Tf
1.6 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(target)Tj
/F11 1 Tf
2.4 0 TD
(, GLint )Tj
/F15 1 Tf
3.1 0 TD
(level)Tj
/F11 1 Tf
1.9 0 TD
(,)Tj
-25.7 -1.1 TD
(GLenum )Tj
/F15 1 Tf
3.8 0 TD
(pname)Tj
/F11 1 Tf
2.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(TYPE)Tj
/F11 1 Tf
2.3 0 TD
( *)Tj
/F15 1 Tf
0.8 0 TD
(params)Tj
/F11 1 Tf
3 0 TD
(\);)Tj
-13.1 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glGetTexParameter)Tj
/F11 1 Tf
8 0 TD
({if})Tj
/F15 1 Tf
1.5 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(target)Tj
/F11 1 Tf
2.4 0 TD
(, GLenum )Tj
/F15 1 Tf
4.3 0 TD
(pname)Tj
/F11 1 Tf
2.7 0 TD
(,)Tj
/F15 1 Tf
-25.5 -1.1 TD
(TYPE)Tj
/F11 1 Tf
2.3 0 TD
( *)Tj
/F15 1 Tf
0.8 0 TD
(params)Tj
/F11 1 Tf
3 0 TD
(\);)Tj
-6.1 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(gluGetNurbsProperty)Tj
/F11 1 Tf
8.8 0 TD
(\(GLUnurbsObj *)Tj
/F15 1 Tf
6.8 0 TD
(nobj)Tj
/F11 1 Tf
1.8 0 TD
(, GLenum )Tj
/F15 1 Tf
4.3 0 TD
(property)Tj
/F11 1 Tf
3.4 0 TD
(,)Tj
-27.1 -1.1 TD
(GLfloat *)Tj
/F15 1 Tf
3.9 0 TD
(value)Tj
/F11 1 Tf
2.2 0 TD
(\);)Tj
-6.1 -2.1 TD
(const GLubyte * )Tj
/F15 1 Tf
6.9 0 TD
(gluGetString)Tj
/F11 1 Tf
5.2 0 TD
(\(GLenum )Tj
/F15 1 Tf
4.1 0 TD
(name)Tj
/F11 1 Tf
2.2 0 TD
(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 1)Tj
ET
endstream
endobj
1483 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1485 0 obj
<<
/Length 6023
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 704.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(void )Tj
/F15 1 Tf
2 0 TD
(gluGetTessProperty)Tj
/F11 1 Tf
8.1 0 TD
0.000 Tw
(\(GLUtesselator *)Tj
/F15 1 Tf
6.9 0 TD
(tess)Tj
/F11 1 Tf
1.5 0 TD
(, GLenum )Tj
/F15 1 Tf
4.3 0 TD
(which)Tj
/F11 1 Tf
2.4 0 TD
(,)Tj
-25.2 -1.2 TD
(GLdouble *)Tj
/F15 1 Tf
4.8 0 TD
(data)Tj
/F11 1 Tf
1.8 0 TD
(\);)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 659.000 Tm
(OpenGL State Variables)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 637.000 Tm
(The following pages contain tables that list the names of queryable state variables. For each variable, the)Tj
0 -1.5 TD
(tables list a description of it, its attribute group, its initial or minimum value, and the suggested )Tj
/F15 1 Tf
38.2 0 TD
(glGet*\(\))Tj
/F11 1 Tf
-38.2 -1.5 TD
(command to use for obtaining it. State variables that can be obtained using )Tj
/F15 1 Tf
30.1 0 TD
(glGetBooleanv\(\))Tj
/F11 1 Tf
6.7 0 TD
(,)Tj
/F15 1 Tf
-36.8 -1.6 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glGetFloatv\(\))Tj
/F11 1 Tf
5.5 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(glGetDoublev\(\))Tj
/F11 1 Tf
6.3 0 TD
( are listed with just one of these commands)Tj
/F33 1 Tf
17.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the one)Tj
-38.4 -1.6 TD
(that's most appropriate given the type of data to be returned. \(Some vertex array variables can be queried)Tj
0 -1.5 TD
(only with )Tj
/F15 1 Tf
4.1 0 TD
(glGetPointerv\(\))Tj
/F11 1 Tf
6.3 0 TD
(.\) These state variables can't be obtained using )Tj
/F15 1 Tf
19 0 TD
(glIsEnabled\(\))Tj
/F11 1 Tf
5.5 0 TD
(. However, state)Tj
-34.9 -1.5 TD
(variables for which )Tj
/F15 1 Tf
8 0 TD
(glIsEnabled\(\))Tj
/F11 1 Tf
5.5 0 TD
( is listed as the query command can also be obtained using)Tj
/F15 1 Tf
-13.5 -1.5 TD
(glGetBooleanv\(\))Tj
/F11 1 Tf
6.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glGetIntegerv\(\))Tj
/F11 1 Tf
6.2 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glGetFloatv\(\))Tj
/F11 1 Tf
5.5 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glGetDoublev\(\))Tj
/F11 1 Tf
6.3 0 TD
(. State variables for which any)Tj
-27.9 -1.5 TD
(other command is listed as the query command can be obtained only by using that command.)Tj
0 -2.1 TD
(If one or more attribute groups are listed, the state variable belongs to the listed group or groups. If no)Tj
0 -1.5 TD
(attribute group is listed, the variable doesn't belong to any group. )Tj
/F15 1 Tf
26.4 0 TD
(glPushAttrib\(\))Tj
/F11 1 Tf
5.8 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glPushClientAttrib\(\))Tj
/F11 1 Tf
8.2 0 TD
(,)Tj
/F15 1 Tf
-40.9 -1.5 TD
(glPopAttrib\(\))Tj
/F11 1 Tf
5.4 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glPopClientAttrib\(\))Tj
/F11 1 Tf
7.8 0 TD
( may be used to save and restore all state values that belong to an)Tj
-15.4 -1.5 TD
[(attribute group. \(See )44("Attribute Groups" in Chapter 2)-83( for more information.\))]TJ
0 -2.1 TD
(All queryable state variables, except the implementation-dependent ones, have initial values. If no initial)Tj
0 -1.5 TD
(value is listed, you need to consult either the section where that variable is discussed or the )Tj
/F15 1 Tf
36.6 0 TD
(OpenGL)Tj
-36.6 -1.5 TD
(Reference Manual)Tj
/F11 1 Tf
7.4 0 TD
( to determine its initial value.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 369.000 Tm
(Current Values and Associated Data)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 357.470 m
551.000 357.470 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 350.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-17635(Description)-11123(Attribute)]TJ
40.875 -1.5 TD
(Group)Tj
6 1.5 TD
[(Initial Value)-1566(Get Command)]TJ
ET
Q
40.000 331.950 m
551.000 331.950 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 324.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_CURRENT_COLOR)-11165(Current color)-9417(current)-2501(1, 1, 1, 1)-2833(glGetIntegerv\(\),)]TJ
48 -1.3333 TD
(glGetFloatv\(\))Tj
-48 -1.4445 TD
[(GL_CURRENT_INDEX)-11444(Current color index)-6945(current)-2501(1)-5833(glGetIntegerv\(\),)]TJ
48 -1.3333 TD
(glGetFloatv\(\))Tj
-48 -1.4444 TD
[(GL_CURRENT_TEXTURE_COORDS)-5442(Current texture coordinates)-3834(current)-2501(0, 0, 0, 1)-2833(glGetFloatv\(\))]TJ
T*
[(GL_CURRENT_NORMAL)-10221(Current normal)-8639(current)-2501(0, 0, 1)-3833(glGetFloatv\(\))]TJ
T*
[(GL_CURRENT_RASTER_POSITION)-5664(Current raster position)-5777(current)-2501(0, 0, 0, 1)-2833(glGetFloatv\(\))]TJ
T*
[(GL_CURRENT_RASTER_DISTANCE)-5275(Current raster distance)-5723(current)-2501(0)-5833(glGetFloatv\(\))]TJ
T*
[(GL_CURRENT_RASTER_COLOR)-6830(Color associated with raster)]TJ
21.5556 -1.3333 TD
(position)Tj
14.7778 1.3333 TD
[(current)-2501(1, 1, 1, 1)-2833(glGetIntegerv\(\),)]TJ
11.6667 -1.3333 TD
(glGetFloatv\(\))Tj
-48 -1.4444 TD
[(GL_CURRENT_RASTER_INDEX)-7109(Color index associated with raster)]TJ
21.5556 -1.3333 TD
(position)Tj
14.7778 1.3333 TD
[(current)-2501(1)-5833(glGetIntegerv\(\),)]TJ
11.6667 -1.3333 TD
(glGetFloatv\(\))Tj
-48 -1.5556 TD
[(GL_CURRENT_RASTER_TEXTURE_COORDS)-1107(Texture coordinates associated)]TJ
21.5556 -1.3333 TD
(with  raster position)Tj
14.7778 1.3333 TD
[(current)-2501(0, 0, 0, 1)-2833(glGetFloatv\(\))]TJ
-36.3333 -2.7778 TD
[(GL_CURRENT_RASTER_POSITION_VALID)-2053(Raster position valid bit)-5192(current)-2501(GL_TRUE)-1889(glGetBooleanv\(\))]TJ
0 -1.4444 TD
[(GL_EDGE_FLAG)-13944(Edge flag)-10917(current)-2501(GL_TRUE)-1889(glGetBooleanv\(\))]TJ
ET
Q
40.000 125.890 m
551.010 125.890 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 110.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-1 )Tj
/F11 1 Tf
4.8 0 TD
(State Variables for Current Values and Associated Data)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 81.000 Tm
(Vertex Array)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 2)Tj
ET
endstream
endobj
1486 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1488 0 obj
<<
/Length 6568
>>
stream
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 717.110 m
544.000 717.110 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 709.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-15260(Description)-9998(Attribute)]TJ
37.375 -1.5 TD
(Group)Tj
8.25 1.5 TD
[(Initial Value)-2191(Get Command)]TJ
ET
Q
40.000 691.590 m
544.000 691.590 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 683.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_VERTEX_ARRAY)-9666(Vertex array enable)-5892(vertex-array)-2216(GL_FALSE)-1999(glIsEnabled\(\))]TJ
0 -1.4445 TD
[(GL_VERTEX_ARRAY_SIZE)-7055(Coordinates per vertex)-4667(vertex-array)-2216(4)-6389(glGetIntegerv\(\))]TJ
T*
[(GL_VERTEX_ARRAY_TYPE)-6665(Type of vertex coordinates)-3029(vertex-array)-2216(GL_FLOAT)-1833(glGetIntegerv\(\))]TJ
T*
[(GL_VERTEX_ARRAY_STRIDE)-5665(Stride between vertices)-4445(vertex-array)-2216(0)-6389(glGetIntegerv\(\))]TJ
T*
[(GL_VERTEX_ARRAY_POINTER)-4943(Pointer to the vertex array)-3334(vertex-array)-2216(NULL)-4223(glGetPointerv\(\))]TJ
T*
[(GL_NORMAL_ARRAY)-9277(Normal array enable)-5558(vertex-array)-2216(GL_FALSE)-1999(glIsEnabled\(\))]TJ
T*
[(GL_NORMAL_ARRAY_TYPE)-6276(Type of normal coordinates)-2695(vertex-array)-2216(GL_FLOAT)-1833(glGetIntegerv\(\))]TJ
T*
[(GL_NORMAL_ARRAY_STRIDE)-5276(Stride between normals)-4333(vertex-array)-2216(0)-6389(glGetIntegerv\(\))]TJ
T*
[(GL_NORMAL_ARRAY_POINTER)-4554(Pointer to the normal array)-3000(vertex-array)-2216(NULL)-4223(glGetPointerv\(\))]TJ
T*
[(GL_COLOR_ARRAY)-10221(RGBA color array enable)-3529(vertex-array)-2216(GL_FALSE)-1999(glIsEnabled\(\))]TJ
T*
[(GL_COLOR_ARRAY_SIZE)-7610(Colors per vertex)-6834(vertex-array)-2216(4)-6389(glGetIntegerv\(\))]TJ
T*
[(GL_COLOR_ARRAY_TYPE)-7221(Type of color components)-3250(vertex-array)-2216(GL_FLOAT)-1833(glGetIntegerv\(\))]TJ
T*
[(GL_COLOR_ARRAY_STRIDE)-6220(Stride between colors)-5111(vertex-array)-2216(0)-6389(glGetIntegerv\(\))]TJ
T*
[(GL_COLOR_ARRAY_POINTER)-5498(Pointer to the color array)-3778(vertex-array)-2216(NULL)-4223(glGetPointerv\(\))]TJ
T*
[(GL_INDEX_ARRAY)-10500(Color-index array enable)-3548(vertex-array)-2216(GL_FALSE)-1999(glIsEnabled\(\))]TJ
T*
[(GL_INDEX_ARRAY_TYPE)-7500(Type of color indices)-5250(vertex-array)-2216(GL_FLOAT)-1833(glGetIntegerv\(\))]TJ
T*
[(GL_INDEX_ARRAY_STRIDE)-6499(Stride between color indices)-2417(vertex-array)-2216(0)-6389(glGetIntegerv\(\))]TJ
T*
[(GL_INDEX_ARRAY_POINTER)-5777(Pointer to the index array)-3611(vertex-array)-2216(NULL)-4223(glGetPointerv\(\))]TJ
T*
[(GL_TEXTURE_COORD_ARRAY)-5054(Texture coordinate array enable)-1031(vertex-array)-2216(GL_FALSE)-1999(glIsEnabled\(\))]TJ
T*
[(GL_TEXTURE_COORD_ARRAY_SIZE)-2443(Texture coordinates per element)-863(vertex-array)-2216(4)-6389(glGetIntegerv\(\))]TJ
0 -1.5556 TD
[(GL_TEXTURE_COORD_ARRAY_TYPE)-2054(Type of texture coordinates)-2751(vertex-array)-2216(GL_FLOAT)-1833(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_TEXTURE_COORD_ARRAY_STRIDE)-1054(Stride between texture)]TJ
19.4444 -1.3333 TD
(coordinates)Tj
13.7778 1.3333 TD
[(vertex-array)-2216(0)-6389(glGetIntegerv\(\))]TJ
-33.2222 -2.7778 TD
(GL_TEXTURE_COORD_ARRAY_POINTE)Tj
0 -1.3333 TD
(R)Tj
19.4444 1.3333 TD
(Pointer to the texture coordinate)Tj
0 -1.3333 TD
(array)Tj
13.7778 1.3333 TD
[(vertex-array)-2216(NULL)-4223(glGetPointerv\(\))]TJ
-33.2222 -2.7778 TD
[(GL_EDGE_FLAG_ARRAY)-7833(Edge flag array enable)-4752(vertex-array)-2216(GL_FALSE)-1999(glIsEnabled\(\))]TJ
0 -1.4444 TD
[(GL_EDGE_FLAG_ARRAY_STRIDE)-3832(Stride between edge flags)-3473(vertex-array)-2216(0)-6389(glGetIntegerv\(\))]TJ
T*
[(GL_EDGE_FLAG_ARRAY_POINTER)-3110(Pointer to the edge flag array)-2140(vertex-array)-2216(NULL)-4223(glGetPointerv\(\))]TJ
ET
Q
40.000 325.780 m
544.010 325.780 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 310.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-2 )Tj
/F11 1 Tf
4.8 0 TD
( \(continued\)  Vertex Array State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 281.000 Tm
(Transformation)Tj
ET
Q
40.000 269.000 m
557.000 269.000 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 261.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-12385(Description)-12248(Attribute)]TJ
36.75 -1.5 TD
(Group)Tj
7.125 1.5 TD
[(Initial Value)-5191(Get Command)]TJ
ET
Q
40.000 243.480 m
557.000 243.480 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 235.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_MODELVIEW_MATRIX)-4445(Modelview matrix stack)]TJ
/F33 1 Tf
32.6667 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
[(Identity)-6444(glGetFloatv\(\))]TJ
-39 -1.5556 TD
[(GL_PROJECTION_MATRIX)-4610(Projection matrix stack)]TJ
/F33 1 Tf
32.6667 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
[(Identity)-6444(glGetFloatv\(\))]TJ
-39 -1.6667 TD
[(GL_TEXTURE_MATRIX)-6055(Texture matrix stack)]TJ
/F33 1 Tf
32.6667 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
[(Identity)-6444(glGetFloatv\(\))]TJ
-39 -1.6667 TD
[(GL_VIEWPORT)-9889(Viewport origin and extent)-4972(viewport)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
9.5556 0.1111 TD
(glGetIntegerv\(\))Tj
-48.5556 -1.6667 TD
[(GL_DEPTH_RANGE)-7889(Depth range near and far)-5836(viewport)-2778(0, 1)-8055(glGetFloatv\(\))]TJ
0 -1.4444 TD
[(GL_MODELVIEW_STACK_DEPTH)-1388(Modelview matrix stack pointer)]TJ
/F33 1 Tf
32.6667 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
[(1)-9056(glGetIntegerv\(\))]TJ
-39 -1.5556 TD
[(GL_PROJECTION_STACK_DEPTH)-1554(Projection matrix stack pointer)]TJ
/F33 1 Tf
32.6667 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
[(1)-9056(glGetIntegerv\(\))]TJ
-39 -1.6667 TD
[(GL_TEXTURE_STACK_DEPTH)-2999(Texture matrix stack pointer)]TJ
/F33 1 Tf
32.6667 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
[(1)-9056(glGetIntegerv\(\))]TJ
-39 -1.6667 TD
[(GL_MATRIX_MODE)-7666(Current matrix mode)-7388(transform)-2445(GL_MODELVIEW)-1556(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_NORMALIZE)-9167(Current normal normalization on/off)-1138(transform/)]TJ
32.6667 -1.3333 TD
(enable)Tj
6.3333 1.3333 TD
[(GL_FALSE)-4666(glIsEnabled\(\))]TJ
-39 -2.7778 TD
(GL_CLIP_PLANE)Tj
/F15 1 Tf
7.7778 0 TD
(i)Tj
/F11 1 Tf
9.1111 0 TD
[(User clipping plane coefficients)-3029(transform)-2445(0, 0, 0, 0)-6055(glGetClipPlane\(\))]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 3)Tj
ET
endstream
endobj
1489 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1491 0 obj
<<
/Length 6170
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(GL_CLIP_PLANE)Tj
/F15 1 Tf
7.7778 0 TD
8.833 Tc
(ii)Tj
/F11 1 Tf
9.4444 0 TD
0.000 Tc
0.000 Tw
[(th user clipping plane enabled)-3445(transform/)]TJ
15.4444 -1.3333 TD
(enable)Tj
6.3333 1.3333 TD
[(GL_FALSE)-4666(glIsEnabled\(\))]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 692.460 m
557.010 692.460 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 676.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-3 )Tj
/F11 1 Tf
4.8 0 TD
(Transformation State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 647.000 Tm
(Coloring)Tj
ET
Q
40.000 635.680 m
552.000 635.680 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 628.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-6385(Description)-9373(Attribute)]TJ
27.875 -1.5 TD
(Group)Tj
7.75 1.5 TD
[(Initial Value)-2691(Get Command)]TJ
ET
Q
40.000 610.160 m
552.000 610.160 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 602.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_FOG_COLOR)-3832(Fog color)-9361(fog)-5556(0, 0, 0, 0)-3833(glGetFloatv\(\))]TJ
0 -1.4445 TD
[(GL_FOG_INDEX)-4111(Fog index)-9194(fog)-5556(0)-6833(glGetFloatv\(\))]TJ
T*
[(GL_FOG_DENSITY)-2944(Exponential fog density)-3666(fog)-5556(1.0)-6083(glGetFloatv\(\))]TJ
T*
[(GL_FOG_START)-4054(Linear fog start)-7056(fog)-5556(0.0)-6083(glGetFloatv\(\))]TJ
T*
[(GL_FOG_END)-5167(Linear fog end)-7334(fog)-5556(1.0)-6083(glGetFloatv\(\))]TJ
T*
[(GL_FOG_MODE)-4277(Fog mode)-9194(fog)-5556(GL_EXP)-3611(glGetIntegerv\(\))]TJ
T*
[(GL_FOG)-7722(True if fog enabled)-5529(fog/enable)-2667(GL_FALSE)-2444(glIsEnabled\(\))]TJ
T*
[(GL_SHADE_MODEL)-2333(glShadeModel\(\) setting)-3805(lighting)-3776(GL_SMOOTH)-1277(glGetIntegerv\(\))]TJ
ET
Q
40.000 503.250 m
552.010 503.250 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 487.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-4 )Tj
/F11 1 Tf
4.8 0 TD
(Coloring State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 458.000 Tm
(Lighting)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 437.000 Tm
[(See also )-45(Table 5-1)]TJ
7.4 0 TD
[( and )-56(Table 5-3)]TJ
5.8 0 TD
( for initial values.)Tj
ET
Q
40.000 425.470 m
560.000 425.470 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 418.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-14135(Description)-11748(Attribute)]TJ
38 -1.5 TD
(Group)Tj
5.875 1.5 TD
[(Initial Value)-5191(Get Command)]TJ
ET
Q
40.000 399.950 m
560.000 399.950 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 392.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_LIGHTING)-11834(True if lighting is enabled)-4944(lighting/e)]TJ
33.7778 -1.3333 TD
(nable)Tj
5.2222 1.3333 TD
[(GL_FALSE)-4666(glIsEnabled\(\))]TJ
-39 -2.7778 TD
[(GL_COLOR_MATERIAL)-7555(True if color tracking is enabled)-2473(lighting)-2110(GL_FALSE)-4666(glIsEnabled\(\))]TJ
0 -1.4444 TD
[(GL_COLOR_MATERIAL_PARAMETER)-998(Material properties tracking current)]TJ
18.4444 -1.3333 TD
(color)Tj
15.3333 1.3333 TD
[(lighting)-2110(GL_AMBIENT_)]TJ
5.2222 -1.1111 TD
(AND_DIFFU)Tj
T*
(SE)Tj
9.5556 2.2222 TD
(glGetIntegerv\(\))Tj
-48.5556 -3.6667 TD
[(GL_COLOR_MATERIAL_FACE)-4498(Face\(s\) affected by color tracking)-1836(lighting)-2110(GL_FRONT_)]TJ
39 -1.1111 TD
(AND_BACK)Tj
9.5556 1.1111 TD
(glGetIntegerv\(\))Tj
-48.5556 -2.5556 TD
[(GL_AMBIENT)-12056(Ambient material color)-6000(lighting)-2110(\(0.2, 0.2, 0.2, 1.0\))-2388(glGetMaterialfv\(\))]TJ
0 -1.5556 TD
[(GL_DIFFUSE)-12555(Diffuse material color)-6501(lighting)-2110(\(0.8, 0.8, 0.8, 1.0\))-2388(glGetMaterialfv\(\))]TJ
0 -1.4444 TD
[(GL_SPECULAR)-11498(Specular material color)-6001(lighting)-2110(\(0.0, 0.0, 0.0, 1.0\))-2388(glGetMaterialfv\(\))]TJ
T*
[(GL_EMISSION)-11888(Emissive material color)-5833(lighting)-2110(\(0.0, 0.0, 0.0, 1.0\))-2388(glGetMaterialfv\(\))]TJ
T*
[(GL_SHININESS)-11499(Specular exponent of material)-3306(lighting)-2110(0.0)-8305(glGetMaterialfv\(\))]TJ
T*
[(GL_LIGHT_MODEL_AMBIENT)-4500(Ambient scene color)-7056(lighting)-2110(\(0.2, 0.2, 0.2, 1.0\))-2388(glGetFloatv\(\))]TJ
T*
[(GL_LIGHT_MODEL_LOCAL_VIEWER)-1334(Viewer is local)-9278(lighting)-2110(GL_FALSE)-4666(glGetBooleanv\(\))]TJ
T*
[(GL_LIGHT_MODEL_TWO_SIDE)-4056(Use two-sided lighting)-5990(lighting)-2110(GL_FALSE)-4666(glGetBooleanv\(\))]TJ
T*
[(GL_AMBIENT)-12056(Ambient intensity of light )]TJ
/F15 1 Tf
29.1111 0 TD
(i)Tj
/F11 1 Tf
4.6667 0 TD
[(lighting)-2110(\(0.0,0.0,0.0,1.0\))-3139(glGetLightfv\(\))]TJ
-33.7778 -1.4444 TD
[(GL_DIFFUSE)-12555(Diffuse intensity of light )]TJ
/F15 1 Tf
28.5556 0 TD
(i)Tj
/F11 1 Tf
5.2222 0 TD
(lighting)Tj
/F33 1 Tf
5.2222 -0.1111 TD
(\276)Tj
/F11 1 Tf
9.5556 0.1111 TD
(glGetLightfv\(\))Tj
-48.5556 -1.6667 TD
[(GL_SPECULAR)-11498(Specular intensity of light )]TJ
/F15 1 Tf
29.1111 0 TD
(i)Tj
/F11 1 Tf
4.6667 0 TD
(lighting)Tj
/F33 1 Tf
5.2222 -0.1111 TD
(\276)Tj
/F11 1 Tf
9.5556 0.1111 TD
(glGetLightfv\(\))Tj
-48.5556 -1.5556 TD
[(GL_POSITION)-12056(Position of light )]TJ
/F15 1 Tf
25.1111 0 TD
(i)Tj
/F11 1 Tf
8.6667 0 TD
[(lighting)-2110(\(0.0, 0.0, 1.0, 0.0\))-2388(glGetLightfv\(\))]TJ
-33.7778 -1.4444 TD
[(GL_CONSTANT_ATTENUATION)-3667(Constant attenuation factor)-4500(lighting)-2110(1.0)-8305(glGetLightfv\(\))]TJ
T*
[(GL_LINEAR_ATTENUATION)-5334(Linear attenuation factor)-5446(lighting)-2110(0.0)-8305(glGetLightfv\(\))]TJ
0 -1.5556 TD
[(GL_QUADRATIC_ATTENUATION)-3112(Quadratic attenuation factor)-4113(lighting)-2110(0.0)-8305(glGetLightfv\(\))]TJ
0 -1.4444 TD
[(GL_SPOT_DIRECTION)-8277(Spotlight direction of light )]TJ
/F15 1 Tf
29.3333 0 TD
(i)Tj
/F11 1 Tf
4.4444 0 TD
[(lighting)-2110(\(0.0, 0.0,)]TJ
5.2222 -1.3333 TD
(-1.0\))Tj
9.5556 1.3333 TD
(glGetLightfv\(\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 4)Tj
ET
endstream
endobj
1492 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1494 0 obj
<<
/Length 6852
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(GL_SPOT_EXPONENT)-8388(Spotlight exponent of light )]TJ
/F15 1 Tf
29.4444 0 TD
(i)Tj
/F11 1 Tf
4.3333 0 TD
[(lighting)-2110(0.0)-8305(glGetLightfv\(\))]TJ
-33.7778 -1.4445 TD
[(GL_SPOT_CUTOFF)-9831(Spotlight angle of light )]TJ
/F15 1 Tf
28 0 TD
(i)Tj
/F11 1 Tf
5.7778 0 TD
[(lighting)-2110(180.0)-7305(glGetLightfv\(\))]TJ
-33.7778 -1.4444 TD
(GL_LIGHT)Tj
/F15 1 Tf
4.7778 0 TD
(i)Tj
/F11 1 Tf
13.6667 0 TD
(True if light )Tj
/F15 1 Tf
5.1111 0 TD
(i)Tj
/F11 1 Tf
0.2222 0 TD
[( enabled)-6640(lighting/e)]TJ
10 -1.3333 TD
(nable)Tj
5.2222 1.3333 TD
[(GL_FALSE)-4666(glIsEnabled\(\))]TJ
-39 -2.7778 TD
[(GL_COLOR_INDEXES)-8444(ca, cd, and cs for color-index)]TJ
18.4444 -1.3333 TD
(lighting)Tj
15.3333 1.3333 TD
(lighting/e)Tj
0 -1.3333 TD
(nable)Tj
5.2222 1.3333 TD
[(0, 1, 1)-7055(glGetMaterialfv\(\))]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 641.310 m
560.010 641.310 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 625.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-5 )Tj
/F11 1 Tf
4.8 0 TD
( \(continued\)  Lighting State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 596.000 Tm
(Rasterization)Tj
ET
Q
40.000 584.530 m
556.000 584.530 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 577.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-12385(Description)-14623(Attribute Group)-2680(Initial Value)-941(Get Command)]TJ
ET
Q
40.000 571.010 m
556.000 571.010 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 563.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_POINT_SIZE)-9500(Point size)-13971(point)-6944(1.0)-4528(glGetFloatv\(\))]TJ
0 -1.4444 TD
[(GL_POINT_SMOOTH)-7388(Point antialiasing on)-9665(point/enable)-4055(GL_FALSE)-888(glIsEnabled\(\))]TJ
T*
[(GL_LINE_WIDTH)-8946(Line width)-13527(line)-7500(1.0)-4528(glGetFloatv\(\))]TJ
T*
[(GL_LINE_SMOOTH)-8056(Line antialiasing on)-9944(line/enable)-4611(GL_FALSE)-888(glIsEnabled\(\))]TJ
T*
[(GL_LINE_STIPPLE_PATTERN)-3443(Line stipple)-13138(line)-7500(1's)-4556(glGetIntegerv\(\))]TJ
T*
[(GL_LINE_STIPPLE_REPEAT)-4165(Line stipple repeat)-10445(line)-7500(1)-5278(glGetIntegerv\(\))]TJ
T*
[(GL_LINE_STIPPLE)-8444(Line stipple enable)-10278(line/enable)-4611(GL_FALSE)-888(glIsEnabled\(\))]TJ
T*
[(GL_CULL_FACE)-9388(Polygon culling enabled)-8165(polygon/enable)-2833(GL_FALSE)-888(glIsEnabled\(\))]TJ
T*
[(GL_CULL_FACE_MODE)-5943(Cull front-/back-facing polygons)-4260(polygon)-5722(GL_BACK)-1166(glGetIntegerv\(\))]TJ
0 -1.5556 TD
[(GL_FRONT_FACE)-8721(Polygon front-face CW/CCW)]TJ
16.8889 -1.1111 TD
(indicator)Tj
17.8889 1.1111 TD
[(polygon)-5722(GL_CCW)-1666(glGetIntegerv\(\))]TJ
-34.7778 -2.5556 TD
[(GL_POLYGON_SMOOTH)-5555(Polygon antialiasing on)-8442(polygon/enable)-2833(GL_FALSE)-888(glIsEnabled\(\))]TJ
0 -1.4444 TD
[(GL_POLYGON_MODE)-6833(Polygon rasterization mode \(front and)]TJ
16.8889 -1.3333 TD
(back\))Tj
17.8889 1.3333 TD
[(polygon)-5722(GL_FILL)-1833(glGetIntegerv\(\))]TJ
-34.7778 -2.7778 TD
[(GL_POLYGON_OFFSET_FACTOR)-1720(Polygon offset factor)-9445(polygon)-5722(0)-5278(glGetFloatv\(\))]TJ
0 -1.4445 TD
[(GL_POLYGON_OFFSET_BIAS)-3387(Polygon offset bias)-10166(polygon)-5722(0)-5278(glGetFloatv\(\))]TJ
T*
[(GL_POLYGON_OFFSET_POINT)-2721(Polygon offset enable for GL_POINT)]TJ
16.8889 -1.3333 TD
(mode  rasterization)Tj
17.8889 1.3333 TD
[(polygon/enable)-2833(GL_FALSE)-888(glIsEnabled\(\))]TJ
-34.7778 -2.7778 TD
[(GL_POLYGON_OFFSET_LINE)-3388(Polygon offset enable for GL_LINE mode)]TJ
16.8889 -1.3333 TD
(rasterization)Tj
17.8889 1.3333 TD
[(polygon/enable)-2833(GL_FALSE)-888(glIsEnabled\(\))]TJ
-34.7778 -2.7778 TD
[(GL_POLYGON_OFFSET_FILL)-3554(Polygon offset enable for GL_FILL mode)]TJ
16.8889 -1.3333 TD
(rasterization)Tj
17.8889 1.3333 TD
[(polygon/enable)-2833(GL_FALSE)-888(glIsEnabled\(\))]TJ
-34.7778 -2.7778 TD
[(GL_POLYGON_STIPPLE)-5943(Polygon stipple enable)-8776(polygon/enable)-2833(GL_FALSE)-888(glIsEnabled\(\))]TJ
/F33 1 Tf
0 -1.5556 TD
(\276)Tj
/F11 1 Tf
16.8889 0.1111 TD
[(Polygon stipple pattern)-8609(polygon-stipple)-2490(1's)-4556(glGetPolygon-)]TJ
32.6667 -1.1111 TD
(Stipple\(\))Tj
ET
Q
40.000 252.470 m
556.010 252.470 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 236.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-6 )Tj
/F11 1 Tf
4.8 0 TD
( \(continued\)  Rasterization State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 207.000 Tm
(Texturing)Tj
ET
Q
40.000 195.690 m
560.000 195.690 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 188.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-11760(Description)-13498(Attribute)]TJ
37.375 -1.5 TD
(Group)Tj
5.375 1.5 TD
[(Initial Value)-2066(Get Command)]TJ
ET
Q
40.000 170.170 m
560.000 170.170 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 162.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(GL_TEXTURE_)Tj
/F15 1 Tf
6.8889 0 TD
0.000 Tw
(x)Tj
/F11 1 Tf
9.4444 0 TD
(True if )Tj
/F15 1 Tf
3 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texturing enabled \()Tj
/F15 1 Tf
8.8889 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
( is 1D)Tj
-12.7778 -1.3333 TD
(or  2D\))Tj
16.8889 1.3333 TD
(texture/e)Tj
0 -1.3333 TD
(nable)Tj
4.7778 1.3333 TD
[(GL_FALSE)-1888(glIsEnabled\(\))]TJ
-38 -2.7778 TD
(GL_TEXTURE_BINDING_)Tj
/F15 1 Tf
11.5556 0 TD
(x)Tj
/F11 1 Tf
4.7778 0 TD
(Texture object bound to)Tj
0 -1.3333 TD
(GL_TEXTURE_)Tj
/F15 1 Tf
6.8889 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
( \()Tj
/F15 1 Tf
0.5556 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
( is 1D or 2D\))Tj
8.5556 1.3333 TD
[(texture)-2000(GL_FALSE)-1888(glGetIntegerv\(\))]TJ
-33.2222 -2.7778 TD
(GL_TEXTURE)Tj
/F15 1 Tf
16.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image at level of detail )Tj
/F15 1 Tf
13.7778 0 TD
(i)Tj
/F33 1 Tf
2.6667 -0.1111 TD
3.778 Tc
(\276\276)Tj
/F11 1 Tf
11.5556 0.1111 TD
0.000 Tc
(glGetTexImage\(\))Tj
-44.7778 -1.6667 TD
(GL_TEXTURE_WIDTH)Tj
/F15 1 Tf
16.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s width)Tj
/F33 1 Tf
9.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -1.5556 TD
(GL_TEXTURE_HEIGHT)Tj
/F15 1 Tf
16.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s height)Tj
/F33 1 Tf
9.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 5)Tj
ET
endstream
endobj
1495 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1497 0 obj
<<
/Length 6963
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(GL_TEXTURE_BORDER)Tj
/F15 1 Tf
16.3333 0 TD
0.000 Tw
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s border width)Tj
/F33 1 Tf
9.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -1.6667 TD
(GL_TEXTURE_INTERNAL)Tj
0 -1.1111 TD
(_FORMAT)Tj
/F15 1 Tf
16.3333 1.1111 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s internal image)Tj
-7.7778 -1.3333 TD
(format)Tj
/F33 1 Tf
16.8889 1.2222 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(1)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -2.7778 TD
(GL_TEXTURE_RED_SIZE)Tj
/F15 1 Tf
16.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s red resolution)Tj
/F33 1 Tf
9.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -1.6667 TD
(GL_TEXTURE_GREEN_SIZE)Tj
/F15 1 Tf
16.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s green resolution)Tj
/F33 1 Tf
9.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -1.5556 TD
(GL_TEXTURE_BLUE_SIZE)Tj
/F15 1 Tf
16.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s blue resolution)Tj
/F33 1 Tf
9.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -1.6667 TD
(GL_TEXTURE_ALPHA_SIZE)Tj
/F15 1 Tf
16.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s alpha resolution)Tj
/F33 1 Tf
9.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -1.6667 TD
(GL_TEXTURE_LUMINANCE_SIZ)Tj
0 -1.3333 TD
(E)Tj
/F15 1 Tf
16.3333 1.3333 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s luminance)Tj
-7.7778 -1.3333 TD
(resolution)Tj
/F33 1 Tf
16.8889 1.2222 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -2.7778 TD
(GL_TEXTURE_INTENSITY_SIZE)Tj
/F15 1 Tf
16.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(-D texture image )Tj
/F15 1 Tf
7 0 TD
(i)Tj
/F11 1 Tf
0.3333 0 TD
('s intensity)Tj
-7.7778 -1.3333 TD
(resolution)Tj
/F33 1 Tf
16.8889 1.2222 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-6278(glGetTexLevelParameter*\(\))]TJ
-38 -2.7778 TD
[(GL_TEXTURE_BORDER_COLOR)-1498(Texture border color)-8613(texture)-2000(0, 0, 0, 0)-3277(glGetTexParameter*\(\))]TJ
0 -1.4444 TD
[(GL_TEXTURE_MIN_FILTER)-3610(Texture minification function)-5055(texture)-2000(GL_)]TJ
38 -1.1111 TD
(NEAR)Tj
T*
(EST_)Tj
T*
(MIPM)Tj
T*
(AP_)Tj
T*
(LINEA)Tj
T*
(R)Tj
6.7778 6.6667 TD
(glGetTexParameter*\(\))Tj
-44.7778 -8.1111 TD
[(GL_TEXTURE_MAG_FILTER)-3221(Texture magnification function)-4389(texture)-2000(GL_LINEAR)-1278(glGetTexParameter*\(\))]TJ
0 -1.4444 TD
(GL_TEXTURE_WRAP_)Tj
/F15 1 Tf
10.2222 0 TD
(x)Tj
/F11 1 Tf
6.1111 0 TD
(Texture wrap mode \()Tj
/F15 1 Tf
8.4444 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
[( is S or T\))-3999(texture)-2000(GL_REPEAT)-1166(glGetTexParameter*\(\))]TJ
-25.2222 -1.4444 TD
[(GL_TEXTURE_PRIORITY)-4833(Texture object priority)-7833(texture)-2000(1)-6278(glGetTexParameter*\(\))]TJ
T*
[(GL_TEXTURE_RESIDENCY)-3832(Texture residency)-9696(texture)-2000(GL_FALSE)-1888(glGetTexParameteriv\(\))]TJ
T*
[(GL_TEXTURE_ENV_MODE)-3944(Texture application function)-5500(texture)-2000(GL_)]TJ
38 -1.1111 TD
(MODU)Tj
T*
(LATE)Tj
6.7778 2.2222 TD
(glGetTexEnviv\(\))Tj
-44.7778 -3.7778 TD
[(GL_TEXTURE_ENV_COLOR)-3499(Texture environment color)-6167(texture)-2000(0, 0, 0, 0)-3277(glGetTexEnvfv\(\))]TJ
0 -1.4444 TD
(GL_TEXTURE_GEN_)Tj
/F15 1 Tf
9.4444 0 TD
(x)Tj
/F11 1 Tf
6.8889 0 TD
(Texgen enabled \()Tj
/F15 1 Tf
6.8889 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
[( is S, T, R, or Q\))-2916(texture/e)]TJ
9.5556 -1.3333 TD
(nable)Tj
4.7778 1.3333 TD
[(GL_FALSE)-1888(glIsEnabled\(\))]TJ
-38 -2.7778 TD
[(GL_EYE_PLANE)-8833(Texgen plane equation coefficients)-2863(texture)]TJ
/F33 1 Tf
38 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.7778 0.1111 TD
(glGetTexGenfv\(\))Tj
-44.7778 -1.5555 TD
[(GL_OBJECT_PLANE)-7110(Texgen object linear coefficients)-3752(texture)]TJ
/F33 1 Tf
38 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.7778 0.1111 TD
(glGetTexGenfv\(\))Tj
-44.7778 -1.6667 TD
[(GL_TEXTURE_GEN_MODE)-3944(Function used for texgen)-6916(texture)-2000(GL_EYE_)]TJ
38 -1.1111 TD
(LINEA)Tj
T*
(R)Tj
6.7778 2.2222 TD
(glGetTexGeniv\(\))Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 296.350 m
560.010 296.350 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 280.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-7 )Tj
/F11 1 Tf
4.8 0 TD
( \(continued\)  Texturing State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 251.000 Tm
(Pixel Operations)Tj
ET
Q
40.000 239.570 m
560.000 239.570 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 232.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-12885(Description)-12998(Attribute Group)-1430(Initial Value)-3316(Get Command)]TJ
ET
Q
40.000 226.050 m
560.000 226.050 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 218.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_SCISSOR_TEST)-8553(Scissoring enabled)-8916(scissor/enable)-2278(GL_FALSE)-2999(glIsEnabled\(\))]TJ
0 -1.4444 TD
[(GL_SCISSOR_BOX)-8831(Scissor box)-11805(scissor)]TJ
/F33 1 Tf
41.6667 -0.1111 TD
(\276)Tj
/F11 1 Tf
7.8889 0.1111 TD
(glGetIntegerv\(\))Tj
-49.5556 -1.6667 TD
[(GL_ALPHA_TEST)-9277(Alpha test enabled)-9000(color-buffer/)]TJ
33.7778 -1.1111 TD
(enable)Tj
7.8889 1.1111 TD
[(GL_FALSE)-2999(glIsEnabled\(\))]TJ
-41.6667 -2.5556 TD
[(GL_ALPHA_TEST_FUNC)-6110(Alpha test function)-8777(color-buffer)-2826(GL_ALWAYS)-1778(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_ALPHA_TEST_REF)-6943(Alpha test reference value)-5975(color-buffer)-2826(0)-7389(glGetIntegerv\(\))]TJ
T*
[(GL_STENCIL_TEST)-8499(Stenciling enabled)-9027(stencil-buffer/en)]TJ
33.7778 -1.3333 TD
(able)Tj
7.8889 1.3333 TD
[(GL_FALSE)-2999(glIsEnabled\(\))]TJ
-41.6667 -2.7778 TD
[(GL_STENCIL_FUNC)-8221(Stencil function)-10082(stencil-buffer)-2270(GL_ALWAYS)-1778(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_STENCIL_VALUE_MASK)-4110(Stencil mask)-11305(stencil-buffer)-2270(1's)-6667(glGetIntegerv\(\))]TJ
T*
[(GL_STENCIL_REF)-9054(Stencil reference value)-7280(stencil-buffer)-2270(0)-7389(glGetIntegerv\(\))]TJ
T*
[(GL_STENCIL_FAIL)-8666(Stencil fail action)-9388(stencil-buffer)-2270(GL_KEEP)-3555(glGetIntegerv\(\))]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 6)Tj
ET
endstream
endobj
1498 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1501 0 obj
<<
/Length 6178
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(GL_STENCIL_PASS_DEPTH_FAIL)-2053(Stencil depth buffer fail action)-4223(stencil-buffer)-2270(GL_KEEP)-3555(glGetIntegerv\(\))]TJ
0 -1.4445 TD
[(GL_STENCIL_PASS_DEPTH_PASS)-1885(Stencil depth buffer pass action)-3833(stencil-buffer)-2270(GL_KEEP)-3555(glGetIntegerv\(\))]TJ
T*
[(GL_DEPTH_TEST)-9388(Depth buffer enabled)-7946(depth-buffer/ena)]TJ
33.7778 -1.3333 TD
(ble)Tj
7.8889 1.3333 TD
[(GL_FALSE)-2999(glIsEnabled\(\))]TJ
-41.6667 -2.7778 TD
[(GL_DEPTH_FUNC)-9110(Depth buffer test function)-6084(depth-buffer)-2659(GL_LESS)-3721(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_BLEND)-12167(Blending enabled)-9416(color-buffer/)]TJ
33.7778 -1.2222 TD
(enable)Tj
7.8889 1.2222 TD
[(GL_FALSE)-2999(glIsEnabled\(\))]TJ
-41.6667 -2.6667 TD
[(GL_BLEND_SRC)-9776(Blending source function)-6333(color-buffer)-2826(GL_ONE)-4000(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_BLEND_DST)-9777(Blending destination function)-4554(color-buffer)-2826(GL_ZERO)-3444(glGetIntegerv\(\))]TJ
T*
[(GL_DITHER)-11834(Dithering enabled)-9250(color-buffer/)]TJ
33.7778 -1.1111 TD
(enable)Tj
7.8889 1.1111 TD
[(GL_TRUE)-3444(glIsEnabled\(\))]TJ
-41.6667 -2.5556 TD
[(GL_INDEX_LOGIC_OP)-7056(Color index logical operation enabled)-1333(color-buffer/)]TJ
33.7778 -1.1111 TD
(enable)Tj
7.8889 1.1111 TD
[(GL_FALSE)-2999(glIsEnabled\(\))]TJ
-41.6667 -2.5556 TD
[(GL_COLOR_LOGIC_OP)-6777(RGBA color logical operation enabled)-1000(color-buffer/)]TJ
33.7778 -1.1111 TD
(enable)Tj
7.8889 1.1111 TD
[(GL_FALSE)-2999(glIsEnabled\(\))]TJ
-41.6667 -2.5556 TD
[(GL_LOGIC_OP_MODE)-7222(Logical operation function)-5778(color-buffer)-2826(GL_COPY)-3388(glGetIntegerv\(\))]TJ
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 521.610 m
560.010 521.610 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 505.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-8 )Tj
/F11 1 Tf
4.8 0 TD
( \(continued\)  Pixel Operations)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 477.000 Tm
(Framebuffer Control)Tj
ET
Q
40.000 464.830 m
557.000 464.830 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 457.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-11135(Description)-15873(Attribute Group)-1430(Initial)]TJ
48 -1.5 TD
(Value)Tj
6.625 1.5 TD
(Get Command)Tj
ET
Q
40.000 439.310 m
557.000 439.310 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 431.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_DRAW_BUFFER)-6609(Buffers selected for drawing)-7585(color-buffer)]TJ
/F33 1 Tf
42.6667 -0.1111 TD
(\276)Tj
/F11 1 Tf
5.8889 0.1111 TD
(glGetIntegerv\(\))Tj
-48.5556 -1.6667 TD
[(GL_INDEX_WRITEMASK)-4278(Color-index writemask)-9519(color-buffer)-2826(1's)-4667(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_COLOR_WRITEMASK)-3999(Color write enables; R, G, B, or A)-5277(color-buffer)-2826(GL_TRUE)-1444(glGetBooleanv\(\))]TJ
T*
[(GL_DEPTH_WRITEMASK)-4166(Depth buffer enabled for writing)-5946(depth-buffer)-2659(GL_TRUE)-1444(glGetBooleanv\(\))]TJ
T*
[(GL_STENCIL_WRITEMASK)-3277(Stencil-buffer writemask)-8797(stencil-buffer)-2270(1's)-4667(glGetIntegerv\(\))]TJ
T*
[(GL_COLOR_CLEAR_VALUE)-2888(Color-buffer clear value \(RGBA mode\))-2937(color-buffer)-2826(0, 0, 0, 0)-2388(glGetFloatv\(\))]TJ
T*
[(GL_INDEX_CLEAR_VALUE)-3167(Color-buffer clear value \(color-index mode\))-874(color-buffer)-2826(0)-5389(glGetFloatv\(\))]TJ
T*
[(GL_DEPTH_CLEAR_VALUE)-3055(Depth-buffer clear value)-8938(depth-buffer)-2659(1)-5389(glGetIntegerv\(\))]TJ
T*
[(GL_STENCIL_CLEAR_VALUE)-2166(Stencil-buffer clear value)-8604(stencil-buffer)-2270(0)-5389(glGetIntegerv\(\))]TJ
T*
[(GL_ACCUM_CLEAR_VALUE)-2610(Accumulation-buffer clear value)-5716(accum-buffer)-2271(0)-5389(glGetFloatv\(\))]TJ
ET
Q
40.000 304.620 m
557.010 304.620 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 288.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-9 )Tj
/F11 1 Tf
4.8 0 TD
(Framebuffer Control State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 260.000 Tm
(Pixels)Tj
ET
Q
40.000 247.840 m
555.000 247.840 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 240.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-10010(Description)-18248(Attribute)]TJ
40.375 -1.5 TD
(Group)Tj
7.125 1.5 TD
[(Initial Value)-1566(Get Command)]TJ
ET
Q
40.000 222.320 m
555.000 222.320 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 214.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_UNPACK_SWAP_BYTES)-1887(Value of GL_UNPACK_SWAP_BYTES)-4498(pixel-store)-1825(GL_FALSE)-1444(glGetBooleanv\(\))]TJ
0 -1.4444 TD
[(GL_UNPACK_LSB_FIRST)-3275(Value of GL_UNPACK_LSB_FIRST)-5887(pixel-store)-1825(GL_FALSE)-1444(glGetBooleanv\(\))]TJ
T*
[(GL_UNPACK_ROW_LENGTH)-1500(Value of GL_UNPACK_ROW_LENGTH)-4111(pixel-store)-1825(0)-5833(glGetIntegerv\(\))]TJ
T*
[(GL_UNPACK_SKIP_ROWS)-2776(Value of GL_UNPACK_SKIP_ROWS)-5388(pixel-store)-1825(0)-5833(glGetIntegerv\(\))]TJ
T*
[(GL_UNPACK_SKIP_PIXELS)-2276(Value of GL_UNPACK_SKIP_PIXELS)-4888(pixel-store)-1825(0)-5833(glGetIntegerv\(\))]TJ
T*
[(GL_UNPACK_ALIGNMENT)-2389(Value of GL_UNPACK_ALIGNMENT)-5001(pixel-store)-1825(4)-5833(glGetIntegerv\(\))]TJ
T*
[(GL_PACK_SWAP_BYTES)-3331(Value of GL_PACK_SWAP_BYTES)-5943(pixel-store)-1825(GL_FALSE)-1444(glGetBooleanv\(\))]TJ
T*
[(GL_PACK_LSB_FIRST)-4719(Value of GL_PACK_LSB_FIRST)-7331(pixel-store)-1825(GL_FALSE)-1444(glGetBooleanv\(\))]TJ
T*
[(GL_PACK_ROW_LENGTH)-2944(Value of GL_PACK_ROW_LENGTH)-5556(pixel-store)-1825(0)-5833(glGetIntegerv\(\))]TJ
T*
[(GL_PACK_SKIP_ROWS)-4220(Value of GL_PACK_SKIP_ROWS)-6832(pixel-store)-1825(0)-5833(glGetIntegerv\(\))]TJ
T*
[(GL_PACK_SKIP_PIXELS)-3720(Value of GL_PACK_SKIP_PIXELS)-6332(pixel-store)-1825(0)-5833(glGetIntegerv\(\))]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 7)Tj
ET
endstream
endobj
1502 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1504 0 obj
<<
/Length 6786
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 712.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(GL_PACK_ALIGNMENT)-3833(Value of GL_PACK_ALIGNMENT)-6445(pixel-store)-1825(4)-5833(glGetIntegerv\(\))]TJ
0 -1.4445 TD
[(GL_MAP_COLOR)-6888(True if colors are mapped)-10780(pixel)-4333(GL_FALSE)-1444(glGetBooleanv\(\))]TJ
T*
[(GL_MAP_STENCIL)-6165(True if stencil values are mapped)-7807(pixel)-4333(GL_FALSE)-1444(glGetBooleanv\(\))]TJ
T*
[(GL_INDEX_SHIFT)-6556(Value of GL_INDEX_SHIFT)-9167(pixel)-4333(0)-5833(glGetIntegerv\(\))]TJ
T*
[(GL_INDEX_OFFSET)-5721(Value of GL_INDEX_OFFSET)-8333(pixel)-4333(0)-5833(glGetIntegerv\(\))]TJ
T*
(GL_)Tj
/F15 1 Tf
1.8889 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
[(_SCALE)-8777(Value of GL_)]TJ
/F15 1 Tf
18 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(_SCALE; )Tj
/F15 1 Tf
4.2222 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
( is GL_RED,)Tj
-10.6667 -1.3333 TD
(GL_GREEN, GL_BLUE, GL_ALPHA, or)Tj
T*
(GL_DEPTH)Tj
21.1111 2.6667 TD
[(pixel)-4333(1)-5833(glGetFloatv\(\))]TJ
-35.8889 -4.1111 TD
(GL_)Tj
/F15 1 Tf
1.8889 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
[(_BIAS)-9666(Value of GL_)]TJ
/F15 1 Tf
18 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
(_BIAS; )Tj
/F15 1 Tf
3.3333 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
( is one of GL_RED,)Tj
-9.7778 -1.3333 TD
(GL_GREEN, GL_BLUE, GL_ALPHA, or)Tj
T*
(GL_DEPTH)Tj
21.1111 2.6667 TD
[(pixel)-4333(0)-5833(glGetFloatv\(\))]TJ
-35.8889 -4.1111 TD
(GL_ZOOM_X)Tj
/F15 1 Tf
14.7778 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
[( zoom factor)-15612(pixel)-4333(1.0)-5083(glGetFloatv\(\))]TJ
-15.2222 -1.4444 TD
(GL_ZOOM_Y)Tj
/F15 1 Tf
14.7778 0 TD
(y)Tj
/F11 1 Tf
0.4444 0 TD
[( zoom factor)-15612(pixel)-4333(1.0)-5083(glGetFloatv\(\))]TJ
-15.2222 -1.5556 TD
[(GL_x)-12444(glPixelMap\(\) translation tables; )]TJ
/F15 1 Tf
27.6667 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
( is a map name)Tj
-13.3333 -1.3333 TD
0.028 Tw
[(from Table )28(8-1)]TJ
/F33 1 Tf
21.1111 1.2222 TD
0.000 Tw
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
[(0's)-5111(glGetPixelMap*\(\))]TJ
-42.2222 -2.7778 TD
(GL_)Tj
/F15 1 Tf
1.8889 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
[(_SIZE)-9833(Size of table )]TJ
/F15 1 Tf
17.6667 0 TD
(x)Tj
/F33 1 Tf
15.8889 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
[(1)-5833(glGetIntegerv\(\))]TJ
-42.2222 -1.5556 TD
[(GL_READ_BUFFER)-5942(Read source buffer)-13502(pixel)]TJ
/F33 1 Tf
42.2222 -0.1111 TD
(\276)Tj
/F11 1 Tf
6.3333 0.1111 TD
(glGetIntegerv\(\))Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 497.550 m
555.010 497.550 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 481.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-10 )Tj
/F11 1 Tf
5.3 0 TD
( \(continued\)  Pixel State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 453.000 Tm
(Evaluators)Tj
ET
Q
40.000 440.770 m
554.000 440.770 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 433.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-10510(Description)-12373(Attribute Group)-1430(Initial Value)-2191(Get Command)]TJ
ET
Q
40.000 427.250 m
554.000 427.250 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 419.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_ORDER)-9999(1D map order)]TJ
/F33 1 Tf
31.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
7.8889 0.1111 TD
[(1)-6389(glGetMapiv\(\))]TJ
-39 -1.6667 TD
[(GL_ORDER)-9999(2D map orders)]TJ
/F33 1 Tf
31.1111 -0.1111 TD
(\276)Tj
/F11 1 Tf
7.8889 0.1111 TD
[(1, 1)-5389(glGetMapiv\(\))]TJ
-39 -1.5556 TD
[(GL_COEFF)-10277(1D control points)]TJ
/F33 1 Tf
31.1111 -0.1111 TD
6.889 Tc
(\276\276)Tj
/F11 1 Tf
14.7778 0.1111 TD
0.000 Tc
(glGetMapfv\(\))Tj
-45.8889 -1.6667 TD
[(GL_COEFF)-10277(2D control points)]TJ
/F33 1 Tf
31.1111 -0.1111 TD
6.889 Tc
(\276\276)Tj
/F11 1 Tf
14.7778 0.1111 TD
0.000 Tc
(glGetMapfv\(\))Tj
-45.8889 -1.6667 TD
[(GL_DOMAIN)-9278(1D domain endpoints)]TJ
/F33 1 Tf
31.1111 -0.1111 TD
6.889 Tc
(\276\276)Tj
/F11 1 Tf
14.7778 0.1111 TD
0.000 Tc
(glGetMapfv\(\))Tj
-45.8889 -1.5556 TD
[(GL_DOMAIN)-9278(2D domain endpoints)]TJ
/F33 1 Tf
31.1111 -0.2222 TD
6.889 Tc
(\276\276)Tj
/F11 1 Tf
14.7778 0.2222 TD
0.000 Tc
(glGetMapfv\(\))Tj
-45.8889 -1.6667 TD
(GL_MAP1_)Tj
/F15 1 Tf
5 0 TD
(x)Tj
/F11 1 Tf
10.2222 0 TD
(1D map enables: )Tj
/F15 1 Tf
7 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
[( is map type)-3583(eval/enable)-3334(GL_FALSE)-1999(glIsEnabled\(\))]TJ
-22.6667 -1.4444 TD
(GL_MAP2_)Tj
/F15 1 Tf
5 0 TD
(x)Tj
/F11 1 Tf
10.2222 0 TD
(2D map enables: )Tj
/F15 1 Tf
7 0 TD
(x)Tj
/F11 1 Tf
0.4444 0 TD
[( is map type)-3583(eval/enable)-3334(GL_FALSE)-1999(glIsEnabled\(\))]TJ
-22.6667 -1.4444 TD
[(GL_MAP1_GRID_DOMAIN)-3166(1D grid endpoints)-8666(eval)-6223(0, 1)-5389(glGetFloatv\(\))]TJ
T*
[(GL_MAP2_GRID_DOMAIN)-3166(2D grid endpoints)-8666(eval)-6223(0, 1; 0, 1)-3360(glGetFloatv\(\))]TJ
T*
[(GL_MAP1_GRID_SEGMENTS)-1998(1D grid divisions)-8943(eval)-6223(1)-6389(glGetFloatv\(\))]TJ
T*
[(GL_MAP2_GRID_SEGMENTS)-1998(2D grid divisions)-8943(eval)-6223(1,1)-5639(glGetFloatv\(\))]TJ
0 -1.5556 TD
[(GL_AUTO_NORMAL)-5778(True if automatic normal generation)]TJ
15.2222 -1.3333 TD
(enabled)Tj
15.8889 1.3333 TD
[(eval)-6223(GL_FALSE)-1999(glIsEnabled\(\))]TJ
ET
Q
40.000 233.010 m
554.010 233.010 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 217.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-11 )Tj
/F11 1 Tf
5.3 0 TD
(Evaluator State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 188.000 Tm
(Hints)Tj
ET
Q
40.000 176.230 m
554.000 176.230 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 169.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-15260(Description)-9998(Attribute)]TJ
37.375 -1.5 TD
(Group)Tj
5.875 1.5 TD
[(Initial Value)-5816(Get Command)]TJ
ET
Q
40.000 150.710 m
554.000 150.710 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 143.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_PERSPECTIVE_CORRECTION_HINT)-1331(Perspective correction hint)-3056(hint)-3666(GL_DONT_CARE)-2333(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_POINT_SMOOTH_HINT)-7056(Point smooth hint)-6664(hint)-3666(GL_DONT_CARE)-2333(glGetIntegerv\(\))]TJ
T*
[(GL_LINE_SMOOTH_HINT)-7723(Line smooth hint)-6943(hint)-3666(GL_DONT_CARE)-2333(glGetIntegerv\(\))]TJ
0 -1.5556 TD
[(GL_POLYGON_SMOOTH_HINT)-5222(Polygon smooth hint)-5441(hint)-3666(GL_DONT_CARE)-2333(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_FOG_HINT)-12722(Fog hint)-10415(hint)-3666(GL_DONT_CARE)-2333(glGetIntegerv\(\))]TJ
ET
Q
40.000 82.950 m
554.010 82.950 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 8)Tj
ET
endstream
endobj
1505 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1507 0 obj
<<
/Length 7428
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Table B-12 )Tj
/F11 1 Tf
5.3 0 TD
(Hint State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 682.000 Tm
(Implementation-Dependent Values)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 669.830 m
557.000 669.830 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 662.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-16510(Description)-15248(Attribute)]TJ
43.875 -1.5 TD
(Group)Tj
5.375 1.5 TD
(Minimum)Tj
0 -1.5 TD
(Value)Tj
5.875 1.5 TD
(Get Command)Tj
ET
Q
40.000 644.310 m
557.000 644.310 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 636.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_MAX_LIGHTS)-12333(Maximum number of lights)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(8)-4722(glGetIntegerv\(\))]TJ
-43.7778 -1.6667 TD
[(GL_MAX_CLIP_PLANES)-9443(Maximum number of user clipping planes)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(6)-4722(glGetIntegerv\(\))]TJ
-43.7778 -1.5556 TD
[(GL_MAX_MODELVIEW_STACK_DEPTH)-2222(Maximum modelview-matrix stack depth)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(32)-4222(glGetIntegerv\(\))]TJ
-43.7778 -1.6667 TD
[(GL_MAX_PROJECTION_STACK_DEPTH)-2387(Maximum projection-matrix stack depth)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(2)-4722(glGetIntegerv\(\))]TJ
-43.7778 -1.6667 TD
[(GL_MAX_TEXTURE_STACK_DEPTH)-3832(Maximum depth of texture matrix stack)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(2)-4722(glGetIntegerv\(\))]TJ
-43.7778 -1.5556 TD
[(GL_SUBPIXEL_BITS)-11276(Number of bits of subpixel precision in x)]TJ
20.5556 -1.3333 TD
(and  y)Tj
/F33 1 Tf
18.4444 1.2222 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(4)-4722(glGetIntegerv\(\))]TJ
-43.7778 -2.7778 TD
[(GL_MAX_TEXTURE_SIZE)-8722(See discussion in )29("Texture Proxy" in)]TJ
20.5556 -1.3333 TD
(Chapter 9)Tj
/F33 1 Tf
18.4444 1.2222 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(64)-4222(glGetIntegerv\(\))]TJ
-43.7778 -2.8889 TD
[(GL_MAX_PIXEL_MAP_TABLE)-6665(Maximum size of a glPixelMap\(\))]TJ
20.5556 -1.3333 TD
(translation  table)Tj
/F33 1 Tf
18.4444 1.2222 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(32)-4222(glGetIntegerv\(\))]TJ
-43.7778 -2.7778 TD
[(GL_MAX_NAME_STACK_DEPTH)-5443(Maximum selection-name stack depth)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(64)-4222(glGetIntegerv\(\))]TJ
-43.7778 -1.5556 TD
[(GL_MAX_LIST_NESTING)-9000(Maximum display-list call nesting)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(64)-4222(glGetIntegerv\(\))]TJ
-43.7778 -1.6667 TD
[(GL_MAX_EVAL_ORDER)-9333(Maximum evaluator polynomial order)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(8)-4722(glGetIntegerv\(\))]TJ
-43.7778 -1.6667 TD
[(GL_MAX_VIEWPORT_DIMS)-7722(Maximum viewport dimensions)]TJ
/F33 1 Tf
39 -0.1111 TD
3.778 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -1.6667 TD
[(GL_MAX_ATTRIB_STACK_DEPTH)-4776(Maximum depth of the attribute stack)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(16)-4222(glGetIntegerv\(\))]TJ
-43.7778 -1.5556 TD
(GL_MAX_CLIENT_ATTRIB_STACK_DEPT)Tj
0 -1.3333 TD
(H)Tj
20.5556 1.3333 TD
(Maximum depth of the client attribute stack)Tj
/F33 1 Tf
18.4444 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(16)-4222(glGetIntegerv\(\))]TJ
-43.7778 -2.7778 TD
[(GL_AUX_BUFFERS)-11720(Number of auxiliary buffers)]TJ
/F33 1 Tf
39 -0.1111 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(0)-4722(glGetBooleanv\(\))]TJ
-43.7778 -1.6667 TD
[(GL_RGBA_MODE)-12499(True if color buffers store RGBA)]TJ
/F33 1 Tf
39 -0.1111 TD
3.778 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetBooleanv\(\))Tj
-49 -1.6667 TD
[(GL_INDEX_MODE)-12167(True if color buffers store indices)]TJ
/F33 1 Tf
39 -0.1111 TD
3.778 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetBooleanv\(\))Tj
-49 -1.5556 TD
[(GL_DOUBLEBUFFER)-10887(True if front and back buffers exist)]TJ
/F33 1 Tf
39 -0.1111 TD
3.778 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetBooleanv\(\))Tj
-49 -1.6667 TD
[(GL_STEREO)-14944(True if left and right buffers exist)]TJ
/F33 1 Tf
39 -0.1111 TD
3.778 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetBooleanv\(\))Tj
-49 -1.6667 TD
[(GL_POINT_SIZE_RANGE)-9222(Range \(low to high\) of antialiased point)]TJ
20.5556 -1.3333 TD
(sizes)Tj
/F33 1 Tf
18.4444 1.2222 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(1, 1)-3722(glGetFloatv\(\))]TJ
-43.7778 -2.7778 TD
[(GL_POINT_SIZE_GRANULARITY)-5444(Antialiased point-size granularity)]TJ
/F33 1 Tf
39 -0.1111 TD
3.778 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetFloatv\(\))Tj
-49 -1.6667 TD
[(GL_LINE_WIDTH_RANGE)-8668(Range \(low to high\) of antialiased line)]TJ
20.5556 -1.3333 TD
(widths)Tj
/F33 1 Tf
18.4444 1.2222 TD
(\276)Tj
/F11 1 Tf
4.7778 0.1111 TD
[(1, 1)-3722(glGetFloatv\(\))]TJ
-43.7778 -2.7778 TD
[(GL_LINE_WIDTH_GRANULARITY)-4890(Antialiased line-width granularity)]TJ
/F33 1 Tf
39 -0.1111 TD
3.778 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetFloatv\(\))Tj
ET
Q
40.000 241.090 m
557.010 241.090 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 225.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-13 )Tj
/F11 1 Tf
5.3 0 TD
( \(continued\)  Implementation-Dependent State Variables)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 196.000 Tm
(Implementation-Dependent Pixel Depths)Tj
ET
Q
40.000 184.310 m
556.000 184.310 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 177.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-11135(Description)-20623(Attribute)]TJ
43.875 -1.5 TD
(Group)Tj
6 1.5 TD
(Minimu)Tj
0 -1.5 TD
(m  Value)Tj
5.25 1.5 TD
(Get Command)Tj
ET
Q
40.000 158.790 m
556.000 158.790 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 151.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_RED_BITS)-9277(Number of bits per red component in color buffers)]TJ
/F33 1 Tf
39 -0.1111 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -1.6667 TD
[(GL_GREEN_BITS)-7944(Number of bits per green component in color buffers)]TJ
/F33 1 Tf
39 -0.1111 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -1.6667 TD
[(GL_BLUE_BITS)-8666(Number of bits per blue component in color buffers)]TJ
/F33 1 Tf
39 -0.1111 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -1.5556 TD
[(GL_ALPHA_BITS)-7944(Number of bits per alpha component in color buffers)]TJ
/F33 1 Tf
39 -0.2222 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.2222 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -1.6667 TD
[(GL_INDEX_BITS)-8167(Number of bits per index in color buffers)]TJ
/F33 1 Tf
39 -0.1111 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -1.6667 TD
[(GL_DEPTH_BITS)-8055(Number of depth-buffer bitplanes)]TJ
/F33 1 Tf
39 -0.1111 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix B,  State Variables - 9)Tj
ET
endstream
endobj
1508 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1510 0 obj
<<
/Length 4632
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(GL_STENCIL_BITS)-7165(Number of stencil bitplanes)]TJ
/F33 1 Tf
39 -0.1111 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -1.5556 TD
[(GL_ACCUM_RED_BITS)-5109(Number of bits per red component in the accumulation)]TJ
15.7778 -1.3333 TD
(buffer)Tj
/F33 1 Tf
23.2222 1.2222 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -2.7778 TD
[(GL_ACCUM_GREEN_BITS)-3776(Number of bits per green component in the)]TJ
15.7778 -1.3333 TD
(accumulation  buffer)Tj
/F33 1 Tf
23.2222 1.2222 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -2.8889 TD
[(GL_ACCUM_BLUE_BITS)-4498(Number of bits per blue component in the accumulation)]TJ
15.7778 -1.3333 TD
(buffer)Tj
/F33 1 Tf
23.2222 1.2222 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
-49 -2.7778 TD
[(GL_ACCUM_ALPHA_BITS)-3776(Number of bits per alpha component in the)]TJ
15.7778 -1.3333 TD
(accumulation  buffer)Tj
/F33 1 Tf
23.2222 1.2222 TD
4.333 Tc
(\276\276)Tj
/F11 1 Tf
10 0.1111 TD
0.000 Tc
(glGetIntegerv\(\))Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
40.000 600.970 m
556.010 600.970 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 585.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-14 )Tj
/F11 1 Tf
5.3 0 TD
(Implementation-Dependent Pixel-Depth State Variables \(continued\))Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 556.000 Tm
(Miscellaneous)Tj
ET
Q
40.000 544.190 m
554.000 544.190 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
8.000 0.000 0.000 8.000 40.000 536.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(State Variable)-12885(Description)-15873(Attribute)]TJ
40.875 -1.5 TD
(Group)Tj
6 1.5 TD
[(Initial Value)-2691(Get Command)]TJ
ET
Q
40.000 518.670 m
554.000 518.670 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
9.000 0.000 0.000 9.000 40.000 511.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
[(GL_LIST_BASE)-10332(Setting of glListBase\(\))-9888(list)-4110(0)-6833(glGetIntegerv\(\))]TJ
0 -1.4444 TD
[(GL_LIST_INDEX)-9778(Number of display list under construction; 0)]TJ
17.3333 -1.3333 TD
(if  none)Tj
/F33 1 Tf
19 1.2222 TD
(\276)Tj
/F11 1 Tf
5.3333 0.1111 TD
[(0)-6833(glGetIntegerv\(\))]TJ
-41.6667 -2.8889 TD
[(GL_LIST_MODE)-9944(Mode of display list under construction;)]TJ
17.3333 -1.3333 TD
(undefined if none)Tj
/F33 1 Tf
19 1.2222 TD
(\276)Tj
/F11 1 Tf
5.3333 0.1111 TD
[(0)-6833(glGetIntegerv\(\))]TJ
-41.6667 -2.7778 TD
[(GL_ATTRIB_STACK_DEPTH)-4387(Attribute stack pointer)]TJ
/F33 1 Tf
36.3333 -0.1111 TD
(\276)Tj
/F11 1 Tf
5.3333 0.1111 TD
[(0)-6833(glGetIntegerv\(\))]TJ
-41.6667 -1.5556 TD
(GL_CLIENT_ATTRIB_STACK_DEPT)Tj
0 -1.3333 TD
(H)Tj
17.3333 1.3333 TD
(Client attribute stack pointer)Tj
/F33 1 Tf
19 -0.1111 TD
(\276)Tj
/F11 1 Tf
5.3333 0.1111 TD
[(0)-6833(glGetIntegerv\(\))]TJ
-41.6667 -2.7778 TD
[(GL_NAME_STACK_DEPTH)-5054(Name stack depth)]TJ
/F33 1 Tf
36.3333 -0.1111 TD
(\276)Tj
/F11 1 Tf
5.3333 0.1111 TD
[(0)-6833(glGetIntegerv\(\))]TJ
-41.6667 -1.6667 TD
[(GL_RENDER_MODE)-8055(glRenderMode\(\) setting)]TJ
/F33 1 Tf
36.3333 -0.1111 TD
(\276)Tj
/F11 1 Tf
5.3333 0.1111 TD
[(GL_RENDER)-1499(glGetIntegerv\(\))]TJ
-41.6667 -1.6667 TD
[(GL_SELECTION_BUFFER_POINTER)-1053(Pointer to selection buffer)-8583(select)-3056(0)-6833(glGetPointerv\(\))]TJ
0 -1.4444 TD
[(GL_SELECTION_BUFFER_SIZE)-3164(Size of selection buffer)-9696(select)-3056(0)-6833(glGetIntegerv\(\))]TJ
T*
[(GL_FEEDBACK_BUFFER_POINTER)-1219(Pointer to feedback buffer)-8529(feedback)-1724(0)-6833(glGetPointerv\(\))]TJ
T*
[(GL_FEEDBACK_BUFFER_SIZE)-3330(Size of feedback buffer)-9642(feedback)-1724(0)-6833(glGetIntegerv\(\))]TJ
T*
[(GL_FEEDBACK_BUFFER_TYPE)-2941(Type of feedback buffer)-9308(feedback)-1724(GL_2D)-4278(glGetIntegerv\(\))]TJ
/F33 1 Tf
0 -1.5555 TD
(\276)Tj
/F11 1 Tf
17.3333 0.1111 TD
(Current error code\(s\))Tj
/F33 1 Tf
19 -0.1111 TD
(\276)Tj
/F11 1 Tf
5.3333 0.1111 TD
[(0)-6833(glGetError\(\))]TJ
ET
Q
40.000 303.790 m
554.010 303.790 l
S
q
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 40.000 288.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Table B-15 )Tj
/F11 1 Tf
5.3 0 TD
(Miscellaneous State Variables)Tj
ET
Q
124.000 266.790 m
547.000 266.790 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 10)Tj
ET
endstream
endobj
1511 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1513 0 obj
<<
/Length 3950
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix C)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(OpenGL and Window Systems)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(OpenGL is available on many different platforms and works with many different window systems.)Tj
0 -1.5 TD
(OpenGL is designed to complement window systems, not duplicate their functionality. Therefore,)Tj
T*
(OpenGL performs geometric and image rendering in two and three dimensions, but it does not manage)Tj
T*
(windows or handle input events.)Tj
0 -2.1 TD
(However, the basic definitions of most window systems don't support a library as sophisticated as)Tj
0 -1.5 TD
(OpenGL, with its complex and diverse pixel formats, including depth, stencil, and accumulation buffers,)Tj
T*
(as well as double-buffering. For most window systems, some routines are added to extend the window)Tj
T*
(system to support OpenGL.)Tj
0 -2.1 TD
(This appendix introduces the extensions defined for several window and operating systems: the X)Tj
0 -1.5 TD
(Window System, the Apple Mac OS, OS/2 Warp from IBM, and Microsoft Windows NT and Windows)Tj
T*
(95. You need to have some knowledge of the window systems to fully understand this appendix.)Tj
0 -2.1 TD
(This appendix has the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("GLX: OpenGL Extension for the X Window System")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("AGL: OpenGL Extension to the Apple Macintosh")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("PGL: OpenGL Extension for IBM OS/2 Warp")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("WGL: OpenGL Extension for Microsoft Windows NT and Windows 95")Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 356.000 Tm
(GLX: OpenGL Extension for the X Window System)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 334.000 Tm
(In the X Window System, OpenGL rendering is made available as an extension to X in the formal X)Tj
0 -1.5 TD
(sense. GLX is an extension to the X protocol \(and its associated API\) for communicating OpenGL)Tj
T*
(commands to an extended X server. Connection and authentication are accomplished with the normal X)Tj
T*
(mechanisms.)Tj
0 -2.1 TD
(As with other X extensions, there is a defined network protocol for OpenGL's rendering commands)Tj
0 -1.5 TD
(encapsulated within the X byte stream, so client-server OpenGL rendering is supported. Since)Tj
T*
(performance is critical in three-dimensional rendering, the OpenGL extension to X allows OpenGL to)Tj
T*
(bypass the X server's involvement in data encoding, copying, and interpretation and instead render)Tj
T*
(directly to the graphics pipeline.)Tj
0 -2.1 TD
(The X Visual is the key data structure to maintain pixel format information about the OpenGL window.)Tj
0 -1.5 TD
(A variable of data type XVisualInfo keeps track of pixel information, including pixel type \(RGBA or)Tj
T*
(color index\), single or double-buffering, resolution of colors, and presence of depth, stencil, and)Tj
T*
(accumulation buffers. The standard X Visuals \(for example, PseudoColor, TrueColor\) do not describe the)Tj
T*
(pixel format details, so each implementation must extend the number of X Visuals supported.)Tj
0 -2.1 TD
(The GLX routines are discussed in more detail in the )Tj
/F15 1 Tf
21.4 0 TD
(OpenGL Reference Manual)Tj
/F11 1 Tf
11.1 0 TD
(. Integrating OpenGL)Tj
-32.5 -1.5 TD
(applications with the X Window System and the Motif widget set is discussed in great detail in )Tj
/F15 1 Tf
38.2 0 TD
(OpenGL)Tj
-38.2 -1.5 TD
(Programming for the X Window System )Tj
/F11 1 Tf
16.2 0 TD
(by  Mark Kilgard \(Reading, MA: Addison-Wesley Developers)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 1)Tj
ET
endstream
endobj
1514 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1516 0 obj
<<
/Length 4634
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Press, 1996\), which includes full source code examples. If you absolutely want to learn about the)Tj
0 -1.5 TD
(internals of GLX, you may want to read the GLX specification, which can be found at)Tj
/F7 1 Tf
0 -2.1 TD
(ftp://sgigate.sgi.com/pub/opengl/doc/)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 644.000 Tm
(Initialization)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 622.000 Tm
(Use )Tj
/F15 1 Tf
1.8 0 TD
(glXQueryExtension\(\))Tj
/F11 1 Tf
8.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(glXQueryVersion\(\))Tj
/F11 1 Tf
7.7 0 TD
( to determine whether the GLX extension is defined for)Tj
-19.9 -1.5 TD
(an X server and, if so, which version is present. )Tj
/F15 1 Tf
19.2 0 TD
(glXQueryExtensionsString\(\))Tj
/F11 1 Tf
11.4 0 TD
( returns extension)Tj
-30.6 -1.5 TD
(information about the client-server connection. )Tj
/F15 1 Tf
19.1 0 TD
(glXGetClientString\(\))Tj
/F11 1 Tf
8.3 0 TD
( returns information about the client)Tj
-27.4 -1.5 TD
(library, including extensions and version number. )Tj
/F15 1 Tf
20.1 0 TD
(glXQueryServerString\(\))Tj
/F11 1 Tf
9.6 0 TD
( returns similar information)Tj
-29.7 -1.5 TD
(about the server.)Tj
/F15 1 Tf
0 -2.1 TD
(glXChooseVisual\(\))Tj
/F11 1 Tf
7.6 0 TD
( returns a pointer to an XVisualInfo structure describing the visual that meets the)Tj
-7.6 -1.5 TD
(client's specified attributes. You can query a visual about its support of a particular OpenGL attribute)Tj
T*
(with )Tj
/F15 1 Tf
2 0 TD
(glXGetConfig\(\))Tj
/F11 1 Tf
6.3 0 TD
(.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 483.000 Tm
(Controlling Rendering)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 461.000 Tm
(Several GLX routines are provided for creating and managing an OpenGL rendering context. You can)Tj
0 -1.5 TD
(use such a context to render off-screen if you want. Routines are also provided for such tasks as)Tj
T*
(synchronizing execution between the X and OpenGL streams, swapping front and back buffers, and)Tj
T*
(using an X font.)Tj
/F27 1 Tf
0 -3 TD
(Managing an OpenGL Rendering Context)Tj
/F11 1 Tf
0 -2.1 TD
(An OpenGL rendering context is created with )Tj
/F15 1 Tf
18.6 0 TD
(glXCreateContext\(\))Tj
/F11 1 Tf
7.9 0 TD
(. One of the arguments to this routine)Tj
-26.5 -1.5 TD
(allows you to request a direct rendering context that bypasses the X server as described previously. \(Note)Tj
T*
(that to do direct rendering, the X server connection must be local, and the OpenGL implementation needs)Tj
T*
(to support direct rendering.\) )Tj
/F15 1 Tf
11.5 0 TD
(glXCreateContext\(\))Tj
/F11 1 Tf
7.9 0 TD
( also allows display-list and texture-object indices and)Tj
-19.4 -1.5 TD
(definitions to be shared by multiple rendering contexts. You can determine whether a GLX context is)Tj
T*
(direct with )Tj
/F15 1 Tf
4.6 0 TD
(glXIsDirect\(\))Tj
/F11 1 Tf
5.3 0 TD
(.)Tj
-9.9 -2.1 TD
(To make a rendering context current, use )Tj
/F15 1 Tf
16.7 0 TD
(glXMakeCurrent\(\))Tj
/F11 1 Tf
7.4 0 TD
(; )Tj
/F15 1 Tf
0.5 0 TD
(glXGetCurrentContext\(\))Tj
/F11 1 Tf
9.8 0 TD
( returns the current)Tj
-34.4 -1.5 TD
(context. You can also obtain the current drawable with )Tj
/F15 1 Tf
22.2 0 TD
(glXGetCurrentDrawable\(\))Tj
/F11 1 Tf
10.6 0 TD
( and the current X)Tj
-32.8 -1.5 TD
(Display with )Tj
/F15 1 Tf
5.4 0 TD
(glXGetCurrentDisplay\(\))Tj
/F11 1 Tf
9.8 0 TD
(. Remember that only one context can be current for any thread at)Tj
-15.2 -1.5 TD
(any one time. If you have multiple contexts, you can copy selected groups of OpenGL state variables)Tj
T*
(from one context to another with )Tj
/F15 1 Tf
13.4 0 TD
(glXCopyContext\(\))Tj
/F11 1 Tf
7.3 0 TD
(. When you're finished with a particular context,)Tj
-20.7 -1.5 TD
(destroy it with )Tj
/F15 1 Tf
6 0 TD
(glXDestroyContext\(\))Tj
/F11 1 Tf
8.4 0 TD
(.)Tj
/F27 1 Tf
-14.4 -3 TD
(Off-Screen Rendering)Tj
/F11 1 Tf
0 -2.1 TD
(To render off-screen, first create an X Pixmap and then pass this as an argument to)Tj
/F15 1 Tf
0 -1.5 TD
(glXCreateGLXPixmap\(\))Tj
/F11 1 Tf
9.7 0 TD
(. Once rendering is completed,)Tj
-9.7 -1.1 TD
(you can destroy the association between the X and GLX Pixmaps with )Tj
/F15 1 Tf
28.5 0 TD
(glXDestroyGLXPixmap\(\))Tj
/F11 1 Tf
10.2 0 TD
(.)Tj
-38.7 -1.1 TD
(\(Off-screen rendering isn't guaranteed to be supported for direct renderers.\))Tj
/F27 1 Tf
0 -3 TD
(Synchronizing Execution)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 2)Tj
ET
endstream
endobj
1517 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1519 0 obj
<<
/Length 4767
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 703.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(To prevent X requests from executing until any outstanding OpenGL rendering is completed, call)Tj
/F15 1 Tf
0 -1.5 TD
(glXWaitGL\(\))Tj
/F11 1 Tf
5.2 0 TD
(. Then, any previously issued OpenGL commands are guaranteed to be executed before any)Tj
-5.2 -1.5 TD
(X rendering calls made after )Tj
/F15 1 Tf
11.6 0 TD
(glXWaitGL\(\))Tj
/F11 1 Tf
5.3 0 TD
(. Although the same result can be achieved with )Tj
/F15 1 Tf
19.4 0 TD
(glFinish\(\))Tj
/F11 1 Tf
4 0 TD
(,)Tj
/F15 1 Tf
-40.3 -1.5 TD
(glXWaitGL\(\))Tj
/F11 1 Tf
5.2 0 TD
( doesn't require a round trip to the server and thus is more efficient in cases where the client)Tj
-5.2 -1.5 TD
(and server are on separate machines.)Tj
0 -2.1 TD
(To prevent an OpenGL command sequence from executing until any outstanding X requests are)Tj
0 -1.5 TD
(completed, use )Tj
/F15 1 Tf
6.2 0 TD
(glXWaitX\(\))Tj
/F11 1 Tf
4.6 0 TD
(. This routine guarantees that previously issued X rendering calls are executed)Tj
-10.8 -1.5 TD
(before any OpenGL calls made after )Tj
/F15 1 Tf
14.8 0 TD
(glXWaitX\(\))Tj
/F11 1 Tf
4.6 0 TD
(.)Tj
/F27 1 Tf
-19.4 -3 TD
(Swapping Buffers)Tj
/F11 1 Tf
0 -2.1 TD
(For drawables that are double-buffered, the front and back buffers can be exchanged by calling)Tj
/F15 1 Tf
0 -1.5 TD
(glXSwapBuffers\(\))Tj
/F11 1 Tf
7.1 0 TD
(. An implicit )Tj
/F15 1 Tf
5.3 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.8 0 TD
( is done as part of this routine.)Tj
/F27 1 Tf
-16.2 -3 TD
(Using an X Font)Tj
/F11 1 Tf
0 -2.1 TD
(A shortcut for using X fonts in OpenGL is provided with the command )Tj
/F15 1 Tf
28.7 0 TD
(glXUseXFont\(\))Tj
/F11 1 Tf
6.1 0 TD
(. This routine)Tj
-34.8 -1.5 TD
(builds display lists, each of which calls )Tj
/F15 1 Tf
15.9 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
(, for each requested character from the specified font)Tj
-20.2 -1.5 TD
(and font size.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 416.000 Tm
(GLX Prototypes)Tj
10.000 0.000 0.000 10.000 124.000 385.000 Tm
(Initialization)Tj
/F11 1 Tf
0 -2.1 TD
(Determine whether the GLX extension is defined on the X server:)Tj
T*
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(glXQueryExtension)Tj
/F11 1 Tf
7.8 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.5 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(errorBase)Tj
/F11 1 Tf
4 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(eventBase )Tj
/F11 1 Tf
4.3 0 TD
(\);)Tj
-29.1 -2.1 TD
(Query version and extension information for client and server:)Tj
T*
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(glXQueryVersion)Tj
/F11 1 Tf
7 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.4 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(major)Tj
/F11 1 Tf
2.4 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(minor )Tj
/F11 1 Tf
2.7 0 TD
(\);)Tj
-25 -2.1 TD
(const char* )Tj
/F15 1 Tf
4.8 0 TD
(glXGetClientString)Tj
/F11 1 Tf
7.8 0 TD
( \( Display *)Tj
/F15 1 Tf
4.6 0 TD
(dpy)Tj
/F11 1 Tf
1.5 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(name )Tj
/F11 1 Tf
2.4 0 TD
(\);)Tj
-22.9 -2.1 TD
(const char* )Tj
/F15 1 Tf
4.8 0 TD
(glXQueryServerString)Tj
/F11 1 Tf
9 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(screen)Tj
/F11 1 Tf
2.6 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(name )Tj
/F11 1 Tf
2.5 0 TD
(\);)Tj
-28.6 -2.1 TD
(const char* )Tj
/F15 1 Tf
4.8 0 TD
(glXQueryExtensionsString)Tj
/F11 1 Tf
10.7 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(screen )Tj
/F11 1 Tf
2.9 0 TD
(\);)Tj
-26.3 -2.1 TD
(Obtain the desired visual:)Tj
T*
(XVisualInfo* )Tj
/F15 1 Tf
5.7 0 TD
(glXChooseVisual)Tj
/F11 1 Tf
7 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(screen)Tj
/F11 1 Tf
2.6 0 TD
(,)Tj
-23.2 -1.1 TD
(int *)Tj
/F15 1 Tf
1.8 0 TD
(attribList )Tj
/F11 1 Tf
4 0 TD
(\);)Tj
-5.8 -2.1 TD
(int )Tj
/F15 1 Tf
1.3 0 TD
(glXGetConfig)Tj
/F11 1 Tf
5.6 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.4 0 TD
(, XVisualInfo *)Tj
/F15 1 Tf
6.2 0 TD
(visual)Tj
/F11 1 Tf
2.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(attrib)Tj
/F11 1 Tf
2.3 0 TD
(,)Tj
-25.7 -1.1 TD
(int *)Tj
/F15 1 Tf
1.8 0 TD
(value )Tj
/F11 1 Tf
2.4 0 TD
(\);)Tj
/F27 1 Tf
-4.2 -3 TD
(Controlling Rendering)Tj
/F11 1 Tf
0 -2.1 TD
(Manage or query an OpenGL rendering context:)Tj
T*
(GLXContext )Tj
/F15 1 Tf
5.5 0 TD
(glXCreateContext)Tj
/F11 1 Tf
7.2 0 TD
( \( Display )Tj
/F15 1 Tf
4.2 0 TD
(*dpy)Tj
/F11 1 Tf
1.9 0 TD
(, XVisualInfo )Tj
/F15 1 Tf
5.8 0 TD
(*visual)Tj
/F11 1 Tf
2.9 0 TD
(,)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 3)Tj
ET
endstream
endobj
1520 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1522 0 obj
<<
/Length 4803
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(GLXContext )Tj
/F15 1 Tf
5.5 0 TD
(shareList)Tj
/F11 1 Tf
3.7 0 TD
0.000 Tw
(, Bool )Tj
/F15 1 Tf
2.7 0 TD
(direct )Tj
/F11 1 Tf
2.6 0 TD
(\);)Tj
-14.5 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glXDestroyContext)Tj
/F11 1 Tf
7.7 0 TD
( \( Display )Tj
/F15 1 Tf
4.2 0 TD
(*dpy)Tj
/F11 1 Tf
1.9 0 TD
(, GLXContext )Tj
/F15 1 Tf
6 0 TD
(context )Tj
/F11 1 Tf
3.1 0 TD
(\);)Tj
-24.9 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glXCopyContext)Tj
/F11 1 Tf
6.6 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.5 0 TD
(, GLXContext )Tj
/F15 1 Tf
5.9 0 TD
(source)Tj
/F11 1 Tf
2.7 0 TD
(,)Tj
-23.4 -1.1 TD
(GLXContext )Tj
/F15 1 Tf
5.5 0 TD
(dest)Tj
/F11 1 Tf
1.6 0 TD
(, unsigned long )Tj
/F15 1 Tf
6.4 0 TD
(mask )Tj
/F11 1 Tf
2.3 0 TD
(\);)Tj
-15.8 -2.1 TD
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(glXIsDirect)Tj
/F11 1 Tf
4.7 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.4 0 TD
(, GLXContext )Tj
/F15 1 Tf
6 0 TD
(context )Tj
/F11 1 Tf
3.1 0 TD
(\);)Tj
-22.1 -2.1 TD
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(glXMakeCurrent)Tj
/F11 1 Tf
6.8 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.4 0 TD
(, GLXDrawable )Tj
/F15 1 Tf
6.7 0 TD
(draw)Tj
/F11 1 Tf
2.1 0 TD
(,)Tj
-23.9 -1.1 TD
(GLXContext )Tj
/F15 1 Tf
5.5 0 TD
(context )Tj
/F11 1 Tf
3.1 0 TD
(\);)Tj
-8.6 -2.1 TD
(GLXContext )Tj
/F15 1 Tf
5.5 0 TD
(glXGetCurrentContext)Tj
/F11 1 Tf
9.1 0 TD
( \(void\);)Tj
-14.6 -2.1 TD
(Display* )Tj
/F15 1 Tf
3.9 0 TD
(glXGetCurrentDisplay)Tj
/F11 1 Tf
9.1 0 TD
( \(void\);)Tj
-13 -2.1 TD
(GLXDrawable )Tj
/F15 1 Tf
6.2 0 TD
(glXGetCurrentDrawable)Tj
/F11 1 Tf
10 0 TD
( \(void\);)Tj
-16.2 -2.1 TD
(Perform off-screen rendering:)Tj
T*
(GLXPixmap )Tj
/F15 1 Tf
5.4 0 TD
(glXCreateGLXPixmap)Tj
/F11 1 Tf
9 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.5 0 TD
(, XVisualInfo *)Tj
/F15 1 Tf
6.2 0 TD
(visual)Tj
/F11 1 Tf
2.4 0 TD
(,)Tj
-29.2 -1.1 TD
(Pixmap )Tj
/F15 1 Tf
3.3 0 TD
(pixmap )Tj
/F11 1 Tf
3.2 0 TD
(\);)Tj
-6.5 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glXDestroyGLXPixmap)Tj
/F11 1 Tf
9.5 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.5 0 TD
(, GLXPixmap )Tj
/F15 1 Tf
5.8 0 TD
(pix )Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-25 -2.1 TD
(Synchronize execution:)Tj
T*
(void )Tj
/F15 1 Tf
2 0 TD
(glXWaitGL)Tj
/F11 1 Tf
4.6 0 TD
( \(void\);)Tj
-6.6 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(glXWaitX)Tj
/F11 1 Tf
3.9 0 TD
( \(void\);)Tj
-5.9 -2.1 TD
(Exchange front and back buffers:)Tj
T*
(void )Tj
/F15 1 Tf
2 0 TD
(glXSwapBuffers)Tj
/F11 1 Tf
6.5 0 TD
( \( Display *)Tj
/F15 1 Tf
4.7 0 TD
(dpy)Tj
/F11 1 Tf
1.4 0 TD
(, GLXDrawable )Tj
/F15 1 Tf
6.7 0 TD
(drawable )Tj
/F11 1 Tf
4 0 TD
(\);)Tj
-25.3 -2.1 TD
(Use an X font:)Tj
T*
(void )Tj
/F15 1 Tf
2 0 TD
(glXUseXFont)Tj
/F11 1 Tf
5.5 0 TD
( \( Font )Tj
/F15 1 Tf
2.9 0 TD
(font)Tj
/F11 1 Tf
1.5 0 TD
(, int )Tj
/F15 1 Tf
1.9 0 TD
(first)Tj
/F11 1 Tf
1.6 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(count)Tj
/F11 1 Tf
2.2 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(listBase )Tj
/F11 1 Tf
3.4 0 TD
(\);)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 287.000 Tm
(AGL: OpenGL Extension to the Apple Macintosh)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 265.000 Tm
(This section covers the routines defined as the OpenGL extension to the Apple Macintosh \(AGL\), as)Tj
0 -1.5 TD
(defined by Template Graphics Software. An understanding of the way the Macintosh handles graphics)Tj
T*
(rendering \(QuickDraw\) is required. The )Tj
/F15 1 Tf
16.2 0 TD
(Macintosh Toolbox Essentials)Tj
/F11 1 Tf
12.1 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(Imaging With QuickDraw)Tj
/F11 1 Tf
-30.2 -1.5 TD
(manuals from the )Tj
/F15 1 Tf
7.2 0 TD
(Inside Macintosh)Tj
/F11 1 Tf
7 0 TD
( series are also useful to have at hand.)Tj
-14.2 -2.1 TD
(For more information \(including how to obtain the OpenGL software library for the Power Macintosh\),)Tj
0 -1.5 TD
(you may want to check out the web site for OpenGL information at Template Graphics Software:)Tj
/F7 1 Tf
0 -2.1 TD
(http://www.sd.tgs.com/Products/opengl.htm)Tj
/F11 1 Tf
T*
(For the Macintosh, OpenGL rendering is made available as a library that is either compiled in or resident)Tj
0 -1.5 TD
(as an extension for an application that wishes to make use of it. OpenGL is implemented in software for)Tj
T*
(systems that do not possess hardware acceleration. Where acceleration is available \(through the)Tj
T*
(QuickDraw 3D Accelerator\), those capabilities that match the OpenGL pipeline are used with the)Tj
T*
(remaining functionality being provided through software rendering.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 4)Tj
ET
endstream
endobj
1523 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1525 0 obj
<<
/Length 4398
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The data type AGLPixelFmtID \(the AGL equivalent to XVisualInfo\) maintains pixel information,)Tj
0 -1.5 TD
(including pixel type \(RGBA or color index\), single- or double-buffering, resolution of colors, and)Tj
T*
(presence of depth, stencil, and accumulation buffers.)Tj
0 -2.1 TD
(In contrast to other OpenGL implementations on other systems \(such as the X Window System\), the)Tj
0 -1.5 TD
(client/server model is not used. However, you may still need to call )Tj
/F15 1 Tf
27.2 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( since some hardware)Tj
-30.9 -1.5 TD
(accelerators buffer the OpenGL pipeline and require a flush to empty it.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 599.000 Tm
(Initialization)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 578.000 Tm
(Use )Tj
/F15 1 Tf
1.8 0 TD
(aglQueryVersion\(\))Tj
/F11 1 Tf
7.6 0 TD
( to determine what version of OpenGL for the Macintosh is available.)Tj
-9.4 -2.1 TD
(The capabilities of underlying graphics devices and your requirements for rendering buffers are resolved)Tj
0 -1.5 TD
(using )Tj
/F15 1 Tf
2.4 0 TD
(aglChoosePixelFmt\(\))Tj
/F11 1 Tf
8.6 0 TD
(. Use )Tj
/F15 1 Tf
2.3 0 TD
(aglListPixelFmts\(\))Tj
/F11 1 Tf
7.5 0 TD
( to find the particular formats supported by a)Tj
-20.8 -1.5 TD
(graphics device. Given a pixel format, you can determine which attributes are available by using)Tj
/F15 1 Tf
T*
(aglGetConfig\(\))Tj
/F11 1 Tf
6.1 0 TD
(.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 483.000 Tm
(Rendering and Contexts)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 461.000 Tm
(Several AGL routines are provided for creating and managing an OpenGL rendering context. You can)Tj
0 -1.5 TD
(use such a context to render into either a window or an off-screen graphics world. Routines are also)Tj
T*
(provided that allow you to swap front and back rendering buffers, adjust buffers in response to a move,)Tj
T*
(resize or graphics device change event, and use Macintosh fonts. For software rendering \(and in some)Tj
T*
(cases, hardware-accelerated rendering\) the rendering buffers are created in your application memory)Tj
T*
(space. For the application to work properly you must provide sufficient memory for these buffers in your)Tj
T*
(application's SIZE resource.)Tj
/F27 1 Tf
0 -3 TD
(Managing an OpenGL Rendering Context)Tj
/F11 1 Tf
0 -2.1 TD
(An OpenGL rendering context is created \(at least one context per window being rendered into\) with)Tj
/F15 1 Tf
0 -1.5 TD
(aglCreateContext\(\))Tj
/F11 1 Tf
7.8 0 TD
(. This takes the pixel format you selected as a parameter and uses it to initialize the)Tj
-7.8 -1.5 TD
(context.)Tj
0 -2.1 TD
(Use )Tj
/F15 1 Tf
1.8 0 TD
(aglMakeCurrent\(\))Tj
/F11 1 Tf
7.3 0 TD
( to make a rendering context current. Only one context can be current for a thread)Tj
-9.1 -1.5 TD
(of control at any time. This indicates which drawable is to be rendered into and which context to use with)Tj
T*
(it. It's possible for more than one context to be used \(not simultaneously\) with a particular drawable.)Tj
T*
(Two routines allow you to determine which is the current rendering context and drawable being rendered)Tj
T*
(into: )Tj
/F15 1 Tf
2.1 0 TD
(aglGetCurrentContext\(\))Tj
/F11 1 Tf
9.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(aglGetCurrentDrawable\(\))Tj
/F11 1 Tf
10.5 0 TD
(.)Tj
-24.2 -2.1 TD
(If you have multiple contexts, you can copy selected groups of OpenGL state variables from one context)Tj
0 -1.5 TD
(to another with )Tj
/F15 1 Tf
6.3 0 TD
(aglCopyContext\(\))Tj
/F11 1 Tf
7.2 0 TD
(. When a particular context is finished with, it should be destroyed by)Tj
-13.5 -1.5 TD
(calling )Tj
/F15 1 Tf
3 0 TD
(aglDestroyContext\(\))Tj
/F11 1 Tf
8.2 0 TD
(.)Tj
/F27 1 Tf
-11.2 -3 TD
(On-screen Rendering)Tj
/F11 1 Tf
0 -2.1 TD
(With the OpenGL extensions for the Apple Macintosh you can choose whether window clipping is)Tj
0 -1.5 TD
(performed when writing to the screen and whether the cursor is hidden during screen writing operations.)Tj
T*
(This is important since these two items may affect how fast rendering can be performed. Call)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 5)Tj
ET
endstream
endobj
1526 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1528 0 obj
<<
/Length 3852
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(aglSetOptions\(\))Tj
/F11 1 Tf
6.3 0 TD
0.000 Tw
( to select these options.)Tj
/F27 1 Tf
-6.3 -3 TD
(Off-screen Rendering)Tj
/F11 1 Tf
0 -2.1 TD
(To render off-screen, first create an off-screen graphics world in the usual way, and pass the handle into)Tj
/F15 1 Tf
0 -1.5 TD
(aglCreateAGLPixmap\(\))Tj
/F11 1 Tf
9.6 0 TD
(. This routine returns a drawable that can be used with )Tj
/F15 1 Tf
22 0 TD
(aglMakeCurrent\(\))Tj
/F11 1 Tf
7.3 0 TD
(. Once)Tj
-38.9 -1.5 TD
(rendering is completed, you can destroy the association with )Tj
/F15 1 Tf
24.4 0 TD
(aglDestroyAGLPixmap\(\))Tj
/F11 1 Tf
10.1 0 TD
(.)Tj
/F27 1 Tf
-34.5 -3 TD
(Swapping Buffers)Tj
/F11 1 Tf
0 -2.1 TD
(For drawables that are double-buffered \(as per the pixel format of the current rendering context\), call)Tj
/F15 1 Tf
0 -1.5 TD
(aglSwapBuffers\(\))Tj
/F11 1 Tf
7 0 TD
( to exchange the front and back buffers. An implicit )Tj
/F15 1 Tf
21 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( is performed as part of)Tj
-31.7 -1.5 TD
(this routine.)Tj
/F27 1 Tf
0 -3 TD
(Updating the Rendering Buffers)Tj
/F11 1 Tf
0 -2.1 TD
(The Apple Macintosh toolbox requires you to perform your own event handling and does not provide a)Tj
0 -1.5 TD
(way for libraries to automatically hook in to the event stream. So that the drawables maintained by)Tj
T*
(OpenGL can adjust to changes in drawable size, position and pixel depth, )Tj
/F15 1 Tf
29.7 0 TD
(aglUpdateCurrent\(\))Tj
/F11 1 Tf
8 0 TD
( is)Tj
-37.7 -1.5 TD
(provided.)Tj
0 -2.1 TD
(This routine must be called by your event processing code whenever one of these events occurs in the)Tj
0 -1.5 TD
(current drawable. Ideally the scene should be rerendered after a update call to take into account the)Tj
T*
(changes made to the rendering buffers.)Tj
/F27 1 Tf
0 -3 TD
(Using an Apple Macintosh Font)Tj
/F11 1 Tf
0 -2.1 TD
(A shortcut for using Macintosh fonts is provided with )Tj
/F15 1 Tf
21.7 0 TD
(aglUseFont\(\))Tj
/F11 1 Tf
5.4 0 TD
(. This routine builds display lists,)Tj
-27.1 -1.5 TD
(each of which calls )Tj
/F15 1 Tf
7.9 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.4 0 TD
(, for each requested character from the specified font and font size.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 307.000 Tm
(Error Handling)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 285.000 Tm
(An error-handling mechanism is provided for the Apple Macintosh OpenGL extension. When an error)Tj
0 -1.5 TD
(occurs you can call )Tj
/F15 1 Tf
7.9 0 TD
(aglGetError\(\))Tj
/F11 1 Tf
5.7 0 TD
( to get a more precise description of what caused the error.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 241.000 Tm
(AGL Prototypes)Tj
10.000 0.000 0.000 10.000 124.000 211.000 Tm
(Initialization)Tj
/F11 1 Tf
0 -2.1 TD
(Determine AGL version:)Tj
T*
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglQueryVersion )Tj
/F11 1 Tf
7.2 0 TD
(\( int *)Tj
/F15 1 Tf
2.4 0 TD
(major)Tj
/F11 1 Tf
2.4 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(minor)Tj
/F11 1 Tf
2.4 0 TD
( \);)Tj
-21.4 -2.1 TD
(Pixel format selection, availability, and capability:)Tj
T*
(AGLPixelFmtID )Tj
/F15 1 Tf
7 0 TD
(aglChoosePixelFmt )Tj
/F11 1 Tf
8.2 0 TD
(\( GDHandle *)Tj
/F15 1 Tf
5.7 0 TD
(dev)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(ndev)Tj
/F11 1 Tf
1.9 0 TD
(,)Tj
-26 -1.1 TD
(int *)Tj
/F15 1 Tf
1.8 0 TD
(attribs)Tj
/F11 1 Tf
2.6 0 TD
( \);)Tj
-4.4 -2.1 TD
(int )Tj
/F15 1 Tf
1.3 0 TD
(aglListPixelFmts )Tj
/F11 1 Tf
7.1 0 TD
(\( GDHandle )Tj
/F15 1 Tf
5.2 0 TD
(dev)Tj
/F11 1 Tf
1.3 0 TD
(, AGLPixelFmtID **)Tj
/F15 1 Tf
8.6 0 TD
(fmts)Tj
/F11 1 Tf
1.6 0 TD
( \);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 6)Tj
ET
endstream
endobj
1529 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1532 0 obj
<<
/Length 4211
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglGetConfig )Tj
/F11 1 Tf
5.7 0 TD
0.000 Tw
(\( AGLPixelFmtID )Tj
/F15 1 Tf
7.7 0 TD
(pix)Tj
/F11 1 Tf
1.2 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(attrib)Tj
/F11 1 Tf
2.2 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(value)Tj
/F11 1 Tf
2.2 0 TD
( \);)Tj
/F27 1 Tf
-27.8 -3 TD
(Controlling Rendering)Tj
/F11 1 Tf
0 -2.1 TD
(Manage an OpenGL rendering context:)Tj
T*
(AGLContext )Tj
/F15 1 Tf
5.5 0 TD
(aglCreateContext )Tj
/F11 1 Tf
7.3 0 TD
(\( AGLPixelFmtID )Tj
/F15 1 Tf
7.6 0 TD
(pix)Tj
/F11 1 Tf
1.3 0 TD
(,)Tj
-21.7 -1.1 TD
(AGLContext )Tj
/F15 1 Tf
5.5 0 TD
(shareList)Tj
/F11 1 Tf
3.7 0 TD
( \);)Tj
-9.2 -2.1 TD
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglDestroyContext )Tj
/F11 1 Tf
7.9 0 TD
(\( AGLContext )Tj
/F15 1 Tf
6 0 TD
(context)Tj
/F11 1 Tf
2.9 0 TD
( \);)Tj
-21.5 -2.1 TD
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglCopyContext )Tj
/F11 1 Tf
6.8 0 TD
(\( AGLContext )Tj
/F15 1 Tf
6.1 0 TD
(source)Tj
/F11 1 Tf
2.6 0 TD
(, AGLContext )Tj
/F15 1 Tf
6 0 TD
(dest)Tj
/F11 1 Tf
1.6 0 TD
(,)Tj
-27.8 -1.1 TD
(GLuint )Tj
/F15 1 Tf
3.1 0 TD
(mask)Tj
/F11 1 Tf
2.1 0 TD
( \);)Tj
-5.2 -2.1 TD
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglMakeCurrent )Tj
/F11 1 Tf
7 0 TD
(\( AGLDrawable )Tj
/F15 1 Tf
6.7 0 TD
(drawable)Tj
/F11 1 Tf
3.8 0 TD
(,)Tj
-22.2 -1.1 TD
(AGLContext )Tj
/F15 1 Tf
5.5 0 TD
(context)Tj
/F11 1 Tf
2.9 0 TD
( \);)Tj
-8.4 -2.1 TD
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglSetOptions )Tj
/F11 1 Tf
6 0 TD
(\( int )Tj
/F15 1 Tf
1.9 0 TD
(opts)Tj
/F11 1 Tf
1.6 0 TD
( \);)Tj
-14.2 -2.1 TD
(AGLContext )Tj
/F15 1 Tf
5.5 0 TD
(aglGetCurrentContext )Tj
/F11 1 Tf
9.2 0 TD
(\(void\);)Tj
-14.7 -2.1 TD
(AGLDrawable )Tj
/F15 1 Tf
6.2 0 TD
(aglGetCurrentDrawable )Tj
/F11 1 Tf
10.1 0 TD
(\(void\);)Tj
-16.3 -2.1 TD
(Perform off-screen rendering:)Tj
T*
(AGLPixmap )Tj
/F15 1 Tf
5.4 0 TD
(aglCreateAGLPixmap )Tj
/F11 1 Tf
9.2 0 TD
(\( AGLPixelFmtID )Tj
/F15 1 Tf
7.6 0 TD
(pix)Tj
/F11 1 Tf
1.2 0 TD
(,)Tj
-23.4 -1.2 TD
(GWorldPtr )Tj
/F15 1 Tf
4.7 0 TD
(pixmap)Tj
/F11 1 Tf
2.9 0 TD
( \);)Tj
-7.6 -2.1 TD
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglDestroyAGLPixmap )Tj
/F11 1 Tf
9.7 0 TD
(\( AGLPixmap )Tj
/F15 1 Tf
5.9 0 TD
(pix)Tj
/F11 1 Tf
1.3 0 TD
( \);)Tj
-21.6 -2.1 TD
(Exchange front and back buffers:)Tj
T*
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglSwapBuffers )Tj
/F11 1 Tf
6.6 0 TD
(\( AGLDrawable )Tj
/F15 1 Tf
6.8 0 TD
(drawable)Tj
/F11 1 Tf
3.8 0 TD
( \);)Tj
-21.9 -2.1 TD
(Update the current rendering buffers:)Tj
T*
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglUpdateCurrent )Tj
/F11 1 Tf
7.7 0 TD
(\(void\);)Tj
-12.4 -2.1 TD
(Use a Macintosh font:)Tj
T*
(GLboolean )Tj
/F15 1 Tf
4.7 0 TD
(aglUseFont )Tj
/F11 1 Tf
5 0 TD
(\( int )Tj
/F15 1 Tf
1.9 0 TD
(familyID)Tj
/F11 1 Tf
3.6 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(size)Tj
/F11 1 Tf
1.5 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(first)Tj
/F11 1 Tf
1.6 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(count)Tj
/F11 1 Tf
2.2 0 TD
(,)Tj
-25.9 -1.1 TD
(int )Tj
/F15 1 Tf
1.3 0 TD
(listBase)Tj
/F11 1 Tf
3.2 0 TD
( \);)Tj
-4.5 -2.1 TD
(Find the cause of an error:)Tj
T*
(GLenum )Tj
/F15 1 Tf
3.8 0 TD
(aglGetError )Tj
/F11 1 Tf
5.3 0 TD
(\(void\);)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 193.000 Tm
(PGL: OpenGL Extension for IBM OS/2 Warp)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 171.000 Tm
(OpenGL rendering for IBM OS/2 Warp is accomplished by using PGL routines added to integrate)Tj
0 -1.5 TD
(OpenGL into the standard IBM Presentation Manager. OpenGL with PGL supports both a direct)Tj
T*
(OpenGL context \(which is often faster\) and an indirect context \(which allows some integration of Gpi)Tj
T*
(and OpenGL rendering\).)Tj
0 -2.1 TD
(The data type VISUALCONFIG \(the PGL equivalent to XVisualInfo\) maintains the visual configuration,)Tj
0 -1.5 TD
(including pixel type \(RGBA or color index\), single- or double-buffering, resolution of colors, and)Tj
T*
(presence of depth, stencil, and accumulation buffers.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 7)Tj
ET
endstream
endobj
1533 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1535 0 obj
<<
/Length 4449
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 702.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(To get more information \(including how to obtain the OpenGL software library for IBM OS/2 Warp,)Tj
0 -1.5 TD
(Version 3.0\), you may want to start at)Tj
/F7 1 Tf
0 -2.1 TD
(http://www.austin.ibm.com/software/OpenGL/)Tj
/F11 1 Tf
T*
(Packaged along with the software is the document, )Tj
/F15 1 Tf
20.6 0 TD
(OpenGL On OS/2 Warp)Tj
/F11 1 Tf
9.6 0 TD
(, which provides more)Tj
-30.2 -1.5 TD
(detailed information. OpenGL support is included with the base operating system with OS/2 Warp)Tj
T*
(Version 4.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 586.000 Tm
(Initialization)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 564.000 Tm
(Use )Tj
/F15 1 Tf
1.8 0 TD
(pglQueryCapability\(\))Tj
/F11 1 Tf
8.7 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(pglQueryVersion\(\))Tj
/F11 1 Tf
7.6 0 TD
( to determine whether the OpenGL is supported on this)Tj
-20 -1.5 TD
(machine and, if so, how it is supported and which version is present. )Tj
/F15 1 Tf
27.6 0 TD
(pglChooseConfig\(\))Tj
/F11 1 Tf
7.7 0 TD
( returns a pointer)Tj
-35.3 -1.5 TD
(to an VISUALCONFIG structure describing the visual configuration that best meets the client's specified)Tj
T*
(attributes. A list of the particular visual configurations supported by a graphics device can be found using)Tj
/F15 1 Tf
T*
(pglQueryConfigs\(\))Tj
/F11 1 Tf
7.6 0 TD
(.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 476.000 Tm
(Controlling Rendering)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 454.000 Tm
(Several PGL routines are provided for creating and managing an OpenGL rendering context, capturing)Tj
0 -1.5 TD
(the contents of a bitmap, synchronizing execution between the Presentation Manager and OpenGL)Tj
T*
(streams, swapping front and back buffers, using a color palette, and using an OS/2 logical font.)Tj
/F27 1 Tf
0 -3 TD
(Managing an OpenGL Rendering Context)Tj
/F11 1 Tf
0 -2.1 TD
(An OpenGL rendering context is created with )Tj
/F15 1 Tf
18.6 0 TD
(pglCreateContext\(\))Tj
/F11 1 Tf
7.8 0 TD
(. One of the arguments to this routine)Tj
-26.4 -1.5 TD
(allows you to request a direct rendering context that bypasses the Gpi and render to a PM window, which)Tj
T*
(is generally faster. You can determine whether a OpenGL context is direct with )Tj
/F15 1 Tf
32 0 TD
(pglIsIndirect\(\))Tj
/F11 1 Tf
5.9 0 TD
(.)Tj
-37.9 -2.1 TD
(To make a rendering context current, use )Tj
/F15 1 Tf
16.7 0 TD
(pglMakeCurrent\(\))Tj
/F11 1 Tf
7.3 0 TD
(; )Tj
/F15 1 Tf
0.5 0 TD
(pglGetCurrentContext\(\))Tj
/F11 1 Tf
9.7 0 TD
( returns the current)Tj
-34.2 -1.5 TD
(context. You can also obtain the current window with )Tj
/F15 1 Tf
21.7 0 TD
(pglGetCurrentWindow\(\))Tj
/F11 1 Tf
9.9 0 TD
(. You can copy some)Tj
-31.6 -1.5 TD
(OpenGL state variables from one context to another with )Tj
/F15 1 Tf
23.1 0 TD
(pglCopyContext\(\))Tj
/F11 1 Tf
7.1 0 TD
(. When you're finished with a)Tj
-30.2 -1.5 TD
(particular context, destroy it with )Tj
/F15 1 Tf
13.6 0 TD
(pglDestroyContext\(\))Tj
/F11 1 Tf
8.2 0 TD
(.)Tj
/F27 1 Tf
-21.8 -3 TD
(Access the Bitmap of the Front Buffer)Tj
/F11 1 Tf
0 -2.1 TD
(To lock access to the bitmap representation of the contents of the front buffer, use)Tj
/F15 1 Tf
0 -1.5 TD
(pglGrabFrontBitmap\(\))Tj
/F11 1 Tf
9.2 0 TD
(. An implicit )Tj
/F15 1 Tf
5.4 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( is performed, and you can read the bitmap, but its contents)Tj
-18.3 -1.5 TD
(are effectively read-only. Immediately after access is completed, you should call)Tj
/F15 1 Tf
T*
(pglReleaseFrontBitmap\(\))Tj
/F11 1 Tf
10.2 0 TD
( to restore write access to the front buffer.)Tj
/F27 1 Tf
-10.2 -3 TD
(Synchronizing Execution)Tj
/F11 1 Tf
0 -2.1 TD
(To prevent Gpi rendering requests from executing until any outstanding OpenGL rendering is completed,)Tj
0 -1.5 TD
(call )Tj
/F15 1 Tf
1.7 0 TD
(pglWaitGL\(\))Tj
/F11 1 Tf
5.1 0 TD
(. Then, any previously issued OpenGL commands are guaranteed to be executed before)Tj
-6.8 -1.5 TD
(any Gpi rendering calls made after )Tj
/F15 1 Tf
14.1 0 TD
(pglWaitGL\(\))Tj
/F11 1 Tf
5.1 0 TD
(.)Tj
-19.2 -2.1 TD
(To prevent an OpenGL command sequence from executing until any outstanding Gpi requests are)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 8)Tj
ET
endstream
endobj
1536 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1538 0 obj
<<
/Length 4202
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(completed, use )Tj
/F15 1 Tf
6.2 0 TD
(pglWaitPM\(\))Tj
/F11 1 Tf
5.3 0 TD
(. This routine guarantees that previously issued Gpi rendering calls are)Tj
-11.5 -1.5 TD
(executed before any OpenGL calls made after )Tj
/F15 1 Tf
18.6 0 TD
(pglWaitPM\(\))Tj
/F11 1 Tf
5.3 0 TD
(.)Tj
/F27 1 Tf
-23.9 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(OpenGL and Gpi rendering can be integrated in the same window only if the OpenGL context is)Tj
-2.8 -1.4 TD
(an indirect context.)Tj
/F27 1 Tf
0 -3 TD
(Swapping Buffers)Tj
/F11 1 Tf
0 -2.1 TD
(For windows that are double-buffered, the front and back buffers can be exchanged by calling)Tj
/F15 1 Tf
0 -1.5 TD
(pglSwapBuffers\(\))Tj
/F11 1 Tf
7 0 TD
(. An implicit )Tj
/F15 1 Tf
5.3 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.8 0 TD
( is done as part of this routine.)Tj
/F27 1 Tf
-16.1 -3 TD
(Using a Color Index Palette)Tj
T*
(When you are running in 8-bit \(256 color\) mode, you have to worry about color palette)Tj
0 -1.5 TD
(management. For windows with a color index Visual Configuration, call)Tj
/F17 1 Tf
T*
(pglSelectColorIndexPalette\(\))Tj
/F27 1 Tf
11.9 0 TD
( to tell OpenGL what color-index palette you want to use with)Tj
-11.9 -1.5 TD
(your context. A color palette must be selected before the context is initially bound to a)Tj
T*
(window. In RGBA mode, OpenGL sets up a palette automatically.)Tj
0 -3 TD
(Using an OS/2 Logical Font)Tj
/F11 1 Tf
0 -2.1 TD
(A shortcut for using OS/2 logical fonts in OpenGL is provided with the command )Tj
/F15 1 Tf
33 0 TD
(pglUseFont\(\))Tj
/F11 1 Tf
5.4 0 TD
(. This)Tj
-38.4 -1.5 TD
(routine builds display lists, each of which calls )Tj
/F15 1 Tf
19 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
(, for each requested character from the)Tj
-23.3 -1.5 TD
(specified font and font size.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 365.000 Tm
(PGL Prototypes)Tj
10.000 0.000 0.000 10.000 124.000 335.000 Tm
(Initialization)Tj
/F11 1 Tf
0 -2.2 TD
(Determine whether OpenGL is supported and, if so, its version number:)Tj
0 -2.1 TD
(long )Tj
/F15 1 Tf
2 0 TD
(pglQueryCapability)Tj
/F11 1 Tf
8 0 TD
( \(HAB )Tj
/F15 1 Tf
3 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-14.5 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(pglQueryVersion)Tj
/F11 1 Tf
6.9 0 TD
( \(HAB )Tj
/F15 1 Tf
3 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(major)Tj
/F11 1 Tf
2.4 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(minor)Tj
/F11 1 Tf
2.4 0 TD
(\);)Tj
-22.8 -2.1 TD
(Visual configuration selection, availability and capability:)Tj
T*
(PVISUALCONFIG )Tj
/F15 1 Tf
8.2 0 TD
(pglChooseConfig)Tj
/F11 1 Tf
7 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, int *)Tj
/F15 1 Tf
2.3 0 TD
(attribList)Tj
/F11 1 Tf
3.8 0 TD
(\);)Tj
-25.7 -2.1 TD
(PVISUALCONFIG * )Tj
/F15 1 Tf
8.9 0 TD
(pglQueryConfigs)Tj
/F11 1 Tf
6.9 0 TD
( \(HAB )Tj
/F15 1 Tf
3 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
/F27 1 Tf
-20.3 -2.9 TD
(Controlling Rendering)Tj
/F11 1 Tf
0 -2.2 TD
(Manage or query an OpenGL rendering context:)Tj
0 -2.1 TD
(HGC )Tj
/F15 1 Tf
2.4 0 TD
(pglCreateContext)Tj
/F11 1 Tf
7.1 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, PVISUALCONFIG )Tj
/F15 1 Tf
8.7 0 TD
(pVisualConfig)Tj
/F11 1 Tf
5.8 0 TD
(,)Tj
-28.4 -1.1 TD
(HGC )Tj
/F15 1 Tf
2.4 0 TD
(shareList)Tj
/F11 1 Tf
3.7 0 TD
(, Bool isD)Tj
/F15 1 Tf
4.1 0 TD
(irect)Tj
/F11 1 Tf
1.8 0 TD
(\);)Tj
-12 -2.1 TD
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(pglDestroyContext)Tj
/F11 1 Tf
7.6 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, HGC )Tj
/F15 1 Tf
2.9 0 TD
(hgc)Tj
/F11 1 Tf
1.4 0 TD
(\);)Tj
-18.5 -2.1 TD
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(pglCopyContext)Tj
/F11 1 Tf
6.5 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, HGC )Tj
/F15 1 Tf
2.9 0 TD
(source)Tj
/F11 1 Tf
2.7 0 TD
(, HGC )Tj
/F15 1 Tf
2.8 0 TD
(dest)Tj
/F11 1 Tf
1.6 0 TD
(, GLuint )Tj
/F15 1 Tf
3.7 0 TD
(mask)Tj
/F11 1 Tf
2 0 TD
(\);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 9)Tj
ET
endstream
endobj
1539 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F17 1374 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1541 0 obj
<<
/Length 4688
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(pglMakeCurrent)Tj
/F11 1 Tf
6.7 0 TD
0.000 Tw
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, HGC )Tj
/F15 1 Tf
2.9 0 TD
(hgc)Tj
/F11 1 Tf
1.4 0 TD
(, HWND )Tj
/F15 1 Tf
3.9 0 TD
(hwnd)Tj
/F11 1 Tf
2.1 0 TD
(\);)Tj
-23.6 -2.1 TD
(long )Tj
/F15 1 Tf
2 0 TD
(pglIsIndirect)Tj
/F11 1 Tf
5.2 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, HGC )Tj
/F15 1 Tf
2.9 0 TD
(hgc)Tj
/F11 1 Tf
1.4 0 TD
(\);)Tj
-15.9 -2.1 TD
(HGC )Tj
/F15 1 Tf
2.4 0 TD
(pglGetCurrentContext)Tj
/F11 1 Tf
9 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-15.8 -2.1 TD
(HWND )Tj
/F15 1 Tf
3.4 0 TD
(pglGetCurrentWindow)Tj
/F11 1 Tf
9.1 0 TD
( \(HAB )Tj
/F15 1 Tf
3 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-17 -2.1 TD
(Access and release the bitmap of the front buffer:)Tj
T*
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(pglGrabFrontBitmap)Tj
/F11 1 Tf
8.6 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, HPS *)Tj
/F15 1 Tf
3.1 0 TD
(hps)Tj
/F11 1 Tf
1.4 0 TD
(, HBITMAP *)Tj
/F15 1 Tf
5.7 0 TD
(phbitmap)Tj
/F11 1 Tf
3.8 0 TD
(\);)Tj
-29.2 -2.1 TD
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(pglReleaseFrontBitmap)Tj
/F11 1 Tf
9.6 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-16.2 -2.1 TD
(Synchronize execution:)Tj
T*
(HPS )Tj
/F15 1 Tf
2.1 0 TD
(pglWaitGL)Tj
/F11 1 Tf
4.4 0 TD
( \(HAB )Tj
/F15 1 Tf
3 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-11 -2.1 TD
(void )Tj
/F15 1 Tf
2 0 TD
(pglWaitPM)Tj
/F11 1 Tf
4.6 0 TD
( \(HAB )Tj
/F15 1 Tf
3 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(\);)Tj
-11.1 -2.1 TD
(Exchange front and back buffers:)Tj
T*
(void )Tj
/F15 1 Tf
2 0 TD
(pglSwapBuffers)Tj
/F11 1 Tf
6.4 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, HWND )Tj
/F15 1 Tf
3.9 0 TD
(hwnd)Tj
/F11 1 Tf
2.1 0 TD
(\);)Tj
-18.8 -2.1 TD
(Finding a color-index palette:)Tj
T*
(void )Tj
/F15 1 Tf
2 0 TD
(pglSelectColorIndexPalette)Tj
/F11 1 Tf
11.1 0 TD
( \(HAB )Tj
/F15 1 Tf
2.9 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, HPAL, )Tj
/F15 1 Tf
3.6 0 TD
(hpal)Tj
/F11 1 Tf
1.8 0 TD
(, HGC )Tj
/F15 1 Tf
2.9 0 TD
(hgc)Tj
/F11 1 Tf
1.4 0 TD
(\);)Tj
-27.2 -2.1 TD
(Use an OS/2 logical font:)Tj
T*
(Bool )Tj
/F15 1 Tf
2.2 0 TD
(pglUseFont)Tj
/F11 1 Tf
4.7 0 TD
( \(HAB )Tj
/F15 1 Tf
3 0 TD
(hab)Tj
/F11 1 Tf
1.5 0 TD
(, HPS )Tj
/F15 1 Tf
2.5 0 TD
(hps)Tj
/F11 1 Tf
1.4 0 TD
(, FATTRS )Tj
/F15 1 Tf
4.5 0 TD
(*fontAttribs)Tj
/F11 1 Tf
4.8 0 TD
(,)Tj
-24.6 -1.1 TD
(long )Tj
/F15 1 Tf
2 0 TD
(logicalId)Tj
/F11 1 Tf
3.6 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(first)Tj
/F11 1 Tf
1.7 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(count)Tj
/F11 1 Tf
2.2 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(listBase)Tj
/F11 1 Tf
3.2 0 TD
(\);)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 351.000 Tm
(WGL: OpenGL Extension for Microsoft Windows NT and)Tj
0 -1.2143 TD
(Windows 95)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 312.000 Tm
(OpenGL rendering is supported on systems that run Microsoft Windows NT and Windows 95. The)Tj
0 -1.5 TD
(functions and routines of the Win32 library are necessary to initialize the pixel format and control)Tj
T*
(rendering for OpenGL. Some routines, which are prefixed by )Tj
/F15 1 Tf
24.7 0 TD
(wgl)Tj
/F11 1 Tf
1.5 0 TD
(, extend Win32 so that OpenGL can be)Tj
-26.2 -1.5 TD
(fully supported.)Tj
0 -2.1 TD
(For Win32/WGL, the PIXELFORMATDESCRIPTOR is the key data structure to maintain pixel format)Tj
0 -1.5 TD
(information about the OpenGL window. A variable of data type PIXELFORMATDESCRIPTOR keeps)Tj
T*
(track of pixel information, including pixel type \(RGBA or color index\), single- or double- buffering,)Tj
T*
(resolution of colors, and presence of depth, stencil, and accumulation buffers.)Tj
0 -2.1 TD
(To get more information about WGL, you may want to start with technical articles available through the)Tj
0 -1.5 TD
(Microsoft Developer Network at)Tj
/F7 1 Tf
0 -2.1 TD
(http://www.microsoft.com/msdn/)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 115.000 Tm
(Initialization)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 94.000 Tm
(Use )Tj
/F15 1 Tf
1.8 0 TD
(GetVersion\(\))Tj
/F11 1 Tf
5.2 0 TD
( or the newer )Tj
/F15 1 Tf
5.5 0 TD
(GetVersionEx\(\))Tj
/F11 1 Tf
6.3 0 TD
( to determine version information. )Tj
/F15 1 Tf
13.9 0 TD
(ChoosePixelFormat\(\))Tj
/F11 1 Tf
-32.7 -1.5 TD
(tries to find a PIXELFORMATDESCRIPTOR with specified attributes. If a good match for the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 10)Tj
ET
endstream
endobj
1542 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1544 0 obj
<<
/Length 4906
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(requested pixel format is found, then )Tj
/F15 1 Tf
15 0 TD
(SetPixelFormat\(\))Tj
/F11 1 Tf
6.9 0 TD
( should be called to actually use the pixel format.)Tj
-21.9 -1.5 TD
(You should select a pixel format in the device context before calling )Tj
/F15 1 Tf
27.6 0 TD
(wglCreateContext\(\))Tj
/F11 1 Tf
8 0 TD
(.)Tj
-35.6 -2.1 TD
(If you want to find out details about a given pixel format, use )Tj
/F15 1 Tf
24.8 0 TD
(DescribePixelFormat\(\))Tj
/F11 1 Tf
9.3 0 TD
( or, for overlays or)Tj
-34.1 -1.5 TD
(underlays, )Tj
/F15 1 Tf
4.4 0 TD
(wglDescribeLayerPlane\(\))Tj
/F11 1 Tf
10.4 0 TD
(.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 631.000 Tm
(Controlling Rendering)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 610.000 Tm
(Several WGL routines are provided for creating and managing an OpenGL rendering context, rendering)Tj
0 -1.5 TD
(to a bitmap, swapping front and back buffers, finding a color palette, and using either bitmap or outline)Tj
T*
(fonts.)Tj
/F27 1 Tf
0 -3 TD
(Managing an OpenGL Rendering Context)Tj
/F15 1 Tf
0 -2.1 TD
(wglCreateContext\(\))Tj
/F11 1 Tf
7.9 0 TD
( creates an OpenGL rendering context for drawing on the device in the selected pixel)Tj
-7.9 -1.5 TD
(format of the device context. \(To create an OpenGL rendering context for overlay or underlay windows,)Tj
T*
(use )Tj
/F15 1 Tf
1.6 0 TD
(wglCreateLayerContext\(\))Tj
/F11 1 Tf
10.3 0 TD
( instead.\) To make a rendering context current, use )Tj
/F15 1 Tf
20.5 0 TD
(wglMakeCurrent\(\))Tj
/F11 1 Tf
7.5 0 TD
(;)Tj
/F15 1 Tf
-39.9 -1.5 TD
(wglGetCurrentContext\(\))Tj
/F11 1 Tf
9.8 0 TD
( returns the current context. You can also obtain the current device context with)Tj
/F15 1 Tf
-9.8 -1.5 TD
(wglGetCurrentDC\(\))Tj
/F11 1 Tf
8.1 0 TD
(. You can copy some OpenGL state variables from one context to another with)Tj
/F15 1 Tf
-8.1 -1.5 TD
(wglCopyContext\(\))Tj
/F11 1 Tf
7.3 0 TD
( or make two contexts share the same display lists and texture objects with)Tj
/F15 1 Tf
-7.3 -1.5 TD
(wglShareLists\(\))Tj
/F11 1 Tf
6.3 0 TD
(. When you're finished with a particular context, destroy it with )Tj
/F15 1 Tf
25.8 0 TD
(wglDestroyContext\(\))Tj
/F11 1 Tf
8.4 0 TD
(.)Tj
/F27 1 Tf
-40.5 -3 TD
(OpenGL Rendering to a Bitmap)Tj
/F11 1 Tf
0 -2.1 TD
(Win32 has a few routines to allocate \(and deallocate\) bitmaps, to which you can render OpenGL directly.)Tj
/F15 1 Tf
0 -1.5 TD
(CreateDIBitmap\(\))Tj
/F11 1 Tf
7.3 0 TD
( creates a device-dependent bitmap \(DDB\) from a device-independent bitmap \(DIB\).)Tj
/F15 1 Tf
-7.3 -1.5 TD
(CreateDIBSection\(\))Tj
/F11 1 Tf
8 0 TD
( creates a device-independent bitmap \(DIB\) that applications can write to directly.)Tj
-8 -1.5 TD
(When finished with your bitmap, you can use )Tj
/F15 1 Tf
18.5 0 TD
(DeleteObject\(\))Tj
/F11 1 Tf
5.9 0 TD
( to free it up.)Tj
/F27 1 Tf
-24.4 -3 TD
(Synchronizing Execution)Tj
/F11 1 Tf
0 -2.1 TD
(If you want to combine GDI and OpenGL rendering, be aware there are no equivalents to functions like)Tj
/F15 1 Tf
0 -1.5 TD
(glXWaitGL\(\))Tj
/F11 1 Tf
5.2 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glXWaitX\(\))Tj
/F11 1 Tf
4.6 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(pglWaitGL\(\))Tj
/F11 1 Tf
5.1 0 TD
( in Win32. Although )Tj
/F15 1 Tf
8.5 0 TD
(glXWaitGL\(\))Tj
/F11 1 Tf
5.2 0 TD
( has no equivalent in Win32,)Tj
-30.7 -1.5 TD
(you can achieve the same effect by calling )Tj
/F15 1 Tf
17.2 0 TD
(glFinish\(\),)Tj
/F11 1 Tf
4.3 0 TD
( which waits until all pending OpenGL commands)Tj
-21.5 -1.5 TD
(are executed, or by calling )Tj
/F15 1 Tf
10.8 0 TD
(GdiFlush\(\))Tj
/F11 1 Tf
4.5 0 TD
(, which waits until all GDI drawing has completed.)Tj
/F27 1 Tf
-15.3 -3 TD
(Swapping Buffers)Tj
/F11 1 Tf
0 -2.1 TD
(For windows that are double-buffered, the front and back buffers can be exchanged by calling)Tj
/F15 1 Tf
0 -1.5 TD
(SwapBuffers\(\))Tj
/F11 1 Tf
5.7 0 TD
( or )Tj
/F15 1 Tf
1.4 0 TD
(wglSwapLayerBuffers\(\))Tj
/F11 1 Tf
9.5 0 TD
(; the latter for overlays and underlays.)Tj
/F27 1 Tf
-16.6 -3 TD
(Finding a Color Palette)Tj
/F11 1 Tf
0 -2.1 TD
(To access the color palette for the standard \(non-layer\) bitplanes, use the standard GDI functions to set)Tj
0 -1.5 TD
(the palette entries. For overlay or underlay layers, use )Tj
/F15 1 Tf
21.7 0 TD
(wglRealizeLayerPalette\(\))Tj
/F11 1 Tf
10.3 0 TD
(, which maps palette)Tj
-32 -1.5 TD
(entries from a given color-index layer plane into the physical palette or initializes the palette of an RGBA)Tj
T*
(layer plane. )Tj
/F15 1 Tf
4.9 0 TD
(wglGetLayerPaletteEntries\(\))Tj
/F11 1 Tf
11.6 0 TD
( is used to query the entries in palettes of layer planes.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 11)Tj
ET
endstream
endobj
1545 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1547 0 obj
<<
/Length 4878
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 703.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Using a Bitmap or Outline Font)Tj
/F11 1 Tf
0 -2.1 TD
(WGL has two routines, )Tj
/F15 1 Tf
9.6 0 TD
(wglUseFontBitmaps\(\))Tj
/F11 1 Tf
8.8 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(wglUseFontOutlines\(\))Tj
/F11 1 Tf
8.9 0 TD
(, for converting system fonts to)Tj
-29.3 -1.5 TD
(use with OpenGL. Both routines build a display list for each requested character from the specified font)Tj
T*
(and font size.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 623.000 Tm
(WGL Prototypes)Tj
10.000 0.000 0.000 10.000 124.000 593.000 Tm
(Initialization)Tj
/F11 1 Tf
0 -2.2 TD
(Determine version information:)Tj
0 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(GetVersion)Tj
/F11 1 Tf
4.5 0 TD
( \( LPOSVERSIONINFO )Tj
/F15 1 Tf
10.2 0 TD
(lpVersionInformation)Tj
/F11 1 Tf
8.7 0 TD
( \);)Tj
-26.4 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(GetVersionEx)Tj
/F11 1 Tf
5.6 0 TD
( \( LPOSVERSIONINFO )Tj
/F15 1 Tf
10.2 0 TD
(lpVersionInformation)Tj
/F11 1 Tf
8.6 0 TD
( \);)Tj
-27.4 -2.1 TD
(Pixel format availability, selection, and capability:)Tj
T*
(int )Tj
/F15 1 Tf
1.3 0 TD
(ChoosePixelFormat)Tj
/F11 1 Tf
8.1 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.4 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
(,)Tj
-14.2 -1.1 TD
(CONST PIXELFORMATDESCRIPTOR * )Tj
/F15 1 Tf
17.6 0 TD
(ppfd)Tj
/F11 1 Tf
1.8 0 TD
( \);)Tj
-19.4 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(SetPixelFormat)Tj
/F11 1 Tf
6.2 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.5 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(iPixelFormat)Tj
/F11 1 Tf
5.4 0 TD
(,)Tj
-21.3 -1.1 TD
(CONST PIXELFORMATDESCRIPTOR * )Tj
/F15 1 Tf
17.6 0 TD
(ppfd)Tj
/F11 1 Tf
1.8 0 TD
( \);)Tj
-19.4 -2.1 TD
(int )Tj
/F15 1 Tf
1.3 0 TD
(DescribePixelFormat)Tj
/F11 1 Tf
8.7 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.4 0 TD
(hdc)Tj
/F11 1 Tf
1.5 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(iPixelFormat)Tj
/F11 1 Tf
5.3 0 TD
(, UINT )Tj
/F15 1 Tf
3.1 0 TD
(nBytes)Tj
/F11 1 Tf
2.7 0 TD
(,)Tj
-27.8 -1.1 TD
(LPPIXELFORMATDESCRIPTOR  )Tj
/F15 1 Tf
14.8 0 TD
(ppfd)Tj
/F11 1 Tf
1.8 0 TD
( \);)Tj
-16.6 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglDescribeLayerPlane)Tj
/F11 1 Tf
9.7 0 TD
( \( HDC )Tj
/F15 1 Tf
3.2 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(iPixelFormat)Tj
/F11 1 Tf
5.4 0 TD
(,)Tj
-24.5 -1.1 TD
(int )Tj
/F15 1 Tf
1.3 0 TD
(iLayerPlane)Tj
/F11 1 Tf
5 0 TD
(, UINT )Tj
/F15 1 Tf
3.1 0 TD
(nBytes)Tj
/F11 1 Tf
2.7 0 TD
(, LPLAYERPLANEDESCRIPTOR )Tj
/F15 1 Tf
14.5 0 TD
(plpd)Tj
/F11 1 Tf
1.8 0 TD
( \);)Tj
/F27 1 Tf
-28.4 -3 TD
(Controlling Rendering)Tj
/F11 1 Tf
0 -2.1 TD
(Manage or query an OpenGL rendering context:)Tj
T*
(HGLRC )Tj
/F15 1 Tf
3.6 0 TD
(wglCreateContext)Tj
/F11 1 Tf
7.3 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.5 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
( \);)Tj
-15.8 -2.1 TD
(HGLRC )Tj
/F15 1 Tf
3.6 0 TD
(wglCreateLayerContext)Tj
/F11 1 Tf
9.7 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.4 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(iLayerPlane)Tj
/F11 1 Tf
5 0 TD
( \);)Tj
-24.9 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglShareLists)Tj
/F11 1 Tf
5.6 0 TD
( \( HGLRC  )Tj
/F15 1 Tf
4.8 0 TD
(hglrc1)Tj
/F11 1 Tf
2.6 0 TD
(, HGLRC  )Tj
/F15 1 Tf
4.4 0 TD
(hglrc2)Tj
/F11 1 Tf
2.6 0 TD
( \);)Tj
-23 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglDeleteContext)Tj
/F11 1 Tf
7.1 0 TD
( \( HGLRC  )Tj
/F15 1 Tf
4.8 0 TD
(hglrc)Tj
/F11 1 Tf
2.1 0 TD
( \);)Tj
-17 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglCopyContext)Tj
/F11 1 Tf
6.6 0 TD
( \( HGLRC  )Tj
/F15 1 Tf
4.8 0 TD
(hglrcSource)Tj
/F11 1 Tf
4.8 0 TD
(, HGLRC  )Tj
/F15 1 Tf
4.4 0 TD
(hlglrcDest)Tj
/F11 1 Tf
4.3 0 TD
(,)Tj
-27.9 -1.1 TD
(UINT  )Tj
/F15 1 Tf
2.9 0 TD
(mask)Tj
/F11 1 Tf
2 0 TD
( \);)Tj
-4.9 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglMakeCurrent)Tj
/F11 1 Tf
6.8 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.4 0 TD
(hdc)Tj
/F11 1 Tf
1.5 0 TD
(, HGLRC  )Tj
/F15 1 Tf
4.4 0 TD
(hglrc)Tj
/F11 1 Tf
2.1 0 TD
( \);)Tj
-21.2 -2.1 TD
(HGLRC )Tj
/F15 1 Tf
3.6 0 TD
(wglGetCurrentContext)Tj
/F11 1 Tf
9.2 0 TD
( \(VOID\) ;)Tj
-12.8 -2.1 TD
(HDC )Tj
/F15 1 Tf
2.4 0 TD
(wglGetCurrentDC)Tj
/F11 1 Tf
7.4 0 TD
( \(VOID\);)Tj
-9.8 -2.1 TD
(Access and release the bitmap of the front buffer:)Tj
T*
(HBITMAP )Tj
/F15 1 Tf
4.8 0 TD
(CreateDIBitmap)Tj
/F11 1 Tf
6.6 0 TD
( \( HDC )Tj
/F15 1 Tf
3.2 0 TD
(hdc)Tj
/F11 1 Tf
1.5 0 TD
(,)Tj
-16.1 -1.1 TD
(CONST BITMAPINFOHEADER *)Tj
/F15 1 Tf
14.4 0 TD
(lpbmih)Tj
/F11 1 Tf
2.8 0 TD
(, DWORD )Tj
/F15 1 Tf
4.5 0 TD
(fdwInit)Tj
/F11 1 Tf
2.9 0 TD
(,)Tj
-24.6 -1.2 TD
(CONST VOID *)Tj
/F15 1 Tf
6.8 0 TD
(lpbInit)Tj
/F11 1 Tf
2.6 0 TD
(, CONST BITMAPINFO *)Tj
/F15 1 Tf
10.9 0 TD
(lpbmi)Tj
/F11 1 Tf
2.3 0 TD
(, UINT )Tj
/F15 1 Tf
3.1 0 TD
(fuUsage)Tj
/F11 1 Tf
3.4 0 TD
( \);)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix C,  OpenGL and Window Systems - 12)Tj
ET
endstream
endobj
1548 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1550 0 obj
<<
/Length 3289
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(HBITMAP )Tj
/F15 1 Tf
4.8 0 TD
(CreateDIBSection)Tj
/F11 1 Tf
7.3 0 TD
0.000 Tw
( \( HDC )Tj
/F15 1 Tf
3.2 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
(, CONST BITMAPINFO *)Tj
/F15 1 Tf
10.9 0 TD
(pbmi)Tj
/F11 1 Tf
2 0 TD
(,)Tj
-29.6 -1.1 TD
(UINT )Tj
/F15 1 Tf
2.6 0 TD
(iUsage)Tj
/F11 1 Tf
2.9 0 TD
(, VOID *)Tj
/F15 1 Tf
3.7 0 TD
(ppvBits)Tj
/F11 1 Tf
3 0 TD
(, HANDLE )Tj
/F15 1 Tf
4.9 0 TD
(hSection)Tj
/F11 1 Tf
3.4 0 TD
(, DWORD )Tj
/F15 1 Tf
4.6 0 TD
(dwOffset)Tj
/F11 1 Tf
3.5 0 TD
( \);)Tj
-28.6 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(DeleteObject)Tj
/F11 1 Tf
5.2 0 TD
( \( HGDIOBJ )Tj
/F15 1 Tf
5.4 0 TD
(hObject)Tj
/F11 1 Tf
3.2 0 TD
( \);)Tj
-16.8 -2.1 TD
(Exchange front and back buffers:)Tj
T*
(BOOL )Tj
/F15 1 Tf
3 0 TD
(SwapBuffers)Tj
/F11 1 Tf
5 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.5 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
( \);)Tj
-12.9 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglSwapLayerBuffers)Tj
/F11 1 Tf
8.8 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.5 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
(, UINT  )Tj
/F15 1 Tf
3.4 0 TD
(fuPlanes)Tj
/F11 1 Tf
3.5 0 TD
( \);)Tj
-23.6 -2.1 TD
(Finding a color palette for overlay or underlay layers:)Tj
T*
(int )Tj
/F15 1 Tf
1.3 0 TD
(wglGetLayerPaletteEntries)Tj
/F11 1 Tf
11 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.4 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(iLayerPlane)Tj
/F11 1 Tf
5 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(iStart)Tj
/F11 1 Tf
2.2 0 TD
(,)Tj
-27.9 -1.1 TD
(int )Tj
/F15 1 Tf
1.3 0 TD
(cEntries)Tj
/F11 1 Tf
3.3 0 TD
(, CONST COLORREF *)Tj
/F15 1 Tf
10 0 TD
(pcr)Tj
/F11 1 Tf
1.4 0 TD
( \);)Tj
-16 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglRealizeLayerPalette)Tj
/F11 1 Tf
9.5 0 TD
( \( HDC  )Tj
/F15 1 Tf
3.5 0 TD
(hdc)Tj
/F11 1 Tf
1.4 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(iLayerPlane)Tj
/F11 1 Tf
5 0 TD
(,)Tj
-24.2 -1.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(bRealize)Tj
/F11 1 Tf
3.4 0 TD
( \);)Tj
-6.4 -2.1 TD
(Use a bitmap or an outline font:)Tj
T*
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglUseFontBitmaps)Tj
/F11 1 Tf
8.1 0 TD
( \( HDC )Tj
/F15 1 Tf
3.2 0 TD
(hdc)Tj
/F11 1 Tf
1.5 0 TD
(, DWORD )Tj
/F15 1 Tf
4.5 0 TD
(first)Tj
/F11 1 Tf
1.6 0 TD
(, DWORD )Tj
/F15 1 Tf
4.5 0 TD
(count)Tj
/F11 1 Tf
2.3 0 TD
(,)Tj
-28.7 -1.2 TD
(DWORD )Tj
/F15 1 Tf
4 0 TD
(listBase)Tj
/F11 1 Tf
3.2 0 TD
( \);)Tj
-7.2 -2.1 TD
(BOOL )Tj
/F15 1 Tf
3 0 TD
(wglUseFontOutlines)Tj
/F11 1 Tf
8.3 0 TD
( \( HDC )Tj
/F15 1 Tf
3.1 0 TD
(hdc)Tj
/F11 1 Tf
1.5 0 TD
(, DWORD )Tj
/F15 1 Tf
4.5 0 TD
(first)Tj
/F11 1 Tf
1.6 0 TD
(, DWORD )Tj
/F15 1 Tf
4.6 0 TD
(count)Tj
/F11 1 Tf
2.2 0 TD
(,)Tj
-28.8 -1.1 TD
(DWORD )Tj
/F15 1 Tf
4 0 TD
(listBase)Tj
/F11 1 Tf
3.2 0 TD
(, FLOAT )Tj
/F15 1 Tf
4 0 TD
(deviation)Tj
/F11 1 Tf
3.7 0 TD
(, FLOAT )Tj
/F15 1 Tf
4 0 TD
(extrusion)Tj
/F11 1 Tf
3.7 0 TD
(, int )Tj
/F15 1 Tf
1.8 0 TD
(format)Tj
/F11 1 Tf
2.7 0 TD
(,)Tj
-27.1 -1.1 TD
(LPGLYPHMETRICSFLOAT )Tj
/F15 1 Tf
12.3 0 TD
(lpgmf)Tj
/F11 1 Tf
2.3 0 TD
( \);)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 413.390 m
547.000 413.390 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix D,   Basics of GLUT: The OpenGL Utility Toolkit - 13)Tj
ET
endstream
endobj
1551 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1553 0 obj
<<
/Length 3904
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix D)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Basics of GLUT: The OpenGL Utility Toolkit)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(This appendix describes a subset of Mark Kilgard's OpenGL Utility Toolkit \(GLUT\), which is fully)Tj
0 -1.5 TD
(documented in his book, )Tj
/F15 1 Tf
10.1 0 TD
(OpenGL Programming for the X Window System)Tj
/F11 1 Tf
19.6 0 TD
( \(Reading, MA:)Tj
-29.7 -1.5 TD
(Addison-Wesley Developers Press, 1996\). GLUT has become a popular library for OpenGL)Tj
T*
(programmers, because it standardizes and simplifies window and event management. GLUT has been)Tj
T*
(ported atop a variety of OpenGL implementations, including both the X Window System and Microsoft)Tj
T*
(Windows NT.)Tj
0 -2.1 TD
(This appendix has the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Initializing and Creating a Window")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Handling Window and Input Events")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Loading the Color Map")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Initializing and Drawing Three-Dimensional Objects")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Managing a Background Process")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Running the Program")Tj
-1.9 -2.8 TD
[(\(See )27("How to Obtain the Sample Code")-55( in the Preface for information about how to obtain the source)]TJ
0 -1.5 TD
(code for GLUT.\))Tj
0 -2.1 TD
(With GLUT, your application structures its event handling to use callback functions. \(This method is)Tj
0 -1.5 TD
(similar to using the Xt Toolkit, also known as the X Intrinsics, with a widget set.\) For example, first you)Tj
T*
(open a window and register callback routines for specific events. Then, you create a main loop without)Tj
T*
(an exit. In that loop, if an event occurs, its registered callback functions are executed. Upon completion)Tj
T*
(of the callback functions, flow of control is returned to the main loop.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 280.000 Tm
(Initializing and Creating a Window)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 258.000 Tm
(Before you can open a window, you must specify its characteristics: Should it be single-buffered or)Tj
T*
(double-buffered? Should it store colors as RGBA values or as color indices? Where should it appear on)Tj
T*
(your display? To specify the answers to these questions, call )Tj
/F15 1 Tf
24.4 0 TD
(glutInit\(\))Tj
/F11 1 Tf
3.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glutInitDisplayMode\(\))Tj
/F11 1 Tf
9 0 TD
(,)Tj
/F15 1 Tf
-37.5 -1.5 TD
(glutInitWindowSize\(\))Tj
/F11 1 Tf
8.5 0 TD
(, and)Tj
/F15 1 Tf
1.9 0 TD
( glutInitWindowPosition\(\) )Tj
/F11 1 Tf
10.8 0 TD
(before you call )Tj
/F15 1 Tf
6.2 0 TD
(glutCreateWindow\(\))Tj
/F11 1 Tf
8.2 0 TD
( to open the)Tj
-35.6 -1.5 TD
(window.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glutInit)45(\(int )-61(argc)33(, char **)-17(argv)33(\);)]TJ
1.8 -1.5 TD
[(glutInit\(\))11( should be called before any other GLUT routine, because it initializes the GLUT library.)]TJ
T*
[(glutInit\(\))11( will also process command line options, but the specific options are window system)]TJ
T*
(dependent. For the X Window System, -iconic, -geometry, and -display are examples of command)Tj
T*
[(line options, processed by )39(glutInit\(\))11(. \(The parameters to the )-11(glutInit\(\))11( should be the same as those to)]TJ
T*
[(main\(\))-34(.\))]TJ
-1.8 -2.1 TD
0.028 Tw
[(void glutInitDisplayMode)34(\(unsigned )28(int )29(mode)-34(\);)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix D,   Basics of GLUT: The OpenGL Utility Toolkit - 1)Tj
ET
endstream
endobj
1554 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1556 0 obj
<<
/Length 4409
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 142.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Specifies a display mode \(such as RGBA or color-index, or single- or double-buffered\) for windows)Tj
0 -1.5 TD
[(created when )11(glutCreateWindow\(\))23( is called. You can also specify that the window have an)]TJ
T*
[(associated depth, stencil, and/or accumulation buffer. The )-42(mask)55( argument is a bitwise ORed)]TJ
T*
(combination of GLUT_RGBA or GLUT_INDEX, GLUT_SINGLE or GLUT_DOUBLE, and any of)Tj
T*
(the buffer-enabling flags: GLUT_DEPTH, GLUT_STENCIL, or GLUT_ACCUM. For example, for a)Tj
T*
(double-buffered, RGBA-mode window with a depth and stencil buffer, use GLUT_DOUBLE |)Tj
T*
(GLUT_RGBA | GLUT_DEPTH | GLUT_STENCIL. The default value is GLUT_RGBA |)Tj
T*
(GLUT_SINGLE \(an RGBA, single-buffered window\).)Tj
-1.8 -2.1 TD
0.028 Tw
[(void glutInitWindowSize)35(\(int )67(width)-77(, )28(int )34(height\);)]TJ
0 -1.1 TD
[(void glutInitWindowPosition)58(\(int )-33(x)44(,)0( )28(int )34(y)-56(\))0(;)]TJ
1.8 -1.5 TD
0.000 Tw
[(Requests windows created by glutCreateWindow\(\))23( to have an initial size and position. The)]TJ
T*
[(arguments \()6(x, y)-12(\))0( indicate the location of a corner of the window, relative to the entire display. The)]TJ
T*
[(width)23( and height indicate the window's size \(in pixels\). The initial window size and position are)]TJ
T*
(hints and may be overridden by other requests.)Tj
-1.8 -2.1 TD
-0.006 Tw
[(int glutCreateWindow)-43(\(char )-6(*)16(name)66(\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Opens a window with previously set characteristics \(display mode, width, height, and so on\). The)Tj
T*
[(string )-16(name)-34( may appear in the title bar if your window system does that sort of thing. The window is)]TJ
T*
[(not initially displayed until )-42(glutMainLoop\(\))90( is entered, so do not render into the window until then.)]TJ
T*
(The value returned is a unique integer identifier for the window. This identifier can be used for)Tj
T*
(controlling and rendering to multiple windows \(each with an OpenGL rendering context\) from the)Tj
T*
(same application.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 370.000 Tm
(Handling Window and Input Events)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 348.000 Tm
(After the window is created, but before you enter the main loop, you should register callback functions)Tj
T*
(using the following routines.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glutDisplayFunc)23(\(void )28(\(*)38(func)-78(\)\(void\)\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Specifies the function that's called whenever the contents of the window need to be redrawn. The)Tj
T*
(contents of the window may need to be redrawn when the window is initially opened, when the)Tj
T*
[(window is popped and window damage is exposed, and when )-47(glutPostRedisplay\(\))45( is explicitly called.)]TJ
-1.8 -2.1 TD
0.028 Tw
[(void glutReshapeFunc\(void )28(\(*)38(func)22(\)\(int width)23(, )28(int )34(height\)\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Specifies the function that's called whenever the window is resized or moved. The argument )29(func)22( is a)]TJ
T*
(pointer to a function that expects two arguments, the new width and height of the window. Typically,)Tj
T*
[(func)22( calls )-11(glViewport\(\))12(, so that the display is clipped to the new size, and it redefines the projection)]TJ
T*
(matrix so that the aspect ratio of the projected image matches the viewport, avoiding aspect ratio)Tj
T*
[(distortion. If )-48(glutReshapeFunc\(\))66( isn't called or is deregistered by passing NULL, a default reshape)]TJ
T*
[(function is called, which calls )-32(glViewport)46(\()33(0, 0, width)-77(, height\).)]TJ
-1.8 -2.1 TD
[(void )-28(glutKeyboardFunc)56(\(void \(*)-62(func)22(\)\(unsigned int )34(key)-68(, int )6(x)44(,)0( int )6(y)-56(\))0(;)]TJ
1.8 -1.5 TD
[(Specifies the function, )-44(func)22(, that's called when a key that generates an ASCII character is pressed.)]TJ
T*
[(The )-50(key)32( callback parameter is the generated ASCII value. The )55(x)-56( and y)44( callback parameters indicate)]TJ
T*
(the location of the mouse \(in window-relative coordinates\) when the key was pressed.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix D,   Basics of GLUT: The OpenGL Utility Toolkit - 2)Tj
ET
endstream
endobj
1557 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1559 0 obj
<<
/Length 4174
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
[(void )-28(glutMouseFunc)78(\(void \(*)-62(func)22(\)\(int )-28(button)56(, int )6(state)-11(, int )6(x)-56(,)0( int )6(y)44(\)\);)]TJ
1.8 -1.5 TD
[(Specifies the function, )-44(func)22(, that's called when a mouse button is pressed or released.   The )46(button)]TJ
T*
(callback parameter is one of GLUT_LEFT_BUTTON, GLUT_MIDDLE_BUTTON, or)Tj
T*
[(GLUT_RIGHT_BUTTON. The )-14(state)-11( callback parameter is either GLUT_UP or GLUT_DOWN,)]TJ
T*
[(depending upon whether the mouse has been released or pressed. The )-23(x)44( and y)-56( callback parameters)]TJ
T*
(indicate the location \(in window-relative coordinates\) of the mouse when the event occurred.)Tj
-1.8 -2.1 TD
0.028 Tw
[(void glutMotionFunc\(void )28(\(*)38(func)22(\)\(int x)44(,)0( )28(int )-66(y)44(\)\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Specifies the function, )-44(func)22(, that's called when the mouse pointer moves within the window while one)]TJ
T*
[(or more mouse buttons is pressed. The )-32(x)44( and y)-56( callback parameters indicate the location \(in)]TJ
T*
(window-relative coordinates\) of the mouse when the event occurred.)Tj
-1.8 -2.1 TD
0.028 Tw
[(void glutPostRedisplay)-21(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Marks the current window as needing to be redrawn. At the next opportunity, the callback function)Tj
T*
[(registered by glutDisplayFunc\(\))-11( will be called.)]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 486.000 Tm
(Loading the Color Map)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 464.000 Tm
(If you're using color-index mode, you might be surprised to discover there's no OpenGL routine to load)Tj
T*
(a color into a color lookup table. This is because the process of loading a color map depends entirely on)Tj
T*
(the window system. GLUT provides a generalized routine to load a single color index with an RGB)Tj
T*
(value, )Tj
/F15 1 Tf
2.7 0 TD
(glutSetColor\(\))Tj
/F11 1 Tf
5.7 0 TD
(.)Tj
/F15 1 Tf
-8.4 -2.1 TD
[(void )-28(glutSetColor)13(\(GLint )17(index)-34(, GLfloat )62(red)-67(, GLfloat )62(green)-23(, GLfloat )-38(blue)22(\);)]TJ
1.8 -1.5 TD
[(Loads the index in the color map, )-32(index)66(, with the given )-38(red)33(, green)-23(, and )-50(blue)22( values. These values are)]TJ
T*
(normalized to lie in the range [0.0,1.0].)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 334.000 Tm
(Initializing and Drawing Three-Dimensional Objects)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 312.000 Tm
(Many sample programs in this guide use three-dimensional models to illustrate various rendering)Tj
T*
(properties. The following drawing routines are included in GLUT to avoid having to reproduce the code)Tj
T*
(to draw these models in each program. The routines render all their graphics in immediate mode. Each)Tj
T*
(three-dimensional model comes in two flavors: wireframe without surface normals, and solid with)Tj
T*
(shading and surface normals. Use the solid version when you're applying lighting. Only the teapot)Tj
T*
(generates texture coordinates.)Tj
/F15 1 Tf
0 -2.1 TD
[(void )-28(glutWireSphere)78(\(GLdouble )-16(radius, )-44(GLint)34( slices)-28(, GLint)34( stacks)-6(\);)]TJ
0 -1.1 TD
[(void )-28(glutSolidSphere)-10(\(GLdouble )84(radius, )-44(GLint)34( slices)-28(, GLint)34( stacks)-6(\);)]TJ
0 -2.1 TD
0.028 Tw
[(void glutWireCube)12(\(GLdouble )12(size\);)]TJ
0 -1.1 TD
[(void glutSolidCube)24(\(GLdouble )12(size\);)]TJ
0 -2.1 TD
[(void glutWireTorus)35(\(GLdouble )12(innerRadius)-10(, )28(GLdouble )79(outerRadius)-10(,)]TJ
0 -1.1 TD
0.000 Tw
[(GLint)34( nsides, )-50(GLint)34( rings)6(\);)]TJ
T*
0.028 Tw
[(void glutSolidTorus)47(\(GLdouble )12(innerRadius)-10(, )28(GLdouble )79(outerRadius)-10(,)]TJ
T*
0.000 Tw
[(GLint)34( nsides, )-50(GLint)34( rings)6(\);)]TJ
0 -2.7 TD
0.028 Tw
(void glutWireIcosahedron\(void\);)Tj
0 -1.1 TD
[(void glutSolidIcosahedron)12(\(void\);)]TJ
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix D,   Basics of GLUT: The OpenGL Utility Toolkit - 3)Tj
ET
endstream
endobj
1560 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1563 0 obj
<<
/Length 2621
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F15 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.028 Tw
[(void glutWireOctahedron)78(\(void\);)]TJ
0 -1.1 TD
[(void glutSolidOctahedron)-10(\(void\);)]TJ
0 -2.1 TD
(void glutWireTetrahedron\(void\);)Tj
0 -1.1 TD
[(void glutSolidTetrahedron)13(\(void\);)]TJ
0 -2.1 TD
[(void glutWireDodecahedron)44(\(GLdouble )12(radius)-44(\);)]TJ
0 -1.1 TD
[(void glutSolidDodecahedron)56(\(GLdouble )12(radius)-44(\);)]TJ
0 -2.1 TD
0.000 Tw
[(void )-28(glutWireCone)12(\(GLdouble )-16(radius)56(, GLdouble )-49(height, GLint)34( slices)-28(,)]TJ
0 -1.1 TD
[(GLint)34( stacks)-6(\);)]TJ
T*
[(void )-28(glutSolidCone)24(\(GLdouble )-16(radius)56(, GLdouble )-49(height, GLint)34( slices)-28(,)]TJ
T*
[(GLint)34( stacks)-6(\);)]TJ
0 -2.1 TD
0.028 Tw
[(void glutWireTeapot)-21(\(GLdouble )112(size\);)]TJ
0 -1.1 TD
[(void glutSolidTeapot)-9(\(GLdouble )112(size\);)]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 513.000 Tm
0.000 Tw
(Managing a Background Process)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 490.000 Tm
(You can specify a function that's to be executed if no other events are pending)Tj
/F33 1 Tf
31.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, when the)Tj
-32.4 -1.7 TD
(event loop would otherwise be idle)Tj
/F33 1 Tf
14 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(with )Tj
/F15 1 Tf
2.1 0 TD
(glutIdleFunc\(\))Tj
/F11 1 Tf
5.8 0 TD
(. This is particularly useful for continuous)Tj
-22.9 -1.6 TD
(animation or other background processing.)Tj
/F15 1 Tf
0 -2.1 TD
0.028 Tw
[(void glutIdleFunc)67(\(void )28(\(*)-62(func\))55(\(void\)\);)]TJ
1.8 -1.5 TD
0.000 Tw
[(Specifies the function, )-44(func)22(, to be executed if no other events are pending. If NULL \(zero\) is passed)]TJ
T*
[(in, execution of )-11(func)22( is disabled.)]TJ
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 373.000 Tm
(Running the Program)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 351.000 Tm
(After all the setup is completed, GLUT programs enter an event processing loop, )Tj
/F15 1 Tf
32.6 0 TD
(glutMainLoop\(\))Tj
/F11 1 Tf
6.4 0 TD
(.)Tj
/F15 1 Tf
-39 -2.1 TD
0.028 Tw
[(void glutMainLoop)24(\(void\);)]TJ
1.8 -1.5 TD
0.000 Tw
(Enters the GLUT processing loop, never to return. Registered callback functions will be called when)Tj
T*
(the corresponding events instigate them.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 273.170 m
547.000 273.170 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix E,  Calculating Normal Vectors - 4)Tj
ET
endstream
endobj
1564 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1565 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im118
/Width 386
/Height 108
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.117)
>>
stream
endstream
endobj
1567 0 obj
<<
/Length 3521
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix E)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Calculating Normal Vectors)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(This appendix describes how to calculate normal vectors for surfaces. You need to define normals to use)Tj
0 -1.5 TD
[(the OpenGL lighting facility, which is described in )39(Chapter 5)-84(.)0( "Normal Vectors" in Chapter 2)26( introduces)]TJ
T*
(normals and the OpenGL command for specifying them. This appendix goes through the details of)Tj
T*
(calculating them. It has the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Finding Normals for Analytic Surfaces")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Finding Normals from Polygonal Data")Tj
-1.9 -2.8 TD
(Since normals are perpendicular to a surface, you can find the normal at a particular point on a surface by)Tj
0 -1.5 TD
(first finding the flat plane that just touches the surface at that point. The normal is the vector that's)Tj
T*
(perpendicular to that plane. On a perfect sphere, for example, the normal at a point on the surface is in)Tj
T*
(the same direction as the vector from the center of the sphere to that point. For other types of surfaces,)Tj
T*
(there are other, better means for determining the normals, depending on how the surface is specified.)Tj
0 -2.1 TD
(Recall that smooth curved surfaces are approximated by a large number of small flat polygons. If the)Tj
0 -1.5 TD
(vectors perpendicular to these polygons are used as the surface normals in such an approximation, the)Tj
T*
(surface appears faceted, since the normal direction is discontinuous across the polygonal boundaries. In)Tj
T*
(many cases, however, an exact mathematical description exists for the surface, and true surface normals)Tj
T*
(can be calculated at every point. Using the true normals improves the rendering considerably, as shown)Tj
T*
[(in )28(Figure E-1)236(. Even if you don't have a mathematical description, you can do better than the faceted look)]TJ
T*
(shown in the figure. The two major sections in this appendix describe how to calculate normal vectors for)Tj
T*
(these two cases:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Finding Normals for Analytic Surfaces")27( explains what to do when you have a mathematical)]TJ
0 -1.6 TD
(description of a surface.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
[("Finding Normals from Polygonal Data")-38( covers the case when you have only the polygonal data to)]TJ
0 -1.6 TD
(describe a surface.)Tj
ET
Q
/GS1 gs
q
386.0001 0 0 108 143 167.97 cm
/Im118 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 143.000 155.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Figure E-1 )Tj
/F11 1 Tf
5.2 0 TD
(Rendering with Polygonal Normals vs. True Normals)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 116.000 Tm
(Finding Normals for Analytic Surfaces)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 94.000 Tm
(Analytic surfaces are smooth, differentiable surfaces that are described by a mathematical equation \(or)Tj
0 -1.5 TD
(set of equations\). In many cases, the easiest surfaces to find normals for are analytic surfaces for which)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix E,  Calculating Normal Vectors - 1)Tj
ET
endstream
endobj
1568 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im118 1565 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1569 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im119
/Width 99
/Height 50
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.118)
>>
stream
endstream
endobj
1570 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im120
/Width 84
/Height 50
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.119)
>>
stream
endstream
endobj
1571 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im121
/Width 460
/Height 36
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.120)
>>
stream
endstream
endobj
1572 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im122
/Width 170
/Height 39
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.121)
>>
stream
endstream
endobj
1573 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im123
/Width 433
/Height 50
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.122)
>>
stream
endstream
endobj
1575 0 obj
<<
/Length 4078
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(you have an explicit definition in the following form:)Tj
/F15 1 Tf
0 -2.1 TD
(V)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(s,t)Tj
/F11 1 Tf
1 0 TD
(\) = [ )Tj
/F15 1 Tf
1.9 0 TD
(X)Tj
/F11 1 Tf
0.7 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(s,t)Tj
/F11 1 Tf
0.9 0 TD
(\)  )Tj
/F15 1 Tf
0.8 0 TD
(Y)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(s,t)Tj
/F11 1 Tf
0.9 0 TD
(\)  )Tj
/F15 1 Tf
0.9 0 TD
(Z)Tj
/F11 1 Tf
0.5 0 TD
(\()Tj
/F15 1 Tf
0.4 0 TD
(s,t)Tj
/F11 1 Tf
0.9 0 TD
(\) ])Tj
-11 -2.1 TD
(where )Tj
/F15 1 Tf
2.7 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(t)Tj
/F11 1 Tf
0.3 0 TD
( are constrained to be in some domain, and )Tj
/F15 1 Tf
17.4 0 TD
(X)Tj
/F11 1 Tf
0.6 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(Y)Tj
/F11 1 Tf
0.6 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(Z)Tj
/F11 1 Tf
0.5 0 TD
( are differentiable functions of two)Tj
-27.1 -1.5 TD
(variables. To calculate the normal, find)Tj
ET
Q
/GS1 gs
q
99 0 0 50 124 589.84 cm
/Im119 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 565.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(which are vectors tangent to the surface in the )Tj
/F15 1 Tf
18.6 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(t)Tj
/F11 1 Tf
0.2 0 TD
( directions. The cross product)Tj
ET
Q
q
84 0 0 50 124 500.8401 cm
/Im120 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 482.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(is perpendicular to both and, hence, to the surface. The following shows how to calculate the cross)Tj
0 -1.5 TD
(product of two vectors. \(Watch out for the degenerate cases where the cross product has zero length!\))Tj
ET
Q
q
423 0 0 33 124 419.84 cm
/Im121 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 401.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(You should probably normalize the resulting vector. To normalize a vector [x y z], calculate its length)Tj
ET
Q
q
170 0 0 39 124 347.74 cm
/Im122 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 329.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(and divide each component of the vector by the length.)Tj
0 -2.1 TD
(As an example of these calculations, consider the analytic surface)Tj
/F15 1 Tf
T*
(V)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(s,t)Tj
/F11 1 Tf
1 0 TD
(\) = [ )Tj
/F15 1 Tf
1.9 0 TD
(s)Tj
/F11 1 Tf
0.4 0 TD
(2)Tj
/F15 1 Tf
0.5 0 TD
( t)Tj
/F11 1 Tf
0.6 0 TD
(3 3-)Tj
/F15 1 Tf
1.5 0 TD
(st)Tj
/F11 1 Tf
0.7 0 TD
( ])Tj
-7.5 -2.1 TD
(From this we have)Tj
ET
Q
q
1 i 
124.000 251.740 423.000 -48.840 re
W n
q
423 0 0 49 124 202.74 cm
/Im123 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 184.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(So, for example, when)Tj
/F15 1 Tf
9 0 TD
( s)Tj
/F11 1 Tf
0.7 0 TD
(=1 and)Tj
/F15 1 Tf
2.7 0 TD
( t)Tj
/F11 1 Tf
0.6 0 TD
(=2, the corresponding point on the surface is \(1, 8, 1\), and the vector)Tj
-13 -1.5 TD
(\(-24, 2, 24\) is perpendicular to the surface at that point. The length of this vector is 34, so the unit normal)Tj
T*
(vector is \(-24/34, 2/34, 24/34\) = \(-0.70588, 0.058823, 0.70588\).)Tj
0 -2.1 TD
(For analytic surfaces that are described implicitly, as )Tj
/F15 1 Tf
21.4 0 TD
(F)Tj
/F11 1 Tf
0.6 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(x, y, z)Tj
/F11 1 Tf
2.3 0 TD
(\) = 0, the problem is harder. In some cases,)Tj
-24.6 -1.5 TD
(you can solve for one of the variables, say )Tj
/F15 1 Tf
17.1 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( = )Tj
/F15 1 Tf
1.1 0 TD
(G)Tj
/F11 1 Tf
0.7 0 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(x, y)Tj
/F11 1 Tf
1.4 0 TD
(\), and put it in the explicit form given previously:)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix E,  Calculating Normal Vectors - 2)Tj
ET
endstream
endobj
1576 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F15 19 0 R
>>
/XObject <<
/Im119 1569 0 R
/Im120 1570 0 R
/Im121 1571 0 R
/Im122 1572 0 R
/Im123 1573 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1577 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im124
/Width 159
/Height 34
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.123)
>>
stream
endstream
endobj
1578 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im125
/Width 141
/Height 58
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.124)
>>
stream
endstream
endobj
1579 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im126
/Width 131
/Height 39
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.125)
>>
stream
endstream
endobj
1580 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im127
/Width 179
/Height 47
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.126)
>>
stream
endstream
endobj
1581 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im128
/Width 127
/Height 44
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.127)
>>
stream
endstream
endobj
1583 0 obj
<<
/Length 3001
>>
stream
/GS1 gs
q
159 0 0 34 124 686 cm
/Im124 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 667.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Then continue as described earlier.)Tj
0 -2.1 TD
(If you can't get the surface equation in an explicit form, you might be able to make use of the fact that)Tj
0 -1.5 TD
(the normal vector is given by the gradient)Tj
ET
Q
q
141 0 0 58 124 559 cm
/Im125 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 534.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(evaluated at a particular point \()Tj
/F15 1 Tf
12.5 0 TD
(x, y, z)Tj
/F11 1 Tf
2.2 0 TD
(\). Calculating the gradient might be easy, but finding a point that lies)Tj
-14.7 -1.5 TD
(on the surface can be difficult. As an example of an implicitly defined analytic function, consider the)Tj
T*
(equation of a sphere of radius 1 centered at the origin:)Tj
0 -2.4 TD
(x)Tj
0.5 0.3 TD
(2)Tj
0.5 -0.3 TD
( + y)Tj
1.6 0.3 TD
(2)Tj
0.5 -0.3 TD
( + z)Tj
1.5 0.3 TD
(2)Tj
0.5 -0.3 TD
( - 1 = 0 \))Tj
-5.1 -2.1 TD
(This means that)Tj
/F13 1 Tf
0 -2.4 TD
(F)Tj
/F11 1 Tf
0.6 0 TD
( \(x, y, z\) = x)Tj
4.9 0.3 TD
(2)Tj
0.5 -0.3 TD
( + y)Tj
1.6 0.3 TD
(2)Tj
0.5 -0.3 TD
( + z)Tj
1.5 0.3 TD
(2)Tj
0.5 -0.3 TD
( - 1)Tj
-10.1 -2.1 TD
(which can be solved for)Tj
/F15 1 Tf
9.6 0 TD
( z)Tj
/F11 1 Tf
0.6 0 TD
( to yield)Tj
ET
Q
q
131 0 0 39 124 361 cm
/Im126 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 342.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Thus, normals can be calculated from the explicit form)Tj
ET
Q
q
179 0 0 47 124 281 cm
/Im127 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 262.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(as described previously.)Tj
0 -2.1 TD
(If you could not solve for )Tj
/F15 1 Tf
10.4 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(, you could have used the gradient)Tj
ET
Q
q
127 0 0 44 124 183 cm
/Im128 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 163.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(as long as you could find a point on the surface. In this case, it's not so hard to find a point)Tj
/F33 1 Tf
36.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example,)Tj
-37.2 -1.6 TD
(\(2/3, 1/3, 2/3\) lies on the surface. Using the gradient, the normal at this point is \(4/3, 2/3, 4/3\). The)Tj
0 -1.5 TD
(unit-length normal is \(2/3, 1/3, 2/3\), which is the same as the point on the surface, as expected.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 99.000 Tm
(Finding Normals from Polygonal Data)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 77.000 Tm
(As mentioned previously, you often want to find normals for surfaces that are described with polygonal)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix E,  Calculating Normal Vectors - 3)Tj
ET
endstream
endobj
1584 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im124 1577 0 R
/Im125 1578 0 R
/Im126 1579 0 R
/Im127 1580 0 R
/Im128 1581 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1585 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im129
/Width 396
/Height 508
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.128)
>>
stream
endstream
endobj
1587 0 obj
<<
/Length 1303
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(data such that the surfaces appear smooth rather than faceted. In most cases, the easiest way for you to do)Tj
0 -1.5 TD
(this \(though it might not be the most efficient way\) is to calculate the normal vectors for each of the)Tj
T*
(polygonal facets and then to average the normals for neighboring facets. Use the averaged normal for the)Tj
T*
[(vertex that the neighboring facets have in common. Figure E-2)236( shows a surface and its polygonal)]TJ
T*
(approximation. \(Of course, if the polygons represent the exact surface and aren't merely an)Tj
0 -1.6 TD
(approximation)Tj
/F33 1 Tf
5.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(if you're drawing a cube or a cut diamond, for example)Tj
/F33 1 Tf
22.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(don't do the averaging.)Tj
-30 -1.6 TD
(Calculate the normal for each facet as described in the following paragraphs, and use that same normal)Tj
0 -1.5 TD
(for each vertex of the facet.\))Tj
ET
Q
/GS1 gs
q
396 0 0 508 124 80.61 cm
/Im129 Do
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix E,  Calculating Normal Vectors - 4)Tj
ET
endstream
endobj
1588 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F33 12 0 R
>>
/XObject <<
/Im129 1585 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1590 0 obj
<<
/Length 3124
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Figure E-2 )Tj
/F11 1 Tf
5.2 0 TD
(Averaging Normal Vectors)Tj
-5.2 -2.1 TD
(To find the normal for a flat polygon, take any three vertices )Tj
/F15 1 Tf
24.5 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
(1, )Tj
/F15 1 Tf
1 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(2, and )Tj
/F15 1 Tf
2.6 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
(3 of the polygon that do not lie)Tj
-29.5 -1.5 TD
(in a straight line. The cross product)Tj
0 -2.2 TD
([)Tj
/F15 1 Tf
0.3 0 TD
(v)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
( - )Tj
/F15 1 Tf
0.8 0 TD
(v)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
0.5 0.2 TD
(] )Tj
/F33 1 Tf
0.5 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
( [)Tj
/F15 1 Tf
0.6 0 TD
(v)Tj
/F11 1 Tf
0.4 -0.2 TD
(2)Tj
0.5 0.2 TD
( - )Tj
/F15 1 Tf
0.8 0 TD
(v)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
0.5 0.2 TD
(])Tj
-7.5 -2.3 TD
(is perpendicular to the polygon. \(Typically, you want to normalize the resulting vector.\) Then you need)Tj
0 -1.5 TD
(to average the normals for adjoining facets to avoid giving too much weight to one of them. For instance,)Tj
T*
[(in the example shown in )28(Figure E-2)236(, if )]TJ
/F15 1 Tf
15.7 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
0.5 0.2 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
0.5 0.2 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
( are the normals for the four polygons meeting)Tj
-22.9 -1.7 TD
(at point P, calculate )Tj
/F15 1 Tf
8.1 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(1)Tj
0.5 0.2 TD
(+)Tj
/F15 1 Tf
0.6 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(2)Tj
0.5 0.2 TD
(+)Tj
/F15 1 Tf
0.6 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(3)Tj
0.5 0.2 TD
(+)Tj
/F15 1 Tf
0.5 0 TD
(n)Tj
/F11 1 Tf
0.5 -0.2 TD
(4)Tj
0.5 0.2 TD
( and then normalize it. \(You can get a better average if you weight the)Tj
-13.8 -1.7 TD
(normals by the size of the angles at the shared intersection.\) The resulting vector can be used as the)Tj
0 -1.5 TD
(normal for point P.)Tj
0 -2.1 TD
(Sometimes, you need to vary this method for particular situations. For instance, at the boundary of a)Tj
0 -1.5 TD
[(surface \(for example, point Q in )-18(Figure E-2)236(\), you might be able to choose a better normal based on your)]TJ
T*
(knowledge of what the surface should look like. Sometimes the best you can do is to average the polygon)Tj
T*
(normals on the boundary as well. Similarly, some models have some smooth parts and some sharp)Tj
T*
[(corners \(point R is on such an edge in )-39(Figure E-2)236(\). In this case, the normals on either side of the crease)]TJ
T*
(shouldn't be averaged. Instead, polygons on one side of the crease should be drawn with one normal, and)Tj
T*
(polygons on the other side with another.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 418.490 m
547.000 418.490 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix F,  Homogeneous Coordinates and Transformation Matrices - 5)Tj
ET
endstream
endobj
1591 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1593 0 obj
<<
/Length 6244
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix F)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Homogeneous Coordinates and Transformation Matrices)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(This appendix presents a brief discussion of homogeneous coordinates. It also lists the form of the)Tj
0 -1.5 TD
(transformation matrices used for rotation, scaling, translation, perspective projection, and orthographic)Tj
T*
[(projection. These topics are introduced and discussed in )38(Chapter 3)-84(.)0( For a more detailed discussion of)]TJ
0 -1.6 TD
(these subjects, see almost any book on three-dimensional computer graphics)Tj
/F33 1 Tf
30.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, )Tj
/F15 1 Tf
5.3 0 TD
(Computer)Tj
-36.9 -1.6 TD
(Graphics: Principles and Practice)Tj
/F11 1 Tf
13.8 0 TD
( by Foley, van Dam, Feiner, and Hughes \(Reading, MA:)Tj
-13.8 -1.6 TD
(Addison-Wesley, 1990\))Tj
/F33 1 Tf
9.6 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(or a text on projective geometry)Tj
/F33 1 Tf
12.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(for example, )Tj
/F15 1 Tf
5.3 0 TD
(The Real Projective Plane)Tj
/F11 1 Tf
10.5 0 TD
(, by)Tj
-40.2 -1.6 TD
(H. S. M. Coxeter, 2nd ed. \(Cambridge: Cambridge University Press, 1961\). In the discussion that)Tj
0 -1.5 TD
(follows, the term )Tj
/F13 1 Tf
7.1 0 TD
(homogeneous coordinates)Tj
/F11 1 Tf
10.9 0 TD
( always means three-dimensional homogeneous coordinates,)Tj
-18 -1.5 TD
(although projective geometries exist for all dimensions.)Tj
0 -2.1 TD
(This appendix has the following major sections:)Tj
/F33 1 Tf
0.1 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Homogeneous Coordinates")Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("Transformation Matrices")Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 439.000 Tm
(Homogeneous Coordinates)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 417.000 Tm
(OpenGL commands usually deal with two- and three-dimensional vertices, but in fact all are treated)Tj
0 -1.5 TD
(internally as three-dimensional homogeneous vertices comprising four coordinates. Every column vector)Tj
0 -1.8 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.5 0 TD
(\))Tj
0.3 0.3 TD
(T)Tj
0.6 -0.3 TD
( represents a homogeneous vertex if at least one of its elements is nonzero. If the real number)Tj
/F15 1 Tf
-4.7 -1.8 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
( is nonzero, then \()Tj
/F15 1 Tf
7.2 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.4 0 TD
(\))Tj
0.4 0.3 TD
(T)Tj
0.6 -0.3 TD
( and \()Tj
/F15 1 Tf
2.3 0 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
(x,)Tj
/F15 1 Tf
0.7 0 TD
( a)Tj
/F11 1 Tf
0.8 0 TD
(y,)Tj
/F15 1 Tf
0.7 0 TD
( a)Tj
/F11 1 Tf
0.8 0 TD
(z,)Tj
/F15 1 Tf
0.7 0 TD
( a)Tj
/F11 1 Tf
0.7 0 TD
(w\))Tj
1.1 0.3 TD
(T)Tj
0.6 -0.3 TD
( represent the same homogeneous vertex. \(This is)Tj
-21 -1.8 TD
(just like fractions: )Tj
/F15 1 Tf
7.5 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(/)Tj
/F15 1 Tf
0.3 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( = \()Tj
/F15 1 Tf
1.4 0 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
(x\)/\()Tj
/F15 1 Tf
1.5 0 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
(y\).\) A three-dimensional euclidean space point \()Tj
/F15 1 Tf
19.3 0 TD
(x, y, z)Tj
/F11 1 Tf
2.3 0 TD
(\))Tj
0.3 0.3 TD
(T)Tj
0.6 -0.3 TD
( becomes the)Tj
-35 -1.8 TD
(homogeneous vertex with coordinates \()Tj
/F15 1 Tf
15.8 0 TD
(x, y, z)Tj
/F11 1 Tf
2.3 0 TD
(, 1.0\))Tj
2 0.3 TD
(T)Tj
0.6 -0.3 TD
(, and the two-dimensional euclidean point \()Tj
/F15 1 Tf
17.4 0 TD
(x, y)Tj
/F11 1 Tf
1.4 0 TD
(\))Tj
0.3 0.3 TD
(T)Tj
-39.8 -2.1 TD
(becomes \()Tj
/F15 1 Tf
4.1 0 TD
(x, y)Tj
/F11 1 Tf
1.4 0 TD
(, 0.0, 1.0\))Tj
3.8 0.3 TD
(T)Tj
0.6 -0.3 TD
(.)Tj
-9.9 -2.4 TD
(As long as )Tj
/F15 1 Tf
4.5 0 TD
(w)Tj
/F11 1 Tf
0.6 0 TD
( is nonzero, the homogeneous vertex \()Tj
/F15 1 Tf
15.3 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.4 0 TD
(\))Tj
0.4 0.3 TD
(T)Tj
0.6 -0.3 TD
( corresponds to the three-dimensional point)Tj
-24.8 -1.8 TD
(\()Tj
/F15 1 Tf
0.3 0 TD
(x/w, y/w, z/w)Tj
/F11 1 Tf
5.1 0 TD
(\))Tj
0.4 0.3 TD
(T)Tj
0.6 -0.3 TD
(. If )Tj
/F15 1 Tf
1.4 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( = 0.0, it corresponds to no euclidean point, but rather to some idealized "point at)Tj
-8.5 -1.5 TD
(infinity." To understand this point at infinity, consider the point \(1, 2, 0, 0\), and note that the sequence of)Tj
T*
(points \(1, 2, 0, 1\), \(1, 2, 0, 0.01\), and \(1, 2.0, 0.0, 0.0001\), corresponds to the euclidean points \(1, 2\),)Tj
T*
(\(100, 200\), and \(10000, 20000\). This sequence represents points rapidly moving toward infinity along the)Tj
T*
(line 2)Tj
/F15 1 Tf
2.3 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
( = )Tj
/F15 1 Tf
1.1 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(. Thus, you can think of \(1, 2, 0, 0\) as the point at infinity in the direction of that line.)Tj
/F27 1 Tf
-4.2 -2.1 TD
[(Note)22(: )]TJ
/F11 1 Tf
2.8 0 TD
(OpenGL might not handle homogeneous clip coordinates with )Tj
/F15 1 Tf
25.3 0 TD
(w)Tj
/F11 1 Tf
0.6 0 TD
( < 0 correctly. To be sure that)Tj
-28.7 -1.4 TD
(your code is portable to all OpenGL systems, use only nonnegative )Tj
/F15 1 Tf
27.1 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( values.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 146.000 Tm
(Transforming Vertices)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 125.000 Tm
(Vertex transformations \(such as rotations, translations, scaling, and shearing\) and projections \(such as)Tj
0 -1.7 TD
(perspective and orthographic\) can all be represented by applying an appropriate 4)Tj
/F33 1 Tf
32.6 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(4 matrix to the)Tj
-33.2 -1.6 TD
(coordinates representing the vertex. If )Tj
/F15 1 Tf
15.4 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( represents a homogeneous vertex and )Tj
/F15 1 Tf
15.5 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
( is a 4)Tj
/F33 1 Tf
2.4 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 transformation)Tj
-35.1 -1.6 TD
(matrix, then )Tj
/F15 1 Tf
5.1 0 TD
(Mv)Tj
/F11 1 Tf
1.3 0 TD
( is the image of )Tj
/F15 1 Tf
6.4 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( under the transformation by )Tj
/F15 1 Tf
11.7 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
(. \(In computer-graphics applications, the)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix F,  Homogeneous Coordinates and Transformation Matrices - 1)Tj
ET
endstream
endobj
1594 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1596 0 obj
<<
/Length 6435
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(transformations used are usually nonsingular)Tj
/F33 1 Tf
17.9 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(in other words, the matrix )Tj
/F15 1 Tf
10.7 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
( can be inverted. This isn't)Tj
-30.4 -1.6 TD
(required, but some problems arise with nonsingular transformations.\))Tj
0 -2.2 TD
(After transformation, all transformed vertices are clipped so that )Tj
/F15 1 Tf
26 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.5 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( are in the range [-)Tj
/F33 1 Tf
7.3 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(])Tj
-39.2 -1.6 TD
(\(assuming )Tj
/F15 1 Tf
4.4 0 TD
(w)Tj
/F11 1 Tf
0.6 0 TD
( > 0\). Note that this range corresponds in euclidean space to [-1.0, 1.0].)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 625.000 Tm
(Transforming Normals)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 604.000 Tm
(Normal vectors aren't transformed in the same way as vertices or position vectors. Mathematically, it's)Tj
0 -1.5 TD
(better to think of normal vectors not as vectors, but as planes perpendicular to those vectors. Then, the)Tj
T*
(transformation rules for normal vectors are described by the transformation rules for perpendicular)Tj
T*
(planes.)Tj
0 -2.1 TD
(A homogeneous plane is denoted by the row vector \()Tj
/F15 1 Tf
21.1 0 TD
(a, b, c, d)Tj
/F11 1 Tf
3.5 0 TD
(\), where at least one of )Tj
/F15 1 Tf
9.3 0 TD
(a, b, c)Tj
/F11 1 Tf
2.5 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
( is)Tj
-38.5 -1.5 TD
(nonzero. If )Tj
/F15 1 Tf
4.6 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( is a nonzero real number, then \()Tj
/F15 1 Tf
13 0 TD
(a, b, c, d)Tj
/F11 1 Tf
3.4 0 TD
(\) and \()Tj
/F15 1 Tf
2.6 0 TD
(qa, qb, qc, qd)Tj
/F11 1 Tf
5.5 0 TD
(\) represent the same plane. A)Tj
-29.6 -1.8 TD
(point \()Tj
/F15 1 Tf
2.6 0 TD
(x, y, z, w)Tj
/F11 1 Tf
3.5 0 TD
(\))Tj
0.3 0.3 TD
(T)Tj
0.6 -0.3 TD
( is on the plane \()Tj
/F15 1 Tf
6.7 0 TD
(a, b, c, d)Tj
/F11 1 Tf
3.4 0 TD
(\) if )Tj
/F15 1 Tf
1.5 0 TD
(ax)Tj
/F11 1 Tf
0.9 0 TD
(+)Tj
/F15 1 Tf
0.6 0 TD
(by)Tj
/F11 1 Tf
0.9 0 TD
(+)Tj
/F15 1 Tf
0.6 0 TD
(cz)Tj
/F11 1 Tf
0.8 0 TD
(+)Tj
/F15 1 Tf
0.6 0 TD
(dw)Tj
/F11 1 Tf
1.1 0 TD
( = 0. \(If )Tj
/F15 1 Tf
3.3 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( = 1, this is the standard)Tj
-28.1 -1.5 TD
(description of a euclidean plane.\) In order for \()Tj
/F15 1 Tf
18.7 0 TD
(a, b, c, d)Tj
/F11 1 Tf
3.5 0 TD
(\) to represent a euclidean plane, at least one of )Tj
/F15 1 Tf
18.8 0 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
(,)Tj
/F15 1 Tf
-41.5 -1.5 TD
(b)Tj
/F11 1 Tf
0.5 0 TD
(, or )Tj
/F15 1 Tf
1.6 0 TD
(c)Tj
/F11 1 Tf
0.4 0 TD
( must be nonzero. If they're all zero, then \(0, 0, 0, )Tj
/F15 1 Tf
20.2 0 TD
(d)Tj
/F11 1 Tf
0.5 0 TD
(\) represents the "plane at infinity," which)Tj
-23.2 -1.5 TD
(contains all the "points at infinity.")Tj
0 -2.1 TD
(If )Tj
/F15 1 Tf
0.9 0 TD
(p)Tj
/F11 1 Tf
0.5 0 TD
( is a homogeneous plane and )Tj
/F15 1 Tf
11.8 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( is a homogeneous vertex, then the statement ")Tj
/F15 1 Tf
18.6 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( lies on plane )Tj
/F15 1 Tf
5.5 0 TD
(p)Tj
/F11 1 Tf
0.5 0 TD
(" is)Tj
-38.7 -1.5 TD
(written mathematically as )Tj
/F15 1 Tf
10.6 0 TD
(pv)Tj
/F11 1 Tf
0.9 0 TD
( = 0, where )Tj
/F15 1 Tf
4.8 0 TD
(pv)Tj
/F11 1 Tf
0.9 0 TD
( is normal matrix multiplication. If )Tj
/F15 1 Tf
14.2 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
( is a nonsingular vertex)Tj
-32.2 -1.8 TD
(transformation \(that is, a 4)Tj
/F33 1 Tf
10.6 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4 matrix that has an inverse )Tj
/F15 1 Tf
11.3 0 TD
(M)Tj
/F11 1 Tf
0.8 0.3 TD
(-1)Tj
0.9 -0.3 TD
(\), then )Tj
/F15 1 Tf
2.8 0 TD
(pv)Tj
/F11 1 Tf
0.9 0 TD
( = 0 is equivalent to )Tj
/F15 1 Tf
8.2 0 TD
(pM)Tj
/F11 1 Tf
1.3 0.3 TD
(-1)Tj
/F15 1 Tf
0.9 -0.3 TD
(Mv)Tj
/F11 1 Tf
1.2 0 TD
( = 0,)Tj
-39.4 -1.9 TD
(so )Tj
/F15 1 Tf
1.1 0 TD
(Mv)Tj
/F11 1 Tf
1.3 0 TD
( lies on the plane )Tj
/F15 1 Tf
7 0 TD
(pM)Tj
/F11 1 Tf
1.4 0.3 TD
(-1)Tj
0.8 -0.3 TD
(. Thus, )Tj
/F15 1 Tf
3 0 TD
(pM)Tj
/F11 1 Tf
1.3 0.3 TD
(-1)Tj
0.9 -0.3 TD
( is the image of the plane under the vertex transformation )Tj
/F15 1 Tf
23.2 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
(.)Tj
-40.8 -2.1 TD
(If you like to think of normal vectors as vectors instead of as the planes perpendicular to them, let )Tj
/F15 1 Tf
39.3 0 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(n)Tj
/F11 1 Tf
-41.7 -1.8 TD
(be vectors such that )Tj
/F15 1 Tf
8.2 0 TD
(v)Tj
/F11 1 Tf
0.4 0 TD
( is perpendicular to )Tj
/F15 1 Tf
8 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(. Then, )Tj
/F15 1 Tf
3 0 TD
(n)Tj
/F11 1 Tf
0.5 0.3 TD
(T)Tj
/F15 1 Tf
0.6 -0.3 TD
(v)Tj
/F11 1 Tf
0.5 0 TD
( = 0. Thus, for an arbitrary nonsingular)Tj
-21.7 -1.8 TD
(transformation )Tj
/F15 1 Tf
6.1 0 TD
(M)Tj
/F11 1 Tf
0.9 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(n)Tj
/F11 1 Tf
0.5 0.3 TD
(T)Tj
/F15 1 Tf
0.6 -0.3 TD
(M)Tj
/F11 1 Tf
0.8 0.3 TD
(-1)Tj
/F15 1 Tf
0.8 -0.3 TD
(Mv)Tj
/F11 1 Tf
1.3 0 TD
( = 0, which means that nTM-1 is the transpose of the transformed normal)Tj
-11.5 -1.8 TD
(vector. Thus, the transformed normal vector is)Tj
/F15 1 Tf
18.6 0 TD
( \(M)Tj
/F11 1 Tf
1.4 0.3 TD
(-1)Tj
/F15 1 Tf
0.8 -0.3 TD
(\))Tj
/F11 1 Tf
0.3 0.3 TD
(T)Tj
/F15 1 Tf
0.6 -0.3 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(. In other words, normal vectors are transformed)Tj
-22.2 -1.5 TD
(by the inverse transpose of the transformation that transforms points. Whew!)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 263.000 Tm
(Transformation Matrices)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 241.000 Tm
(Although any nonsingular matrix )Tj
/F15 1 Tf
13.6 0 TD
(M)Tj
/F11 1 Tf
0.8 0 TD
( represents a valid projective transformation, a few special matrices)Tj
-14.4 -1.5 TD
(are particularly useful. These matrices are listed in the following subsections.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 198.000 Tm
(Translation)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 176.000 Tm
(The call )Tj
/F15 1 Tf
3.5 0 TD
[(glTranslate*\()46(x, y, z)-23(\))]TJ
/F11 1 Tf
8.1 0 TD
( generates )Tj
/F13 1 Tf
4.2 0 TD
(T)Tj
/F11 1 Tf
0.7 0 TD
(, where)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix F,  Homogeneous Coordinates and Transformation Matrices - 2)Tj
ET
endstream
endobj
1597 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1598 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im130
/Width 263
/Height 94
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.129)
>>
stream
endstream
endobj
1599 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im131
/Width 267
/Height 125
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.130)
>>
stream
endstream
endobj
1600 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im132
/Width 403
/Height 78
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.131)
>>
stream
endstream
endobj
1601 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im133
/Width 520
/Height 94
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.132)
>>
stream
endstream
endobj
1603 0 obj
<<
/Length 2209
>>
stream
/GS1 gs
q
263 0 0 94 124 626 cm
/Im130 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 599.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(Scaling)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 578.000 Tm
0.000 Tw
(The call )Tj
/F15 1 Tf
3.5 0 TD
[(glScale*\()-23(x, y, z)-23(\))]TJ
/F11 1 Tf
6.4 0 TD
( generates S, where)Tj
ET
Q
q
267 0 0 125 124 438.73 cm
/Im131 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 420.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Notice that S-1 is defined only if )Tj
/F15 1 Tf
13.4 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( are all nonzero.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 391.000 Tm
(Rotation)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 370.000 Tm
(The call )Tj
/F15 1 Tf
3.5 0 TD
[(glRotate*\()22(a, x, y, z)-23(\))]TJ
/F11 1 Tf
7.8 0 TD
( generates R as follows:)Tj
-11.3 -2.1 TD
(Let v = \(x, y, z\)T, and u = v/||v|| = \(x', y', z'\)T.)Tj
T*
(Also let)Tj
ET
Q
q
403 0 0 78 124 235.46 cm
/Im132 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 217.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(Then)Tj
ET
Q
q
423 0 0 76 124 126.46 cm
/Im133 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 107.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
(The )Tj
/F13 1 Tf
1.8 0 TD
0.000 Tw
(R)Tj
/F11 1 Tf
0.7 0 TD
( matrix is always defined. If )Tj
/F15 1 Tf
11.5 0 TD
(x=y=z)Tj
/F11 1 Tf
2.6 0 TD
(=0, then )Tj
/F13 1 Tf
3.6 0 TD
(R)Tj
/F11 1 Tf
0.7 0 TD
( is the identity matrix. You can obtain the inverse of)Tj
/F13 1 Tf
-20.9 -1.6 TD
(R)Tj
/F11 1 Tf
0.7 0 TD
(, )Tj
/F13 1 Tf
0.5 0 TD
-0.022 Tc
[(R-)-22(1)]TJ
/F11 1 Tf
1.6 0 TD
0.000 Tc
(, by substituting -)Tj
/F33 1 Tf
7 0 TD
(a)Tj
/F11 1 Tf
0.6 0 TD
( for )Tj
/F15 1 Tf
1.7 0 TD
(a)Tj
/F11 1 Tf
0.5 0 TD
(, or by transposition.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix F,  Homogeneous Coordinates and Transformation Matrices - 3)Tj
ET
endstream
endobj
1604 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im130 1598 0 R
/Im131 1599 0 R
/Im132 1600 0 R
/Im133 1601 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1605 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im134
/Width 302
/Height 291
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.133)
>>
stream
endstream
endobj
1606 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im135
/Width 446
/Height 157
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.134)
>>
stream
endstream
endobj
1608 0 obj
<<
/Length 2019
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(The )Tj
/F15 1 Tf
1.8 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
0.000 Tw
( command generates a matrix for rotation about an arbitrary axis. Often, you're rotating)Tj
-6.4 -1.5 TD
(about one of the coordinate axes; the corresponding matrices are as follows:)Tj
ET
Q
/GS1 gs
q
302 0 0 291 124 390.84 cm
/Im134 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 372.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(As before, the inverses are obtained by transposition.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 343.000 Tm
(Perspective Projection)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 321.000 Tm
(The call )Tj
/F15 1 Tf
3.5 0 TD
[(glFrustum\(l, r, b, t, n, f)24(\))]TJ
/F11 1 Tf
9.6 0 TD
( generates )Tj
/F13 1 Tf
4.2 0 TD
(R)Tj
/F11 1 Tf
0.8 0 TD
(, where)Tj
ET
Q
q
423 0 0 149 124 158.2 cm
/Im135 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 138.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(R)Tj
/F11 1 Tf
0.7 0 TD
( is defined as long as )Tj
/F15 1 Tf
8.6 0 TD
(l)Tj
/F33 1 Tf
0.3 0 TD
(\271)Tj
/F15 1 Tf
0.6 0 TD
(r)Tj
/F11 1 Tf
0.3 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(t)Tj
/F33 1 Tf
0.3 0 TD
(\271)Tj
/F15 1 Tf
0.6 0 TD
(b)Tj
/F11 1 Tf
0.5 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(n)Tj
/F33 1 Tf
0.5 0 TD
(\271)Tj
/F15 1 Tf
0.5 0 TD
(f)Tj
/F11 1 Tf
0.3 0 TD
(.)Tj
/F27 1 Tf
12.000 0.000 0.000 12.000 124.000 109.000 Tm
(Orthographic Projection)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 87.000 Tm
(The call )Tj
/F15 1 Tf
3.5 0 TD
[(glOrtho\(l, r, b, t, n, f)24( \))]TJ
/F11 1 Tf
8.8 0 TD
( generates )Tj
/F13 1 Tf
4.3 0 TD
(R)Tj
/F11 1 Tf
0.7 0 TD
(, where)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix F,  Homogeneous Coordinates and Transformation Matrices - 4)Tj
ET
endstream
endobj
1609 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im134 1605 0 R
/Im135 1606 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1611 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im136
/Width 446
/Height 157
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.135)
>>
stream
endstream
endobj
1613 0 obj
<<
/Length 814
>>
stream
/GS1 gs
q
423 0 0 149 124 571 cm
/Im136 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F13 1 Tf
10.000 0.000 0.000 10.000 124.000 551.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(R)Tj
/F11 1 Tf
0.7 0 TD
( is defined as long as )Tj
/F15 1 Tf
8.6 0 TD
(l)Tj
/F33 1 Tf
0.3 0 TD
(\271)Tj
/F15 1 Tf
0.6 0 TD
(r)Tj
/F11 1 Tf
0.3 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(t)Tj
/F33 1 Tf
0.3 0 TD
(\271)Tj
/F15 1 Tf
0.6 0 TD
(b)Tj
/F11 1 Tf
0.5 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(n)Tj
/F33 1 Tf
0.5 0 TD
(\271)Tj
/F15 1 Tf
0.5 0 TD
(f)Tj
/F11 1 Tf
0.3 0 TD
(.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
1 i 
124.000 523.740 m
547.000 523.740 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix G,  Programming Tips  - 5)Tj
ET
endstream
endobj
1614 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F33 12 0 R
>>
/XObject <<
/Im136 1611 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1616 0 obj
<<
/Length 4467
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix G)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Programming Tips)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(This appendix lists some tips and guidelines that you might find useful. Keep in mind that these tips are)Tj
0 -1.5 TD
(based on the intentions of the designers of the OpenGL, not on any experience with actual applications)Tj
T*
(and implementations! This appendix has the following major sections:)Tj
/F33 1 Tf
0.1 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("OpenGL Correctness Tips")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("OpenGL Performance Tips")Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
("GLX Tips")Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 531.000 Tm
(OpenGL Correctness Tips)Tj
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 508.000 Tm
(  )Tj
/F11 1 Tf
1.8 0 TD
(Perform error checking often. Call )Tj
/F15 1 Tf
14.1 0 TD
(glGetError\(\))Tj
/F11 1 Tf
5.1 0 TD
( at least once each time the scene is rendered to)Tj
-19.2 -1.5 TD
(make certain error conditions are noticed.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Do not count on the error behavior of an OpenGL implementation)Tj
/F33 1 Tf
26.4 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(it might change in a future)Tj
-27.4 -1.5 TD
(release of OpenGL. For example, OpenGL 1.1 ignores matrix operations invoked between)Tj
/F15 1 Tf
36.2 0 TD
( glBegin\(\))Tj
/F11 1 Tf
-36.2 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(glEnd\(\))Tj
/F11 1 Tf
3 0 TD
( commands, but a future version might not. Put another way, OpenGL error semantics)Tj
-4.7 -1.5 TD
(may change between upward-compatible revisions.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If you need to collapse all geometry to a single plane, use the projection matrix. If the modelview)Tj
0 -1.6 TD
(matrix is used, OpenGL features that operate in eye coordinates \(such as lighting and)Tj
0 -1.5 TD
(application-defined clipping planes\) might fail.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Do not make extensive changes to a single matrix. For example, do not animate a rotation by)Tj
0 -1.6 TD
(continually calling )Tj
/F15 1 Tf
7.7 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
( with an incremental angle. Rather, use )Tj
/F15 1 Tf
15.8 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( to initialize)Tj
-34.7 -1.5 TD
(the given matrix for each frame, then call )Tj
/F15 1 Tf
16.8 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.6 0 TD
( with the desired complete angle for that frame.)Tj
/F33 1 Tf
-23.2 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Count on multiple passes through a rendering database to generate the same pixel fragments only if)Tj
0 -1.6 TD
(this behavior is guaranteed by the invariance rules established for a compliant OpenGL)Tj
0 -1.5 TD
[(implementation. \(See )6(Appendix H)17( for details on the invariance rules.\) Otherwise, a different set of)]TJ
T*
(fragments might be generated.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Do not expect errors to be reported while a display list is being defined. The commands within a)Tj
0 -1.6 TD
(display list generate errors only when the list is executed.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Place the near frustum plane as far from the viewpoint as possible to optimize the operation of the)Tj
0 -1.6 TD
(depth buffer.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Call )Tj
/F15 1 Tf
1.9 0 TD
(glFlush\(\))Tj
/F11 1 Tf
3.7 0 TD
( to force all previous OpenGL commands to be executed. Do not count on )Tj
/F15 1 Tf
29.9 0 TD
(glGet*\(\))Tj
/F11 1 Tf
3.4 0 TD
( or)Tj
/F15 1 Tf
-38.9 -1.6 TD
(glIs*\(\))Tj
/F11 1 Tf
2.7 0 TD
( to flush the rendering stream. Query commands flush as much of the stream as is required to)Tj
-2.7 -1.5 TD
(return valid data but don't guarantee completing all pending rendering commands.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Turn dithering off when rendering predithered images \(for example, when )Tj
/F15 1 Tf
29.9 0 TD
(glCopyPixels\(\))Tj
/F11 1 Tf
6 0 TD
( is called\).)Tj
/F33 1 Tf
-37.7 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Make use of the full range of the accumulation buffer. For example, if accumulating four images,)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix G,  Programming Tips  - 1)Tj
ET
endstream
endobj
1617 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1619 0 obj
<<
/Length 4628
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 143.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(scale each by one-quarter as it's accumulated.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If exact two-dimensional rasterization is desired, you must carefully specify both the orthographic)Tj
0 -1.6 TD
(projection and the vertices of primitives that are to be rasterized. The orthographic projection should)Tj
0 -1.5 TD
(be specified with integer coordinates, as shown in the following example:)Tj
/F7 1 Tf
0 -2.1 TD
(gluOrtho2D\(0, width, 0, height\);)Tj
/F11 1 Tf
T*
(where )Tj
/F15 1 Tf
2.7 0 TD
(width)Tj
/F11 1 Tf
2.2 0 TD
( and )Tj
/F15 1 Tf
2 0 TD
(height)Tj
/F11 1 Tf
2.5 0 TD
( are the dimensions of the viewport. Given this projection matrix, polygon)Tj
-9.4 -1.5 TD
(vertices and pixel image positions should be placed at integer coordinates to rasterize predictably.)Tj
T*
(For example, )Tj
/F15 1 Tf
5.5 0 TD
(glRecti\()Tj
/F11 1 Tf
3.2 0 TD
(0, 0, 1, 1)Tj
/F15 1 Tf
3.5 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
( reliably fills the lower left pixel of the viewport, and)Tj
/F15 1 Tf
-12.5 -1.5 TD
(glRasterPos2i\()Tj
/F11 1 Tf
6 0 TD
(0, 0)Tj
/F15 1 Tf
1.5 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
( reliably positions an unzoomed image at the lower left of the viewport. Point)Tj
-7.8 -1.5 TD
(vertices, line vertices, and bitmap positions should be placed at half-integer locations, however. For)Tj
T*
(example, a line drawn from \()Tj
/F15 1 Tf
11.6 0 TD
(x1)Tj
/F11 1 Tf
1 0 TD
(, 0.5\) to \()Tj
/F15 1 Tf
3.6 0 TD
(x2)Tj
/F11 1 Tf
1 0 TD
(, 0.5\) will be reliably rendered along the bottom row of)Tj
-17.2 -1.5 TD
(pixels into the viewport, and a point drawn at \(0.5, 0.5\) will reliably fill the same pixel as )Tj
/F15 1 Tf
35.9 0 TD
(glRecti\()Tj
/F11 1 Tf
3.2 0 TD
(0,)Tj
-39.1 -1.5 TD
(0, 1, 1)Tj
/F15 1 Tf
2.5 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
(.)Tj
-2.8 -2.1 TD
(An optimum compromise that allows all primitives to be specified at integer positions, while still)Tj
0 -1.5 TD
(ensuring predictable rasterization, is to translate )Tj
/F15 1 Tf
19.4 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
( and )Tj
/F15 1 Tf
1.9 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
( by 0.375, as shown in the following code)Tj
-22.2 -1.5 TD
(fragment. Such a translation keeps polygon and pixel image edges safely away from the centers of)Tj
T*
(pixels, while moving line vertices close enough to the pixel centers.)Tj
/F7 1 Tf
0 -2.1 TD
(glViewport\(0, 0, width, height\);)Tj
0 -1.5 TD
(glMatrixMode\(GL_PROJECTION\);)Tj
T*
(glLoadIdentity\(\);)Tj
T*
(gluOrtho2D\(0, width, 0, height\);)Tj
T*
(glMatrixMode\(GL_MODELVIEW\);)Tj
T*
(glLoadIdentity\(\);)Tj
T*
(glTranslatef\(0.375, 0.375, 0.0\);)Tj
T*
(/* render all primitives at integer positions */)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Avoid using negative )Tj
/F15 1 Tf
8.8 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
( vertex coordinates and negative )Tj
/F15 1 Tf
13.2 0 TD
(q)Tj
/F11 1 Tf
0.5 0 TD
( texture coordinates. OpenGL might not)Tj
-23.2 -1.6 TD
(clip such coordinates correctly and might make interpolation errors when shading primitives defined)Tj
0 -1.5 TD
(by such coordinates.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Do not assume the precision of operations, based upon the data type of parameters to OpenGL)Tj
0 -1.6 TD
(commands. For example, if you are using )Tj
/F15 1 Tf
16.9 0 TD
(glRotated\(\))Tj
/F11 1 Tf
4.5 0 TD
(, you should not assume that geometric)Tj
-21.4 -1.5 TD
(processing pipeline operates with double-precision floating point. It is possible that the parameters)Tj
T*
(to )Tj
/F15 1 Tf
1 0 TD
(glRotated\(\))Tj
/F11 1 Tf
4.6 0 TD
( are converted to a different data type before processing.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 157.000 Tm
(OpenGL Performance Tips)Tj
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 134.000 Tm
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use )Tj
/F15 1 Tf
1.8 0 TD
(glColorMaterial\(\))Tj
/F11 1 Tf
7.3 0 TD
( when only a single material property is being varied rapidly \(at each vertex,)Tj
-9.1 -1.5 TD
(for example\). Use )Tj
/F15 1 Tf
7.4 0 TD
(glMaterial\(\))Tj
/F11 1 Tf
5 0 TD
( for infrequent changes, or when more than a single material property)Tj
-12.4 -1.5 TD
(is being varied rapidly.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use )Tj
/F15 1 Tf
1.8 0 TD
(glLoadIdentity\(\))Tj
/F11 1 Tf
6.6 0 TD
( to initialize a matrix, rather than loading your own copy of the identity matrix.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix G,  Programming Tips  - 2)Tj
ET
endstream
endobj
1620 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F7 26 0 R
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1622 0 obj
<<
/Length 5686
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use specific matrix calls such as )Tj
/F15 1 Tf
13.3 0 TD
(glRotate*\(\))Tj
/F11 1 Tf
4.5 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(glTranslate*\(\))Tj
/F11 1 Tf
5.8 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(glScale*\(\))Tj
/F11 1 Tf
4.1 0 TD
( rather than composing)Tj
-30.4 -1.6 TD
(your own rotation, translation, or scale matrices and calling )Tj
/F15 1 Tf
24 0 TD
(glMultMatrix\(\))Tj
/F11 1 Tf
6.1 0 TD
(.)Tj
/F33 1 Tf
-31.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use query functions when your application requires just a few state values for its own computations.)Tj
0 -1.6 TD
(If your application requires several state values from the same attribute group, use )Tj
/F15 1 Tf
33.1 0 TD
(glPushAttrib\(\))Tj
/F11 1 Tf
-33.1 -1.5 TD
(and )Tj
/F15 1 Tf
1.7 0 TD
(glPopAttrib\(\))Tj
/F11 1 Tf
5.4 0 TD
( to save and restore them.)Tj
/F33 1 Tf
-8.9 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use display lists to encapsulate potentially expensive state changes.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use display lists to encapsulate the rendering calls of rigid objects that will be drawn repeatedly.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use texture objects to encapsulate texture data. Place all the )Tj
/F15 1 Tf
24.2 0 TD
(glTexImage*\(\))Tj
/F11 1 Tf
5.9 0 TD
( calls \(including)Tj
-30.1 -1.6 TD
(mipmaps\) required to completely specify a texture and the associated )Tj
/F15 1 Tf
27.9 0 TD
(glTexParameter*\(\))Tj
/F11 1 Tf
7.7 0 TD
( calls)Tj
-35.6 -1.5 TD
(\(which set texture properties\) into a texture object. Bind this texture object to select the texture.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If the situation allows it, use )Tj
/F15 1 Tf
11.6 0 TD
(gl*TexSubImage\(\))Tj
/F11 1 Tf
7.4 0 TD
( to replace all or part of an existing texture image)Tj
-19 -1.6 TD
(rather than the more costly operations of deleting and creating an entire new image.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(If your OpenGL implementation supports a high-performance working set of resident textures, try to)Tj
0 -1.5 TD
(make all your textures resident; that is, make them fit into the high-performance texture memory. If)Tj
T*
(necessary, reduce the size or internal format resolution of your textures until they all fit into)Tj
T*
(memory. If such a reduction creates intolerably fuzzy textured objects, you may give some textures)Tj
T*
(lower priority, which will, when push comes to shove, leave them out of the working set.)Tj
/F33 1 Tf
-1.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use evaluators even for simple surface tessellations to minimize network bandwidth in client-server)Tj
0 -1.5 TD
(environments.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Provide unit-length normals if it's possible to do so, and avoid the overhead of GL_NORMALIZE.)Tj
0 -1.6 TD
(Avoid using )Tj
/F15 1 Tf
5.2 0 TD
(glScale*\(\))Tj
/F11 1 Tf
4.1 0 TD
( when doing lighting because it almost always requires that)Tj
-9.3 -1.5 TD
(GL_NORMALIZE be enabled.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Set )Tj
/F15 1 Tf
1.5 0 TD
(glShadeModel\(\))Tj
/F11 1 Tf
6.5 0 TD
( to GL_FLAT if smooth shading isn't required.)Tj
/F33 1 Tf
-9.8 -2.3 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use a single )Tj
/F15 1 Tf
5.1 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.8 0 TD
( call per frame if possible. Do not use )Tj
/F15 1 Tf
15.2 0 TD
(glClear\(\))Tj
/F11 1 Tf
3.8 0 TD
( to clear small subregions of)Tj
-27.9 -1.6 TD
(the buffers; use it only for complete or near-complete clears.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use a single call to )Tj
/F15 1 Tf
7.9 0 TD
(glBegin\()Tj
/F11 1 Tf
3.4 0 TD
(GL_TRIANGLES)Tj
/F15 1 Tf
7.4 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
( to draw multiple independent triangles rather than)Tj
-19 -1.6 TD
(calling )Tj
/F15 1 Tf
3 0 TD
(glBegin\()Tj
/F11 1 Tf
3.4 0 TD
(GL_TRIANGLES)Tj
/F15 1 Tf
7.4 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
( multiple times, or calling )Tj
/F15 1 Tf
10.6 0 TD
(glBegin\()Tj
/F11 1 Tf
3.4 0 TD
(GL_POLYGON)Tj
/F15 1 Tf
6.6 0 TD
(\))Tj
/F11 1 Tf
0.4 0 TD
(. Even if)Tj
-35.1 -1.5 TD
(only a single triangle is to be drawn, use GL_TRIANGLES rather than GL_POLYGON. Use a)Tj
T*
(single call to )Tj
/F15 1 Tf
5.4 0 TD
(glBegin\()Tj
/F11 1 Tf
3.4 0 TD
(GL_QUADS)Tj
/F15 1 Tf
5.3 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
( in the same manner rather than calling)Tj
/F15 1 Tf
-14.4 -1.5 TD
(glBegin\()Tj
/F11 1 Tf
3.4 0 TD
(GL_POLYGON)Tj
/F15 1 Tf
6.7 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
( repeatedly. Likewise, use a single call to )Tj
/F15 1 Tf
16.7 0 TD
(glBegin\()Tj
/F11 1 Tf
3.5 0 TD
(GL_LINES)Tj
/F15 1 Tf
4.6 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
( to draw)Tj
-35.5 -1.5 TD
(multiple independent line segments rather than calling )Tj
/F15 1 Tf
22 0 TD
(glBegin\()Tj
/F11 1 Tf
3.4 0 TD
(GL_LINES)Tj
/F15 1 Tf
4.7 0 TD
(\))Tj
/F11 1 Tf
0.3 0 TD
( multiple times.)Tj
/F33 1 Tf
-32.2 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Some OpenGL implementations benefit from storing vertex data in vertex arrays. Use of vertex)Tj
0 -1.6 TD
(arrays reduces function call overhead. Some implementations can improve performance by batch)Tj
0 -1.5 TD
(processing or reusing processed vertices.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(In general, use the vector forms of commands to pass precomputed data, and use the scalar forms of)Tj
0 -1.6 TD
(commands to pass values that are computed near call time.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix G,  Programming Tips  - 3)Tj
ET
endstream
endobj
1623 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1625 0 obj
<<
/Length 2284
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 704.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(  )Tj
/F11 1 Tf
1.8 0 TD
(Avoid making redundant mode changes, such as setting the color to the same value between each)Tj
0 -1.5 TD
(vertex of a flat-shaded polygon.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Be sure to disable expensive rasterization and per-fragment operations when drawing or copying)Tj
0 -1.6 TD
(images. OpenGL will even apply textures to pixel images if asked to!)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Unless absolutely needed, avoid having different front and back polygon modes.)Tj
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 588.000 Tm
(GLX Tips)Tj
/F33 1 Tf
10.000 0.000 0.000 10.000 125.000 565.000 Tm
(  )Tj
/F11 1 Tf
1.8 0 TD
(Use )Tj
/F15 1 Tf
1.8 0 TD
(glXWaitGL\(\))Tj
/F11 1 Tf
5.2 0 TD
( rather than )Tj
/F15 1 Tf
4.8 0 TD
(glFinish\(\))Tj
/F11 1 Tf
4 0 TD
( to force X rendering commands to follow GL rendering)Tj
-15.8 -1.6 TD
(commands.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Likewise, use )Tj
/F15 1 Tf
5.7 0 TD
(glXWaitX\(\))Tj
/F11 1 Tf
4.6 0 TD
( rather than )Tj
/F15 1 Tf
4.8 0 TD
(XSync\(\))Tj
/F11 1 Tf
3.2 0 TD
( to force GL rendering commands to follow X)Tj
-18.3 -1.6 TD
(rendering commands.)Tj
/F33 1 Tf
-1.8 -2.2 TD
(  )Tj
/F11 1 Tf
1.8 0 TD
(Be careful when using )Tj
/F15 1 Tf
9.2 0 TD
(glXChooseVisual\(\),)Tj
/F11 1 Tf
7.9 0 TD
( because boolean selections are matched exactly. Since)Tj
-17.1 -1.5 TD
(some implementations won't export visuals with all combinations of boolean capabilities, you)Tj
T*
(should call )Tj
/F15 1 Tf
4.6 0 TD
(glXChooseVisual\(\))Tj
/F11 1 Tf
7.6 0 TD
( several times with different boolean values before you give up. For)Tj
-12.2 -1.5 TD
(example, if no single-buffered visual with the required characteristics is available, check for a)Tj
T*
(double-buffered visual with the same capabilities. It might be available, and it's easy to use.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 401.950 m
547.000 401.950 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix H,  OpenGL Invariance - 4)Tj
ET
endstream
endobj
1626 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1628 0 obj
<<
/Length 4692
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix H)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(OpenGL Invariance)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(OpenGL is not a pixel-exact specification. It therefore doesn't guarantee an exact match between images)Tj
0 -1.5 TD
(produced by different OpenGL implementations. However, OpenGL does specify exact matches, in some)Tj
T*
(cases, for images produced by the same implementation. This appendix describes the invariance rules)Tj
T*
(that define these cases.)Tj
0 -2.1 TD
(The obvious and most fundamental case is repeatability. A conforming OpenGL implementation)Tj
0 -1.5 TD
(generates the same results each time a specific sequence of commands is issued from the same initial)Tj
T*
(conditions. Although such repeatability is useful for testing and verification, it's often not useful to)Tj
T*
(application programmers, because it's difficult to arrange for equivalent initial conditions. For example,)Tj
T*
(rendering a scene twice, the second time after swapping the front and back buffers, doesn't meet this)Tj
T*
(requirement. So repeatability can't be used to guarantee a stable, double-buffered image.)Tj
0 -2.1 TD
(A simple and useful algorithm that counts on invariant execution is erasing a line by redrawing it in the)Tj
0 -1.5 TD
(background color. This algorithm works only if rasterizing the line results in the same fragment )Tj
/F15 1 Tf
38.5 0 TD
(x,y)Tj
/F11 1 Tf
1.1 0 TD
( pairs)Tj
-39.6 -1.5 TD
(being generated in both the foreground and background color cases. OpenGL requires that the)Tj
T*
(coordinates of the fragments generated by rasterization be invariant with respect to framebuffer contents,)Tj
T*
(which color buffers are enabled for drawing, the values of matrices other than those on the top of the)Tj
T*
(matrix stacks, the scissor parameters, all writemasks, all clear values, the current color, index, normal,)Tj
T*
(texture coordinates, and edge-flag values, the current raster color, raster index, and raster texture)Tj
T*
(coordinates, and the material properties. It is further required that exactly the same fragments be)Tj
T*
(generated, including the fragment color values, when framebuffer contents, color buffer enables, matrices)Tj
T*
(other than those on the top of the matrix stacks, the scissor parameters, writemasks, or clear values differ.)Tj
0 -2.1 TD
(OpenGL further suggests, but doesn't require, that fragment generation be invariant with respect to the)Tj
0 -1.5 TD
(matrix mode, the depths of the matrix stacks, the alpha test parameters \(other than alpha test enable\), the)Tj
T*
(stencil parameters \(other than stencil enable\), the depth test parameters \(other than depth test enable\), the)Tj
T*
(blending parameters \(other than enable\), the logical operation \(but not logical operation enable\), and the)Tj
T*
(pixel-storage and pixel-transfer parameters. Because invariance with respect to several enables isn't)Tj
T*
(recommended, you should use other parameters to disable functions when invariant rendering is required.)Tj
T*
(For example, to render invariantly with blending enabled and disabled, set the blending parameters to)Tj
T*
(GL_ONE and GL_ZERO to disable blending rather than calling )Tj
/F15 1 Tf
25.9 0 TD
(glDisable)Tj
/F11 1 Tf
3.9 0 TD
(\(GL_BLEND\). Alpha testing,)Tj
-29.8 -1.5 TD
(stencil testing, depth testing, and the logical operation all can be disabled in this manner.)Tj
0 -2.1 TD
(Finally, OpenGL requires that per-fragment arithmetic, such as blending and the depth test, is invariant to)Tj
0 -1.5 TD
(all OpenGL state except the state that directly defines it. For example, the only OpenGL parameters that)Tj
T*
(affect how the arithmetic of blending is performed are the source and destination blend parameters and)Tj
T*
(the blend enable parameter. Blending is invariant to all other state changes. This invariance holds for the)Tj
T*
(scissor test, the alpha test, the stencil test, the depth test, blending, dithering, logical operations, and)Tj
T*
(buffer writemasking.)Tj
0 -2.1 TD
(As a result of all these invariance requirements, OpenGL can guarantee that images rendered into)Tj
0 -1.5 TD
(different color buffers, either simultaneously or separately using the same command sequence, are pixel)Tj
T*
(identical. This holds for all the color buffers in the framebuffer or all the color buffers in an off-screen)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix H,  OpenGL Invariance - 1)Tj
ET
endstream
endobj
1629 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1631 0 obj
<<
/Length 496
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(buffer, but it isn't guaranteed between the framebuffer and off-screen buffers.)Tj
ET
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
/GS1 gs
1 i 
124.000 690.350 m
547.000 690.350 l
S
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 2)Tj
ET
endstream
endobj
1632 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1633 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im137
/Width 1010
/Height 762
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.136)
>>
stream
endstream
endobj
1635 0 obj
<<
/Length 1030
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 2.126 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Appendix I)Tj
14.000 0.000 0.000 14.000 124.000 695.000 Tm
(Color Plates)Tj
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 670.000 Tm
(This appendix contains the color plates that appear in the printed version of this guide.)Tj
/F27 1 Tf
0 -3 TD
(Plate 1)Tj
/F11 1 Tf
0 -2.1 TD
(The scene from the cover of this book, with the objects rendered as wireframe models. See Chapter 2.)Tj
ET
Q
/GS1 gs
q
423 0 0 319 124 285.45 cm
/Im137 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 258.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 2)Tj
/F11 1 Tf
0 -2.1 TD
(The same scene using fog for depth-cueing \(lines further from the eye are dimmer\). See Chapter 6.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 1)Tj
ET
endstream
endobj
1636 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im137 1633 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1637 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im138
/Width 1114
/Height 921
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.137)
>>
stream
endstream
endobj
1639 0 obj
<<
/Length 552
>>
stream
q
1 i 
124.000 720.000 423.000 -349.710 re
W n
/GS1 gs
q
423 0 0 350 124 370 cm
/Im138 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 343.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 3)Tj
/F11 1 Tf
0 -2.2 TD
(The same scene with antialiased lines that smooth the jagged edges.)Tj
0 -1.1 TD
(See Chapter 6.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 2)Tj
ET
endstream
endobj
1640 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im138 1637 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1641 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im139
/Width 1009
/Height 760
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.138)
>>
stream
endstream
endobj
1643 0 obj
<<
/Length 556
>>
stream
q
1 i 
124.000 720.000 422.990 -318.610 re
W n
/GS1 gs
q
423 0 0 319 124 401 cm
/Im139 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 374.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 4)Tj
/F11 1 Tf
0 -2.1 TD
(The scene drawn with flat-shaded polygons \(a single color for each filled polygon\). See Chapter 4.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 3)Tj
ET
endstream
endobj
1644 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im139 1641 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1646 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im140
/Width 1009
/Height 760
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.139)
>>
stream
endstream
endobj
1648 0 obj
<<
/Length 552
>>
stream
q
1 i 
124.000 720.000 422.990 -318.610 re
W n
/GS1 gs
q
423 0 0 319 124 401 cm
/Im140 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 374.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 5)Tj
/F11 1 Tf
0 -2.1 TD
(The scene rendered with lighting and smooth-shaded polygons.)Tj
0 -1.2 TD
(See Chapters 4 and 5.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 4)Tj
ET
endstream
endobj
1649 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im140 1646 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1650 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im141
/Width 1196
/Height 922
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.140)
>>
stream
endstream
endobj
1652 0 obj
<<
/Length 623
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 396.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(.)Tj
ET
Q
/GS1 gs
q
420 0 0 324 126.5 396 cm
/Im141 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 366.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 6)Tj
/F11 1 Tf
0 -2.1 TD
(The scene with texturemaps and shadows added. See Chapters 9 and 14.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 5)Tj
ET
endstream
endobj
1653 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im141 1650 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1654 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im142
/Width 1266
/Height 956
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.141)
>>
stream
endstream
endobj
1656 0 obj
<<
/Length 576
>>
stream
/GS1 gs
q
423 0 0 319 124 401 cm
/Im142 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 373.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 7)Tj
/F11 1 Tf
0 -2.1 TD
(The scene drawn with one of the objects motion-blurred. The accumulation buffer is used to compose the)Tj
0 -1.5 TD
(sequence of images needed to blur the moving object. See Chapter 10.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 6)Tj
ET
endstream
endobj
1657 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im142 1654 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1658 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im143
/Width 1266
/Height 954
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.142)
>>
stream
endstream
endobj
1660 0 obj
<<
/Length 579
>>
stream
q
1 i 
124.000 720.000 422.990 -318.750 re
W n
/GS1 gs
q
423 0 0 319 124 401 cm
/Im143 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 374.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 8)Tj
/F11 1 Tf
0 -2.3 TD
(A close-up shot)Tj
/F33 1 Tf
6.3 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(the scene is rendered from a new viewpoint. See Chapter 3.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 7)Tj
ET
endstream
endobj
1661 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
/F33 12 0 R
>>
/XObject <<
/Im143 1658 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1662 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im144
/Width 1194
/Height 922
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.143)
>>
stream
endstream
endobj
1664 0 obj
<<
/Length 553
>>
stream
q
1 i 
124.000 720.000 423.000 -326.630 re
W n
/GS1 gs
q
423 0 0 327 124 393 cm
/Im144 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 366.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 9)Tj
/F11 1 Tf
0 -2.1 TD
(The scene drawn using atmospheric effects \(fog\) to simulate a smoke-filled room. See Chapter 6.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 8)Tj
ET
endstream
endobj
1665 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im144 1662 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1666 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im145
/Width 1191
/Height 921
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.144)
>>
stream
endstream
endobj
1667 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im146
/Width 397
/Height 107
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.145)
>>
stream
endstream
endobj
1669 0 obj
<<
/Length 1160
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 395.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(.)Tj
ET
Q
/GS1 gs
q
420 0 0 325 126.5 395 cm
/Im145 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 365.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 10)Tj
/F11 1 Tf
0 -2.1 TD
(Teapots drawn with jittered viewing volumes into the accumulation buffer for a depth-of-field effect. The)Tj
0 -1.5 TD
(gold teapot is in sharpest focus.)Tj
0 -1.1 TD
(See Chapter 10.)Tj
ET
Q
q
397 0 0 107 124 196.49 cm
/Im146 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 169.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 11)Tj
/F11 1 Tf
0 -2.1 TD
(A smooth-shaded triangle. The three vertices at the corners are drawn in red, green, and blue; the rest of)Tj
0 -1.5 TD
(the triangle is smoothly shaded between these three colors. See Chapter 4.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 9)Tj
ET
endstream
endobj
1670 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im145 1666 0 R
/Im146 1667 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1671 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im147
/Width 118
/Height 118
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.146)
>>
stream
endstream
endobj
1672 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im148
/Width 346
/Height 176
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.147)
>>
stream
endstream
endobj
1674 0 obj
<<
/Length 1487
>>
stream
/GS1 gs
q
118 0 0 118 124 602 cm
/Im147 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 574.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 12)Tj
/F11 1 Tf
0 -2.1 TD
(The color cube. On the left, the red, green, and blue axes are shown; on the right, the axes denote yellow,)Tj
0 -1.5 TD
(cyan, and magenta. See Chapter 4.)Tj
ET
Q
q
346 0 0 176 124 348 cm
/Im148 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 320.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 13)Tj
/F11 1 Tf
0 -2.1 TD
(Objects drawn with gray material parameters and colored light sources. \(a\) The scene on the left has pale)Tj
0 -1.5 TD
(blue ambient light and a white diffuse light source. The scene on the right has a pale blue diffuse light)Tj
T*
(source and almost no ambient light. \(b\) On the left, an infinite light source is used; on the right, a local)Tj
T*
(light source is used. With the infinite light source, the highlight \(specular reflection\) is centered on both)Tj
T*
(the cone and the sphere because the angle between the object and the line of sight is ignored. With a local)Tj
T*
(light source, the angle is taken into account, so the highlights are located appropriately on both objects.)Tj
T*
(See Chapter 5.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 10)Tj
ET
endstream
endobj
1675 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im147 1671 0 R
/Im148 1672 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1676 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im149
/Width 527
/Height 392
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.148)
>>
stream
endstream
endobj
1678 0 obj
<<
/Length 924
>>
stream
q
1 i 
124.000 720.000 422.990 -314.640 re
W n
/GS1 gs
q
423 0 0 315 124 405 cm
/Im149 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 378.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 14)Tj
/F11 1 Tf
0 -2.1 TD
(Gray teapots drawn with different lighting conditions. \(a\) Each of the three teapots is drawn with)Tj
0 -1.5 TD
(increasing ambient light. \(b\) The teapots are clipped to expose their interiors. The top teapot uses)Tj
T*
(one-sided lighting, the middle one uses two-sided lighting with the same material for both front and back)Tj
T*
(faces, and the bottom teapot uses two-sided lighting and different materials for the front and back faces.)Tj
T*
(See Chapter 5.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 11)Tj
ET
endstream
endobj
1679 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im149 1676 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1680 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im150
/Width 502
/Height 293
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.149)
>>
stream
endstream
endobj
1681 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im151
/Width 186
/Height 170
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.150)
>>
stream
endstream
endobj
1683 0 obj
<<
/Length 1191
>>
stream
/GS1 gs
q
423 0 0 247 124 473 cm
/Im150 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 445.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 15)Tj
/F11 1 Tf
0 -2.1 TD
(A lighted sphere drawn using color index mode. See Chapter 5.)Tj
ET
Q
q
186 0 0 170 124 240.11 cm
/Im151 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 212.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 16)Tj
/F11 1 Tf
0 -2.1 TD
(Twelve spheres, each with different material parameters. The row properties are as labeled above. The)Tj
0 -1.5 TD
(first column uses a blue diffuse material color with no specular properties. The second column adds)Tj
T*
(white specular reflection with a low shininess exponent. The third column uses a high shininess exponent)Tj
T*
(and thus has a more concentrated highlight. The fourth column uses the blue diffuse color and, instead of)Tj
T*
(specular reflection, adds an emissive component. See Chapter 5.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 12)Tj
ET
endstream
endobj
1684 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im150 1680 0 R
/Im151 1681 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1685 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im152
/Width 498
/Height 325
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.151)
>>
stream
endstream
endobj
1687 0 obj
<<
/Length 901
>>
stream
/GS1 gs
q
423 0 0 276 124 444 cm
/Im152 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 416.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 17)Tj
/F11 1 Tf
0 -2.1 TD
(Lighted, smooth-shaded teapots drawn with different material properties that approximate real materials.)Tj
0 -1.5 TD
(The first column has materials that resemble \(from top to bottom\) emerald, jade, obsidian, pearl, ruby,)Tj
T*
(and turquoise. The second column resembles brass, bronze, chrome, copper, gold, and silver. The third)Tj
T*
(column represents various colors of plastic: black, cyan, green, red, white, and yellow. The fourth)Tj
T*
(column is drawn with similar colors of rubber. See Chapter 5)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 13)Tj
ET
endstream
endobj
1688 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im152 1685 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1690 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im153
/Width 495
/Height 595
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.152)
>>
stream
endstream
endobj
1692 0 obj
<<
/Length 1294
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 215.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(.)Tj
ET
Q
q
1 i 
126.500 720.000 420.500 -505.440 re
W n
/GS1 gs
q
421 0 0 504.9999 126.5 215.0001 cm
/Im153 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 185.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 18)Tj
/F11 1 Tf
0 -2.1 TD
(Lighted, green teapots drawn using automatic texture-coordinate generation and a red contour texture)Tj
0 -1.5 TD
(map. \(a\) The texture contour stripes are parallel to the plane x = 0, relative to the transformed object \(that)Tj
T*
(is, using GL_OBJECT_LINEAR\). As the object moves, the texture appears to be attached to it. \(b\) A)Tj
T*
(different planar equation \(x + y + z = 0\) is used, so the stripes have a different orientation. \(c\) The texture)Tj
T*
(coordinates are calculated relative to eye coordinates and hence aren't fixed to the object)Tj
T*
(\(GL_EYE_LINEAR\). As the object moves, it appears to "swim" through the texture. See Chapter 9.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 14)Tj
ET
endstream
endobj
1693 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im153 1690 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1694 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im154
/Width 524
/Height 193
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.153)
>>
stream
endstream
endobj
1695 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im155
/Width 294
/Height 294
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.154)
>>
stream
endstream
endobj
1697 0 obj
<<
/Length 1144
>>
stream
q
1 i 
124.000 720.000 423.000 -155.790 re
W n
/GS1 gs
q
423 0 0 156 124 564 cm
/Im154 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 536.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 19)Tj
/F11 1 Tf
0 -2.1 TD
(A texture-mapped Bezier surface mesh created using evaluators. See Chapters 9 and 12.)Tj
ET
Q
/GS1 gs
q
294 0 0 294 124 207.2 cm
/Im155 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 179.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 20)Tj
/F11 1 Tf
0 -2.1 TD
(A single polygon drawn using a set of mipmapped textures. In this case, each texture is simply a different)Tj
0 -1.5 TD
(color. The polygon is actually a rectangle oriented so that it recedes into the distance, appearing to)Tj
T*
(become progressively smaller. As the visible area of the polygon becomes smaller, correspondingly)Tj
T*
(smaller mipmaps are used. See Chapter 9.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 15)Tj
ET
endstream
endobj
1698 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im154 1694 0 R
/Im155 1695 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1699 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im156
/Width 457
/Height 440
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.155)
>>
stream
endstream
endobj
1701 0 obj
<<
/Length 730
>>
stream
/GS1 gs
q
423 0 0 407 124 313 cm
/Im156 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 285.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 21)Tj
/F11 1 Tf
0 -2.1 TD
(An environment-mapped object. On the left is the original texture, a processed photograph of a coffee)Tj
0 -1.5 TD
(shop in Palo Alto, taken with a very wide-angle lens. Below is a goblet with the environment map)Tj
T*
(applied; because of the mapping, the goblet appears to reflect the coffee shop off its surface. See Chapter)Tj
T*
(9.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 16)Tj
ET
endstream
endobj
1702 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im156 1699 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1703 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im157
/Width 526
/Height 532
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.156)
>>
stream
endstream
endobj
1705 0 obj
<<
/Length 768
>>
stream
q
1 i 
124.000 720.000 423.000 -427.820 re
W n
/GS1 gs
q
423 0 0 428 124 292 cm
/Im157 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 264.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 22)Tj
/F11 1 Tf
0 -2.1 TD
(A scene with several flat-shaded objects. On the left, the scene is aliased. On the right, the accumulation)Tj
0 -1.5 TD
(buffer is used for scene antialiasing: the scene is rendered several times, each time jittered less than one)Tj
T*
(pixel, and the images are accumulated and then averaged. See Chapter 10.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 17)Tj
ET
endstream
endobj
1706 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im157 1703 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1707 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im158
/Width 394
/Height 186
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.157)
>>
stream
endstream
endobj
1708 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im159
/Width 400
/Height 171
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.158)
>>
stream
endstream
endobj
1710 0 obj
<<
/Length 1022
>>
stream
/GS1 gs
q
394.0001 0 0 186 124 534 cm
/Im158 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 506.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 23)Tj
/F11 1 Tf
0 -2.1 TD
(A magnification of the previous scenes. The left image shows the aliased, jagged edges. In the right)Tj
0 -1.5 TD
(image, the edges are blurred, or antialiased, and hence less jagged. See Chapter 10.)Tj
ET
Q
q
400 0 0 171 124 285 cm
/Im159 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 257.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 24)Tj
/F11 1 Tf
0 -2.1 TD
(A scene drawn with texture mapping, lighting, and shadows. The paintings, floor, ceiling, and benches)Tj
0 -1.5 TD
(are texture-mapped. Note the use of spotlights and shadows. See Chapters 5, 9, and 14.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 18)Tj
ET
endstream
endobj
1711 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im158 1707 0 R
/Im159 1708 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1712 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im160
/Width 768
/Height 504
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.159)
>>
stream
endstream
endobj
1714 0 obj
<<
/Length 554
>>
stream
q
1 i 
124.000 720.000 422.990 -277.590 re
W n
/GS1 gs
q
422.9999 0 0 278 124 442 cm
/Im160 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 415.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 25)Tj
/F11 1 Tf
0 -2.1 TD
(A lighted, smooth-shaded model on a texture-mapped surface.)Tj
0 -1.2 TD
(See Chapters 4, 5)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 19)Tj
ET
endstream
endobj
1715 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im160 1712 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1716 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im161
/Width 981
/Height 898
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.160)
>>
stream
endstream
endobj
1718 0 obj
<<
/Length 542
>>
stream
/GS1 gs
q
423 0 0 387 124 333 cm
/Im161 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 305.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 26)Tj
/F11 1 Tf
0 -2.1 TD
(A dramatically lit and shadowed scene, with most of the surfaces textured. The iris is a polygonal model.)Tj
0 -1.5 TD
(See Chapters 2, 5, 9, and 14.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 20)Tj
ET
endstream
endobj
1719 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im161 1716 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1720 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im162
/Width 1280
/Height 1024
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.161)
>>
stream
endstream
endobj
1722 0 obj
<<
/Length 577
>>
stream
/GS1 gs
q
423 0 0 338 124 382 cm
/Im162 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 354.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 27)Tj
/F11 1 Tf
0 -2.1 TD
(Sophisticated use of texturing. All surfaces are texture-mapped. In addition, the attenuated spotlight)Tj
0 -1.5 TD
(effect is created using a projected texture. See Chapters 9 and 14.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 21)Tj
ET
endstream
endobj
1723 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im162 1720 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1724 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im163
/Width 1145
/Height 752
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.162)
>>
stream
endstream
endobj
1725 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im164
/Width 692
/Height 200
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.163)
>>
stream
endstream
endobj
1727 0 obj
<<
/Length 1135
>>
stream
q
1 i 
124.000 720.000 422.990 -277.810 re
W n
/GS1 gs
q
423 0 0 278 124 442 cm
/Im163 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 414.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 28)Tj
/F11 1 Tf
0 -2.1 TD
(Lit, smooth-shaded three-dimensional font. The font is created by extruding a two-dimensional shape)Tj
0 -1.5 TD
(along a specified axis.)Tj
0 -1.1 TD
(See Chapters 2, 4, and 5.)Tj
ET
Q
/GS1 gs
q
423 0 0 122 124 231.03 cm
/Im164 Do
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 203.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(Plate 29 and 30)Tj
/F11 1 Tf
0 -2.1 TD
(Two scenes snapped from a visual simulation program. The hills are composed of just a few polygons,)Tj
0 -1.5 TD
(but all the polygons are texture-mapped. Similarly, the buildings are composed of only a few textured)Tj
T*
(rectangular walls. See Chapters 2, 3, and 9.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 22)Tj
ET
endstream
endobj
1728 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im163 1724 0 R
/Im164 1725 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1729 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im165
/Width 827
/Height 398
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.164)
>>
stream
endstream
endobj
1730 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im166
/Width 892
/Height 478
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.165)
>>
stream
endstream
endobj
1732 0 obj
<<
/Length 756
>>
stream
q
1 i 
124.000 720.000 422.990 -203.570 re
W n
/GS1 gs
q
423 0 0 204 124 516 cm
/Im165 Do
Q
Q
q
1 i 
124.000 504.430 422.990 -226.670 re
W n
/GS1 gs
q
423 0 0 227 124 277.43 cm
/Im166 Do
Q
Q
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
10.000 0.000 0.000 10.000 124.000 250.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Plate 31)Tj
/F11 1 Tf
0 -2.1 TD
(Another scene from a different visual simulation program. The hills are textured, and the scene is)Tj
0 -1.5 TD
(rendered with fog. The airplanes, obviously, are polygonal. See Chapters 2, 3, 6, and 9.)Tj
ET
Q
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 76.000 45.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(OpenGL   Programming Guide - Appendix I,  Color Plates - 23)Tj
ET
endstream
endobj
1733 0 obj
<<
/ProcSet [/PDF /Text /ImageB ]
/Font <<
/F11 4 0 R
/F27 5 0 R
>>
/XObject <<
/Im165 1729 0 R
/Im166 1730 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1735 0 obj
<<
/Type /XObject
/Subtype /Image
/Name /Im167
/Width 1280
/Height 1024
/BitsPerComponent 8
/ColorSpace /DeviceGray
/Length 0
/F (OGLPG_12.pdf.ext.166)
>>
stream
endstream
endobj
1737 0 obj
<<
/Length 132
>>
stream
/GS1 gs
q
423 0 0 338 124 382 cm
/Im167 Do
Q
0.000 0.000 0.000 RG
0 J 0 j 1 w 10 M []0 d
1 i 
124.000 363.110 m
547.000 363.110 l
S
endstream
endobj
1738 0 obj
<<
/ProcSet [/PDF /ImageB ]
/XObject <<
/Im167 1735 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1740 0 obj
<<
/Length 2985
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F27 1 Tf
14.000 0.000 0.000 14.000 124.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(Glossary)Tj
/F13 1 Tf
10.000 0.000 0.000 10.000 125.000 681.000 Tm
0.000 Tw
(accumulation buffer)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Memory \(bitplanes\) that is used to accumulate a series of images generated in the color buffer. Using the)Tj
T*
(accumulation buffer may significantly improve the quality of the image, but also take correspondingly)Tj
T*
(longer to render. The accumulation buffer is used for effects such as depth of field, motion blur, and)Tj
T*
(full-scene antialiasing.)Tj
/F13 1 Tf
0.1 -2.3 TD
(aliasing)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A rendering technique that assigns to pixels the color of the primitive being rendered, regardless of)Tj
T*
(whether that primitive covers all or only a portion of the pixel's area. This results in jagged edges, or)Tj
T*
(jaggies.)Tj
/F13 1 Tf
0.1 -2.3 TD
(alpha)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A fourth color component. The alpha component is never displayed directly and is typically used to)Tj
T*
(control color blending. By convention, OpenGL alpha corresponds to the notion of opacity rather than)Tj
T*
(transparency, meaning that an alpha value of 1.0 implies complete opacity, and an alpha value of 0.0)Tj
T*
(complete transparency.)Tj
/F13 1 Tf
0.1 -2.3 TD
(ambient)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Ambient light is nondirectional and distributed uniformly throughout space. Ambient light falling upon a)Tj
T*
(surface approaches from all directions. The light is reflected from the object independent of surface)Tj
T*
(location and orientation with equal intensity in all directions.)Tj
/F13 1 Tf
0.1 -2.3 TD
(animation)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Generating repeated renderings of a scene, with smoothly changing viewpoint and/or object positions,)Tj
T*
(quickly enough so that the illusion of motion is achieved. OpenGL animation is almost always done)Tj
T*
(using double-buffering.)Tj
/F13 1 Tf
0.1 -2.3 TD
(antialiasing)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A rendering technique that assigns pixel colors based on the fraction of the pixel's area that's covered by)Tj
T*
(the primitive being rendered. Antialiased rendering reduces or eliminates the jaggies that result from)Tj
T*
(aliased rendering.)Tj
/F13 1 Tf
0.1 -2.3 TD
(application-specific clipping)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Clipping of primitives against planes in eye coordinates; the planes are specified by the application using)Tj
/F15 1 Tf
T*
(glClipPlane\(\))Tj
/F11 1 Tf
5.5 0 TD
(.)Tj
/F13 1 Tf
-5.4 -2.3 TD
(attribute group)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A set of related state variables, which OpenGL can save or restore together at one time.)Tj
/F13 1 Tf
0.1 -2.3 TD
(back faces)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.006 Tw
[(See faces)54(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(bit)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(Binary digit. A state variable having only two possible values: 0 or 1. Binary numbers are constructions)Tj
T*
(of one or more bits.)Tj
ET
Q
endstream
endobj
1741 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F27 5 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1743 0 obj
<<
/Length 3220
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F13 1 Tf
10.000 0.000 0.000 10.000 125.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(bitmap)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(A rectangular array of bits. Also, the primitive rendered by the )Tj
/F15 1 Tf
25.3 0 TD
(glBitmap\(\))Tj
/F11 1 Tf
4.3 0 TD
( command, which uses its)Tj
/F15 1 Tf
-29.6 -1.5 TD
(bitmap)Tj
/F11 1 Tf
2.8 0 TD
( parameter as a mask.)Tj
/F13 1 Tf
-2.7 -2.3 TD
(bitplane)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A rectangular array of bits mapped one-to-one with pixels. The framebuffer is a stack of bitplanes.)Tj
/F13 1 Tf
0.1 -2.3 TD
(blending)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Reduction of two color components to one component, usually as a linear interpolation between the two)Tj
T*
(components.)Tj
/F13 1 Tf
0.1 -2.3 TD
(buffer)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A group of bitplanes that store a single component \(such as depth or green\) or a single index \(such as the)Tj
T*
(color index or the stencil index\). Sometimes the red, green, blue, and alpha buffers together are referred)Tj
T*
(to as the color buffer, rather than the color buffers.)Tj
/F13 1 Tf
0.1 -2.3 TD
(C)Tj
/F11 1 Tf
-0.1 -1.5 TD
(God's programming language.)Tj
/F13 1 Tf
0.1 -2.3 TD
(C++)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The object-oriented programming language of a pagan deity.)Tj
/F13 1 Tf
0.1 -2.3 TD
(client)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The computer from which OpenGL commands are issued. The computer that issues OpenGL commands)Tj
T*
(can be connected via a network to a different computer that executes the commands, or commands can be)Tj
T*
[(issued and executed on the same computer. See also )10(server)-57(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(client memory)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The main memory \(where program variables are stored\) of the client computer.)Tj
/F13 1 Tf
0.1 -2.3 TD
(clip coordinates)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The coordinate system that follows transformation by the projection matrix and precedes perspective)Tj
T*
(division. View-volume clipping is done in clip coordinates, but application-specific clipping is not.)Tj
/F13 1 Tf
0.1 -2.3 TD
(clipping)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Elimination of the portion of a geometric primitive that's outside the half-space defined by a clipping)Tj
T*
(plane. Points are simply rejected if outside. The portion of a line or of a polygon that's outside the)Tj
T*
(half-space is eliminated, and additional vertices are generated as necessary to complete the primitive)Tj
T*
(within the clipping half-space. Geometric primitives and the current raster position \(when specified\) are)Tj
T*
(always clipped against the six half-spaces defined by the left, right, bottom, top, near, and far planes of)Tj
T*
(the view volume. Applications can specify optional application-specific clipping planes to be applied in)Tj
T*
(eye coordinates.)Tj
/F13 1 Tf
0.1 -2.3 TD
(color index)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A single value that represents a color by name, rather than by value. OpenGL color indices are treated as)Tj
T*
(continuous values \(for example, floating-point numbers\), while operations such as interpolation and)Tj
T*
(dithering are performed on them. Color indices stored in the framebuffer are always integer values,)Tj
ET
Q
endstream
endobj
1744 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1746 0 obj
<<
/Length 3309
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(however. Floating-point indices are converted to integers by rounding to the nearest integer value.)Tj
/F13 1 Tf
0.1 -2.3 TD
(color-index mode)Tj
/F11 1 Tf
-0.1 -1.5 TD
(An OpenGL context is in color-index mode if its color buffers store color indices rather than red, green,)Tj
T*
(blue, and alpha color components.)Tj
/F13 1 Tf
0.1 -2.3 TD
(color map)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A table of index-to-RGB mappings that's accessed by the display hardware. Each color index is read)Tj
T*
(from the color buffer, converted to an RGB triple by lookup in the color map, and sent to the monitor.)Tj
/F13 1 Tf
0.1 -2.3 TD
(components)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Single, continuous \(for example, floating-point\) values that represent intensities or quantities. Usually, a)Tj
T*
(component value of zero represents the minimum value or intensity, and a component value of one)Tj
T*
(represents the maximum value or intensity, though other ranges are sometimes used. Because component)Tj
T*
(values are interpreted in a normalized range, they are specified independent of actual resolution. For)Tj
T*
(example, the RGB triple \(1, 1, 1\) is white, regardless of whether the color buffers store 4, 8, or 12 bits)Tj
T*
(each.)Tj
T*
(Out-of-range components are typically clamped to the normalized range, not truncated or otherwise)Tj
T*
(interpreted. For example, the RGB triple \(1.4, 1.5, 0.9\) is clamped to \(1.0, 1.0, 0.9\) before it's used to)Tj
T*
(update the color buffer. Red, green, blue, alpha, and depth are always treated as components, never as)Tj
T*
(indices.)Tj
/F13 1 Tf
0.1 -2.3 TD
(concave)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.050 Tw
[(Not convex)88(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(context)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(A complete set of OpenGL state variables. Note that framebuffer contents are not part of OpenGL state,)Tj
T*
(but that the configuration of the framebuffer is.)Tj
/F13 1 Tf
0.1 -2.3 TD
(convex)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A polygon is convex if no straight line in the plane of the polygon intersects the polygon more than)Tj
T*
(twice.)Tj
/F13 1 Tf
0.1 -2.3 TD
(convex hull)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The smallest convex region enclosing a specified group of points. In two dimensions, the convex hull is)Tj
T*
(found conceptually by stretching a rubber band around the points so that all of the points lie within the)Tj
T*
(band.)Tj
/F13 1 Tf
0.1 -2.3 TD
(coordinate system)Tj
/F11 1 Tf
-0.1 -1.5 TD
(In )Tj
/F15 1 Tf
1.1 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(-dimensional space, a set of )Tj
/F15 1 Tf
11.3 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
( linearly independent vectors anchored to a point \(called the origin\). A)Tj
-13.4 -1.5 TD
(group of coordinates specifies a point in space \(or a vector from the origin\) by indicating how far to)Tj
T*
(travel along each vector to reach the point \(or tip of the vector\).)Tj
/F13 1 Tf
0.1 -2.3 TD
(culling)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The process of eliminating a front face or back face of a polygon so that it isn't drawn.)Tj
/F13 1 Tf
0.1 -2.3 TD
(current matrix)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A matrix that transforms coordinates in one coordinate system to coordinates of another system. There)Tj
ET
Q
endstream
endobj
1747 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1749 0 obj
<<
/Length 3492
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 709.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(are three current matrices in OpenGL: the modelview matrix transforms object coordinates \(coordinates)Tj
0 -1.5 TD
(specified by the programmer\) to eye coordinates; the perspective matrix transforms eye coordinates to)Tj
T*
(clip coordinates; the texture matrix transforms specified or generated texture coordinates as described by)Tj
T*
(the matrix. Each current matrix is the top element on a stack of matrices. Each of the three stacks can be)Tj
T*
(manipulated with OpenGL matrix-manipulation commands.)Tj
/F13 1 Tf
0.1 -2.3 TD
(current raster position)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A window coordinate position that specifies the placement of an image primitive when it's rasterized.)Tj
T*
(The current raster position and other current raster parameters are updated when )Tj
/F15 1 Tf
32.3 0 TD
(glRasterPos\(\))Tj
/F11 1 Tf
5.6 0 TD
( is called.)Tj
/F13 1 Tf
-37.8 -2.3 TD
(decal)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A method of calculating color values during texture application, where the texture colors replace the)Tj
T*
(fragment colors or, if alpha blending is enabled, the texture colors are blended with the fragment colors,)Tj
T*
(using only the alpha value.)Tj
/F13 1 Tf
0.1 -2.3 TD
(depth)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Generally refers to the )Tj
/F15 1 Tf
9.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( window coordinate.)Tj
/F13 1 Tf
-9.5 -2.3 TD
(depth buffer)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Memory that stores the depth value at every pixel. To perform hidden-surface removal, the depth buffer)Tj
T*
(records the depth value of the object that lies closest to the observer at every pixel. The depth value of)Tj
T*
(every new fragment uses the recorded value for depth comparison and must pass the comparison test)Tj
T*
(before being rendered.)Tj
/F13 1 Tf
0.1 -2.3 TD
(depth-cuing)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A rendering technique that assigns color based on distance from the viewpoint.)Tj
/F13 1 Tf
0.1 -2.3 TD
(diffuse)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Diffuse lighting and reflection accounts for the directionality of a light source. The intensity of light)Tj
T*
(striking a surface varies with the angle between the orientation of the object and the direction of the light)Tj
T*
(source. A diffuse material scatters that light evenly in all directions.)Tj
/F13 1 Tf
0.1 -2.3 TD
(directional light source)Tj
/F11 1 Tf
-0.1 -1.5 TD
[(See )-6(infinite light source)34(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(display list)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A named list of OpenGL commands. Display lists are always stored on the server, so display lists can be)Tj
T*
(used to reduce network traffic in client-server environments. The contents of a display list may be)Tj
T*
(preprocessed and might therefore execute more efficiently than the same set of OpenGL commands)Tj
T*
(executed in immediate mode. Such preprocessing is especially important for computing intensive)Tj
T*
(commands such as NURBS or polygon tessellation.)Tj
/F13 1 Tf
0.1 -2.3 TD
(dithering)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A technique for increasing the perceived range of colors in an image at the cost of spatial resolution.)Tj
T*
(Adjacent pixels are assigned differing color values; when viewed from a distance, these colors seem to)Tj
T*
(blend into a single intermediate color. The technique is similar to the halftoning used in black-and-white)Tj
T*
(publications to achieve shades of gray.)Tj
ET
Q
endstream
endobj
1750 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1752 0 obj
<<
/Length 3123
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F13 1 Tf
10.000 0.000 0.000 10.000 125.000 707.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(double-buffering)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(OpenGL contexts with both front and back color buffers are double-buffered. Smooth animation is)Tj
T*
(accomplished by rendering into only the back buffer \(which isn't displayed\), then causing the front and)Tj
T*
(back buffers to be swapped. See )Tj
/F15 1 Tf
13.1 0 TD
(glutSwapBuffers\(\))Tj
/F11 1 Tf
7.3 0 TD
[( in )-22(Appendix D)17(.)]TJ
/F13 1 Tf
-20.3 -2.3 TD
(edge flag)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A Boolean value at a vertex which marks whether that vertex precedes a boundary edge. )Tj
/F15 1 Tf
35.6 0 TD
(glEdgeFlag*\(\))Tj
/F11 1 Tf
-35.6 -1.5 TD
(may be used to mark an edge as not on the boundary. When a polygon is drawn in GL_LINE mode, only)Tj
T*
(boundary edges are drawn.)Tj
/F13 1 Tf
0.1 -2.3 TD
(element)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A single component or index.)Tj
/F13 1 Tf
0.1 -2.3 TD
(emission)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The color of an object which is self-illuminating or self-radiating. The intensity of an emissive material is)Tj
T*
(not attributed to any external light source.)Tj
/F13 1 Tf
0.1 -2.3 TD
(evaluated)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The OpenGL process of generating object-coordinate vertices and parameters from previously specified)Tj
T*
(B\351zier equations.)Tj
/F13 1 Tf
0.1 -2.3 TD
(execute)Tj
/F11 1 Tf
-0.1 -1.5 TD
(An OpenGL command is executed when it's called in immediate mode or when the display list that it's a)Tj
T*
(part of is called.)Tj
/F13 1 Tf
0.1 -2.3 TD
(eye coordinates)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The coordinate system that follows transformation by the modelview matrix and precedes transformation)Tj
T*
(by the projection matrix. Lighting and application-specific clipping are done in eye coordinates.)Tj
/F13 1 Tf
0.1 -2.3 TD
(faces)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The sides of a polygon. Each polygon has two faces: a front face and a back face. Only one face or the)Tj
T*
(other is ever visible in the window. Whether the back or front face is visible is effectively determined)Tj
T*
(after the polygon is projected onto the window. After this projection, if the polygon's edges are directed)Tj
T*
(clockwise, one of the faces is visible; if directed counterclockwise, the other face is visible. Whether)Tj
T*
(clockwise corresponds to front or back \(and counterclockwise corresponds to back or front\) is)Tj
T*
(determined by the OpenGL programmer.)Tj
/F13 1 Tf
0.1 -2.3 TD
(flat shading)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Refers to a primitive colored with a single, constant color across its extent, rather than smoothly)Tj
T*
[(interpolated colors across the primitive. See Gouraud shading)-39(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(fog)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A rendering technique that can be used to simulate atmospheric effects such as haze, fog, and smog by)Tj
T*
(fading object colors to a background color based on distance from the viewer. Fog also aids in the)Tj
T*
(perception of distance from the viewer, giving a depth cue.)Tj
/F13 1 Tf
0.1 -2.3 TD
(fonts)Tj
ET
Q
endstream
endobj
1753 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1755 0 obj
<<
/Length 2827
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(Groups of graphical character representations generally used to display strings of text. The characters)Tj
0 -1.5 TD
(may be roman letters, mathematical symbols, Asian ideograms, Egyptian hieroglyphics, and so on.)Tj
/F13 1 Tf
0.1 -2.3 TD
(fragment)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Fragments are generated by the rasterization of primitives. Each fragment corresponds to a single pixel)Tj
T*
(and includes color, depth, and sometimes texture-coordinate values.)Tj
/F13 1 Tf
0.1 -2.3 TD
(framebuffer)Tj
/F11 1 Tf
-0.1 -1.5 TD
(All the buffers of a given window or context. Sometimes includes all the pixel memory of the graphics)Tj
T*
(hardware accelerator.)Tj
/F13 1 Tf
0.1 -2.3 TD
(front faces)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.006 Tw
[(See faces)54(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(frustum)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(The view volume warped by perspective division.)Tj
/F13 1 Tf
0.1 -2.3 TD
(gamma correction)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A function applied to colors stored in the framebuffer to correct for the nonlinear response of the eye)Tj
T*
(\(and sometimes of the monitor\) to linear changes in color-intensity values.)Tj
/F13 1 Tf
0.1 -2.3 TD
(geometric model)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The object-coordinate vertices and parameters that describe an object. Note that OpenGL doesn't define a)Tj
T*
(syntax for geometric models, but rather a syntax and semantics for the rendering of geometric models.)Tj
/F13 1 Tf
0.1 -2.3 TD
(geometric object)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.006 Tw
[(See geometric )6(model)50(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
0.000 Tw
(geometric primitive)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A point, a line, or a polygon.)Tj
/F13 1 Tf
0.1 -2.3 TD
(Gouraud shading)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Smooth interpolation of colors across a polygon or line segment. Colors are assigned at vertices and)Tj
T*
(linearly interpolated across the primitive to produce a relatively smooth variation in color. Also called)Tj
T*
(smooth shading.)Tj
/F13 1 Tf
0.1 -2.3 TD
(group)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Each pixel of an image in client memory is represented by a group of one, two, three, or four elements.)Tj
T*
(Thus, in the context of a client memory image, a group and a pixel are the same thing.)Tj
/F13 1 Tf
0.1 -2.3 TD
(half-spaces)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A plane divides space into two half-spaces.)Tj
/F13 1 Tf
0.1 -2.3 TD
(hidden-line removal)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A technique to determine which portions of a wireframe object should be visible. The lines that comprise)Tj
T*
(the wireframe are considered to be edges of opaque surfaces, which may obscure other edges that are)Tj
T*
(farther away from the viewer.)Tj
/F13 1 Tf
0.1 -2.3 TD
(hidden-surface removal)Tj
ET
Q
endstream
endobj
1756 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1758 0 obj
<<
/Length 3661
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(A technique to determine which portions of an opaque, shaded object should be visible and which)Tj
0 -1.5 TD
(portions should be obscured. A test of the depth coordinate, using the depth buffer for storage, is a)Tj
T*
(common method of hidden-surface removal.)Tj
/F13 1 Tf
0.1 -2.3 TD
(homogeneous coordinates)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A set of )Tj
/F15 1 Tf
3.4 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(+1 coordinates used to represent points in )Tj
/F15 1 Tf
16.9 0 TD
(n)Tj
/F11 1 Tf
0.5 0 TD
(-dimensional projective space. Points in projective)Tj
-21.3 -1.5 TD
(space can be thought of as points in euclidean space together with some points at infinity. The)Tj
T*
(coordinates are homogeneous because a scaling of each of the coordinates by the same nonzero constant)Tj
T*
(doesn't alter the point to which the coordinates refer. Homogeneous coordinates are useful in the)Tj
T*
(calculations of projective geometry, and thus in computer graphics, where scenes must be projected onto)Tj
T*
(a window.)Tj
/F13 1 Tf
0.1 -2.3 TD
(image)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A rectangular array of pixels, either in client memory or in the framebuffer.)Tj
/F13 1 Tf
0.1 -2.3 TD
(image primitive)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A bitmap or an image.)Tj
/F13 1 Tf
0.1 -2.3 TD
(immediate mode)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Execution of OpenGL commands when they're called, rather than from a display list. No)Tj
T*
(immediate-mode bit exists; the mode in immediate mode refers to use of OpenGL, rather than to a)Tj
T*
(specific bit of OpenGL state.)Tj
/F13 1 Tf
0.1 -2.3 TD
(index)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A single value that's interpreted as an absolute value, rather than as a normalized value in a specified)Tj
T*
(range \(as is a component\). Color indices are the names of colors, which are dereferenced by the display)Tj
T*
(hardware using the color map. Indices are typically masked rather than clamped when out of range. For)Tj
T*
(example, the index 0xf7 is masked to 0x7 when written to a 4-bit buffer \(color or stencil\). Color indices)Tj
T*
(and stencil indices are always treated as indices, never as components.)Tj
/F13 1 Tf
0.1 -2.3 TD
(indices)Tj
/F11 1 Tf
-0.1 -1.6 TD
(Preferred plural of index. \(The choice between the plural forms indices or indexes)Tj
/F33 1 Tf
32.8 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(as well as matrices)Tj
-33.8 -1.7 TD
(or matrixes and vertices or vertexes)Tj
/F33 1 Tf
14.2 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(has engendered much debate between the authors and principal)Tj
-15.2 -1.6 TD
(reviewers of this guide. The authors' compromise solution is to use the -ices form but to state clearly for)Tj
0 -1.5 TD
(the record that the use of indice [)Tj
/F15 1 Tf
13.2 0 TD
(sic)Tj
/F11 1 Tf
1.1 0 TD
(], matrice [)Tj
/F15 1 Tf
4.4 0 TD
(sic)Tj
/F11 1 Tf
1.1 0 TD
(], and vertice [)Tj
/F15 1 Tf
5.9 0 TD
(sic)Tj
/F11 1 Tf
1.1 0 TD
(] for the singular forms is an)Tj
-26.8 -1.5 TD
(abomination.\))Tj
/F13 1 Tf
0.1 -2.3 TD
(infinite light source)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A directional source of illumination. The radiating light from an infinite light source strikes all objects as)Tj
T*
(parallel rays.)Tj
/F13 1 Tf
0.1 -2.3 TD
(interpolation)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Calculation of values \(such as color or depth\) for interior pixels, given the values at the boundaries \(such)Tj
T*
(as at the vertices of a polygon or a line\).)Tj
/F13 1 Tf
0.1 -2.3 TD
(IRIS GL)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Silicon Graphics proprietary graphics library, developed from 1982 through 1992. OpenGL was designed)Tj
ET
Q
endstream
endobj
1759 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1761 0 obj
<<
/Length 3007
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(with IRIS GL as a starting point.)Tj
/F13 1 Tf
0.1 -2.3 TD
(IRIS Inventor)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.006 Tw
[(See Open )6(Inventor.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(jaggies)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(Artifacts of aliased rendering. The edges of primitives that are rendered with aliasing are jagged rather)Tj
T*
(than smooth. A near-horizontal aliased line, for example, is rendered as a set of horizontal lines on)Tj
T*
(adjacent pixel rows rather than as a smooth, continuous line.)Tj
/F13 1 Tf
0.1 -2.3 TD
(jittering)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A pseudo-random displacement \(shaking\) of the objects in a scene, used in conjunction with the)Tj
T*
(accumulation buffer to achieve special effects.)Tj
/F13 1 Tf
0.1 -2.3 TD
(lighting)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The process of computing the color of a vertex based on current lights, material properties, and)Tj
T*
(lighting-model modes.)Tj
/F13 1 Tf
0.1 -2.3 TD
(line)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A straight region of finite width between two vertices. \(Unlike mathematical lines, OpenGL lines have)Tj
T*
(finite width and length.\) Each segment of a strip of lines is itself a line.)Tj
/F13 1 Tf
0.1 -2.3 TD
(local light source)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A source of illumination which has an exact position. The radiating light from a local light source)Tj
T*
[(emanates from that position. Other names for a local light source are )-8(point light source or )33(positional light)]TJ
T*
[(source)10(. A )-28(spotlight is a special kind of local light source.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(logical operation)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Boolean mathematical operations between the incoming fragment's RGBA color or color-index values)Tj
T*
(and the RGBA color or color-index values already stored at the corresponding location in the)Tj
T*
(framebuffer. Examples of logical operations include AND, OR, XOR, NAND, and INVERT.)Tj
/F13 1 Tf
0.1 -2.3 TD
(luminance)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The perceived brightness of a surface. Often refers to a weighted average of red, green, and blue color)Tj
T*
(values that gives the perceived brightness of the combination.)Tj
/F13 1 Tf
0.1 -2.3 TD
(matrices)Tj
/F11 1 Tf
-0.1 -1.5 TD
[(Preferred plural of matrix. See )42(indices)-67(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(matrix)Tj
/F11 1 Tf
-0.1 -1.6 TD
(A two-dimensional array of values. OpenGL matrices are all 4)Tj
/F33 1 Tf
25 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(4, though when stored in client memory)Tj
-25.5 -1.7 TD
(they're treated as 1)Tj
/F33 1 Tf
7.6 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(16 single-dimension arrays.)Tj
/F13 1 Tf
-8.1 -2.4 TD
(modelview matrix)Tj
/F11 1 Tf
-0.1 -1.6 TD
(The 4)Tj
/F33 1 Tf
2.3 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(4 matrix that transforms points, lines, polygons, and raster positions from object coordinates to)Tj
-2.9 -1.6 TD
(eye coordinates.)Tj
/F13 1 Tf
0.1 -2.3 TD
(modulate)Tj
ET
Q
endstream
endobj
1762 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1764 0 obj
<<
/Length 2764
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(A method of calculating color values during texture application, where the texture and the fragment)Tj
0 -1.5 TD
(colors are combined.)Tj
/F13 1 Tf
0.1 -2.3 TD
(monitor)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The device that displays the image in the framebuffer.)Tj
/F13 1 Tf
0.1 -2.3 TD
(motion blurring)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A technique that uses the accumulation buffer to simulate what appears on film when you take a picture)Tj
T*
(of a moving object or when you move the camera while taking a picture of a stationary object. In)Tj
T*
(animations without motion blur, moving objects can appear jerky.)Tj
/F13 1 Tf
0.1 -2.3 TD
(network)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A connection between two or more computers that allows each to transfer data to and from the others.)Tj
/F13 1 Tf
0.1 -2.3 TD
(nonconvex)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A polygon is nonconvex if there exists a line in the plane of the polygon that intersects the polygon more)Tj
T*
(than twice.)Tj
/F13 1 Tf
0.1 -2.3 TD
(normal)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A three-component plane equation that defines the angular orientation, but not position, of a plane or)Tj
T*
(surface.)Tj
/F13 1 Tf
0.1 -2.3 TD
(normalized)Tj
/F11 1 Tf
-0.1 -1.5 TD
(To normalize a normal vector, divide each of the components by the square root of the sum of their)Tj
T*
(squares. Then, if the normal is thought of as a vector from the origin to the point \()Tj
/F15 1 Tf
32.7 0 TD
(nx', ny', nz')Tj
/F11 1 Tf
4.8 0 TD
(\), this)Tj
-37.5 -1.5 TD
(vector has unit length.)Tj
0 -1.8 TD
(factor = sqrt\(nx)Tj
6.2 0.3 TD
(2)Tj
0.5 -0.3 TD
( + ny)Tj
2.1 0.3 TD
(2)Tj
0.5 -0.3 TD
( + nz)Tj
2 0.3 TD
(2)Tj
0.5 -0.3 TD
(\))Tj
-11.8 -1.5 TD
(nx' = nx / factor)Tj
T*
(ny' = ny / factor)Tj
T*
(nz' = nz / factor)Tj
/F13 1 Tf
0.1 -2.3 TD
(normal vectors)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.006 Tw
[(See normal)33(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(NURBS)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(Non-Uniform Rational B-Spline. A common way to specify parametric curves and surfaces. \(See GLU)Tj
T*
[(NURBS routines in )-15(Chapter 12)16(.\))]TJ
/F13 1 Tf
0.1 -2.3 TD
(object)Tj
/F11 1 Tf
-0.1 -1.5 TD
(An object-coordinate model that's rendered as a collection of primitives.)Tj
/F13 1 Tf
0.1 -2.3 TD
(object coordinates)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Coordinate system prior to any OpenGL transformation.)Tj
/F13 1 Tf
0.1 -2.3 TD
(Open Inventor)Tj
/F11 1 Tf
-0.1 -1.5 TD
(An object-oriented 3D toolkit, built on top of OpenGL, based on a 3D scene database and user interaction)Tj
T*
(components. It includes objects such as cubes, polygons, text, materials, cameras, lights, trackballs and)Tj
T*
(handle boxes.)Tj
ET
Q
endstream
endobj
1765 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1769 0 obj
<<
/Length 3409
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F13 1 Tf
10.000 0.000 0.000 10.000 125.000 705.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(orthographic)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(Nonperspective projection, as in some engineering drawings, with no foreshortening.)Tj
/F13 1 Tf
0.1 -2.3 TD
(parameters)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Values passed as arguments to OpenGL commands. Sometimes parameters are passed by reference to an)Tj
T*
(OpenGL command.)Tj
/F13 1 Tf
0.1 -2.3 TD
(perspective division)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The division of )Tj
/F15 1 Tf
6.4 0 TD
(x)Tj
/F11 1 Tf
0.4 0 TD
(, )Tj
/F15 1 Tf
0.5 0 TD
(y)Tj
/F11 1 Tf
0.4 0 TD
(, and )Tj
/F15 1 Tf
2.2 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
( by )Tj
/F15 1 Tf
1.5 0 TD
(w)Tj
/F11 1 Tf
0.7 0 TD
(, carried out in clip coordinates.)Tj
/F13 1 Tf
-12.4 -2.3 TD
(pixel)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Picture element. The bits at location \()Tj
/F15 1 Tf
15 0 TD
(x, y)Tj
/F11 1 Tf
1.4 0 TD
(\) of all the bitplanes in the framebuffer constitute the single)Tj
-16.4 -1.5 TD
(pixel \()Tj
/F15 1 Tf
2.6 0 TD
(x, y)Tj
/F11 1 Tf
1.4 0 TD
(\). In an image in client memory, a pixel is one group of elements. In OpenGL window)Tj
-4 -1.6 TD
(coordinates, each pixel corresponds to a 1.0)Tj
/F33 1 Tf
17.5 0 TD
(\264)Tj
/F11 1 Tf
0.5 0 TD
(1.0 screen area. The coordinates of the lower-left corner of)Tj
-18 -1.6 TD
(the pixel are )Tj
/F15 1 Tf
5.2 0 TD
(x,y)Tj
/F11 1 Tf
1.1 0 TD
( are \()Tj
/F15 1 Tf
2.1 0 TD
(x, y)Tj
/F11 1 Tf
1.4 0 TD
(\), and of the upper-right corner are \()Tj
/F15 1 Tf
14.4 0 TD
(x)Tj
/F11 1 Tf
0.5 0 TD
(+1,)Tj
/F15 1 Tf
1.3 0 TD
( y)Tj
/F11 1 Tf
0.7 0 TD
(+1\).)Tj
/F13 1 Tf
-26.6 -2.3 TD
(point)Tj
/F11 1 Tf
-0.1 -1.5 TD
(An exact location in space, which is rendered as a finite-diameter dot.)Tj
/F13 1 Tf
0.1 -2.3 TD
(point light source)Tj
/F11 1 Tf
-0.1 -1.5 TD
[(See )-6(local light source)-11(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(polygon)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A near-planar surface bounded by edges specified by vertices. Each triangle of a triangle mesh is a)Tj
T*
(polygon, as is each quadrilateral of a quadrilateral mesh. The rectangle specified by )Tj
/F15 1 Tf
33.7 0 TD
(glRect*\(\))Tj
/F11 1 Tf
3.7 0 TD
( is also a)Tj
-37.4 -1.5 TD
(polygon.)Tj
/F13 1 Tf
0.1 -2.3 TD
(positional light source)Tj
/F11 1 Tf
-0.1 -1.5 TD
[(See )-6(local light source)-11(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(primitive)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A point, a line, a polygon, a bitmap, or an image. \(Note: Not just a point, a line, or a polygon!\))Tj
/F13 1 Tf
0.1 -2.3 TD
(projection matrix)Tj
/F11 1 Tf
-0.1 -1.6 TD
(The 4)Tj
/F33 1 Tf
2.3 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(4 matrix that transforms points, lines, polygons, and raster positions from eye coordinates to clip)Tj
-2.9 -1.6 TD
(coordinates.)Tj
/F13 1 Tf
0.1 -2.3 TD
(proxy texture)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A placeholder for a texture image, which is used to determine if there are enough resources to support a)Tj
T*
(texture image of a given size and internal format resolution.)Tj
/F13 1 Tf
0.1 -2.3 TD
(quadrilateral)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A polygon with four edges.)Tj
/F13 1 Tf
0.1 -2.3 TD
(rasterized)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Converted a projected point, line, or polygon, or the pixels of a bitmap or image, to fragments, each)Tj
T*
(corresponding to a pixel in the framebuffer. Note that all primitives are rasterized, not just points, lines,)Tj
T*
(and polygons.)Tj
ET
Q
endstream
endobj
1770 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1772 0 obj
<<
/Length 3071
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F13 1 Tf
10.000 0.000 0.000 10.000 125.000 705.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
(rectangle)Tj
/F11 1 Tf
-0.1 -1.5 TD
0.000 Tw
(A quadrilateral whose alternate edges are parallel to each other in object coordinates. Polygons specified)Tj
T*
(with )Tj
/F15 1 Tf
2 0 TD
(glRect*\(\))Tj
/F11 1 Tf
3.7 0 TD
( are always rectangles; other quadrilaterals might be rectangles.)Tj
/F13 1 Tf
-5.6 -2.3 TD
(rendering)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Conversion of primitives specified in object coordinates to an image in the framebuffer. Rendering is the)Tj
0 -1.6 TD
(primary operation of OpenGL)Tj
/F33 1 Tf
12 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(it's what OpenGL does.)Tj
/F13 1 Tf
-12.9 -2.4 TD
(resident texture)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A texture image that is cached in special, high-performance texture memory. If an OpenGL)Tj
T*
(implementation does not have special, high-performance texture memory, then all texture images are)Tj
T*
(deemed resident textures.)Tj
/F13 1 Tf
0.1 -2.3 TD
(RGBA)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Red, Green, Blue, Alpha.)Tj
/F13 1 Tf
0.1 -2.3 TD
(RGBA mode)Tj
/F11 1 Tf
-0.1 -1.5 TD
(An OpenGL context is in RGBA mode if its color buffers store red, green, blue, and alpha color)Tj
T*
(components, rather than color indices.)Tj
/F13 1 Tf
0.1 -2.3 TD
(server)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The computer on which OpenGL commands are executed. This might differ from the computer from)Tj
T*
[(which commands are issued. See )44(client)-78(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(shading)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The process of interpolating color within the interior of a polygon, or between the vertices of a line,)Tj
T*
(during rasterization.)Tj
/F13 1 Tf
0.1 -2.3 TD
(shininess)Tj
/F11 1 Tf
-0.1 -1.5 TD
[(The exponent associated with )10(specular)32( reflection and lighting. Shininess controls the degree with which)]TJ
T*
(the specular highlight decays.)Tj
/F13 1 Tf
0.1 -2.3 TD
(single-buffering)Tj
/F11 1 Tf
-0.1 -1.5 TD
(OpenGL contexts that don't have back color buffers are single-buffered. You can use these contexts for)Tj
T*
(animation, but take care to avoid visually disturbing flashes when rendering.)Tj
/F13 1 Tf
0.1 -2.3 TD
(singular matrix)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A matrix that has no inverse. Geometrically, such a matrix represents a transformation that collapses)Tj
T*
(points along at least one line to a single point.)Tj
/F13 1 Tf
0.1 -2.3 TD
(specular)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Specular lighting and reflection incorporates reflection off shiny objects and the position of the viewer.)Tj
T*
(Maximum specular reflectance occurs when the angle between the viewer and the direction of the)Tj
T*
(reflected light is zero. A specular material scatters light with greatest intensity in the direction of the)Tj
T*
[(reflection, and its brightness decays, based upon the exponential value )-13(shininess)-33(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(spotlight)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A special type of local light source that has a direction \(where it points to\) as well as a position. A)Tj
ET
Q
endstream
endobj
1773 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1775 0 obj
<<
/Length 3129
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 708.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(spotlight simulates a cone of light, which may have a fall-off in intensity, based upon distance from the)Tj
0 -1.5 TD
(center of the cone.)Tj
/F13 1 Tf
0.1 -2.3 TD
(stencil buffer)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Memory \(bitplanes\) that is used for additional per-fragment testing, along with the )Tj
33.2 0 TD
[(depth buffer)-84(. The)]TJ
-33.2 -1.5 TD
(stencil test may be used for masking regions, capping solid geometry, and overlapping translucent)Tj
T*
(polygons.)Tj
/F13 1 Tf
0.1 -2.3 TD
(stereo)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Enhanced three-dimensional perception of a rendered image by computing separate images for each eye.)Tj
T*
(Stereo requires special hardware, such as two synchronized monitors or special glasses to alternate)Tj
T*
(viewed frames for each eye. Some implementations of OpenGL support stereo by having both left and)Tj
T*
(right buffers for color data.)Tj
/F13 1 Tf
0.1 -2.3 TD
(stipple)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A one- or two-dimensional binary pattern that defeats the generation of fragments where its value is zero.)Tj
T*
(Line stipples are one-dimensional and are applied relative to the start of a line. Polygon stipples are)Tj
T*
(two-dimensional and are applied with a fixed orientation to the window.)Tj
/F13 1 Tf
0.1 -2.3 TD
(tessellation)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Reduction of a portion of an analytic surface to a mesh of polygons, or of a portion of an analytic curve)Tj
T*
(to a sequence of lines.)Tj
/F13 1 Tf
0.1 -2.3 TD
(texel)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A texture element. A texel is obtained from texture memory and represents the color of the texture to be)Tj
T*
(applied to a corresponding fragment.)Tj
/F13 1 Tf
0.1 -2.3 TD
(textures)Tj
/F11 1 Tf
-0.1 -1.5 TD
(One- or two-dimensional images that are used to modify the color of fragments produced by)Tj
T*
(rasterization.)Tj
/F13 1 Tf
0.1 -2.3 TD
(texture mapping)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The process of applying an image \(the texture\) to a primitive. Texture mapping is often used to add)Tj
T*
(realism to a scene. For example, you can apply a picture of a building facade to a polygon representing a)Tj
T*
(wall.)Tj
/F13 1 Tf
0.1 -2.3 TD
(texture matrix)Tj
/F11 1 Tf
-0.1 -1.6 TD
(The 4)Tj
/F33 1 Tf
2.3 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(4 matrix that transforms texture coordinates from the coordinates in which they're specified to the)Tj
-2.9 -1.5 TD
(coordinates that are used for interpolation and texture lookup.)Tj
/F13 1 Tf
0.1 -2.3 TD
(texture object)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A named cache that stores texture data, such as the image array, associated mipmaps, and associated)Tj
T*
(texture parameter values: width, height, border width, internal format, resolution of components,)Tj
T*
(minification and magnification filters, wrapping modes, border color, and texture priority.)Tj
/F13 1 Tf
0.1 -2.3 TD
(transformations)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The warping of spaces. In OpenGL, transformations are limited to projective transformations that include)Tj
ET
Q
endstream
endobj
1776 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1778 0 obj
<<
/Length 3439
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 710.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(anything that can be represented by a 4)Tj
/F33 1 Tf
15.6 0 TD
(\264)Tj
/F11 1 Tf
0.6 0 TD
(4 matrix. Such transformations include rotations, translations,)Tj
-16.2 -1.6 TD
(\(nonuniform\) scalings along the coordinate axes, perspective transformations, and combinations of these.)Tj
/F13 1 Tf
0.1 -2.3 TD
(triangle)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A polygon with three edges. Triangles are always convex.)Tj
/F13 1 Tf
0.1 -2.3 TD
(vertex)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A point in three-dimensional space.)Tj
/F13 1 Tf
0.1 -2.3 TD
(vertex array)Tj
/F11 1 Tf
-0.1 -1.5 TD
(Where a block of vertex data \(vertex coordinates, texture coordinates, surface normals, RGBA colors,)Tj
T*
(color indices, and edge flags\) may be stored in an array and then used to specify multiple geometric)Tj
T*
(primitives through the execution of a single OpenGL command.)Tj
/F13 1 Tf
0.1 -2.3 TD
(vertices)Tj
/F11 1 Tf
-0.1 -1.5 TD
[(Preferred plural of vertex. See )30(indices)-67(.)]TJ
/F13 1 Tf
0.1 -2.3 TD
(viewpoint)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The origin of either the eye- or the clip-coordinate system, depending on context. \(For example, when)Tj
T*
(discussing lighting, the viewpoint is the origin of the eye-coordinate system. When discussing projection,)Tj
T*
(the viewpoint is the origin of the clip-coordinate system.\) With a typical projection matrix, the)Tj
T*
(eye-coordinate and clip-coordinate origins are at the same location.)Tj
/F13 1 Tf
0.1 -2.3 TD
(view volume)Tj
/F11 1 Tf
-0.1 -1.5 TD
(The volume in clip coordinates whose coordinates satisfy the three conditions)Tj
0 -1.6 TD
(-w )Tj
/F33 1 Tf
1.3 0 TD
(\243)Tj
/F11 1 Tf
0.6 0 TD
( x )Tj
/F33 1 Tf
1 0 TD
(\243)Tj
/F11 1 Tf
0.5 0 TD
( w)Tj
-3.4 -1.7 TD
(-w )Tj
/F33 1 Tf
1.3 0 TD
(\243)Tj
/F11 1 Tf
0.6 0 TD
( y )Tj
/F33 1 Tf
1 0 TD
(\243)Tj
/F11 1 Tf
0.5 0 TD
( w)Tj
-3.4 -1.7 TD
(-w )Tj
/F33 1 Tf
1.3 0 TD
(\243)Tj
/F11 1 Tf
0.6 0 TD
( z )Tj
/F33 1 Tf
0.9 0 TD
(\243)Tj
/F11 1 Tf
0.5 0 TD
( w)Tj
-3.3 -1.5 TD
(Geometric primitives that extend outside this volume are clipped.)Tj
/F13 1 Tf
0.1 -2.3 TD
(VRML)Tj
/F11 1 Tf
-0.1 -1.5 TD
(VRML stands for Virtual Reality Modeling Language, which is \(according to the VRML Mission)Tj
T*
(Statement\) "a universal description language for multi-participant simulations." VRML is specifically)Tj
T*
(designed to allow people to navigate through three-dimensional worlds thatare placed on the World Wide)Tj
T*
(Web. The first versions of VRML are subsets of the Open Inventor file format with additions to allow)Tj
0 -1.7 TD
(hyperlinking to the Web \(to URLs)Tj
/F33 1 Tf
13.7 0 TD
(\276)Tj
/F11 1 Tf
1 0 TD
(Universal Resource Locators\).)Tj
/F13 1 Tf
-14.6 -2.3 TD
(window)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A subregion of the framebuffer, usually rectangular, whose pixels all have the same buffer configuration.)Tj
T*
(An OpenGL context renders to a single window at a time.)Tj
/F13 1 Tf
0.1 -2.3 TD
(window-aligned)Tj
/F11 1 Tf
-0.1 -1.5 TD
(When referring to line segments or polygon edges, implies that these are parallel to the window)Tj
T*
(boundaries. \(In OpenGL, the window is rectangular, with horizontal and vertical edges\). When referring)Tj
T*
(to a polygon pattern, implies that the pattern is fixed relative to the window origin.)Tj
/F13 1 Tf
0.1 -2.3 TD
(window coordinates)Tj
ET
Q
endstream
endobj
1779 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F33 12 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1781 0 obj
<<
/Length 1495
>>
stream
q
1 i 
40.000 720.000 532.000 -648.000 re
W n
BT
/F11 1 Tf
10.000 0.000 0.000 10.000 124.000 711.000 Tm
0.000 0.000 0.000 rg
/GS1 gs
0.000 Tc
0.000 Tw
(The coordinate system of a window. It's important to distinguish between the names of pixels, which are)Tj
0 -1.5 TD
(discrete, and the window-coordinate system, which is continuous. For example, the pixel at the lower-left)Tj
T*
(corner of a window is pixel \(0, 0\); the window coordinates of the center of this pixel are \(0.5, 0.5,)Tj
/F15 1 Tf
39 0 TD
( z)Tj
/F11 1 Tf
0.7 0 TD
(\).)Tj
-39.7 -1.5 TD
(Note that window coordinates include a depth, or )Tj
/F15 1 Tf
20 0 TD
(z)Tj
/F11 1 Tf
0.4 0 TD
(, component, and that this component is continuous as)Tj
-20.4 -1.5 TD
(well.)Tj
/F13 1 Tf
0.1 -2.3 TD
(wireframe)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A representation of an object that contains line segments only. Typically, the line segments indicate)Tj
T*
(polygon edges.)Tj
/F13 1 Tf
0.1 -2.3 TD
(working set)Tj
/F11 1 Tf
-0.1 -1.5 TD
(On machines with special hardware that increases texture performance, this is the group of texture)Tj
T*
(objects that are currently resident. The performance of textures within the working set outperforms the)Tj
T*
(textures outside the working set.)Tj
/F13 1 Tf
0.1 -2.3 TD
(X Window System)Tj
/F11 1 Tf
-0.1 -1.5 TD
(A window system used by many of the machines on which OpenGL is implemented. GLX is the name of)Tj
T*
[(the OpenGL extension to the X Window System. \(See )45(Appendix C)-38(.)0(\))]TJ
ET
Q
endstream
endobj
1782 0 obj
<<
/ProcSet [/PDF /Text ]
/Font <<
/F11 4 0 R
/F13 11 0 R
/F15 19 0 R
>>
/ExtGState <<
/GS1 6 0 R
>>
>>
endobj
1783 0 obj
<<
/Type /Halftone
/HalftoneType 1
/HalftoneName (Default)
/Frequency 60
/Angle 45
/SpotFunction /Round
>>
endobj
6 0 obj
<<
/Type /ExtGState
/SA false
/OP false
/HT /Default
/TR /Identity
>>
endobj
26 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F7
/Encoding 1784 0 R
/BaseFont /Courier
>>
endobj
4 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F11
/Encoding 1784 0 R
/BaseFont /Times-Roman
>>
endobj
11 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F13
/Encoding 1784 0 R
/BaseFont /Times-Bold
>>
endobj
19 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F15
/Encoding 1784 0 R
/BaseFont /Times-Italic
>>
endobj
1374 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F17
/Encoding 1784 0 R
/BaseFont /Times-BoldItalic
>>
endobj
5 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F27
/Encoding 1784 0 R
/BaseFont /Helvetica-Bold
>>
endobj
12 0 obj
<<
/Type /Font
/Subtype /Type1
/Name /F33
/Encoding 1785 0 R
/BaseFont /Symbol
>>
endobj
1784 0 obj
<<
/Type /Encoding
/Differences [ 45/minus 144/dotlessi/grave/acute/circumflex/tilde/macron/breve
/dotaccent/dieresis 154/ring/cedilla 157/hungarumlaut/ogonek/caron/space
 164/currency 166/brokenbar 168/dieresis/copyright/ordfeminine 172/logicalnot/hyphen/registered
/macron/degree/plusminus/twosuperior/threesuperior/acute/mu 183/periodcentered
/cedilla/onesuperior/ordmasculine 188/onequarter/onehalf/threequarters 192/Agrave/Aacute
/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla/Egrave/Eacute
/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis/Eth/Ntilde
/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/multiply/Oslash/Ugrave
/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls/agrave/aacute
/acircumflex/atilde/adieresis/aring/ae/ccedilla/egrave/eacute
/ecircumflex/edieresis/igrave/iacute/icircumflex/idieresis/eth/ntilde
/ograve/oacute/ocircumflex/otilde/odieresis/divide/oslash/ugrave
/uacute/ucircumflex/udieresis/yacute/thorn/ydieresis
]
>>
endobj
1785 0 obj
<<
/Type /Encoding
/Differences []
>>
endobj
1 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 3 0 R
/Contents 2 0 R
>>
endobj
8 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 10 0 R
/Contents 9 0 R
>>
endobj
13 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 15 0 R
/Contents 14 0 R
>>
endobj
16 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 18 0 R
/Contents 17 0 R
>>
endobj
20 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 22 0 R
/Contents 21 0 R
>>
endobj
23 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 25 0 R
/Contents 24 0 R
>>
endobj
27 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 29 0 R
/Contents 28 0 R
>>
endobj
30 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 32 0 R
/Contents 31 0 R
>>
endobj
33 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 35 0 R
/Contents 34 0 R
>>
endobj
36 0 obj
<<
/Type /Page
/Parent 7 0 R
/Resources 38 0 R
/Contents 37 0 R
>>
endobj
39 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 41 0 R
/Contents 40 0 R
>>
endobj
44 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 46 0 R
/Contents 45 0 R
>>
endobj
47 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 49 0 R
/Contents 48 0 R
>>
endobj
51 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 53 0 R
/Contents 52 0 R
>>
endobj
54 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 56 0 R
/Contents 55 0 R
>>
endobj
57 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 59 0 R
/Contents 58 0 R
>>
endobj
60 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 62 0 R
/Contents 61 0 R
>>
endobj
64 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 66 0 R
/Contents 65 0 R
>>
endobj
67 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 69 0 R
/Contents 68 0 R
>>
endobj
70 0 obj
<<
/Type /Page
/Parent 43 0 R
/Resources 72 0 R
/Contents 71 0 R
>>
endobj
73 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 75 0 R
/Contents 74 0 R
>>
endobj
77 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 79 0 R
/Contents 78 0 R
>>
endobj
80 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 82 0 R
/Contents 81 0 R
>>
endobj
83 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 85 0 R
/Contents 84 0 R
>>
endobj
86 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 88 0 R
/Contents 87 0 R
>>
endobj
89 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 91 0 R
/Contents 90 0 R
>>
endobj
93 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 95 0 R
/Contents 94 0 R
>>
endobj
96 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 98 0 R
/Contents 97 0 R
>>
endobj
99 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 101 0 R
/Contents 100 0 R
>>
endobj
102 0 obj
<<
/Type /Page
/Parent 76 0 R
/Resources 104 0 R
/Contents 103 0 R
>>
endobj
105 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 107 0 R
/Contents 106 0 R
>>
endobj
109 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 111 0 R
/Contents 110 0 R
>>
endobj
112 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 114 0 R
/Contents 113 0 R
>>
endobj
115 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 117 0 R
/Contents 116 0 R
>>
endobj
118 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 120 0 R
/Contents 119 0 R
>>
endobj
121 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 123 0 R
/Contents 122 0 R
>>
endobj
125 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 127 0 R
/Contents 126 0 R
>>
endobj
129 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 131 0 R
/Contents 130 0 R
>>
endobj
134 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 136 0 R
/Contents 135 0 R
>>
endobj
138 0 obj
<<
/Type /Page
/Parent 108 0 R
/Resources 140 0 R
/Contents 139 0 R
>>
endobj
142 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 144 0 R
/Contents 143 0 R
>>
endobj
146 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 148 0 R
/Contents 147 0 R
>>
endobj
150 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 152 0 R
/Contents 151 0 R
>>
endobj
153 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 155 0 R
/Contents 154 0 R
>>
endobj
156 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 158 0 R
/Contents 157 0 R
>>
endobj
159 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 161 0 R
/Contents 160 0 R
>>
endobj
162 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 164 0 R
/Contents 163 0 R
>>
endobj
165 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 167 0 R
/Contents 166 0 R
>>
endobj
170 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 172 0 R
/Contents 171 0 R
>>
endobj
173 0 obj
<<
/Type /Page
/Parent 145 0 R
/Resources 175 0 R
/Contents 174 0 R
>>
endobj
176 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 178 0 R
/Contents 177 0 R
>>
endobj
180 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 182 0 R
/Contents 181 0 R
>>
endobj
185 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 187 0 R
/Contents 186 0 R
>>
endobj
188 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 190 0 R
/Contents 189 0 R
>>
endobj
192 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 194 0 R
/Contents 193 0 R
>>
endobj
196 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 198 0 R
/Contents 197 0 R
>>
endobj
199 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 201 0 R
/Contents 200 0 R
>>
endobj
203 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 205 0 R
/Contents 204 0 R
>>
endobj
207 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 209 0 R
/Contents 208 0 R
>>
endobj
211 0 obj
<<
/Type /Page
/Parent 179 0 R
/Resources 213 0 R
/Contents 212 0 R
>>
endobj
215 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 217 0 R
/Contents 216 0 R
>>
endobj
219 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 221 0 R
/Contents 220 0 R
>>
endobj
222 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 224 0 R
/Contents 223 0 R
>>
endobj
225 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 227 0 R
/Contents 226 0 R
>>
endobj
228 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 230 0 R
/Contents 229 0 R
>>
endobj
232 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 234 0 R
/Contents 233 0 R
>>
endobj
235 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 237 0 R
/Contents 236 0 R
>>
endobj
238 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 240 0 R
/Contents 239 0 R
>>
endobj
241 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 243 0 R
/Contents 242 0 R
>>
endobj
244 0 obj
<<
/Type /Page
/Parent 218 0 R
/Resources 246 0 R
/Contents 245 0 R
>>
endobj
247 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 249 0 R
/Contents 248 0 R
>>
endobj
251 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 253 0 R
/Contents 252 0 R
>>
endobj
255 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 257 0 R
/Contents 256 0 R
>>
endobj
258 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 260 0 R
/Contents 259 0 R
>>
endobj
261 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 263 0 R
/Contents 262 0 R
>>
endobj
264 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 266 0 R
/Contents 265 0 R
>>
endobj
268 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 270 0 R
/Contents 269 0 R
>>
endobj
271 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 273 0 R
/Contents 272 0 R
>>
endobj
274 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 276 0 R
/Contents 275 0 R
>>
endobj
277 0 obj
<<
/Type /Page
/Parent 250 0 R
/Resources 279 0 R
/Contents 278 0 R
>>
endobj
280 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 282 0 R
/Contents 281 0 R
>>
endobj
284 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 286 0 R
/Contents 285 0 R
>>
endobj
288 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 290 0 R
/Contents 289 0 R
>>
endobj
292 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 294 0 R
/Contents 293 0 R
>>
endobj
296 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 298 0 R
/Contents 297 0 R
>>
endobj
299 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 301 0 R
/Contents 300 0 R
>>
endobj
302 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 304 0 R
/Contents 303 0 R
>>
endobj
305 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 307 0 R
/Contents 306 0 R
>>
endobj
308 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 310 0 R
/Contents 309 0 R
>>
endobj
312 0 obj
<<
/Type /Page
/Parent 283 0 R
/Resources 314 0 R
/Contents 313 0 R
>>
endobj
316 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 318 0 R
/Contents 317 0 R
>>
endobj
320 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 322 0 R
/Contents 321 0 R
>>
endobj
323 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 325 0 R
/Contents 324 0 R
>>
endobj
328 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 330 0 R
/Contents 329 0 R
>>
endobj
332 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 334 0 R
/Contents 333 0 R
>>
endobj
336 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 338 0 R
/Contents 337 0 R
>>
endobj
339 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 341 0 R
/Contents 340 0 R
>>
endobj
343 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 345 0 R
/Contents 344 0 R
>>
endobj
347 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 349 0 R
/Contents 348 0 R
>>
endobj
350 0 obj
<<
/Type /Page
/Parent 319 0 R
/Resources 352 0 R
/Contents 351 0 R
>>
endobj
355 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 357 0 R
/Contents 356 0 R
>>
endobj
360 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 362 0 R
/Contents 361 0 R
>>
endobj
363 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 365 0 R
/Contents 364 0 R
>>
endobj
367 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 369 0 R
/Contents 368 0 R
>>
endobj
371 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 373 0 R
/Contents 372 0 R
>>
endobj
375 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 377 0 R
/Contents 376 0 R
>>
endobj
378 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 380 0 R
/Contents 379 0 R
>>
endobj
382 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 384 0 R
/Contents 383 0 R
>>
endobj
386 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 388 0 R
/Contents 387 0 R
>>
endobj
390 0 obj
<<
/Type /Page
/Parent 359 0 R
/Resources 392 0 R
/Contents 391 0 R
>>
endobj
393 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 395 0 R
/Contents 394 0 R
>>
endobj
400 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 402 0 R
/Contents 401 0 R
>>
endobj
405 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 407 0 R
/Contents 406 0 R
>>
endobj
409 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 411 0 R
/Contents 410 0 R
>>
endobj
412 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 414 0 R
/Contents 413 0 R
>>
endobj
415 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 417 0 R
/Contents 416 0 R
>>
endobj
419 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 421 0 R
/Contents 420 0 R
>>
endobj
423 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 425 0 R
/Contents 424 0 R
>>
endobj
426 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 428 0 R
/Contents 427 0 R
>>
endobj
430 0 obj
<<
/Type /Page
/Parent 397 0 R
/Resources 432 0 R
/Contents 431 0 R
>>
endobj
433 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 435 0 R
/Contents 434 0 R
>>
endobj
437 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 439 0 R
/Contents 438 0 R
>>
endobj
441 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 443 0 R
/Contents 442 0 R
>>
endobj
444 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 446 0 R
/Contents 445 0 R
>>
endobj
447 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 449 0 R
/Contents 448 0 R
>>
endobj
451 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 453 0 R
/Contents 452 0 R
>>
endobj
454 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 456 0 R
/Contents 455 0 R
>>
endobj
457 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 459 0 R
/Contents 458 0 R
>>
endobj
460 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 462 0 R
/Contents 461 0 R
>>
endobj
463 0 obj
<<
/Type /Page
/Parent 436 0 R
/Resources 465 0 R
/Contents 464 0 R
>>
endobj
466 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 468 0 R
/Contents 467 0 R
>>
endobj
471 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 473 0 R
/Contents 472 0 R
>>
endobj
474 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 476 0 R
/Contents 475 0 R
>>
endobj
478 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 480 0 R
/Contents 479 0 R
>>
endobj
482 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 484 0 R
/Contents 483 0 R
>>
endobj
487 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 489 0 R
/Contents 488 0 R
>>
endobj
490 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 492 0 R
/Contents 491 0 R
>>
endobj
493 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 495 0 R
/Contents 494 0 R
>>
endobj
496 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 498 0 R
/Contents 497 0 R
>>
endobj
499 0 obj
<<
/Type /Page
/Parent 469 0 R
/Resources 501 0 R
/Contents 500 0 R
>>
endobj
502 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 504 0 R
/Contents 503 0 R
>>
endobj
506 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 508 0 R
/Contents 507 0 R
>>
endobj
510 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 512 0 R
/Contents 511 0 R
>>
endobj
513 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 515 0 R
/Contents 514 0 R
>>
endobj
516 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 518 0 R
/Contents 517 0 R
>>
endobj
519 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 521 0 R
/Contents 520 0 R
>>
endobj
522 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 524 0 R
/Contents 523 0 R
>>
endobj
525 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 527 0 R
/Contents 526 0 R
>>
endobj
528 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 530 0 R
/Contents 529 0 R
>>
endobj
531 0 obj
<<
/Type /Page
/Parent 505 0 R
/Resources 533 0 R
/Contents 532 0 R
>>
endobj
534 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 536 0 R
/Contents 535 0 R
>>
endobj
538 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 540 0 R
/Contents 539 0 R
>>
endobj
542 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 544 0 R
/Contents 543 0 R
>>
endobj
546 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 548 0 R
/Contents 547 0 R
>>
endobj
549 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 551 0 R
/Contents 550 0 R
>>
endobj
552 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 554 0 R
/Contents 553 0 R
>>
endobj
555 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 557 0 R
/Contents 556 0 R
>>
endobj
558 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 560 0 R
/Contents 559 0 R
>>
endobj
561 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 563 0 R
/Contents 562 0 R
>>
endobj
564 0 obj
<<
/Type /Page
/Parent 537 0 R
/Resources 566 0 R
/Contents 565 0 R
>>
endobj
567 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 569 0 R
/Contents 568 0 R
>>
endobj
571 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 573 0 R
/Contents 572 0 R
>>
endobj
574 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 576 0 R
/Contents 575 0 R
>>
endobj
577 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 579 0 R
/Contents 578 0 R
>>
endobj
580 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 582 0 R
/Contents 581 0 R
>>
endobj
583 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 585 0 R
/Contents 584 0 R
>>
endobj
586 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 588 0 R
/Contents 587 0 R
>>
endobj
589 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 591 0 R
/Contents 590 0 R
>>
endobj
592 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 594 0 R
/Contents 593 0 R
>>
endobj
595 0 obj
<<
/Type /Page
/Parent 570 0 R
/Resources 597 0 R
/Contents 596 0 R
>>
endobj
598 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 600 0 R
/Contents 599 0 R
>>
endobj
603 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 605 0 R
/Contents 604 0 R
>>
endobj
606 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 608 0 R
/Contents 607 0 R
>>
endobj
610 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 612 0 R
/Contents 611 0 R
>>
endobj
613 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 615 0 R
/Contents 614 0 R
>>
endobj
616 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 618 0 R
/Contents 617 0 R
>>
endobj
619 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 621 0 R
/Contents 620 0 R
>>
endobj
622 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 624 0 R
/Contents 623 0 R
>>
endobj
625 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 627 0 R
/Contents 626 0 R
>>
endobj
628 0 obj
<<
/Type /Page
/Parent 601 0 R
/Resources 630 0 R
/Contents 629 0 R
>>
endobj
632 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 634 0 R
/Contents 633 0 R
>>
endobj
636 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 638 0 R
/Contents 637 0 R
>>
endobj
639 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 641 0 R
/Contents 640 0 R
>>
endobj
642 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 644 0 R
/Contents 643 0 R
>>
endobj
645 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 647 0 R
/Contents 646 0 R
>>
endobj
648 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 650 0 R
/Contents 649 0 R
>>
endobj
651 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 653 0 R
/Contents 652 0 R
>>
endobj
655 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 657 0 R
/Contents 656 0 R
>>
endobj
659 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 661 0 R
/Contents 660 0 R
>>
endobj
662 0 obj
<<
/Type /Page
/Parent 635 0 R
/Resources 664 0 R
/Contents 663 0 R
>>
endobj
665 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 667 0 R
/Contents 666 0 R
>>
endobj
669 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 671 0 R
/Contents 670 0 R
>>
endobj
672 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 674 0 R
/Contents 673 0 R
>>
endobj
675 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 677 0 R
/Contents 676 0 R
>>
endobj
678 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 680 0 R
/Contents 679 0 R
>>
endobj
681 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 683 0 R
/Contents 682 0 R
>>
endobj
684 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 686 0 R
/Contents 685 0 R
>>
endobj
687 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 689 0 R
/Contents 688 0 R
>>
endobj
690 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 692 0 R
/Contents 691 0 R
>>
endobj
693 0 obj
<<
/Type /Page
/Parent 668 0 R
/Resources 695 0 R
/Contents 694 0 R
>>
endobj
696 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 698 0 R
/Contents 697 0 R
>>
endobj
700 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 702 0 R
/Contents 701 0 R
>>
endobj
704 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 706 0 R
/Contents 705 0 R
>>
endobj
708 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 710 0 R
/Contents 709 0 R
>>
endobj
711 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 713 0 R
/Contents 712 0 R
>>
endobj
714 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 716 0 R
/Contents 715 0 R
>>
endobj
717 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 719 0 R
/Contents 718 0 R
>>
endobj
722 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 724 0 R
/Contents 723 0 R
>>
endobj
725 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 727 0 R
/Contents 726 0 R
>>
endobj
728 0 obj
<<
/Type /Page
/Parent 699 0 R
/Resources 730 0 R
/Contents 729 0 R
>>
endobj
731 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 733 0 R
/Contents 732 0 R
>>
endobj
736 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 738 0 R
/Contents 737 0 R
>>
endobj
739 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 741 0 R
/Contents 740 0 R
>>
endobj
742 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 744 0 R
/Contents 743 0 R
>>
endobj
745 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 747 0 R
/Contents 746 0 R
>>
endobj
748 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 750 0 R
/Contents 749 0 R
>>
endobj
751 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 753 0 R
/Contents 752 0 R
>>
endobj
754 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 756 0 R
/Contents 755 0 R
>>
endobj
757 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 759 0 R
/Contents 758 0 R
>>
endobj
760 0 obj
<<
/Type /Page
/Parent 735 0 R
/Resources 762 0 R
/Contents 761 0 R
>>
endobj
763 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 765 0 R
/Contents 764 0 R
>>
endobj
767 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 769 0 R
/Contents 768 0 R
>>
endobj
770 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 772 0 R
/Contents 771 0 R
>>
endobj
774 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 776 0 R
/Contents 775 0 R
>>
endobj
777 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 779 0 R
/Contents 778 0 R
>>
endobj
780 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 782 0 R
/Contents 781 0 R
>>
endobj
783 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 785 0 R
/Contents 784 0 R
>>
endobj
786 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 788 0 R
/Contents 787 0 R
>>
endobj
789 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 791 0 R
/Contents 790 0 R
>>
endobj
792 0 obj
<<
/Type /Page
/Parent 766 0 R
/Resources 794 0 R
/Contents 793 0 R
>>
endobj
795 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 797 0 R
/Contents 796 0 R
>>
endobj
800 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 802 0 R
/Contents 801 0 R
>>
endobj
803 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 805 0 R
/Contents 804 0 R
>>
endobj
806 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 808 0 R
/Contents 807 0 R
>>
endobj
810 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 812 0 R
/Contents 811 0 R
>>
endobj
813 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 815 0 R
/Contents 814 0 R
>>
endobj
816 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 818 0 R
/Contents 817 0 R
>>
endobj
819 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 821 0 R
/Contents 820 0 R
>>
endobj
822 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 824 0 R
/Contents 823 0 R
>>
endobj
825 0 obj
<<
/Type /Page
/Parent 798 0 R
/Resources 827 0 R
/Contents 826 0 R
>>
endobj
828 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 830 0 R
/Contents 829 0 R
>>
endobj
833 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 835 0 R
/Contents 834 0 R
>>
endobj
836 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 838 0 R
/Contents 837 0 R
>>
endobj
839 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 841 0 R
/Contents 840 0 R
>>
endobj
842 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 844 0 R
/Contents 843 0 R
>>
endobj
846 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 848 0 R
/Contents 847 0 R
>>
endobj
852 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 854 0 R
/Contents 853 0 R
>>
endobj
856 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 858 0 R
/Contents 857 0 R
>>
endobj
859 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 861 0 R
/Contents 860 0 R
>>
endobj
863 0 obj
<<
/Type /Page
/Parent 831 0 R
/Resources 865 0 R
/Contents 864 0 R
>>
endobj
866 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 868 0 R
/Contents 867 0 R
>>
endobj
870 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 872 0 R
/Contents 871 0 R
>>
endobj
873 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 875 0 R
/Contents 874 0 R
>>
endobj
876 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 878 0 R
/Contents 877 0 R
>>
endobj
879 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 881 0 R
/Contents 880 0 R
>>
endobj
882 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 884 0 R
/Contents 883 0 R
>>
endobj
886 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 888 0 R
/Contents 887 0 R
>>
endobj
889 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 891 0 R
/Contents 890 0 R
>>
endobj
893 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 895 0 R
/Contents 894 0 R
>>
endobj
896 0 obj
<<
/Type /Page
/Parent 869 0 R
/Resources 898 0 R
/Contents 897 0 R
>>
endobj
899 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 901 0 R
/Contents 900 0 R
>>
endobj
903 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 905 0 R
/Contents 904 0 R
>>
endobj
907 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 909 0 R
/Contents 908 0 R
>>
endobj
910 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 912 0 R
/Contents 911 0 R
>>
endobj
913 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 915 0 R
/Contents 914 0 R
>>
endobj
916 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 918 0 R
/Contents 917 0 R
>>
endobj
920 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 922 0 R
/Contents 921 0 R
>>
endobj
923 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 925 0 R
/Contents 924 0 R
>>
endobj
926 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 928 0 R
/Contents 927 0 R
>>
endobj
929 0 obj
<<
/Type /Page
/Parent 902 0 R
/Resources 931 0 R
/Contents 930 0 R
>>
endobj
932 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 934 0 R
/Contents 933 0 R
>>
endobj
936 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 938 0 R
/Contents 937 0 R
>>
endobj
939 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 941 0 R
/Contents 940 0 R
>>
endobj
942 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 944 0 R
/Contents 943 0 R
>>
endobj
946 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 948 0 R
/Contents 947 0 R
>>
endobj
949 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 951 0 R
/Contents 950 0 R
>>
endobj
952 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 954 0 R
/Contents 953 0 R
>>
endobj
955 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 957 0 R
/Contents 956 0 R
>>
endobj
959 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 961 0 R
/Contents 960 0 R
>>
endobj
962 0 obj
<<
/Type /Page
/Parent 935 0 R
/Resources 964 0 R
/Contents 963 0 R
>>
endobj
965 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 967 0 R
/Contents 966 0 R
>>
endobj
969 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 971 0 R
/Contents 970 0 R
>>
endobj
972 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 974 0 R
/Contents 973 0 R
>>
endobj
976 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 978 0 R
/Contents 977 0 R
>>
endobj
979 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 981 0 R
/Contents 980 0 R
>>
endobj
982 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 984 0 R
/Contents 983 0 R
>>
endobj
985 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 987 0 R
/Contents 986 0 R
>>
endobj
988 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 990 0 R
/Contents 989 0 R
>>
endobj
991 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 993 0 R
/Contents 992 0 R
>>
endobj
994 0 obj
<<
/Type /Page
/Parent 968 0 R
/Resources 996 0 R
/Contents 995 0 R
>>
endobj
997 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 999 0 R
/Contents 998 0 R
>>
endobj
1001 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1003 0 R
/Contents 1002 0 R
>>
endobj
1004 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1006 0 R
/Contents 1005 0 R
>>
endobj
1007 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1009 0 R
/Contents 1008 0 R
>>
endobj
1011 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1013 0 R
/Contents 1012 0 R
>>
endobj
1014 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1016 0 R
/Contents 1015 0 R
>>
endobj
1019 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1021 0 R
/Contents 1020 0 R
>>
endobj
1023 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1025 0 R
/Contents 1024 0 R
>>
endobj
1026 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1028 0 R
/Contents 1027 0 R
>>
endobj
1029 0 obj
<<
/Type /Page
/Parent 1000 0 R
/Resources 1031 0 R
/Contents 1030 0 R
>>
endobj
1032 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1034 0 R
/Contents 1033 0 R
>>
endobj
1036 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1038 0 R
/Contents 1037 0 R
>>
endobj
1039 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1041 0 R
/Contents 1040 0 R
>>
endobj
1042 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1044 0 R
/Contents 1043 0 R
>>
endobj
1047 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1049 0 R
/Contents 1048 0 R
>>
endobj
1050 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1052 0 R
/Contents 1051 0 R
>>
endobj
1053 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1055 0 R
/Contents 1054 0 R
>>
endobj
1057 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1059 0 R
/Contents 1058 0 R
>>
endobj
1060 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1062 0 R
/Contents 1061 0 R
>>
endobj
1063 0 obj
<<
/Type /Page
/Parent 1035 0 R
/Resources 1065 0 R
/Contents 1064 0 R
>>
endobj
1066 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1068 0 R
/Contents 1067 0 R
>>
endobj
1071 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1073 0 R
/Contents 1072 0 R
>>
endobj
1074 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1076 0 R
/Contents 1075 0 R
>>
endobj
1077 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1079 0 R
/Contents 1078 0 R
>>
endobj
1080 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1082 0 R
/Contents 1081 0 R
>>
endobj
1083 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1085 0 R
/Contents 1084 0 R
>>
endobj
1086 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1088 0 R
/Contents 1087 0 R
>>
endobj
1089 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1091 0 R
/Contents 1090 0 R
>>
endobj
1092 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1094 0 R
/Contents 1093 0 R
>>
endobj
1095 0 obj
<<
/Type /Page
/Parent 1070 0 R
/Resources 1097 0 R
/Contents 1096 0 R
>>
endobj
1098 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1100 0 R
/Contents 1099 0 R
>>
endobj
1102 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1104 0 R
/Contents 1103 0 R
>>
endobj
1105 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1107 0 R
/Contents 1106 0 R
>>
endobj
1108 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1110 0 R
/Contents 1109 0 R
>>
endobj
1111 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1113 0 R
/Contents 1112 0 R
>>
endobj
1114 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1116 0 R
/Contents 1115 0 R
>>
endobj
1117 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1119 0 R
/Contents 1118 0 R
>>
endobj
1120 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1122 0 R
/Contents 1121 0 R
>>
endobj
1123 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1125 0 R
/Contents 1124 0 R
>>
endobj
1127 0 obj
<<
/Type /Page
/Parent 1101 0 R
/Resources 1129 0 R
/Contents 1128 0 R
>>
endobj
1131 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1133 0 R
/Contents 1132 0 R
>>
endobj
1135 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1137 0 R
/Contents 1136 0 R
>>
endobj
1138 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1140 0 R
/Contents 1139 0 R
>>
endobj
1141 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1143 0 R
/Contents 1142 0 R
>>
endobj
1144 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1146 0 R
/Contents 1145 0 R
>>
endobj
1147 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1149 0 R
/Contents 1148 0 R
>>
endobj
1151 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1153 0 R
/Contents 1152 0 R
>>
endobj
1154 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1156 0 R
/Contents 1155 0 R
>>
endobj
1157 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1159 0 R
/Contents 1158 0 R
>>
endobj
1160 0 obj
<<
/Type /Page
/Parent 1134 0 R
/Resources 1162 0 R
/Contents 1161 0 R
>>
endobj
1163 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1165 0 R
/Contents 1164 0 R
>>
endobj
1167 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1169 0 R
/Contents 1168 0 R
>>
endobj
1171 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1173 0 R
/Contents 1172 0 R
>>
endobj
1175 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1177 0 R
/Contents 1176 0 R
>>
endobj
1178 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1180 0 R
/Contents 1179 0 R
>>
endobj
1181 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1183 0 R
/Contents 1182 0 R
>>
endobj
1184 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1186 0 R
/Contents 1185 0 R
>>
endobj
1187 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1189 0 R
/Contents 1188 0 R
>>
endobj
1190 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1192 0 R
/Contents 1191 0 R
>>
endobj
1193 0 obj
<<
/Type /Page
/Parent 1166 0 R
/Resources 1195 0 R
/Contents 1194 0 R
>>
endobj
1196 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1198 0 R
/Contents 1197 0 R
>>
endobj
1200 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1202 0 R
/Contents 1201 0 R
>>
endobj
1203 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1205 0 R
/Contents 1204 0 R
>>
endobj
1206 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1208 0 R
/Contents 1207 0 R
>>
endobj
1209 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1211 0 R
/Contents 1210 0 R
>>
endobj
1212 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1214 0 R
/Contents 1213 0 R
>>
endobj
1215 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1217 0 R
/Contents 1216 0 R
>>
endobj
1218 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1220 0 R
/Contents 1219 0 R
>>
endobj
1221 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1223 0 R
/Contents 1222 0 R
>>
endobj
1225 0 obj
<<
/Type /Page
/Parent 1199 0 R
/Resources 1227 0 R
/Contents 1226 0 R
>>
endobj
1228 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1230 0 R
/Contents 1229 0 R
>>
endobj
1233 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1235 0 R
/Contents 1234 0 R
>>
endobj
1238 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1240 0 R
/Contents 1239 0 R
>>
endobj
1241 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1243 0 R
/Contents 1242 0 R
>>
endobj
1245 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1247 0 R
/Contents 1246 0 R
>>
endobj
1249 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1251 0 R
/Contents 1250 0 R
>>
endobj
1252 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1254 0 R
/Contents 1253 0 R
>>
endobj
1256 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1258 0 R
/Contents 1257 0 R
>>
endobj
1259 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1261 0 R
/Contents 1260 0 R
>>
endobj
1262 0 obj
<<
/Type /Page
/Parent 1231 0 R
/Resources 1264 0 R
/Contents 1263 0 R
>>
endobj
1265 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1267 0 R
/Contents 1266 0 R
>>
endobj
1269 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1271 0 R
/Contents 1270 0 R
>>
endobj
1273 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1275 0 R
/Contents 1274 0 R
>>
endobj
1276 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1278 0 R
/Contents 1277 0 R
>>
endobj
1279 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1281 0 R
/Contents 1280 0 R
>>
endobj
1282 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1284 0 R
/Contents 1283 0 R
>>
endobj
1285 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1287 0 R
/Contents 1286 0 R
>>
endobj
1288 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1290 0 R
/Contents 1289 0 R
>>
endobj
1291 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1293 0 R
/Contents 1292 0 R
>>
endobj
1294 0 obj
<<
/Type /Page
/Parent 1268 0 R
/Resources 1296 0 R
/Contents 1295 0 R
>>
endobj
1299 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1301 0 R
/Contents 1300 0 R
>>
endobj
1303 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1305 0 R
/Contents 1304 0 R
>>
endobj
1306 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1308 0 R
/Contents 1307 0 R
>>
endobj
1309 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1311 0 R
/Contents 1310 0 R
>>
endobj
1312 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1314 0 R
/Contents 1313 0 R
>>
endobj
1315 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1317 0 R
/Contents 1316 0 R
>>
endobj
1318 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1320 0 R
/Contents 1319 0 R
>>
endobj
1321 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1323 0 R
/Contents 1322 0 R
>>
endobj
1324 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1326 0 R
/Contents 1325 0 R
>>
endobj
1327 0 obj
<<
/Type /Page
/Parent 1302 0 R
/Resources 1329 0 R
/Contents 1328 0 R
>>
endobj
1330 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1332 0 R
/Contents 1331 0 R
>>
endobj
1334 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1336 0 R
/Contents 1335 0 R
>>
endobj
1337 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1339 0 R
/Contents 1338 0 R
>>
endobj
1340 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1342 0 R
/Contents 1341 0 R
>>
endobj
1343 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1345 0 R
/Contents 1344 0 R
>>
endobj
1346 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1348 0 R
/Contents 1347 0 R
>>
endobj
1349 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1351 0 R
/Contents 1350 0 R
>>
endobj
1352 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1354 0 R
/Contents 1353 0 R
>>
endobj
1355 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1357 0 R
/Contents 1356 0 R
>>
endobj
1358 0 obj
<<
/Type /Page
/Parent 1333 0 R
/Resources 1360 0 R
/Contents 1359 0 R
>>
endobj
1361 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1363 0 R
/Contents 1362 0 R
>>
endobj
1365 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1367 0 R
/Contents 1366 0 R
>>
endobj
1368 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1370 0 R
/Contents 1369 0 R
>>
endobj
1371 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1373 0 R
/Contents 1372 0 R
>>
endobj
1375 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1377 0 R
/Contents 1376 0 R
>>
endobj
1378 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1380 0 R
/Contents 1379 0 R
>>
endobj
1381 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1383 0 R
/Contents 1382 0 R
>>
endobj
1384 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1386 0 R
/Contents 1385 0 R
>>
endobj
1387 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1389 0 R
/Contents 1388 0 R
>>
endobj
1390 0 obj
<<
/Type /Page
/Parent 1364 0 R
/Resources 1392 0 R
/Contents 1391 0 R
>>
endobj
1393 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1395 0 R
/Contents 1394 0 R
>>
endobj
1398 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1400 0 R
/Contents 1399 0 R
>>
endobj
1401 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1403 0 R
/Contents 1402 0 R
>>
endobj
1404 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1406 0 R
/Contents 1405 0 R
>>
endobj
1407 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1409 0 R
/Contents 1408 0 R
>>
endobj
1410 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1412 0 R
/Contents 1411 0 R
>>
endobj
1413 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1415 0 R
/Contents 1414 0 R
>>
endobj
1416 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1418 0 R
/Contents 1417 0 R
>>
endobj
1420 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1422 0 R
/Contents 1421 0 R
>>
endobj
1423 0 obj
<<
/Type /Page
/Parent 1397 0 R
/Resources 1425 0 R
/Contents 1424 0 R
>>
endobj
1428 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1430 0 R
/Contents 1429 0 R
>>
endobj
1432 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1434 0 R
/Contents 1433 0 R
>>
endobj
1436 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1438 0 R
/Contents 1437 0 R
>>
endobj
1439 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1441 0 R
/Contents 1440 0 R
>>
endobj
1443 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1445 0 R
/Contents 1444 0 R
>>
endobj
1447 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1449 0 R
/Contents 1448 0 R
>>
endobj
1450 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1452 0 R
/Contents 1451 0 R
>>
endobj
1453 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1455 0 R
/Contents 1454 0 R
>>
endobj
1457 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1459 0 R
/Contents 1458 0 R
>>
endobj
1461 0 obj
<<
/Type /Page
/Parent 1431 0 R
/Resources 1463 0 R
/Contents 1462 0 R
>>
endobj
1464 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1466 0 R
/Contents 1465 0 R
>>
endobj
1469 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1471 0 R
/Contents 1470 0 R
>>
endobj
1472 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1474 0 R
/Contents 1473 0 R
>>
endobj
1475 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1477 0 R
/Contents 1476 0 R
>>
endobj
1478 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1480 0 R
/Contents 1479 0 R
>>
endobj
1481 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1483 0 R
/Contents 1482 0 R
>>
endobj
1484 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1486 0 R
/Contents 1485 0 R
>>
endobj
1487 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1489 0 R
/Contents 1488 0 R
>>
endobj
1490 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1492 0 R
/Contents 1491 0 R
>>
endobj
1493 0 obj
<<
/Type /Page
/Parent 1467 0 R
/Resources 1495 0 R
/Contents 1494 0 R
>>
endobj
1496 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1498 0 R
/Contents 1497 0 R
>>
endobj
1500 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1502 0 R
/Contents 1501 0 R
>>
endobj
1503 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1505 0 R
/Contents 1504 0 R
>>
endobj
1506 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1508 0 R
/Contents 1507 0 R
>>
endobj
1509 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1511 0 R
/Contents 1510 0 R
>>
endobj
1512 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1514 0 R
/Contents 1513 0 R
>>
endobj
1515 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1517 0 R
/Contents 1516 0 R
>>
endobj
1518 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1520 0 R
/Contents 1519 0 R
>>
endobj
1521 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1523 0 R
/Contents 1522 0 R
>>
endobj
1524 0 obj
<<
/Type /Page
/Parent 1499 0 R
/Resources 1526 0 R
/Contents 1525 0 R
>>
endobj
1527 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1529 0 R
/Contents 1528 0 R
>>
endobj
1531 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1533 0 R
/Contents 1532 0 R
>>
endobj
1534 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1536 0 R
/Contents 1535 0 R
>>
endobj
1537 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1539 0 R
/Contents 1538 0 R
>>
endobj
1540 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1542 0 R
/Contents 1541 0 R
>>
endobj
1543 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1545 0 R
/Contents 1544 0 R
>>
endobj
1546 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1548 0 R
/Contents 1547 0 R
>>
endobj
1549 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1551 0 R
/Contents 1550 0 R
>>
endobj
1552 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1554 0 R
/Contents 1553 0 R
>>
endobj
1555 0 obj
<<
/Type /Page
/Parent 1530 0 R
/Resources 1557 0 R
/Contents 1556 0 R
>>
endobj
1558 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1560 0 R
/Contents 1559 0 R
>>
endobj
1562 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1564 0 R
/Contents 1563 0 R
>>
endobj
1566 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1568 0 R
/Contents 1567 0 R
>>
endobj
1574 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1576 0 R
/Contents 1575 0 R
>>
endobj
1582 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1584 0 R
/Contents 1583 0 R
>>
endobj
1586 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1588 0 R
/Contents 1587 0 R
>>
endobj
1589 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1591 0 R
/Contents 1590 0 R
>>
endobj
1592 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1594 0 R
/Contents 1593 0 R
>>
endobj
1595 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1597 0 R
/Contents 1596 0 R
>>
endobj
1602 0 obj
<<
/Type /Page
/Parent 1561 0 R
/Resources 1604 0 R
/Contents 1603 0 R
>>
endobj
1607 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1609 0 R
/Contents 1608 0 R
>>
endobj
1612 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1614 0 R
/Contents 1613 0 R
>>
endobj
1615 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1617 0 R
/Contents 1616 0 R
>>
endobj
1618 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1620 0 R
/Contents 1619 0 R
>>
endobj
1621 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1623 0 R
/Contents 1622 0 R
>>
endobj
1624 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1626 0 R
/Contents 1625 0 R
>>
endobj
1627 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1629 0 R
/Contents 1628 0 R
>>
endobj
1630 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1632 0 R
/Contents 1631 0 R
>>
endobj
1634 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1636 0 R
/Contents 1635 0 R
>>
endobj
1638 0 obj
<<
/Type /Page
/Parent 1610 0 R
/Resources 1640 0 R
/Contents 1639 0 R
>>
endobj
1642 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1644 0 R
/Contents 1643 0 R
>>
endobj
1647 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1649 0 R
/Contents 1648 0 R
>>
endobj
1651 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1653 0 R
/Contents 1652 0 R
>>
endobj
1655 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1657 0 R
/Contents 1656 0 R
>>
endobj
1659 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1661 0 R
/Contents 1660 0 R
>>
endobj
1663 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1665 0 R
/Contents 1664 0 R
>>
endobj
1668 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1670 0 R
/Contents 1669 0 R
>>
endobj
1673 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1675 0 R
/Contents 1674 0 R
>>
endobj
1677 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1679 0 R
/Contents 1678 0 R
>>
endobj
1682 0 obj
<<
/Type /Page
/Parent 1645 0 R
/Resources 1684 0 R
/Contents 1683 0 R
>>
endobj
1686 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1688 0 R
/Contents 1687 0 R
>>
endobj
1691 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1693 0 R
/Contents 1692 0 R
>>
endobj
1696 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1698 0 R
/Contents 1697 0 R
>>
endobj
1700 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1702 0 R
/Contents 1701 0 R
>>
endobj
1704 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1706 0 R
/Contents 1705 0 R
>>
endobj
1709 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1711 0 R
/Contents 1710 0 R
>>
endobj
1713 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1715 0 R
/Contents 1714 0 R
>>
endobj
1717 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1719 0 R
/Contents 1718 0 R
>>
endobj
1721 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1723 0 R
/Contents 1722 0 R
>>
endobj
1726 0 obj
<<
/Type /Page
/Parent 1689 0 R
/Resources 1728 0 R
/Contents 1727 0 R
>>
endobj
1731 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1733 0 R
/Contents 1732 0 R
>>
endobj
1736 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1738 0 R
/Contents 1737 0 R
>>
endobj
1739 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1741 0 R
/Contents 1740 0 R
>>
endobj
1742 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1744 0 R
/Contents 1743 0 R
>>
endobj
1745 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1747 0 R
/Contents 1746 0 R
>>
endobj
1748 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1750 0 R
/Contents 1749 0 R
>>
endobj
1751 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1753 0 R
/Contents 1752 0 R
>>
endobj
1754 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1756 0 R
/Contents 1755 0 R
>>
endobj
1757 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1759 0 R
/Contents 1758 0 R
>>
endobj
1760 0 obj
<<
/Type /Page
/Parent 1734 0 R
/Resources 1762 0 R
/Contents 1761 0 R
>>
endobj
1763 0 obj
<<
/Type /Page
/Parent 1767 0 R
/Resources 1765 0 R
/Contents 1764 0 R
>>
endobj
1768 0 obj
<<
/Type /Page
/Parent 1767 0 R
/Resources 1770 0 R
/Contents 1769 0 R
>>
endobj
1771 0 obj
<<
/Type /Page
/Parent 1767 0 R
/Resources 1773 0 R
/Contents 1772 0 R
>>
endobj
1774 0 obj
<<
/Type /Page
/Parent 1767 0 R
/Resources 1776 0 R
/Contents 1775 0 R
>>
endobj
1777 0 obj
<<
/Type /Page
/Parent 1767 0 R
/Resources 1779 0 R
/Contents 1778 0 R
>>
endobj
1780 0 obj
<<
/Type /Page
/Parent 1767 0 R
/Resources 1782 0 R
/Contents 1781 0 R
>>
endobj
7 0 obj
<<
/Type /Pages
/Kids [1 0 R 8 0 R 13 0 R 16 0 R 20 0 R 23 0 R 27 0 R 30 0 R 33 0 R 36 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
43 0 obj
<<
/Type /Pages
/Kids [39 0 R 44 0 R 47 0 R 51 0 R 54 0 R 57 0 R 60 0 R 64 0 R 67 0 R 70 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
76 0 obj
<<
/Type /Pages
/Kids [73 0 R 77 0 R 80 0 R 83 0 R 86 0 R 89 0 R 93 0 R 96 0 R 99 0 R 102 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
108 0 obj
<<
/Type /Pages
/Kids [105 0 R 109 0 R 112 0 R 115 0 R 118 0 R 121 0 R 125 0 R 129 0 R 134 0 R 138 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
145 0 obj
<<
/Type /Pages
/Kids [142 0 R 146 0 R 150 0 R 153 0 R 156 0 R 159 0 R 162 0 R 165 0 R 170 0 R 173 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
179 0 obj
<<
/Type /Pages
/Kids [176 0 R 180 0 R 185 0 R 188 0 R 192 0 R 196 0 R 199 0 R 203 0 R 207 0 R 211 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
218 0 obj
<<
/Type /Pages
/Kids [215 0 R 219 0 R 222 0 R 225 0 R 228 0 R 232 0 R 235 0 R 238 0 R 241 0 R 244 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
250 0 obj
<<
/Type /Pages
/Kids [247 0 R 251 0 R 255 0 R 258 0 R 261 0 R 264 0 R 268 0 R 271 0 R 274 0 R 277 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
283 0 obj
<<
/Type /Pages
/Kids [280 0 R 284 0 R 288 0 R 292 0 R 296 0 R 299 0 R 302 0 R 305 0 R 308 0 R 312 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
319 0 obj
<<
/Type /Pages
/Kids [316 0 R 320 0 R 323 0 R 328 0 R 332 0 R 336 0 R 339 0 R 343 0 R 347 0 R 350 0 R]
/Count 10
/Parent 42 0 R
>>
endobj
42 0 obj
<<
/Type /Pages
/Kids [7 0 R 43 0 R 76 0 R 108 0 R 145 0 R 179 0 R 218 0 R 250 0 R 283 0 R 319 0 R ]
/Count 100
/Parent 358 0 R
>>
endobj
359 0 obj
<<
/Type /Pages
/Kids [355 0 R 360 0 R 363 0 R 367 0 R 371 0 R 375 0 R 378 0 R 382 0 R 386 0 R 390 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
397 0 obj
<<
/Type /Pages
/Kids [393 0 R 400 0 R 405 0 R 409 0 R 412 0 R 415 0 R 419 0 R 423 0 R 426 0 R 430 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
436 0 obj
<<
/Type /Pages
/Kids [433 0 R 437 0 R 441 0 R 444 0 R 447 0 R 451 0 R 454 0 R 457 0 R 460 0 R 463 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
469 0 obj
<<
/Type /Pages
/Kids [466 0 R 471 0 R 474 0 R 478 0 R 482 0 R 487 0 R 490 0 R 493 0 R 496 0 R 499 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
505 0 obj
<<
/Type /Pages
/Kids [502 0 R 506 0 R 510 0 R 513 0 R 516 0 R 519 0 R 522 0 R 525 0 R 528 0 R 531 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
537 0 obj
<<
/Type /Pages
/Kids [534 0 R 538 0 R 542 0 R 546 0 R 549 0 R 552 0 R 555 0 R 558 0 R 561 0 R 564 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
570 0 obj
<<
/Type /Pages
/Kids [567 0 R 571 0 R 574 0 R 577 0 R 580 0 R 583 0 R 586 0 R 589 0 R 592 0 R 595 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
601 0 obj
<<
/Type /Pages
/Kids [598 0 R 603 0 R 606 0 R 610 0 R 613 0 R 616 0 R 619 0 R 622 0 R 625 0 R 628 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
635 0 obj
<<
/Type /Pages
/Kids [632 0 R 636 0 R 639 0 R 642 0 R 645 0 R 648 0 R 651 0 R 655 0 R 659 0 R 662 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
668 0 obj
<<
/Type /Pages
/Kids [665 0 R 669 0 R 672 0 R 675 0 R 678 0 R 681 0 R 684 0 R 687 0 R 690 0 R 693 0 R]
/Count 10
/Parent 396 0 R
>>
endobj
396 0 obj
<<
/Type /Pages
/Kids [359 0 R 397 0 R 436 0 R 469 0 R 505 0 R 537 0 R 570 0 R 601 0 R 635 0 R 668 0 R ]
/Count 100
/Parent 358 0 R
>>
endobj
699 0 obj
<<
/Type /Pages
/Kids [696 0 R 700 0 R 704 0 R 708 0 R 711 0 R 714 0 R 717 0 R 722 0 R 725 0 R 728 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
735 0 obj
<<
/Type /Pages
/Kids [731 0 R 736 0 R 739 0 R 742 0 R 745 0 R 748 0 R 751 0 R 754 0 R 757 0 R 760 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
766 0 obj
<<
/Type /Pages
/Kids [763 0 R 767 0 R 770 0 R 774 0 R 777 0 R 780 0 R 783 0 R 786 0 R 789 0 R 792 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
798 0 obj
<<
/Type /Pages
/Kids [795 0 R 800 0 R 803 0 R 806 0 R 810 0 R 813 0 R 816 0 R 819 0 R 822 0 R 825 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
831 0 obj
<<
/Type /Pages
/Kids [828 0 R 833 0 R 836 0 R 839 0 R 842 0 R 846 0 R 852 0 R 856 0 R 859 0 R 863 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
869 0 obj
<<
/Type /Pages
/Kids [866 0 R 870 0 R 873 0 R 876 0 R 879 0 R 882 0 R 886 0 R 889 0 R 893 0 R 896 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
902 0 obj
<<
/Type /Pages
/Kids [899 0 R 903 0 R 907 0 R 910 0 R 913 0 R 916 0 R 920 0 R 923 0 R 926 0 R 929 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
935 0 obj
<<
/Type /Pages
/Kids [932 0 R 936 0 R 939 0 R 942 0 R 946 0 R 949 0 R 952 0 R 955 0 R 959 0 R 962 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
968 0 obj
<<
/Type /Pages
/Kids [965 0 R 969 0 R 972 0 R 976 0 R 979 0 R 982 0 R 985 0 R 988 0 R 991 0 R 994 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
1000 0 obj
<<
/Type /Pages
/Kids [997 0 R 1001 0 R 1004 0 R 1007 0 R 1011 0 R 1014 0 R 1019 0 R 1023 0 R 1026 0 R 1029 0 R]
/Count 10
/Parent 734 0 R
>>
endobj
734 0 obj
<<
/Type /Pages
/Kids [699 0 R 735 0 R 766 0 R 798 0 R 831 0 R 869 0 R 902 0 R 935 0 R 968 0 R 1000 0 R ]
/Count 100
/Parent 358 0 R
>>
endobj
1035 0 obj
<<
/Type /Pages
/Kids [1032 0 R 1036 0 R 1039 0 R 1042 0 R 1047 0 R 1050 0 R 1053 0 R 1057 0 R 1060 0 R 1063 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1070 0 obj
<<
/Type /Pages
/Kids [1066 0 R 1071 0 R 1074 0 R 1077 0 R 1080 0 R 1083 0 R 1086 0 R 1089 0 R 1092 0 R 1095 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1101 0 obj
<<
/Type /Pages
/Kids [1098 0 R 1102 0 R 1105 0 R 1108 0 R 1111 0 R 1114 0 R 1117 0 R 1120 0 R 1123 0 R 1127 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1134 0 obj
<<
/Type /Pages
/Kids [1131 0 R 1135 0 R 1138 0 R 1141 0 R 1144 0 R 1147 0 R 1151 0 R 1154 0 R 1157 0 R 1160 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1166 0 obj
<<
/Type /Pages
/Kids [1163 0 R 1167 0 R 1171 0 R 1175 0 R 1178 0 R 1181 0 R 1184 0 R 1187 0 R 1190 0 R 1193 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1199 0 obj
<<
/Type /Pages
/Kids [1196 0 R 1200 0 R 1203 0 R 1206 0 R 1209 0 R 1212 0 R 1215 0 R 1218 0 R 1221 0 R 1225 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1231 0 obj
<<
/Type /Pages
/Kids [1228 0 R 1233 0 R 1238 0 R 1241 0 R 1245 0 R 1249 0 R 1252 0 R 1256 0 R 1259 0 R 1262 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1268 0 obj
<<
/Type /Pages
/Kids [1265 0 R 1269 0 R 1273 0 R 1276 0 R 1279 0 R 1282 0 R 1285 0 R 1288 0 R 1291 0 R 1294 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1302 0 obj
<<
/Type /Pages
/Kids [1299 0 R 1303 0 R 1306 0 R 1309 0 R 1312 0 R 1315 0 R 1318 0 R 1321 0 R 1324 0 R 1327 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1333 0 obj
<<
/Type /Pages
/Kids [1330 0 R 1334 0 R 1337 0 R 1340 0 R 1343 0 R 1346 0 R 1349 0 R 1352 0 R 1355 0 R 1358 0 R]
/Count 10
/Parent 1069 0 R
>>
endobj
1069 0 obj
<<
/Type /Pages
/Kids [1035 0 R 1070 0 R 1101 0 R 1134 0 R 1166 0 R 1199 0 R 1231 0 R 1268 0 R 1302 0 R 1333 0 R ]
/Count 100
/Parent 358 0 R
>>
endobj
1364 0 obj
<<
/Type /Pages
/Kids [1361 0 R 1365 0 R 1368 0 R 1371 0 R 1375 0 R 1378 0 R 1381 0 R 1384 0 R 1387 0 R 1390 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1397 0 obj
<<
/Type /Pages
/Kids [1393 0 R 1398 0 R 1401 0 R 1404 0 R 1407 0 R 1410 0 R 1413 0 R 1416 0 R 1420 0 R 1423 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1431 0 obj
<<
/Type /Pages
/Kids [1428 0 R 1432 0 R 1436 0 R 1439 0 R 1443 0 R 1447 0 R 1450 0 R 1453 0 R 1457 0 R 1461 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1467 0 obj
<<
/Type /Pages
/Kids [1464 0 R 1469 0 R 1472 0 R 1475 0 R 1478 0 R 1481 0 R 1484 0 R 1487 0 R 1490 0 R 1493 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1499 0 obj
<<
/Type /Pages
/Kids [1496 0 R 1500 0 R 1503 0 R 1506 0 R 1509 0 R 1512 0 R 1515 0 R 1518 0 R 1521 0 R 1524 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1530 0 obj
<<
/Type /Pages
/Kids [1527 0 R 1531 0 R 1534 0 R 1537 0 R 1540 0 R 1543 0 R 1546 0 R 1549 0 R 1552 0 R 1555 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1561 0 obj
<<
/Type /Pages
/Kids [1558 0 R 1562 0 R 1566 0 R 1574 0 R 1582 0 R 1586 0 R 1589 0 R 1592 0 R 1595 0 R 1602 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1610 0 obj
<<
/Type /Pages
/Kids [1607 0 R 1612 0 R 1615 0 R 1618 0 R 1621 0 R 1624 0 R 1627 0 R 1630 0 R 1634 0 R 1638 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1645 0 obj
<<
/Type /Pages
/Kids [1642 0 R 1647 0 R 1651 0 R 1655 0 R 1659 0 R 1663 0 R 1668 0 R 1673 0 R 1677 0 R 1682 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1689 0 obj
<<
/Type /Pages
/Kids [1686 0 R 1691 0 R 1696 0 R 1700 0 R 1704 0 R 1709 0 R 1713 0 R 1717 0 R 1721 0 R 1726 0 R]
/Count 10
/Parent 1396 0 R
>>
endobj
1396 0 obj
<<
/Type /Pages
/Kids [1364 0 R 1397 0 R 1431 0 R 1467 0 R 1499 0 R 1530 0 R 1561 0 R 1610 0 R 1645 0 R 1689 0 R ]
/Count 100
/Parent 358 0 R
>>
endobj
1734 0 obj
<<
/Type /Pages
/Kids [1731 0 R 1736 0 R 1739 0 R 1742 0 R 1745 0 R 1748 0 R 1751 0 R 1754 0 R 1757 0 R 1760 0 R]
/Count 10
/Parent 1766 0 R
>>
endobj
1767 0 obj
<<
/Type /Pages
/Kids [1763 0 R 1768 0 R 1771 0 R 1774 0 R 1777 0 R 1780 0 R]
/Count 6
/Parent 1766 0 R
>>
endobj
1766 0 obj
<<
/Type /Pages
/Kids [1734 0 R 1767 0 R ]
/Count 16
/Parent 358 0 R
>>
endobj
358 0 obj
<<
/Type /Pages
/Kids [42 0 R 396 0 R 734 0 R 1069 0 R 1396 0 R 1766 0 R ]
/Count 516
/MediaBox [0 0 594 840]
>>
endobj
1786 0 obj
<<
/Type /Catalog
/Pages 358 0 R
>>
endobj
1787 0 obj
<<
/CreationDate (D:191010217132348)
/Producer (xpsnorm \(Adobe Extreme 10.102\))
>>
endobj
xref
0 1788
0000000000 65535 f 
0001849482 00000 n 
0000000016 00000 n 
0000000516 00000 n 
0001847830 00000 n 
0001848248 00000 n 
0001847647 00000 n 
0001895661 00000 n 
0001849562 00000 n 
0000000622 00000 n 
0000005274 00000 n 
0001847932 00000 n 
0001848353 00000 n 
0001849643 00000 n 
0000005405 00000 n 
0000009817 00000 n 
0001849726 00000 n 
0000009937 00000 n 
0000013645 00000 n 
0001848034 00000 n 
0001849809 00000 n 
0000013788 00000 n 
0000018513 00000 n 
0001849892 00000 n 
0000018644 00000 n 
0000022320 00000 n 
0001847732 00000 n 
0001849975 00000 n 
0000022474 00000 n 
0000023921 00000 n 
0001850058 00000 n 
0000024041 00000 n 
0000028334 00000 n 
0001850141 00000 n 
0000028441 00000 n 
0000032916 00000 n 
0001850224 00000 n 
0000033024 00000 n 
0000033341 00000 n 
0001850307 00000 n 
0000033437 00000 n 
0000037026 00000 n 
0001897116 00000 n 
0001895796 00000 n 
0001850391 00000 n 
0000037157 00000 n 
0000042620 00000 n 
0001850475 00000 n 
0000042752 00000 n 
0000047254 00000 n 
0000047386 00000 n 
0001850559 00000 n 
0000047569 00000 n 
0000051037 00000 n 
0001850643 00000 n 
0000051215 00000 n 
0000055526 00000 n 
0001850727 00000 n 
0000055669 00000 n 
0000060718 00000 n 
0001850811 00000 n 
0000060848 00000 n 
0000065869 00000 n 
0000065999 00000 n 
0001850895 00000 n 
0000066182 00000 n 
0000069448 00000 n 
0001850979 00000 n 
0000069614 00000 n 
0000073767 00000 n 
0001851063 00000 n 
0000073874 00000 n 
0000078469 00000 n 
0001851147 00000 n 
0000078612 00000 n 
0000082686 00000 n 
0001895934 00000 n 
0001851231 00000 n 
0000082828 00000 n 
0000087775 00000 n 
0001851315 00000 n 
0000087906 00000 n 
0000090388 00000 n 
0001851399 00000 n 
0000090518 00000 n 
0000094203 00000 n 
0001851483 00000 n 
0000094345 00000 n 
0000098499 00000 n 
0001851567 00000 n 
0000098641 00000 n 
0000103049 00000 n 
0000103203 00000 n 
0001851651 00000 n 
0000103386 00000 n 
0000107168 00000 n 
0001851735 00000 n 
0000107346 00000 n 
0000109029 00000 n 
0001851819 00000 n 
0000109147 00000 n 
0000110716 00000 n 
0001851905 00000 n 
0000110824 00000 n 
0000115020 00000 n 
0001851992 00000 n 
0000115164 00000 n 
0000119528 00000 n 
0001896073 00000 n 
0001852080 00000 n 
0000119660 00000 n 
0000124326 00000 n 
0001852168 00000 n 
0000124458 00000 n 
0000129076 00000 n 
0001852256 00000 n 
0000129207 00000 n 
0000133184 00000 n 
0001852344 00000 n 
0000133315 00000 n 
0000138604 00000 n 
0001852432 00000 n 
0000138725 00000 n 
0000142373 00000 n 
0000142516 00000 n 
0001852520 00000 n 
0000142700 00000 n 
0000146105 00000 n 
0000146285 00000 n 
0001852608 00000 n 
0000146468 00000 n 
0000150414 00000 n 
0000150582 00000 n 
0000150766 00000 n 
0001852696 00000 n 
0000150950 00000 n 
0000154524 00000 n 
0000154717 00000 n 
0001852784 00000 n 
0000154901 00000 n 
0000158924 00000 n 
0000159103 00000 n 
0001852872 00000 n 
0000159286 00000 n 
0000163122 00000 n 
0001896222 00000 n 
0001852960 00000 n 
0000163289 00000 n 
0000165980 00000 n 
0000166100 00000 n 
0001853048 00000 n 
0000166285 00000 n 
0000168686 00000 n 
0001853136 00000 n 
0000168843 00000 n 
0000173667 00000 n 
0001853224 00000 n 
0000173799 00000 n 
0000178465 00000 n 
0001853312 00000 n 
0000178596 00000 n 
0000183049 00000 n 
0001853400 00000 n 
0000183180 00000 n 
0000187291 00000 n 
0001853488 00000 n 
0000187423 00000 n 
0000191973 00000 n 
0000192116 00000 n 
0000192302 00000 n 
0001853576 00000 n 
0000192488 00000 n 
0000195094 00000 n 
0001853664 00000 n 
0000195288 00000 n 
0000197522 00000 n 
0001853752 00000 n 
0000197630 00000 n 
0000200269 00000 n 
0001896371 00000 n 
0001853840 00000 n 
0000200400 00000 n 
0000205070 00000 n 
0000205225 00000 n 
0000205410 00000 n 
0001853928 00000 n 
0000205595 00000 n 
0000209825 00000 n 
0001854016 00000 n 
0000210031 00000 n 
0000210603 00000 n 
0000210700 00000 n 
0001854104 00000 n 
0000210886 00000 n 
0000211404 00000 n 
0000211549 00000 n 
0001854192 00000 n 
0000211735 00000 n 
0000214113 00000 n 
0001854280 00000 n 
0000214269 00000 n 
0000216288 00000 n 
0000216396 00000 n 
0001854368 00000 n 
0000216582 00000 n 
0000220168 00000 n 
0000220360 00000 n 
0001854456 00000 n 
0000220546 00000 n 
0000223803 00000 n 
0000223995 00000 n 
0001854544 00000 n 
0000224180 00000 n 
0000228723 00000 n 
0000228915 00000 n 
0001854632 00000 n 
0000229101 00000 n 
0000233025 00000 n 
0001896520 00000 n 
0001854720 00000 n 
0000233182 00000 n 
0000237598 00000 n 
0001854808 00000 n 
0000237741 00000 n 
0000242232 00000 n 
0001854896 00000 n 
0000242363 00000 n 
0000245776 00000 n 
0001854984 00000 n 
0000245907 00000 n 
0000249735 00000 n 
0000249866 00000 n 
0001855072 00000 n 
0000250052 00000 n 
0000253609 00000 n 
0001855160 00000 n 
0000253777 00000 n 
0000257823 00000 n 
0001855248 00000 n 
0000257954 00000 n 
0000262498 00000 n 
0001855336 00000 n 
0000262641 00000 n 
0000266612 00000 n 
0001855424 00000 n 
0000266743 00000 n 
0000272509 00000 n 
0001855512 00000 n 
0000272641 00000 n 
0000277283 00000 n 
0001896669 00000 n 
0001855600 00000 n 
0000277403 00000 n 
0000281861 00000 n 
0000281993 00000 n 
0001855688 00000 n 
0000282179 00000 n 
0000285734 00000 n 
0001855776 00000 n 
0000285914 00000 n 
0000289046 00000 n 
0001855864 00000 n 
0000289177 00000 n 
0000292950 00000 n 
0001855952 00000 n 
0000293093 00000 n 
0000295736 00000 n 
0000295855 00000 n 
0001856040 00000 n 
0000296041 00000 n 
0000297779 00000 n 
0001856128 00000 n 
0000297935 00000 n 
0000300549 00000 n 
0001856216 00000 n 
0000300680 00000 n 
0000303175 00000 n 
0001856304 00000 n 
0000303306 00000 n 
0000307601 00000 n 
0001856392 00000 n 
0000307745 00000 n 
0000311823 00000 n 
0001896818 00000 n 
0001856480 00000 n 
0000311944 00000 n 
0000313275 00000 n 
0000313395 00000 n 
0001856568 00000 n 
0000313581 00000 n 
0000313832 00000 n 
0000313966 00000 n 
0001856656 00000 n 
0000314152 00000 n 
0000318614 00000 n 
0000318795 00000 n 
0001856744 00000 n 
0000318980 00000 n 
0000321996 00000 n 
0001856832 00000 n 
0000322164 00000 n 
0000325141 00000 n 
0001856920 00000 n 
0000325284 00000 n 
0000330436 00000 n 
0001857008 00000 n 
0000330568 00000 n 
0000335737 00000 n 
0001857096 00000 n 
0000335869 00000 n 
0000341015 00000 n 
0000341159 00000 n 
0001857184 00000 n 
0000341344 00000 n 
0000346218 00000 n 
0000346387 00000 n 
0001857272 00000 n 
0000346573 00000 n 
0000350347 00000 n 
0001896967 00000 n 
0001857360 00000 n 
0000350527 00000 n 
0000355637 00000 n 
0001857448 00000 n 
0000355780 00000 n 
0000360265 00000 n 
0000360385 00000 n 
0000360571 00000 n 
0001857536 00000 n 
0000360757 00000 n 
0000362339 00000 n 
0000362522 00000 n 
0001857624 00000 n 
0000362708 00000 n 
0000366130 00000 n 
0000366287 00000 n 
0001857712 00000 n 
0000366471 00000 n 
0000368962 00000 n 
0001857800 00000 n 
0000369142 00000 n 
0000373803 00000 n 
0000373935 00000 n 
0001857888 00000 n 
0000374121 00000 n 
0000375947 00000 n 
0000376115 00000 n 
0001857976 00000 n 
0000376301 00000 n 
0000378970 00000 n 
0001858064 00000 n 
0000379138 00000 n 
0000382993 00000 n 
0000383113 00000 n 
0000383299 00000 n 
0001858152 00000 n 
0000383485 00000 n 
0000385516 00000 n 
0001904521 00000 n 
0001897263 00000 n 
0001858240 00000 n 
0000385710 00000 n 
0000389908 00000 n 
0001858328 00000 n 
0000390051 00000 n 
0000394208 00000 n 
0000394351 00000 n 
0001858416 00000 n 
0000394537 00000 n 
0000398133 00000 n 
0000398302 00000 n 
0001858504 00000 n 
0000398488 00000 n 
0000402801 00000 n 
0000402970 00000 n 
0001858592 00000 n 
0000403156 00000 n 
0000406508 00000 n 
0001858680 00000 n 
0000406677 00000 n 
0000411607 00000 n 
0000411727 00000 n 
0001858768 00000 n 
0000411913 00000 n 
0000413997 00000 n 
0000414154 00000 n 
0001858856 00000 n 
0000414340 00000 n 
0000416319 00000 n 
0000416487 00000 n 
0001858944 00000 n 
0000416673 00000 n 
0000420541 00000 n 
0001859032 00000 n 
0000420710 00000 n 
0000424680 00000 n 
0001898763 00000 n 
0001897413 00000 n 
0000424801 00000 n 
0000424987 00000 n 
0001859120 00000 n 
0000425172 00000 n 
0000427776 00000 n 
0000427970 00000 n 
0000428155 00000 n 
0001859208 00000 n 
0000428341 00000 n 
0000431533 00000 n 
0000431716 00000 n 
0001859296 00000 n 
0000431902 00000 n 
0000435237 00000 n 
0001859384 00000 n 
0000435405 00000 n 
0000438589 00000 n 
0001859472 00000 n 
0000438732 00000 n 
0000442517 00000 n 
0000442672 00000 n 
0001859560 00000 n 
0000442858 00000 n 
0000446170 00000 n 
0000446338 00000 n 
0001859648 00000 n 
0000446524 00000 n 
0000448098 00000 n 
0001859736 00000 n 
0000448254 00000 n 
0000451148 00000 n 
0000451291 00000 n 
0001859824 00000 n 
0000451477 00000 n 
0000454873 00000 n 
0001859912 00000 n 
0000455041 00000 n 
0000456782 00000 n 
0001897563 00000 n 
0001860000 00000 n 
0000456890 00000 n 
0000459155 00000 n 
0000459298 00000 n 
0001860088 00000 n 
0000459483 00000 n 
0000462774 00000 n 
0001860176 00000 n 
0000462942 00000 n 
0000464640 00000 n 
0001860264 00000 n 
0000464748 00000 n 
0000466462 00000 n 
0000466581 00000 n 
0001860352 00000 n 
0000466767 00000 n 
0000470596 00000 n 
0001860440 00000 n 
0000470765 00000 n 
0000473622 00000 n 
0001860528 00000 n 
0000473753 00000 n 
0000476359 00000 n 
0001860616 00000 n 
0000476479 00000 n 
0000477552 00000 n 
0001860704 00000 n 
0000477661 00000 n 
0000481921 00000 n 
0001860792 00000 n 
0000482065 00000 n 
0000486841 00000 n 
0001897713 00000 n 
0000486985 00000 n 
0001860880 00000 n 
0000487171 00000 n 
0000490183 00000 n 
0001860968 00000 n 
0000490351 00000 n 
0000495754 00000 n 
0000495898 00000 n 
0001861056 00000 n 
0000496084 00000 n 
0000499233 00000 n 
0000499390 00000 n 
0001861144 00000 n 
0000499576 00000 n 
0000502826 00000 n 
0000502995 00000 n 
0000503181 00000 n 
0001861232 00000 n 
0000503367 00000 n 
0000505210 00000 n 
0001861320 00000 n 
0000505381 00000 n 
0000509774 00000 n 
0001861408 00000 n 
0000509906 00000 n 
0000513911 00000 n 
0001861496 00000 n 
0000514042 00000 n 
0000518847 00000 n 
0001861584 00000 n 
0000518967 00000 n 
0000522210 00000 n 
0001861672 00000 n 
0000522353 00000 n 
0000524560 00000 n 
0001897863 00000 n 
0001861760 00000 n 
0000524668 00000 n 
0000527543 00000 n 
0000527674 00000 n 
0001861848 00000 n 
0000527860 00000 n 
0000530837 00000 n 
0001861936 00000 n 
0000531006 00000 n 
0000534632 00000 n 
0001862024 00000 n 
0000534775 00000 n 
0000538522 00000 n 
0001862112 00000 n 
0000538653 00000 n 
0000543327 00000 n 
0001862200 00000 n 
0000543471 00000 n 
0000547954 00000 n 
0001862288 00000 n 
0000548086 00000 n 
0000550745 00000 n 
0001862376 00000 n 
0000550876 00000 n 
0000553358 00000 n 
0001862464 00000 n 
0000553489 00000 n 
0000558525 00000 n 
0001862552 00000 n 
0000558657 00000 n 
0000563543 00000 n 
0001898013 00000 n 
0001862640 00000 n 
0000563674 00000 n 
0000567973 00000 n 
0000568116 00000 n 
0001862728 00000 n 
0000568301 00000 n 
0000572932 00000 n 
0000573100 00000 n 
0001862816 00000 n 
0000573286 00000 n 
0000576455 00000 n 
0001862904 00000 n 
0000576635 00000 n 
0000580561 00000 n 
0001862992 00000 n 
0000580692 00000 n 
0000584222 00000 n 
0001863080 00000 n 
0000584365 00000 n 
0000587218 00000 n 
0001863168 00000 n 
0000587349 00000 n 
0000590416 00000 n 
0001863256 00000 n 
0000590547 00000 n 
0000592244 00000 n 
0001863344 00000 n 
0000592352 00000 n 
0000595509 00000 n 
0001863432 00000 n 
0000595640 00000 n 
0000599878 00000 n 
0001898163 00000 n 
0001863520 00000 n 
0000600021 00000 n 
0000604376 00000 n 
0001863608 00000 n 
0000604507 00000 n 
0000609027 00000 n 
0001863696 00000 n 
0000609158 00000 n 
0000614396 00000 n 
0001863784 00000 n 
0000614516 00000 n 
0000618545 00000 n 
0001863872 00000 n 
0000618688 00000 n 
0000621660 00000 n 
0001863960 00000 n 
0000621791 00000 n 
0000624594 00000 n 
0001864048 00000 n 
0000624714 00000 n 
0000628930 00000 n 
0001864136 00000 n 
0000629061 00000 n 
0000630973 00000 n 
0001864224 00000 n 
0000631081 00000 n 
0000633095 00000 n 
0001864312 00000 n 
0000633203 00000 n 
0000637535 00000 n 
0001898313 00000 n 
0000637678 00000 n 
0001864400 00000 n 
0000637863 00000 n 
0000641131 00000 n 
0001864488 00000 n 
0000641288 00000 n 
0000645807 00000 n 
0000645939 00000 n 
0001864576 00000 n 
0000646124 00000 n 
0000650316 00000 n 
0001864664 00000 n 
0000650497 00000 n 
0000655518 00000 n 
0001864752 00000 n 
0000655661 00000 n 
0000659217 00000 n 
0001864840 00000 n 
0000659337 00000 n 
0000663423 00000 n 
0001864928 00000 n 
0000663567 00000 n 
0000668897 00000 n 
0001865016 00000 n 
0000669017 00000 n 
0000675136 00000 n 
0001865104 00000 n 
0000675279 00000 n 
0000679973 00000 n 
0000680082 00000 n 
0001865192 00000 n 
0000680268 00000 n 
0000682273 00000 n 
0001898463 00000 n 
0001865280 00000 n 
0000682454 00000 n 
0000684643 00000 n 
0001865368 00000 n 
0000684762 00000 n 
0000686417 00000 n 
0001865456 00000 n 
0000686525 00000 n 
0000690016 00000 n 
0001865544 00000 n 
0000690135 00000 n 
0000692982 00000 n 
0001865632 00000 n 
0000693113 00000 n 
0000695116 00000 n 
0001865720 00000 n 
0000695224 00000 n 
0000696945 00000 n 
0000697053 00000 n 
0001865808 00000 n 
0000697239 00000 n 
0000699753 00000 n 
0000699933 00000 n 
0001865896 00000 n 
0000700119 00000 n 
0000703948 00000 n 
0001865984 00000 n 
0000704105 00000 n 
0000707599 00000 n 
0001866072 00000 n 
0000707730 00000 n 
0000709558 00000 n 
0001898613 00000 n 
0001866160 00000 n 
0000709666 00000 n 
0000711408 00000 n 
0001866248 00000 n 
0000711516 00000 n 
0000713950 00000 n 
0001866336 00000 n 
0000714069 00000 n 
0000715812 00000 n 
0001866424 00000 n 
0000715920 00000 n 
0000718765 00000 n 
0001866512 00000 n 
0000718885 00000 n 
0000723597 00000 n 
0001866600 00000 n 
0000723729 00000 n 
0000725807 00000 n 
0001866688 00000 n 
0000725926 00000 n 
0000727991 00000 n 
0001866776 00000 n 
0000728099 00000 n 
0000729781 00000 n 
0001866864 00000 n 
0000729889 00000 n 
0000733362 00000 n 
0001866952 00000 n 
0000733505 00000 n 
0000735490 00000 n 
0001898915 00000 n 
0001867040 00000 n 
0000735598 00000 n 
0000737547 00000 n 
0000737655 00000 n 
0001867128 00000 n 
0000737840 00000 n 
0000740970 00000 n 
0000741138 00000 n 
0001867216 00000 n 
0000741324 00000 n 
0000744418 00000 n 
0001867304 00000 n 
0000744575 00000 n 
0000746396 00000 n 
0001867392 00000 n 
0000746515 00000 n 
0000748201 00000 n 
0001867480 00000 n 
0000748309 00000 n 
0000752066 00000 n 
0000752197 00000 n 
0000752382 00000 n 
0001867568 00000 n 
0000752568 00000 n 
0000756239 00000 n 
0001867656 00000 n 
0000756421 00000 n 
0000758157 00000 n 
0001867744 00000 n 
0000758277 00000 n 
0000762134 00000 n 
0001867832 00000 n 
0000762278 00000 n 
0000765213 00000 n 
0001900425 00000 n 
0001899065 00000 n 
0001867920 00000 n 
0000765332 00000 n 
0000767067 00000 n 
0001868008 00000 n 
0000767175 00000 n 
0000769140 00000 n 
0001868096 00000 n 
0000769260 00000 n 
0000774705 00000 n 
0001868184 00000 n 
0000774825 00000 n 
0000779025 00000 n 
0001868272 00000 n 
0000779157 00000 n 
0000782545 00000 n 
0001868360 00000 n 
0000782676 00000 n 
0000784538 00000 n 
0001868448 00000 n 
0000784646 00000 n 
0000787635 00000 n 
0001868536 00000 n 
0000787766 00000 n 
0000791418 00000 n 
0001868624 00000 n 
0000791549 00000 n 
0000796696 00000 n 
0001868712 00000 n 
0000796839 00000 n 
0000800538 00000 n 
0001899215 00000 n 
0001868800 00000 n 
0000800669 00000 n 
0000804440 00000 n 
0001868888 00000 n 
0000804571 00000 n 
0000808086 00000 n 
0000808217 00000 n 
0001868976 00000 n 
0000808402 00000 n 
0000810892 00000 n 
0001869064 00000 n 
0000811060 00000 n 
0000812887 00000 n 
0001869152 00000 n 
0000812995 00000 n 
0000814736 00000 n 
0001869240 00000 n 
0000814844 00000 n 
0000816550 00000 n 
0001869328 00000 n 
0000816658 00000 n 
0000820041 00000 n 
0001869416 00000 n 
0000820172 00000 n 
0000823141 00000 n 
0001869504 00000 n 
0000823272 00000 n 
0000824949 00000 n 
0001869592 00000 n 
0000825080 00000 n 
0000828956 00000 n 
0001899365 00000 n 
0000829088 00000 n 
0001869680 00000 n 
0000829274 00000 n 
0000832533 00000 n 
0001869768 00000 n 
0000832713 00000 n 
0000834415 00000 n 
0001869856 00000 n 
0000834523 00000 n 
0000838472 00000 n 
0000838627 00000 n 
0001869944 00000 n 
0000838813 00000 n 
0000842508 00000 n 
0001870032 00000 n 
0000842676 00000 n 
0000848166 00000 n 
0001870120 00000 n 
0000848297 00000 n 
0000853237 00000 n 
0001870208 00000 n 
0000853368 00000 n 
0000856158 00000 n 
0001870296 00000 n 
0000856289 00000 n 
0000858642 00000 n 
0001870384 00000 n 
0000858750 00000 n 
0000860504 00000 n 
0001870472 00000 n 
0000860612 00000 n 
0000862573 00000 n 
0001899515 00000 n 
0000862692 00000 n 
0001870560 00000 n 
0000862878 00000 n 
0000866681 00000 n 
0001870648 00000 n 
0000866850 00000 n 
0000871740 00000 n 
0001870736 00000 n 
0000871872 00000 n 
0000876932 00000 n 
0001870824 00000 n 
0000877076 00000 n 
0000879411 00000 n 
0000879542 00000 n 
0001870912 00000 n 
0000879728 00000 n 
0000883902 00000 n 
0000884071 00000 n 
0000884256 00000 n 
0000884441 00000 n 
0001871000 00000 n 
0000884627 00000 n 
0000887451 00000 n 
0000887636 00000 n 
0001871088 00000 n 
0000887822 00000 n 
0000891669 00000 n 
0001871176 00000 n 
0000891826 00000 n 
0000896804 00000 n 
0000896924 00000 n 
0001871264 00000 n 
0000897110 00000 n 
0000900720 00000 n 
0001871352 00000 n 
0000900889 00000 n 
0000907485 00000 n 
0001899665 00000 n 
0001871440 00000 n 
0000907617 00000 n 
0000912314 00000 n 
0001871528 00000 n 
0000912434 00000 n 
0000918484 00000 n 
0001871616 00000 n 
0000918616 00000 n 
0000920342 00000 n 
0001871704 00000 n 
0000920450 00000 n 
0000922221 00000 n 
0001871792 00000 n 
0000922329 00000 n 
0000924439 00000 n 
0000924558 00000 n 
0001871880 00000 n 
0000924744 00000 n 
0000925615 00000 n 
0001871968 00000 n 
0000925760 00000 n 
0000929431 00000 n 
0000929539 00000 n 
0001872056 00000 n 
0000929725 00000 n 
0000930967 00000 n 
0001872144 00000 n 
0000931124 00000 n 
0000935356 00000 n 
0001872232 00000 n 
0000935488 00000 n 
0000936425 00000 n 
0001899815 00000 n 
0001872320 00000 n 
0000936534 00000 n 
0000940756 00000 n 
0000940888 00000 n 
0001872408 00000 n 
0000941074 00000 n 
0000944865 00000 n 
0001872496 00000 n 
0000945034 00000 n 
0000949139 00000 n 
0001872584 00000 n 
0000949272 00000 n 
0000953000 00000 n 
0001872672 00000 n 
0000953120 00000 n 
0000956451 00000 n 
0000956583 00000 n 
0001872760 00000 n 
0000956769 00000 n 
0000958244 00000 n 
0001872848 00000 n 
0000958400 00000 n 
0000960636 00000 n 
0001872936 00000 n 
0000960744 00000 n 
0000963104 00000 n 
0001873024 00000 n 
0000963224 00000 n 
0000968073 00000 n 
0001873112 00000 n 
0000968205 00000 n 
0000973049 00000 n 
0001899965 00000 n 
0001873200 00000 n 
0000973192 00000 n 
0000978469 00000 n 
0001873288 00000 n 
0000978589 00000 n 
0000983105 00000 n 
0001873376 00000 n 
0000983248 00000 n 
0000987363 00000 n 
0000987483 00000 n 
0001873464 00000 n 
0000987669 00000 n 
0000989490 00000 n 
0001873552 00000 n 
0000989646 00000 n 
0000992557 00000 n 
0001873640 00000 n 
0000992677 00000 n 
0000997606 00000 n 
0001873728 00000 n 
0000997738 00000 n 
0001002232 00000 n 
0001002364 00000 n 
0001873816 00000 n 
0001002550 00000 n 
0001006573 00000 n 
0001873904 00000 n 
0001006742 00000 n 
0001010031 00000 n 
0001873992 00000 n 
0001010174 00000 n 
0001011990 00000 n 
0001900115 00000 n 
0001874080 00000 n 
0001012098 00000 n 
0001014510 00000 n 
0001874168 00000 n 
0001014618 00000 n 
0001017057 00000 n 
0001017177 00000 n 
0001874256 00000 n 
0001017363 00000 n 
0001021321 00000 n 
0001874344 00000 n 
0001021501 00000 n 
0001026268 00000 n 
0001874432 00000 n 
0001026411 00000 n 
0001030660 00000 n 
0001874520 00000 n 
0001030792 00000 n 
0001034754 00000 n 
0001874608 00000 n 
0001034885 00000 n 
0001037208 00000 n 
0001874696 00000 n 
0001037316 00000 n 
0001040688 00000 n 
0001874784 00000 n 
0001040819 00000 n 
0001045712 00000 n 
0001874872 00000 n 
0001045832 00000 n 
0001050592 00000 n 
0001900265 00000 n 
0001874961 00000 n 
0001050712 00000 n 
0001058483 00000 n 
0001875053 00000 n 
0001058592 00000 n 
0001064197 00000 n 
0001875145 00000 n 
0001064330 00000 n 
0001069132 00000 n 
0001069265 00000 n 
0001875237 00000 n 
0001069452 00000 n 
0001073419 00000 n 
0001875329 00000 n 
0001073590 00000 n 
0001076627 00000 n 
0001076748 00000 n 
0001076935 00000 n 
0001875421 00000 n 
0001077122 00000 n 
0001078570 00000 n 
0001078755 00000 n 
0001875513 00000 n 
0001078942 00000 n 
0001082340 00000 n 
0001875605 00000 n 
0001082499 00000 n 
0001088631 00000 n 
0001875697 00000 n 
0001088763 00000 n 
0001090949 00000 n 
0001875789 00000 n 
0001091081 00000 n 
0001093106 00000 n 
0001900578 00000 n 
0001875881 00000 n 
0001093215 00000 n 
0001095247 00000 n 
0001875973 00000 n 
0001095356 00000 n 
0001099167 00000 n 
0001876065 00000 n 
0001099288 00000 n 
0001105126 00000 n 
0001105259 00000 n 
0001105445 00000 n 
0001876157 00000 n 
0001105631 00000 n 
0001113198 00000 n 
0001876249 00000 n 
0001113383 00000 n 
0001118110 00000 n 
0001876341 00000 n 
0001118254 00000 n 
0001121574 00000 n 
0001121719 00000 n 
0001876433 00000 n 
0001121906 00000 n 
0001125185 00000 n 
0001876525 00000 n 
0001125356 00000 n 
0001129826 00000 n 
0001876617 00000 n 
0001129959 00000 n 
0001134397 00000 n 
0001876709 00000 n 
0001134518 00000 n 
0001139277 00000 n 
0001902198 00000 n 
0001900740 00000 n 
0001876801 00000 n 
0001139410 00000 n 
0001143523 00000 n 
0001876893 00000 n 
0001143644 00000 n 
0001148660 00000 n 
0001876985 00000 n 
0001148793 00000 n 
0001152537 00000 n 
0001877077 00000 n 
0001152670 00000 n 
0001157944 00000 n 
0001877169 00000 n 
0001158077 00000 n 
0001163083 00000 n 
0001877261 00000 n 
0001163204 00000 n 
0001165619 00000 n 
0001877353 00000 n 
0001165739 00000 n 
0001167628 00000 n 
0001877445 00000 n 
0001167737 00000 n 
0001169723 00000 n 
0001877537 00000 n 
0001169832 00000 n 
0001174310 00000 n 
0001877629 00000 n 
0001174454 00000 n 
0001178951 00000 n 
0001900902 00000 n 
0001877721 00000 n 
0001179084 00000 n 
0001184905 00000 n 
0001877813 00000 n 
0001185050 00000 n 
0001189724 00000 n 
0001877905 00000 n 
0001189869 00000 n 
0001194190 00000 n 
0001877997 00000 n 
0001194322 00000 n 
0001196306 00000 n 
0001878089 00000 n 
0001196426 00000 n 
0001198520 00000 n 
0001878181 00000 n 
0001198629 00000 n 
0001200403 00000 n 
0001878273 00000 n 
0001200512 00000 n 
0001203146 00000 n 
0001878365 00000 n 
0001203278 00000 n 
0001206074 00000 n 
0001206206 00000 n 
0001878457 00000 n 
0001206393 00000 n 
0001209113 00000 n 
0001209283 00000 n 
0001878549 00000 n 
0001209470 00000 n 
0001212362 00000 n 
0001901064 00000 n 
0001878641 00000 n 
0001212532 00000 n 
0001214649 00000 n 
0001878733 00000 n 
0001214758 00000 n 
0001217082 00000 n 
0001878825 00000 n 
0001217191 00000 n 
0001220386 00000 n 
0001878917 00000 n 
0001220506 00000 n 
0001222638 00000 n 
0001879009 00000 n 
0001222747 00000 n 
0001227279 00000 n 
0001227424 00000 n 
0001879101 00000 n 
0001227611 00000 n 
0001231585 00000 n 
0001879193 00000 n 
0001231744 00000 n 
0001235826 00000 n 
0001879285 00000 n 
0001235947 00000 n 
0001239847 00000 n 
0001879377 00000 n 
0001239979 00000 n 
0001242796 00000 n 
0001879469 00000 n 
0001242928 00000 n 
0001246760 00000 n 
0001901226 00000 n 
0001879561 00000 n 
0001246892 00000 n 
0001251156 00000 n 
0001251277 00000 n 
0001879653 00000 n 
0001251464 00000 n 
0001252913 00000 n 
0001253072 00000 n 
0001879745 00000 n 
0001253259 00000 n 
0001254210 00000 n 
0001879837 00000 n 
0001254357 00000 n 
0001259014 00000 n 
0001879929 00000 n 
0001259147 00000 n 
0001264073 00000 n 
0001880021 00000 n 
0001264194 00000 n 
0001267479 00000 n 
0001880113 00000 n 
0001267611 00000 n 
0001270333 00000 n 
0001880205 00000 n 
0001270465 00000 n 
0001274843 00000 n 
0001880297 00000 n 
0001274964 00000 n 
0001280094 00000 n 
0001880389 00000 n 
0001280215 00000 n 
0001284601 00000 n 
0001901388 00000 n 
0001880481 00000 n 
0001284722 00000 n 
0001289717 00000 n 
0001880573 00000 n 
0001289838 00000 n 
0001294117 00000 n 
0001880665 00000 n 
0001294249 00000 n 
0001296347 00000 n 
0001880757 00000 n 
0001296456 00000 n 
0001298313 00000 n 
0001880849 00000 n 
0001298422 00000 n 
0001300125 00000 n 
0001880941 00000 n 
0001300234 00000 n 
0001300553 00000 n 
0001881033 00000 n 
0001300651 00000 n 
0001304647 00000 n 
0001881125 00000 n 
0001304792 00000 n 
0001309864 00000 n 
0001309997 00000 n 
0001881217 00000 n 
0001310184 00000 n 
0001313257 00000 n 
0001881309 00000 n 
0001313439 00000 n 
0001315263 00000 n 
0001901550 00000 n 
0001315372 00000 n 
0001881401 00000 n 
0001315559 00000 n 
0001318838 00000 n 
0001319021 00000 n 
0001319209 00000 n 
0001881493 00000 n 
0001319396 00000 n 
0001324064 00000 n 
0001881585 00000 n 
0001324251 00000 n 
0001328746 00000 n 
0001328878 00000 n 
0001881677 00000 n 
0001329066 00000 n 
0001333496 00000 n 
0001333667 00000 n 
0001881769 00000 n 
0001333856 00000 n 
0001335960 00000 n 
0001881861 00000 n 
0001336131 00000 n 
0001339448 00000 n 
0001339580 00000 n 
0001881953 00000 n 
0001339769 00000 n 
0001342288 00000 n 
0001882045 00000 n 
0001342459 00000 n 
0001344929 00000 n 
0001882137 00000 n 
0001345061 00000 n 
0001347465 00000 n 
0001882229 00000 n 
0001347597 00000 n 
0001349828 00000 n 
0001901712 00000 n 
0001882321 00000 n 
0001349937 00000 n 
0001352988 00000 n 
0001353120 00000 n 
0001882413 00000 n 
0001353309 00000 n 
0001355967 00000 n 
0001882505 00000 n 
0001356138 00000 n 
0001358066 00000 n 
0001882597 00000 n 
0001358175 00000 n 
0001359962 00000 n 
0001882689 00000 n 
0001360071 00000 n 
0001362169 00000 n 
0001882781 00000 n 
0001362301 00000 n 
0001366325 00000 n 
0001882873 00000 n 
0001366446 00000 n 
0001370376 00000 n 
0001882965 00000 n 
0001370508 00000 n 
0001375020 00000 n 
0001883057 00000 n 
0001375141 00000 n 
0001380269 00000 n 
0001380402 00000 n 
0001380591 00000 n 
0001883149 00000 n 
0001380780 00000 n 
0001382877 00000 n 
0001901874 00000 n 
0001883241 00000 n 
0001383052 00000 n 
0001385604 00000 n 
0001883333 00000 n 
0001385725 00000 n 
0001386046 00000 n 
0001883425 00000 n 
0001386144 00000 n 
0001390256 00000 n 
0001883517 00000 n 
0001390401 00000 n 
0001395277 00000 n 
0001883609 00000 n 
0001395410 00000 n 
0001398853 00000 n 
0001883701 00000 n 
0001398985 00000 n 
0001403878 00000 n 
0001883793 00000 n 
0001404011 00000 n 
0001406485 00000 n 
0001883885 00000 n 
0001406617 00000 n 
0001408785 00000 n 
0001883977 00000 n 
0001408894 00000 n 
0001410605 00000 n 
0001884069 00000 n 
0001410714 00000 n 
0001413630 00000 n 
0001902036 00000 n 
0001884161 00000 n 
0001413774 00000 n 
0001418171 00000 n 
0001884253 00000 n 
0001418315 00000 n 
0001420198 00000 n 
0001884345 00000 n 
0001420307 00000 n 
0001422103 00000 n 
0001884437 00000 n 
0001422212 00000 n 
0001424136 00000 n 
0001884529 00000 n 
0001424256 00000 n 
0001426449 00000 n 
0001884621 00000 n 
0001426569 00000 n 
0001429254 00000 n 
0001884713 00000 n 
0001429386 00000 n 
0001431950 00000 n 
0001884805 00000 n 
0001432082 00000 n 
0001433880 00000 n 
0001884897 00000 n 
0001433989 00000 n 
0001435735 00000 n 
0001884989 00000 n 
0001435844 00000 n 
0001439962 00000 n 
0001902361 00000 n 
0001885081 00000 n 
0001440106 00000 n 
0001444354 00000 n 
0001885173 00000 n 
0001444476 00000 n 
0001448995 00000 n 
0001885265 00000 n 
0001449116 00000 n 
0001454783 00000 n 
0001848138 00000 n 
0001885357 00000 n 
0001454918 00000 n 
0001458385 00000 n 
0001885449 00000 n 
0001458517 00000 n 
0001460319 00000 n 
0001885541 00000 n 
0001460428 00000 n 
0001462327 00000 n 
0001885633 00000 n 
0001462436 00000 n 
0001465206 00000 n 
0001885725 00000 n 
0001465338 00000 n 
0001466546 00000 n 
0001885817 00000 n 
0001466667 00000 n 
0001470566 00000 n 
0001885909 00000 n 
0001470699 00000 n 
0001474890 00000 n 
0001903981 00000 n 
0001902523 00000 n 
0001886001 00000 n 
0001475023 00000 n 
0001479153 00000 n 
0001886093 00000 n 
0001479285 00000 n 
0001482896 00000 n 
0001886185 00000 n 
0001483017 00000 n 
0001486519 00000 n 
0001886277 00000 n 
0001486651 00000 n 
0001489863 00000 n 
0001886369 00000 n 
0001489995 00000 n 
0001494417 00000 n 
0001886461 00000 n 
0001494561 00000 n 
0001498816 00000 n 
0001886553 00000 n 
0001498972 00000 n 
0001502317 00000 n 
0001502449 00000 n 
0001886645 00000 n 
0001502638 00000 n 
0001506059 00000 n 
0001886737 00000 n 
0001506231 00000 n 
0001510659 00000 n 
0001510780 00000 n 
0001510968 00000 n 
0001886829 00000 n 
0001511156 00000 n 
0001514789 00000 n 
0001902685 00000 n 
0001886921 00000 n 
0001514977 00000 n 
0001517961 00000 n 
0001518070 00000 n 
0001887013 00000 n 
0001518259 00000 n 
0001521191 00000 n 
0001887105 00000 n 
0001521339 00000 n 
0001526282 00000 n 
0001526415 00000 n 
0001887197 00000 n 
0001526603 00000 n 
0001531360 00000 n 
0001531532 00000 n 
0001887289 00000 n 
0001531720 00000 n 
0001534710 00000 n 
0001887381 00000 n 
0001534869 00000 n 
0001538172 00000 n 
0001887473 00000 n 
0001538304 00000 n 
0001542907 00000 n 
0001543040 00000 n 
0001887565 00000 n 
0001543229 00000 n 
0001545587 00000 n 
0001545735 00000 n 
0001887657 00000 n 
0001545924 00000 n 
0001549242 00000 n 
0001887749 00000 n 
0001549402 00000 n 
0001553630 00000 n 
0001902847 00000 n 
0001553763 00000 n 
0001887841 00000 n 
0001553952 00000 n 
0001556910 00000 n 
0001887933 00000 n 
0001557082 00000 n 
0001561501 00000 n 
0001888025 00000 n 
0001561622 00000 n 
0001566173 00000 n 
0001888117 00000 n 
0001566306 00000 n 
0001568527 00000 n 
0001888209 00000 n 
0001568648 00000 n 
0001575324 00000 n 
0001888301 00000 n 
0001575457 00000 n 
0001581535 00000 n 
0001888393 00000 n 
0001581668 00000 n 
0001588291 00000 n 
0001888485 00000 n 
0001588424 00000 n 
0001594649 00000 n 
0001888577 00000 n 
0001594782 00000 n 
0001601689 00000 n 
0001888669 00000 n 
0001601822 00000 n 
0001608840 00000 n 
0001903009 00000 n 
0001888761 00000 n 
0001608973 00000 n 
0001615206 00000 n 
0001888853 00000 n 
0001615327 00000 n 
0001622168 00000 n 
0001888945 00000 n 
0001622301 00000 n 
0001629784 00000 n 
0001889037 00000 n 
0001629905 00000 n 
0001634592 00000 n 
0001889129 00000 n 
0001634713 00000 n 
0001638718 00000 n 
0001889221 00000 n 
0001638851 00000 n 
0001643540 00000 n 
0001889313 00000 n 
0001643672 00000 n 
0001648494 00000 n 
0001889405 00000 n 
0001648615 00000 n 
0001653473 00000 n 
0001889497 00000 n 
0001653605 00000 n 
0001658058 00000 n 
0001889589 00000 n 
0001658179 00000 n 
0001662086 00000 n 
0001903171 00000 n 
0001889681 00000 n 
0001662207 00000 n 
0001666473 00000 n 
0001889773 00000 n 
0001666594 00000 n 
0001671098 00000 n 
0001889865 00000 n 
0001671230 00000 n 
0001675487 00000 n 
0001889957 00000 n 
0001675622 00000 n 
0001680365 00000 n 
0001890049 00000 n 
0001680497 00000 n 
0001685458 00000 n 
0001890141 00000 n 
0001685579 00000 n 
0001690512 00000 n 
0001890233 00000 n 
0001690633 00000 n 
0001693977 00000 n 
0001890325 00000 n 
0001694087 00000 n 
0001698046 00000 n 
0001890417 00000 n 
0001698179 00000 n 
0001702643 00000 n 
0001890509 00000 n 
0001702764 00000 n 
0001706993 00000 n 
0001903333 00000 n 
0001890601 00000 n 
0001707114 00000 n 
0001709790 00000 n 
0001709923 00000 n 
0001890693 00000 n 
0001710112 00000 n 
0001713688 00000 n 
0001713848 00000 n 
0001714035 00000 n 
0001714222 00000 n 
0001714410 00000 n 
0001714598 00000 n 
0001890785 00000 n 
0001714786 00000 n 
0001718919 00000 n 
0001719132 00000 n 
0001719320 00000 n 
0001719508 00000 n 
0001719696 00000 n 
0001719884 00000 n 
0001890877 00000 n 
0001720072 00000 n 
0001723128 00000 n 
0001723376 00000 n 
0001890969 00000 n 
0001723565 00000 n 
0001724923 00000 n 
0001891061 00000 n 
0001725072 00000 n 
0001728251 00000 n 
0001891153 00000 n 
0001728384 00000 n 
0001734683 00000 n 
0001891245 00000 n 
0001734828 00000 n 
0001741318 00000 n 
0001741463 00000 n 
0001741651 00000 n 
0001741840 00000 n 
0001742028 00000 n 
0001891337 00000 n 
0001742216 00000 n 
0001744480 00000 n 
0001744712 00000 n 
0001744901 00000 n 
0001891429 00000 n 
0001745090 00000 n 
0001747164 00000 n 
0001903495 00000 n 
0001747364 00000 n 
0001891521 00000 n 
0001747553 00000 n 
0001748421 00000 n 
0001891613 00000 n 
0001748594 00000 n 
0001753116 00000 n 
0001891705 00000 n 
0001753249 00000 n 
0001757932 00000 n 
0001891797 00000 n 
0001758076 00000 n 
0001763817 00000 n 
0001891889 00000 n 
0001763939 00000 n 
0001766278 00000 n 
0001891981 00000 n 
0001766411 00000 n 
0001771158 00000 n 
0001892073 00000 n 
0001771279 00000 n 
0001771829 00000 n 
0001771927 00000 n 
0001892165 00000 n 
0001772117 00000 n 
0001773202 00000 n 
0001773350 00000 n 
0001892257 00000 n 
0001773540 00000 n 
0001774146 00000 n 
0001774294 00000 n 
0001892349 00000 n 
0001774484 00000 n 
0001775094 00000 n 
0001903657 00000 n 
0001775242 00000 n 
0001892441 00000 n 
0001775432 00000 n 
0001776038 00000 n 
0001776186 00000 n 
0001892533 00000 n 
0001776376 00000 n 
0001777053 00000 n 
0001777201 00000 n 
0001892625 00000 n 
0001777391 00000 n 
0001778021 00000 n 
0001778169 00000 n 
0001892717 00000 n 
0001778359 00000 n 
0001778992 00000 n 
0001779152 00000 n 
0001892809 00000 n 
0001779342 00000 n 
0001779949 00000 n 
0001780097 00000 n 
0001780287 00000 n 
0001892901 00000 n 
0001780476 00000 n 
0001781691 00000 n 
0001781855 00000 n 
0001782044 00000 n 
0001892993 00000 n 
0001782233 00000 n 
0001783775 00000 n 
0001783939 00000 n 
0001893085 00000 n 
0001784128 00000 n 
0001785106 00000 n 
0001785254 00000 n 
0001785443 00000 n 
0001893177 00000 n 
0001785632 00000 n 
0001786878 00000 n 
0001787042 00000 n 
0001893269 00000 n 
0001787231 00000 n 
0001788186 00000 n 
0001903819 00000 n 
0001788334 00000 n 
0001893361 00000 n 
0001788523 00000 n 
0001789872 00000 n 
0001790020 00000 n 
0001790209 00000 n 
0001893453 00000 n 
0001790398 00000 n 
0001791597 00000 n 
0001791761 00000 n 
0001893545 00000 n 
0001791950 00000 n 
0001792734 00000 n 
0001792882 00000 n 
0001893637 00000 n 
0001793071 00000 n 
0001793893 00000 n 
0001794041 00000 n 
0001794230 00000 n 
0001893729 00000 n 
0001794419 00000 n 
0001795496 00000 n 
0001795660 00000 n 
0001893821 00000 n 
0001795849 00000 n 
0001796457 00000 n 
0001796605 00000 n 
0001893913 00000 n 
0001796794 00000 n 
0001797390 00000 n 
0001797538 00000 n 
0001894005 00000 n 
0001797729 00000 n 
0001798360 00000 n 
0001798508 00000 n 
0001798698 00000 n 
0001894097 00000 n 
0001798887 00000 n 
0001800077 00000 n 
0001800241 00000 n 
0001800430 00000 n 
0001894189 00000 n 
0001800619 00000 n 
0001801429 00000 n 
0001904144 00000 n 
0001801593 00000 n 
0001894281 00000 n 
0001801784 00000 n 
0001801970 00000 n 
0001894373 00000 n 
0001802078 00000 n 
0001805118 00000 n 
0001894465 00000 n 
0001805251 00000 n 
0001808526 00000 n 
0001894557 00000 n 
0001808648 00000 n 
0001812012 00000 n 
0001894649 00000 n 
0001812134 00000 n 
0001815681 00000 n 
0001894741 00000 n 
0001815803 00000 n 
0001818981 00000 n 
0001894833 00000 n 
0001819103 00000 n 
0001821985 00000 n 
0001894925 00000 n 
0001822095 00000 n 
0001825811 00000 n 
0001895017 00000 n 
0001825945 00000 n 
0001829007 00000 n 
0001895109 00000 n 
0001829129 00000 n 
0001831948 00000 n 
0001904431 00000 n 
0001904306 00000 n 
0001895201 00000 n 
0001832070 00000 n 
0001835534 00000 n 
0001895293 00000 n 
0001835668 00000 n 
0001838794 00000 n 
0001895385 00000 n 
0001838928 00000 n 
0001842112 00000 n 
0001895477 00000 n 
0001842234 00000 n 
0001845728 00000 n 
0001895569 00000 n 
0001845850 00000 n 
0001847400 00000 n 
0001847522 00000 n 
0001848451 00000 n 
0001849426 00000 n 
0001904651 00000 n 
0001904705 00000 n 
trailer
<<
/Size 1788
/Root 1786 0 R
/Info 1787 0 R
/ID [<02096bc4de09171f67e9b0f7eb540cff><02096bc4de09171f67e9b0f7eb540cff>]
>>
startxref
1904808
%%EOF
